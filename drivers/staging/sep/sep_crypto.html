<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › sep › sep_crypto.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sep_crypto.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *  sep_crypto.c - Crypto interface structures</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright(c) 2009-2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *  Contributions(c) 2009-2010 Discretix. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> *  Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> *  more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> *  this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *  CONTACTS:</span>
<span class="cm"> *</span>
<span class="cm"> *  Mark Allyn		mark.a.allyn@intel.com</span>
<span class="cm"> *  Jayant Mangalampalli jayant.mangalampalli@intel.com</span>
<span class="cm"> *</span>
<span class="cm"> *  CHANGES:</span>
<span class="cm"> *</span>
<span class="cm"> *  2009.06.26	Initial publish</span>
<span class="cm"> *  2010.09.14  Upgrade to Medfield</span>
<span class="cm"> *  2011.02.22  Enable Kernel Crypto</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* #define DEBUG */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;crypto/internal/hash.h&gt;</span>
<span class="cp">#include &lt;crypto/scatterwalk.h&gt;</span>
<span class="cp">#include &lt;crypto/sha.h&gt;</span>
<span class="cp">#include &lt;crypto/md5.h&gt;</span>
<span class="cp">#include &lt;crypto/aes.h&gt;</span>
<span class="cp">#include &lt;crypto/des.h&gt;</span>
<span class="cp">#include &lt;crypto/hash.h&gt;</span>
<span class="cp">#include &quot;sep_driver_hw_defs.h&quot;</span>
<span class="cp">#include &quot;sep_driver_config.h&quot;</span>
<span class="cp">#include &quot;sep_driver_api.h&quot;</span>
<span class="cp">#include &quot;sep_dev.h&quot;</span>
<span class="cp">#include &quot;sep_crypto.h&quot;</span>

<span class="cp">#if defined(CONFIG_CRYPTO) || defined(CONFIG_CRYPTO_MODULE)</span>

<span class="cm">/* Globals for queuing */</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">queue_lock</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">crypto_queue</span> <span class="n">sep_queue</span><span class="p">;</span>

<span class="cm">/* Declare of dequeuer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sep_dequeuer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* TESTING */</span>
<span class="cm">/**</span>
<span class="cm"> * crypto_sep_dump_message - dump the message that is pending</span>
<span class="cm"> * @sep: SEP device</span>
<span class="cm"> * This will only print dump if DEBUG is set; it does</span>
<span class="cm"> * follow kernel debug print enabling</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crypto_sep_dump_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	u32 *p;</span>
<span class="c">	u32 *i;</span>
<span class="c">	int count;</span>

<span class="c">	p = sep-&gt;shared_addr;</span>
<span class="c">	i = (u32 *)msg;</span>
<span class="c">	for (count = 0; count &lt; 10 * 4; count += 4)</span>
<span class="c">		dev_dbg(&amp;sep-&gt;pdev-&gt;dev,</span>
<span class="c">			&quot;[PID%d] Word %d of the message is %x (local)%x\n&quot;,</span>
<span class="c">				current-&gt;pid, count/4, *p++, *i++);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_do_callback</span>
<span class="cm"> *	@work: pointer to work_struct</span>
<span class="cm"> *	This is what is called by the queue; it is generic so that it</span>
<span class="cm"> *	can be used by any type of operation as each different callback</span>
<span class="cm"> *	function can use the data parameter in its own way</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_do_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_work_struct</span> <span class="o">*</span><span class="n">sep_work</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sep_work_struct</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep_work</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">sep_work</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)(</span><span class="n">sep_work</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sep_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto: do callback - NULL container</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_submit_work</span>
<span class="cm"> *	@work_queue: pointer to struct_workqueue</span>
<span class="cm"> *	@funct: pointer to function to execute</span>
<span class="cm"> *	@data: pointer to data; function will know</span>
<span class="cm"> *		how to use it</span>
<span class="cm"> *	This is a generic API to submit something to</span>
<span class="cm"> *	the queue. The callback function will depend</span>
<span class="cm"> *	on what operation is to be done</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_submit_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">work_queue</span><span class="p">,</span>
	<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">funct</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_work_struct</span> <span class="o">*</span><span class="n">sep_work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">sep_work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_work_struct</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_work</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto: cant allocate work structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_work</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">funct</span><span class="p">;</span>
	<span class="n">sep_work</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">sep_do_callback</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">queue_work</span><span class="p">(</span><span class="n">work_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep_work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_crypto: queue_work failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_alloc_sg_buf -</span>
<span class="cm"> *	@sep: pointer to struct sep_device</span>
<span class="cm"> *	@size: total size of area</span>
<span class="cm"> *	@block_size: minimum size of chunks</span>
<span class="cm"> *	each page is minimum or modulo this size</span>
<span class="cm"> *	@returns: pointer to struct scatterlist for new</span>
<span class="cm"> *	buffer</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">sep_alloc_sg_buf</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">block_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nbr_pages</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ct1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">current_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">real_page_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="o">*</span><span class="n">sg_temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep alloc sg buf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nbr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">real_page_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">);</span>
	<span class="cm">/**</span>
<span class="cm">	 * The size of each page must be modulo of the operation</span>
<span class="cm">	 * block size; increment by the modified page size until</span>
<span class="cm">	 * the total size is reached, then you have the number of</span>
<span class="cm">	 * pages</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">current_size</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_size</span> <span class="o">+=</span> <span class="n">real_page_size</span><span class="p">;</span>
		<span class="n">nbr_pages</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">)</span> <span class="o">*</span> <span class="n">nbr_pages</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate page for new sg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">nbr_pages</span><span class="p">);</span>

	<span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ct1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">&lt;</span> <span class="n">nbr_pages</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Cannot allocate page for new buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sg_set_buf</span><span class="p">(</span><span class="n">sg_temp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">real_page_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">-</span> <span class="n">current_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">real_page_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_temp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">real_page_size</span><span class="p">;</span>
			<span class="n">current_size</span> <span class="o">+=</span> <span class="n">real_page_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sg_temp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">current_size</span><span class="p">);</span>
			<span class="n">current_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_free_sg_buf -</span>
<span class="cm"> *	@sg: pointer to struct scatterlist; points to area to free</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_free_sg_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">sg_temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sg_virt</span><span class="p">(</span><span class="n">sg_temp</span><span class="p">));</span>
			<span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg_temp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_copy_sg -</span>
<span class="cm"> *	@sep: pointer to struct sep_device</span>
<span class="cm"> *	@sg_src: pointer to struct scatterlist for source</span>
<span class="cm"> *	@sg_dst: pointer to struct scatterlist for destination</span>
<span class="cm"> *      @size: size (in bytes) of data to copy</span>
<span class="cm"> *</span>
<span class="cm"> *	Copy data from one scatterlist to another; both must</span>
<span class="cm"> *	be the same size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_copy_sg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_src</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_dst</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">seg_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">in_offset</span><span class="p">,</span> <span class="n">out_offset</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_src_tmp</span> <span class="o">=</span> <span class="n">sg_src</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_dst_tmp</span> <span class="o">=</span> <span class="n">sg_dst</span><span class="p">;</span>
	<span class="n">in_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">out_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep copy sg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sg_src</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sg_dst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep copy sg not null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sg_src_tmp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">in_offset</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="p">(</span><span class="n">sg_dst_tmp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">out_offset</span><span class="p">))</span>
			<span class="n">seg_size</span> <span class="o">=</span> <span class="n">sg_dst_tmp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">out_offset</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">seg_size</span> <span class="o">=</span> <span class="n">sg_src_tmp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">in_offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">seg_size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">count</span><span class="p">))</span>
			<span class="n">seg_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">sg_virt</span><span class="p">(</span><span class="n">sg_dst_tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">out_offset</span><span class="p">,</span>
			<span class="n">sg_virt</span><span class="p">(</span><span class="n">sg_src_tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">in_offset</span><span class="p">,</span>
			<span class="n">seg_size</span><span class="p">);</span>

		<span class="n">in_offset</span> <span class="o">+=</span> <span class="n">seg_size</span><span class="p">;</span>
		<span class="n">out_offset</span> <span class="o">+=</span> <span class="n">seg_size</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">seg_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_offset</span> <span class="o">&gt;=</span> <span class="n">sg_src_tmp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_src_tmp</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg_src_tmp</span><span class="p">);</span>
			<span class="n">in_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">out_offset</span> <span class="o">&gt;=</span> <span class="n">sg_dst_tmp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_dst_tmp</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg_dst_tmp</span><span class="p">);</span>
			<span class="n">out_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_oddball_pages -</span>
<span class="cm"> *	@sep: pointer to struct sep_device</span>
<span class="cm"> *	@sg: pointer to struct scatterlist - buffer to check</span>
<span class="cm"> *	@size: total data size</span>
<span class="cm"> *	@blocksize: minimum block size; must be multiples of this size</span>
<span class="cm"> *	@to_copy: 1 means do copy, 0 means do not copy</span>
<span class="cm"> *	@new_sg: pointer to location to put pointer to new sg area</span>
<span class="cm"> *	@returns: 1 if new scatterlist is needed; 0 if not needed;</span>
<span class="cm"> *		error value if operation failed</span>
<span class="cm"> *</span>
<span class="cm"> *	The SEP device requires all pages to be multiples of the</span>
<span class="cm"> *	minimum block size appropriate for the operation</span>
<span class="cm"> *	This function check all pages; if any are oddball sizes</span>
<span class="cm"> *	(not multiple of block sizes), it creates a new scatterlist.</span>
<span class="cm"> *	If the to_copy parameter is set to 1, then a scatter list</span>
<span class="cm"> *	copy is performed. The pointer to the new scatterlist is</span>
<span class="cm"> *	put into the address supplied by the new_sg parameter; if</span>
<span class="cm"> *	no new scatterlist is needed, then a NULL is put into</span>
<span class="cm"> *	the location at new_sg.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_oddball_pages</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">data_size</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">block_size</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">**</span><span class="n">new_sg</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">do_copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_temp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nbr_pages</span><span class="p">,</span> <span class="n">page_count</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep oddball</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&lt;</span> <span class="n">block_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep oddball not null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nbr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">page_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sg_temp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nbr_pages</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg_temp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">sg_temp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_temp</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">)</span>
			<span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sg_temp</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg_temp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Do not process if last (or only) page is oddball */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbr_pages</span> <span class="o">==</span> <span class="n">page_count</span><span class="p">)</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep oddball processing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">new_sg</span> <span class="o">=</span> <span class="n">sep_alloc_sg_buf</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">new_sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot allocate new sg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_copy</span><span class="p">)</span>
			<span class="n">sep_copy_sg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="o">*</span><span class="n">new_sg</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_copy_offset_sg -</span>
<span class="cm"> *	@sep: pointer to struct sep_device;</span>
<span class="cm"> *	@sg: pointer to struct scatterlist</span>
<span class="cm"> *	@offset: offset into scatterlist memory</span>
<span class="cm"> *	@dst: place to put data</span>
<span class="cm"> *	@len: length of data</span>
<span class="cm"> *	@returns: number of bytes copies</span>
<span class="cm"> *</span>
<span class="cm"> *	This copies data from scatterlist buffer</span>
<span class="cm"> *	offset from beginning - it is needed for</span>
<span class="cm"> *	handling tail data in hash</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">sep_copy_offset_sg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">page_start</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">page_end</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">offset_within_page</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">length_within_page</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">length_remaining</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">current_offset</span><span class="p">;</span>

	<span class="cm">/* Find which page is beginning of segment */</span>
	<span class="n">page_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">page_end</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">sg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">page_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_start</span> <span class="o">+=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg</span><span class="p">)</span>
			<span class="n">page_end</span> <span class="o">+=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">offset_within_page</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">page_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">offset_within_page</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All within this page */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset_within_page</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Scattered multiple pages */</span>
		<span class="n">current_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">length_remaining</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">sg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current_offset</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">length_within_page</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">offset_within_page</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">length_within_page</span> <span class="o">&gt;=</span> <span class="n">length_remaining</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="o">+</span><span class="n">current_offset</span><span class="p">,</span>
					<span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset_within_page</span><span class="p">,</span>
					<span class="n">length_remaining</span><span class="p">);</span>
				<span class="n">length_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">current_offset</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="o">+</span><span class="n">current_offset</span><span class="p">,</span>
					<span class="n">sg_virt</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset_within_page</span><span class="p">,</span>
					<span class="n">length_within_page</span><span class="p">);</span>
				<span class="n">length_remaining</span> <span class="o">-=</span> <span class="n">length_within_page</span><span class="p">;</span>
				<span class="n">current_offset</span> <span class="o">+=</span> <span class="n">length_within_page</span><span class="p">;</span>
				<span class="n">offset_within_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	partial_overlap -</span>
<span class="cm"> *	@src_ptr: source pointer</span>
<span class="cm"> *	@dst_ptr: destination pointer</span>
<span class="cm"> *	@nbytes: number of bytes</span>
<span class="cm"> *	@returns: 0 for success; -1 for failure</span>
<span class="cm"> *	We cannot have any partial overlap. Total overlap</span>
<span class="cm"> *	where src is the same as dst is okay</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">partial_overlap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">src_ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dst_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check for partial overlap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">src_ptr</span> <span class="o">!=</span> <span class="n">dst_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">src_ptr</span> <span class="o">&lt;</span> <span class="n">dst_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">src_ptr</span> <span class="o">+</span> <span class="n">nbytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dst_ptr</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dst_ptr</span> <span class="o">+</span> <span class="n">nbytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">src_ptr</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Debug - prints only if DEBUG is defined; follows kernel debug model */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	int ct1;</span>
<span class="c">	u8 *ptt;</span>

<span class="c">	dev_dbg(&amp;sep-&gt;pdev-&gt;dev,</span>
<span class="c">		&quot;Dump of %s starting at %08lx for %08x bytes\n&quot;,</span>
<span class="c">		stg, (unsigned long)start, len);</span>
<span class="c">	for (ct1 = 0; ct1 &lt; len; ct1 += 1) {</span>
<span class="c">		ptt = (u8 *)(start + ct1);</span>
<span class="c">		dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;%02x &quot;, *ptt);</span>
<span class="c">		if (ct1 % 16 == 15)</span>
<span class="c">			dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;\n&quot;);</span>
<span class="c">	}</span>
<span class="c">	dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;\n&quot;);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Debug - prints only if DEBUG is defined; follows kernel debug model */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_dump_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stg</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	int ct1, ct2;</span>
<span class="c">	u8 *ptt;</span>

<span class="c">	dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;Dump of scatterlist %s\n&quot;, stg);</span>

<span class="c">	ct1 = 0;</span>
<span class="c">	while (sg) {</span>
<span class="c">		dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;page %x\n size %x&quot;, ct1,</span>
<span class="c">			sg-&gt;length);</span>
<span class="c">		dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;phys addr is %lx&quot;,</span>
<span class="c">			(unsigned long)sg_phys(sg));</span>
<span class="c">		ptt = sg_virt(sg);</span>
<span class="c">		for (ct2 = 0; ct2 &lt; sg-&gt;length; ct2 += 1) {</span>
<span class="c">			dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;byte %x is %02x\n&quot;,</span>
<span class="c">				ct2, (unsigned char)*(ptt + ct2));</span>
<span class="c">		}</span>

<span class="c">		ct1 += 1;</span>
<span class="c">		sg = sg_next(sg);</span>
<span class="c">	}</span>
<span class="c">	dev_dbg(&amp;sep-&gt;pdev-&gt;dev, &quot;\n&quot;);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Debug - prints only if DEBUG is defined */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_dump_ivs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>

	<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_aes_internal_context</span> <span class="o">*</span><span class="n">aes_internal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_des_internal_context</span> <span class="o">*</span><span class="n">des_internal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ct1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>

	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IV DUMP - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">DES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">==</span> <span class="n">SEP_DES_CBC</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">des_internal</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_des_internal_context</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">.</span><span class="n">ctx_buf</span><span class="p">;</span>
		<span class="cm">/* print vendor */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep - vendor iv for DES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">des_internal</span><span class="o">-&gt;</span><span class="n">iv_context</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ct1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">&lt;</span> <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span> <span class="n">ct1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">cptr</span> <span class="o">+</span> <span class="n">ct1</span><span class="p">));</span>

		<span class="cm">/* print walk */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep - walk from kernel crypto iv for DES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ct1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">&lt;</span> <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span> <span class="n">ct1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">cptr</span> <span class="o">+</span> <span class="n">ct1</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">AES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">==</span> <span class="n">SEP_AES_CBC</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">aes_internal</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_aes_internal_context</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">.</span><span class="n">cbuff</span><span class="p">;</span>
		<span class="cm">/* print vendor */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep - vendor iv for AES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">aes_internal</span><span class="o">-&gt;</span><span class="n">aes_ctx_iv</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ct1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">&lt;</span> <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span> <span class="n">ct1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">cptr</span> <span class="o">+</span> <span class="n">ct1</span><span class="p">));</span>

		<span class="cm">/* print walk */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep - walk from kernel crypto iv for AES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ct1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">&lt;</span> <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span> <span class="n">ct1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">cptr</span> <span class="o">+</span> <span class="n">ct1</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * RFC2451: Weak key check</span>
<span class="cm"> * Returns: 1 (weak), 0 (not weak)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_weak_key</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">parity</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">u32</span> <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>

	<span class="n">n</span>  <span class="o">=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span> <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span> <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span> <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]];</span> <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">4</span><span class="p">]];</span> <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">5</span><span class="p">]];</span> <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">6</span><span class="p">]];</span> <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">7</span><span class="p">]];</span>
	<span class="n">w</span> <span class="o">=</span> <span class="mh">0x88888888L</span><span class="p">;</span>

	<span class="cm">/* 1 in 10^10 keys passes this test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">w</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x41415151</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x31312121</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x14141515</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* 01 01 01 01 01 01 01 01 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x11111111</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* 01 1F 01 1F 01 0E 01 0E */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x13131212</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* 01 E0 01 E0 01 F1 01 F1 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x14141515</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* 01 FE 01 FE 01 FE 01 FE */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x16161616</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x34342525</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* 1F 01 1F 01 0E 01 0E 01 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x31312121</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* 1F 1F 1F 1F 0E 0E 0E 0E (?) */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x33332222</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* 1F E0 1F E0 0E F1 0E F1 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x34342525</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* 1F FE 1F FE 0E FE 0E FE */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x36362626</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x61616161</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x44445555</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* E0 01 E0 01 F1 01 F1 01 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x41415151</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* E0 1F E0 1F F1 0E F1 0E */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x43435252</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* E0 E0 E0 E0 F1 F1 F1 F1 (?) */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x44445555</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* E0 FE E0 FE F1 FE F1 FE */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x46465656</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x64646565</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* FE 01 FE 01 FE 01 FE 01 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x61616161</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* FE 1F FE 1F FE 0E FE 0E */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x63636262</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* FE E0 FE E0 FE F1 FE F1 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x64646565</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
					<span class="cm">/* FE FE FE FE FE FE FE FE */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mh">0x66666666</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">weak</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">weak:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> *	sep_sg_nents</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">sep_sg_nents</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ct1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ct1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ct1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_start_msg -</span>
<span class="cm"> *	@ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> *	@returns: offset to place for the next word in the message</span>
<span class="cm"> *	Set up pointer in message pool for new message</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">sep_start_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">word_ptr</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg_len_words</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">word_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">word_ptr</span> <span class="o">=</span> <span class="n">SEP_START_MSG_TOKEN</span><span class="p">;</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_end_msg -</span>
<span class="cm"> *	@ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> *	@messages_offset: current message offset</span>
<span class="cm"> *	Returns: 0 for success; &lt;0 otherwise</span>
<span class="cm"> *	End message; set length and CRC; and</span>
<span class="cm"> *	send interrupt to the SEP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_end_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msg_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">word_ptr</span><span class="p">;</span>
	<span class="cm">/* Msg size goes into msg after token */</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg_len_words</span> <span class="o">=</span> <span class="n">msg_offset</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">word_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span><span class="p">;</span>
	<span class="n">word_ptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">word_ptr</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg_len_words</span><span class="p">;</span>

	<span class="cm">/* CRC (currently 0) goes at end of msg */</span>
	<span class="n">word_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span> <span class="o">+</span> <span class="n">msg_offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">word_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_start_inbound_msg -</span>
<span class="cm"> *	@ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> *	@msg_offset: offset to place for the next word in the message</span>
<span class="cm"> *	@returns: 0 for success; error value for failure</span>
<span class="cm"> *	Set up pointer in message pool for inbound message</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">sep_start_inbound_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">word_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">token</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error</span> <span class="o">=</span> <span class="n">SEP_OK</span><span class="p">;</span>

	<span class="o">*</span><span class="n">msg_offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">word_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span><span class="p">;</span>
	<span class="n">token</span> <span class="o">=</span> <span class="o">*</span><span class="n">word_ptr</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg_len_words</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">word_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">!=</span> <span class="n">SEP_START_MSG_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">SEP_INVALID_START</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end_function:</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_write_msg -</span>
<span class="cm"> *	@ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> *	@in_addr: pointer to start of parameter</span>
<span class="cm"> *	@size: size of parameter to copy (in bytes)</span>
<span class="cm"> *	@max_size: size to move up offset; SEP mesg is in word sizes</span>
<span class="cm"> *	@msg_offset: pointer to current offset (is updated)</span>
<span class="cm"> *	@byte_array: flag ti indicate wheter endian must be changed</span>
<span class="cm"> *	Copies data into the message area from caller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_write_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">in_addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">byte_array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">word_ptr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">void_ptr</span><span class="p">;</span>
	<span class="n">void_ptr</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span> <span class="o">+</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">;</span>
	<span class="n">word_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">void_ptr</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">void_ptr</span><span class="p">,</span> <span class="n">in_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">msg_offset</span> <span class="o">+=</span> <span class="n">max_size</span><span class="p">;</span>

	<span class="cm">/* Do we need to manipulate endian? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">byte_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">size</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">word_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">CHG_ENDIAN</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">word_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_make_header</span>
<span class="cm"> *	@ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> *	@msg_offset: pointer to current offset (is updated)</span>
<span class="cm"> *	@op_code: op code to put into message</span>
<span class="cm"> *	Puts op code into message and updates offset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_make_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">op_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">word_ptr</span><span class="p">;</span>

	<span class="o">*</span><span class="n">msg_offset</span> <span class="o">=</span> <span class="n">sep_start_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>
	<span class="n">word_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span> <span class="o">+</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">word_ptr</span> <span class="o">=</span> <span class="n">op_code</span><span class="p">;</span>
	<span class="o">*</span><span class="n">msg_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/**</span>
<span class="cm"> *	sep_read_msg -</span>
<span class="cm"> *	@ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> *	@in_addr: pointer to start of parameter</span>
<span class="cm"> *	@size: size of parameter to copy (in bytes)</span>
<span class="cm"> *	@max_size: size to move up offset; SEP mesg is in word sizes</span>
<span class="cm"> *	@msg_offset: pointer to current offset (is updated)</span>
<span class="cm"> *	@byte_array: flag ti indicate wheter endian must be changed</span>
<span class="cm"> *	Copies data out of the message area to caller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_read_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">in_addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">byte_array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">word_ptr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">void_ptr</span><span class="p">;</span>
	<span class="n">void_ptr</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msgptr</span> <span class="o">+</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">;</span>
	<span class="n">word_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">void_ptr</span><span class="p">;</span>

	<span class="cm">/* Do we need to manipulate endian? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">byte_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">size</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">word_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">CHG_ENDIAN</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">word_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">in_addr</span><span class="p">,</span> <span class="n">void_ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">msg_offset</span> <span class="o">+=</span> <span class="n">max_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_verify_op -</span>
<span class="cm"> *	@ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> *	@op_code: expected op_code</span>
<span class="cm"> *      @msg_offset: pointer to current offset (is updated)</span>
<span class="cm"> *	@returns: 0 for success; error for failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">sep_verify_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op_code</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">in_ary</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dumping return message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_start_inbound_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep_start_inbound_msg error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_read_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">in_ary</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_ary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep got back wrong opcode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;got back %x; expected %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">in_ary</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">op_code</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SEP_WRONG_OPCODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_ary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SEP_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep execution error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;got back %x; expected %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">in_ary</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">SEP_OK</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">in_ary</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>

<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_read_context -</span>
<span class="cm"> * @ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> * @msg_offset: point to current place in SEP msg; is updated</span>
<span class="cm"> * @dst: pointer to place to put the context</span>
<span class="cm"> * @len: size of the context structure (differs for crypro/hash)</span>
<span class="cm"> * This function reads the context from the msg area</span>
<span class="cm"> * There is a special way the vendor needs to have the maximum</span>
<span class="cm"> * length calculated so that the msg_offset is updated properly;</span>
<span class="cm"> * it skips over some words in the msg area depending on the size</span>
<span class="cm"> * of the context</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_read_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_length</span> <span class="o">=</span> <span class="p">((</span><span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">sep_read_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_write_context -</span>
<span class="cm"> * @ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> * @msg_offset: point to current place in SEP msg; is updated</span>
<span class="cm"> * @src: pointer to the current context</span>
<span class="cm"> * @len: size of the context structure (differs for crypro/hash)</span>
<span class="cm"> * This function writes the context to the msg area</span>
<span class="cm"> * There is a special way the vendor needs to have the maximum</span>
<span class="cm"> * length calculated so that the msg_offset is updated properly;</span>
<span class="cm"> * it skips over some words in the msg area depending on the size</span>
<span class="cm"> * of the context</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_write_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg_offset</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_length</span> <span class="o">=</span> <span class="p">((</span><span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_clear_out -</span>
<span class="cm"> * @ta_ctx: pointer to struct this_task_ctx</span>
<span class="cm"> * Clear out crypto related values in sep device structure</span>
<span class="cm"> * to enable device to be used by anyone; either kernel</span>
<span class="cm"> * crypto or userspace app via middleware</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_clear_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_free_sg_buf</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span><span class="p">);</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg_hold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_free_sg_buf</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg_hold</span><span class="p">);</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg_hold</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sep_free_dma_table_data_handler</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">i_own_sep</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/**</span>
<span class="cm">		 * The following unlocks the sep and makes it available</span>
<span class="cm">		 * to any other application</span>
<span class="cm">		 * First, null out crypto entries in sep before relesing it</span>
<span class="cm">		 */</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">in_kernel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Remove anything confidentail */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

		<span class="n">sep_queue_status_remove</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">queue_elem</span><span class="p">);</span>

<span class="cp">#ifdef SEP_ENABLE_RUNTIME_PM</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pm_runtime_mark_last_busy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_put_autosuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SEP_WORKING_LOCK_BIT</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">);</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pid_doing_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] waking up next transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SEP_TRANSACTION_STARTED_LOCK_BIT</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">event_transactions</span><span class="p">);</span>

		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">i_own_sep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">  * Release crypto infrastructure from EINPROGRESS and</span>
<span class="cm">  * clear sep_dev so that SEP is available to anyone</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_crypto_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">hash_req</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">cypher_req</span> <span class="o">=</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">;</span>

	<span class="n">sep_clear_out</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * This may not yet exist depending when we</span>
<span class="cm">	 * chose to bail out. If it does exist, set</span>
<span class="cm">	 * it to 1</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">are_we_done_yet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cypher_req</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cypher_req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">complete</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;release is null for cypher!&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cypher_req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">cypher_req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hash_req</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hash_req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">complete</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;release is null for hash!&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hash_req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">hash_req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	This is where we grab the sep itself and tell it to do something.</span>
<span class="cm"> *	It will sleep if the sep is currently busy</span>
<span class="cm"> *	and it will return 0 if sep is now ours; error value if there</span>
<span class="cm"> *	were problems</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_crypto_take_sep</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_msgarea_hdr</span> <span class="o">*</span><span class="n">my_msg_header</span><span class="p">;</span>

	<span class="n">my_msg_header</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_msgarea_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>

	<span class="cm">/* add to status queue */</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">queue_elem</span> <span class="o">=</span> <span class="n">sep_queue_status_add</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">my_msg_header</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">queue_elem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] updating queue&quot;</span>
			<span class="s">&quot; status error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the device; this can sleep */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sep_wait_transaction</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">power_save_setup</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Copy in the message */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span>
		<span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="cm">/* Copy in the dcb information if there is any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">sep_activate_dcb_dmatables_context</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_region</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_region</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark the device so we know how to finish the job in the tasklet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">)</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="p">;</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_kernel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">i_own_sep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* need to set bit first to avoid race condition with interrupt */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_SENDMSG_DONE_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sep_send_command_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d]: sending command to the sep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d]: command sent okay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d]: cant send command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_SENDMSG_DONE_OFFSET</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * This function sets things up for a crypto data block process</span>
<span class="cm"> * This does all preparation, but does not try to grab the</span>
<span class="cm"> * sep</span>
<span class="cm"> * @req: pointer to struct ablkcipher_request</span>
<span class="cm"> * returns: 0 if all went well, non zero if error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_crypto_block_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">int_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">msg</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">src_ptr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dst_ptr</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">char</span> <span class="n">small_buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
	<span class="kt">ssize_t</span> <span class="n">copy_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">new_sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sep_des_internal_context</span> <span class="o">*</span><span class="n">des_internal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_aes_internal_context</span> <span class="o">*</span><span class="n">aes_internal</span><span class="p">;</span>

	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="cm">/* start the walk on scatterlists */</span>
	<span class="n">ablkcipher_walk_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep crypto block data size of %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>

	<span class="n">int_error</span> <span class="o">=</span> <span class="n">ablkcipher_walk_phys</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;walk phys error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">int_error</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;crypto block: src is %lx dst is %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>

	<span class="cm">/* Make sure all pages are even block */</span>
	<span class="n">int_error</span> <span class="o">=</span> <span class="n">sep_oddball_pages</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">blocksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;oddball page eerror</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">int_error</span> <span class="o">=</span> <span class="n">sep_oddball_pages</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">blocksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_sg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;walk phys error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">int_error</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg_hold</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg_hold</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set nbytes for queue status */</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">;</span>

	<span class="cm">/* Key already done; this is for data */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sending data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sep_dump_sg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
		<span class="s">&quot;block sg in&quot;</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">);</span>

	<span class="cm">/* check for valid data and proper spacing */</span>
	<span class="n">src_ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">);</span>
	<span class="n">dst_ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_ptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">dst_ptr</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">%</span>
		<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;cipher block size odd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;cipher block size is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;cipher data size is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">partial_overlap</span><span class="p">(</span><span class="n">src_ptr</span><span class="p">,</span> <span class="n">dst_ptr</span><span class="p">,</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;block partial overlap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Put together the message */</span>
	<span class="n">sep_make_header</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span><span class="p">);</span>

	<span class="cm">/* If des, and size is 1 block, put directly in msg */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">==</span> <span class="n">SEP_DES_BLOCK_OPCODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">==</span> <span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;writing out one block des</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">copy_result</span> <span class="o">=</span> <span class="n">sg_copy_to_buffer</span><span class="p">(</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">,</span> <span class="n">sep_sg_nents</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">),</span>
			<span class="n">small_buf</span><span class="p">,</span> <span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_result</span> <span class="o">!=</span> <span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;des block copy faild</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Put data into message */</span>
		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">small_buf</span><span class="p">,</span>
			<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">),</span>
			<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Put size into message */</span>
		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise, fill out dma tables */</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">app_in_address</span> <span class="o">=</span> <span class="n">src_ptr</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">data_in_size</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">app_out_address</span> <span class="o">=</span> <span class="n">dst_ptr</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">block_size</span> <span class="o">=</span>
			<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">tail_block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">is_applet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">sep_create_dcb_dmatables_context_kernel</span><span class="p">(</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_region</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_region</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">,</span>
			<span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;crypto dma table create failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Portion of msg is nulled (no data) */</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/**</span>
<span class="cm">	 * Before we write the message, we need to overwrite the</span>
<span class="cm">	 * vendor&#39;s IV with the one from our own ablkcipher walk</span>
<span class="cm">	 * iv because this is needed for dm-crypt</span>
<span class="cm">	 */</span>
	<span class="n">sep_dump_ivs</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="s">&quot;sending data block to sep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">DES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">==</span> <span class="n">SEP_DES_CBC</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;overwrite vendor iv on DES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">des_internal</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_des_internal_context</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">.</span><span class="n">ctx_buf</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">des_internal</span><span class="o">-&gt;</span><span class="n">iv_context</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">AES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">==</span> <span class="n">SEP_AES_CBC</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;overwrite vendor iv on AES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">aes_internal</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_aes_internal_context</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">.</span><span class="n">cbuff</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">aes_internal</span><span class="o">-&gt;</span><span class="n">aes_ctx_iv</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Write context into message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">==</span> <span class="n">SEP_DES_BLOCK_OPCODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_write_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_des_private_context</span><span class="p">));</span>
		<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;ctx to block des&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sep_write_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_aes_private_context</span><span class="p">));</span>
		<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;ctx to block aes&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* conclude message */</span>
	<span class="n">sep_end_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">);</span>

	<span class="cm">/* Parent (caller) is now ready to tell the sep to do ahead */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * This function sets things up for a crypto key submit process</span>
<span class="cm"> * This does all preparation, but does not try to grab the</span>
<span class="cm"> * sep</span>
<span class="cm"> * @req: pointer to struct ablkcipher_request</span>
<span class="cm"> * returns: 0 if all went well, non zero if error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_crypto_send_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">int_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">msg</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="n">u32</span> <span class="n">max_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>

	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sending key</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* start the walk on scatterlists */</span>
	<span class="n">ablkcipher_walk_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;sep crypto block data size of %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>

	<span class="n">int_error</span> <span class="o">=</span> <span class="n">ablkcipher_walk_phys</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;walk phys error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">int_error</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check iv */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">DES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">==</span> <span class="n">SEP_DES_CBC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no iv found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">SEP_DES_IV_SIZE_BYTES</span><span class="p">);</span>
		<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;iv&quot;</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">,</span> <span class="n">SEP_DES_IV_SIZE_BYTES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">AES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">==</span> <span class="n">SEP_AES_CBC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no iv found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">SEP_AES_IV_SIZE_BYTES</span><span class="p">);</span>
		<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;iv&quot;</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">,</span> <span class="n">SEP_AES_IV_SIZE_BYTES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* put together message to SEP */</span>
	<span class="cm">/* Start with op code */</span>
	<span class="n">sep_make_header</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span><span class="p">);</span>

	<span class="cm">/* now deal with IV */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">==</span> <span class="n">SEP_DES_INIT_OPCODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">==</span> <span class="n">SEP_DES_CBC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">,</span>
				<span class="n">SEP_DES_IV_SIZE_BYTES</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;initial IV&quot;</span><span class="p">,</span>
				<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">SEP_DES_IV_SIZE_BYTES</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Skip if ECB */</span>
			<span class="n">msg_offset</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">max_length</span> <span class="o">=</span> <span class="p">((</span><span class="n">SEP_AES_IV_SIZE_BYTES</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">==</span> <span class="n">SEP_AES_CBC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">,</span>
				<span class="n">SEP_AES_IV_SIZE_BYTES</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;initial IV&quot;</span><span class="p">,</span>
				<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">SEP_AES_IV_SIZE_BYTES</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Skip if ECB */</span>
				<span class="n">msg_offset</span> <span class="o">+=</span> <span class="n">max_length</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="cm">/* load the key */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">==</span> <span class="n">SEP_DES_INIT_OPCODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">des</span><span class="p">.</span><span class="n">key1</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_nbr_keys</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_encmode</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span><span class="p">;</span>

		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">aes</span><span class="p">,</span>
			<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">keylen</span><span class="p">,</span>
			<span class="n">SEP_AES_MAX_KEY_SIZE_BYTES</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_key_size</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_encmode</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* Secret key is not used */</span>
		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* conclude message */</span>
	<span class="n">sep_end_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">);</span>

	<span class="cm">/* Parent (caller) is now ready to tell the sep to do ahead */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* This needs to be run as a work queue as it can be put asleep */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_crypto_block</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_crypto_block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tfm is %p sctx is %p ta_ctx is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">tfm</span><span class="p">,</span> <span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;key_sent is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span><span class="p">);</span>

	<span class="cm">/* do we need to send the key */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">sep_crypto_send_key</span><span class="p">(</span><span class="n">req</span><span class="p">);</span> <span class="cm">/* prep to send key */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;could not prep key %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">sep_crypto_take_sep</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;sep_crypto_take_sep for key send failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* now we sit and wait up to a fixed time for completion */</span>
		<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">WAIT_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">schedule</span><span class="p">();</span>

		<span class="cm">/* Done waiting; still not done yet? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Send key job never got done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set the key sent variable so this can be skipped later */</span>
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Key sent (or maybe not if we did not have to), now send block */</span>
	<span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sep_crypto_block_data</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;could prep not send block %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sep_crypto_take_sep</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep_crypto_take_sep for block send failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* now we sit and wait up to a fixed time for completion */</span>
	<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">WAIT_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="cm">/* Done waiting; still not done yet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Send block job never got done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* That&#39;s it; entire thing done, get out of queue */</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;crypto_block leaving</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tfm is %p sctx is %p ta_ctx is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tfm</span><span class="p">,</span> <span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Post operation (after interrupt) for crypto block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">crypto_post_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* HERE */</span>
	<span class="n">u32</span> <span class="n">u32_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>

	<span class="kt">ssize_t</span> <span class="n">copy_result</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">small_buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sep_des_internal_context</span> <span class="o">*</span><span class="n">des_internal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_aes_internal_context</span> <span class="o">*</span><span class="n">aes_internal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* hold req since we need to submit work after clearing sep */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="p">;</span>

	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="p">);</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;crypto_post op</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;key_sent is %d tfm is %p sctx is %p ta_ctx is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span><span class="p">,</span> <span class="n">tfm</span><span class="p">,</span> <span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;crypto post_op</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;crypto post_op message dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">crypto_sep_dump_message</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* first bring msg from shared area to local area */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span>
		<span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="cm">/* Is this the result of performing init (key to SEP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Did SEP do it okay */</span>
		<span class="n">u32_error</span> <span class="o">=</span> <span class="n">sep_verify_op</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">u32_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;aes init error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">u32_error</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="cm">/* Read Context */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">==</span> <span class="n">SEP_DES_INIT_OPCODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sep_read_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_des_private_context</span><span class="p">));</span>

			<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;ctx init des&quot;</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sep_read_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_aes_private_context</span><span class="p">));</span>

			<span class="n">sep_dump</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;ctx init aes&quot;</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sep_dump_ivs</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="s">&quot;after sending key to sep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* key sent went okay; release sep, and set are_we_done_yet */</span>
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/**</span>
<span class="cm">		 * This is the result of a block request</span>
<span class="cm">		 */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;crypto_post_op block response</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">u32_error</span> <span class="o">=</span> <span class="n">sep_verify_op</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">u32_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;sep block error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">==</span> <span class="n">SEP_DES_BLOCK_OPCODE</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;post op for DES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/* special case for 1 block des */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">==</span>
				<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">sep_read_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">small_buf</span><span class="p">,</span>
					<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">),</span>
					<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;reading in block des</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="n">copy_result</span> <span class="o">=</span> <span class="n">sg_copy_from_buffer</span><span class="p">(</span>
					<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">,</span>
					<span class="n">sep_sg_nents</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">),</span>
					<span class="n">small_buf</span><span class="p">,</span>
					<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">copy_result</span> <span class="o">!=</span>
					<span class="n">crypto_ablkcipher_blocksize</span><span class="p">(</span><span class="n">tfm</span><span class="p">))</span> <span class="p">{</span>

					<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;des block copy faild</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span>
						<span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* Read Context */</span>
			<span class="n">sep_read_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_des_private_context</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;post op for AES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/* Skip the MAC Output */</span>
			<span class="n">msg_offset</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

			<span class="cm">/* Read Context */</span>
			<span class="n">sep_read_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_aes_private_context</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">sep_dump_sg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
			<span class="s">&quot;block sg out&quot;</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">);</span>

		<span class="cm">/* Copy to correct sg if this block had oddball pages */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg_hold</span><span class="p">)</span>
			<span class="n">sep_copy_sg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
				<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">,</span>
				<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span>
				<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>

		<span class="cm">/**</span>
<span class="cm">		 * Copy the iv&#39;s back to the walk.iv</span>
<span class="cm">		 * This is required for dm_crypt</span>
<span class="cm">		 */</span>
		<span class="n">sep_dump_ivs</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="s">&quot;got data block from sep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">DES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">==</span> <span class="n">SEP_DES_CBC</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;returning result iv to walk on DES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">des_internal</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_des_internal_context</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_private_ctx</span><span class="p">.</span><span class="n">ctx_buf</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">des_internal</span><span class="o">-&gt;</span><span class="n">iv_context</span><span class="p">,</span>
				<span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">==</span> <span class="n">AES_CBC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">==</span> <span class="n">SEP_AES_CBC</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;returning result iv to walk on AES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">aes_internal</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_aes_internal_context</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_private_ctx</span><span class="p">.</span><span class="n">cbuff</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">aes_internal</span><span class="o">-&gt;</span><span class="n">aes_ctx_iv</span><span class="p">,</span>
				<span class="n">crypto_ablkcipher_ivsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* finished, release everything */</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;crypto_post_op done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;key_sent is %d tfm is %p sctx is %p ta_ctx is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span><span class="p">,</span> <span class="n">tfm</span><span class="p">,</span> <span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hash_init_post_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">u32_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;hash init post op</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* first bring msg from shared area to local area */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span>
		<span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="n">u32_error</span> <span class="o">=</span> <span class="n">sep_verify_op</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">SEP_HASH_INIT_OPCODE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u32_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hash init error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">u32_error</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">u32_error</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Read Context */</span>
	<span class="n">sep_read_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">hash_private_ctx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_hash_private_context</span><span class="p">));</span>

	<span class="cm">/* Signal to crypto infrastructure and clear out */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hash init post op done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hash_update_post_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">u32_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;hash update post op</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* first bring msg from shared area to local area */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span>
		<span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="n">u32_error</span> <span class="o">=</span> <span class="n">sep_verify_op</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">SEP_HASH_UPDATE_OPCODE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u32_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hash init error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">u32_error</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">u32_error</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Read Context */</span>
	<span class="n">sep_read_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">hash_private_ctx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_hash_private_context</span><span class="p">));</span>

	<span class="cm">/**</span>
<span class="cm">	 * Following is only for finup; if we just completd the</span>
<span class="cm">	 * data portion of finup, we now need to kick off the</span>
<span class="cm">	 * finish portion of finup.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">==</span> <span class="n">HASH_FINUP_DATA</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* first reset stage to HASH_FINUP_FINISH */</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINUP_FINISH</span><span class="p">;</span>

		<span class="cm">/* now enqueue the finish operation */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">u32_error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">u32_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u32_error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;spe cypher post op cant queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">u32_error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* schedule the data send */</span>
		<span class="n">u32_error</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
			<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">u32_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;cant submit work sep_crypto_block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Signal to crypto infrastructure and clear out */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hash update post op done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hash_final_post_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_length</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">u32_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;hash final post op</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* first bring msg from shared area to local area */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span>
		<span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="n">u32_error</span> <span class="o">=</span> <span class="n">sep_verify_op</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">SEP_HASH_FINISH_OPCODE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u32_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hash finish error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">u32_error</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">u32_error</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Grab the result */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Oops, null buffer; error out here */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash finish null buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">max_length</span> <span class="o">=</span> <span class="p">(((</span><span class="n">SEP_HASH_RESULT_SIZE_WORDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="n">sep_read_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span>
		<span class="n">crypto_ahash_digestsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">),</span> <span class="n">max_length</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Signal to crypto infrastructure and clear out */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hash finish post op done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hash_digest_post_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_length</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">u32_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;hash digest post op</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* first bring msg from shared area to local area */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span>
		<span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="n">u32_error</span> <span class="o">=</span> <span class="n">sep_verify_op</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">SEP_HASH_SINGLE_OPCODE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u32_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash digest finish error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>

		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="n">u32_error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">u32_error</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Grab the result */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Oops, null buffer; error out here */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash digest finish null buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">max_length</span> <span class="o">=</span> <span class="p">(((</span><span class="n">SEP_HASH_RESULT_SIZE_WORDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="n">sep_read_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span>
		<span class="n">crypto_ahash_digestsize</span><span class="p">(</span><span class="n">tfm</span><span class="p">),</span> <span class="n">max_length</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Signal to crypto infrastructure and clear out */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;hash digest finish post op done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * The sep_finish function is the function that is schedule (via tasket)</span>
<span class="cm"> * by the interrupt service routine when the SEP sends and interrupt</span>
<span class="cm"> * This is only called by the interrupt handler as a tasklet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_finish</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_finish called with null data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_finish; sep_dev is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">in_kernel</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep_finish; not in kernel operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Did we really do a sep command prior to this? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_SENDMSG_DONE_OFFSET</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">.</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sendmsg not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">send_ct</span> <span class="o">!=</span> <span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] poll; no message came back</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for error (In case time ran out) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mh">0x8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] poll; poll error GPR3 is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* What kind of interrupt from sep was this? */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR2_REG_ADDR</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] GPR2 at crypto finish is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="cm">/* Print request? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep print req</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] contents: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
			<span class="n">SEP_DRIVER_PRINTF_OFFSET_IN_BYTES</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Request for daemon (not currently in POR)? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] sep request; ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we got here, then we have a replay to a sep command */</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] sep reply to command; processing request: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">current_request</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">current_request</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AES_CBC</span>:
	<span class="k">case</span> <span class="n">AES_ECB</span>:
	<span class="k">case</span> <span class="n">DES_CBC</span>:
	<span class="k">case</span> <span class="n">DES_ECB</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">crypto_post_op</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SHA1</span>:
	<span class="k">case</span> <span class="n">MD5</span>:
	<span class="k">case</span> <span class="n">SHA224</span>:
	<span class="k">case</span> <span class="n">SHA256</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HASH_INIT</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">hash_init_post_op</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HASH_UPDATE</span>:
		<span class="k">case</span> <span class="n">HASH_FINUP_DATA</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">hash_update_post_op</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HASH_FINUP_FINISH</span>:
		<span class="k">case</span> <span class="n">HASH_FINISH</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">hash_final_post_op</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HASH_DIGEST</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">hash_digest_post_op</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - invalid stage for hash finish</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - invalid request for finish</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - finish returned error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_hash_cra_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_tfm</span> <span class="o">*</span><span class="n">tfm</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alg_name</span> <span class="o">=</span> <span class="n">crypto_tfm_alg_name</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_hash_cra_init name is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alg_name</span><span class="p">);</span>

	<span class="n">crypto_ahash_set_reqsize</span><span class="p">(</span><span class="n">__crypto_ahash_cast</span><span class="p">(</span><span class="n">tfm</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_hash_cra_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_tfm</span> <span class="o">*</span><span class="n">tfm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_hash_cra_exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_hash_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;sep_hash_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_INIT</span><span class="p">;</span>
	<span class="cm">/* opcode and mode */</span>
	<span class="n">sep_make_header</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">SEP_HASH_INIT_OPCODE</span><span class="p">);</span>
	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sep_end_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">);</span>

	<span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sep_crypto_take_sep</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep_hash_init take sep failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now we sit and wait up to a fixed time for completion */</span>
	<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">WAIT_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="cm">/* Done waiting; still not done yet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash init never got done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_hash_update</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">int_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_hash_internal_context</span> <span class="o">*</span><span class="n">int_ctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">head_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tail_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="k">static</span> <span class="n">u32</span> <span class="n">msg</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">small_buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">src_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">new_sg</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">copy_result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="cm">/* length for queue status */</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;sep_hash_update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_UPDATE</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">;</span>

	<span class="n">block_size</span> <span class="o">=</span> <span class="n">crypto_tfm_alg_blocksize</span><span class="p">(</span><span class="n">crypto_ahash_tfm</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
	<span class="n">tail_len</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;length is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;block_size is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;tail len is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">);</span>

	<span class="cm">/* Compute header/tail sizes */</span>
	<span class="n">int_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_hash_internal_context</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span>
		<span class="n">hash_private_ctx</span><span class="p">.</span><span class="n">internal_context</span><span class="p">;</span>
	<span class="n">head_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">-</span> <span class="n">int_ctx</span><span class="o">-&gt;</span><span class="n">prev_update_bytes</span><span class="p">)</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">tail_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="n">head_len</span><span class="p">)</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">;</span>

	<span class="cm">/* Make sure all pages are even block */</span>
	<span class="n">int_error</span> <span class="o">=</span> <span class="n">sep_oddball_pages</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span>
		<span class="n">block_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;oddball pages error in crash update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">src_ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* null data */</span>
		<span class="n">src_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_dump_sg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;hash block sg in&quot;</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">app_in_address</span> <span class="o">=</span> <span class="n">src_ptr</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">data_in_size</span> <span class="o">=</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="p">(</span><span class="n">head_len</span> <span class="o">+</span> <span class="n">tail_len</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">app_out_address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">tail_block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">is_applet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">int_error</span> <span class="o">=</span> <span class="n">sep_create_dcb_dmatables_context_kernel</span><span class="p">(</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_region</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_region</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash update dma table create failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Construct message to SEP */</span>
	<span class="n">sep_make_header</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">SEP_HASH_UPDATE_OPCODE</span><span class="p">);</span>

	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Handle remainders */</span>

	<span class="cm">/* Head */</span>
	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_result</span> <span class="o">=</span> <span class="n">sg_copy_to_buffer</span><span class="p">(</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span>
			<span class="n">sep_sg_nents</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">),</span>
			<span class="n">small_buf</span><span class="p">,</span> <span class="n">head_len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_result</span> <span class="o">!=</span> <span class="n">head_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;sg head copy failure in hash block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">small_buf</span><span class="p">,</span> <span class="n">head_len</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">msg_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tail */</span>
	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tail_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_result</span> <span class="o">=</span> <span class="n">sep_copy_offset_sg</span><span class="p">(</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="n">tail_len</span><span class="p">,</span>
			<span class="n">small_buf</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_result</span> <span class="o">!=</span> <span class="n">tail_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;sg tail copy failure in hash block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">small_buf</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">msg_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Context */</span>
	<span class="n">sep_write_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">hash_private_ctx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_hash_private_context</span><span class="p">));</span>

	<span class="n">sep_end_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">);</span>
	<span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">int_error</span> <span class="o">=</span> <span class="n">sep_crypto_take_sep</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep_hash_update take sep failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now we sit and wait up to a fixed time for completion */</span>
	<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">WAIT_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="cm">/* Done waiting; still not done yet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash update never got done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_hash_final</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;sep_hash_final</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINISH</span><span class="p">;</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="cm">/* opcode and mode */</span>
	<span class="n">sep_make_header</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">SEP_HASH_FINISH_OPCODE</span><span class="p">);</span>

	<span class="cm">/* Context */</span>
	<span class="n">sep_write_context</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">hash_private_ctx</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_hash_private_context</span><span class="p">));</span>

	<span class="n">sep_end_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">);</span>
	<span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sep_crypto_take_sep</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep_hash_final take sep failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now we sit and wait up to a fixed time for completion */</span>
	<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">WAIT_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="cm">/* Done waiting; still not done yet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash final job never got done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_hash_digest</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">int_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">copy_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">are_we_done_yet</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tail_len</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">small_buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">new_sg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">src_ptr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;sep_hash_digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_DIGEST</span><span class="p">;</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">are_we_done_yet</span><span class="p">;</span>

	<span class="cm">/* length for queue status */</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">;</span>

	<span class="n">block_size</span> <span class="o">=</span> <span class="n">crypto_tfm_alg_blocksize</span><span class="p">(</span><span class="n">crypto_ahash_tfm</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
	<span class="n">tail_len</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;length is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;block_size is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;tail len is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">);</span>

	<span class="cm">/* Make sure all pages are even block */</span>
	<span class="n">int_error</span> <span class="o">=</span> <span class="n">sep_oddball_pages</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span>
		<span class="n">block_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;oddball pages error in crash update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span> <span class="o">=</span> <span class="n">new_sg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg_hold</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">src_ptr</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* null data */</span>
		<span class="n">src_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_dump_sg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span> <span class="s">&quot;hash block sg in&quot;</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">app_in_address</span> <span class="o">=</span> <span class="n">src_ptr</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">data_in_size</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="n">tail_len</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">app_out_address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">tail_block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">is_applet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">.</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">int_error</span> <span class="o">=</span> <span class="n">sep_create_dcb_dmatables_context_kernel</span><span class="p">(</span>
		<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_region</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_region</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">dcb_input_data</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash update dma table create failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Construct message to SEP */</span>
	<span class="n">sep_make_header</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="n">SEP_HASH_SINGLE_OPCODE</span><span class="p">);</span>
	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Tail */</span>
	<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tail_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_result</span> <span class="o">=</span> <span class="n">sep_copy_offset_sg</span><span class="p">(</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="p">,</span>
			<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="n">tail_len</span><span class="p">,</span>
			<span class="n">small_buf</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_result</span> <span class="o">!=</span> <span class="n">tail_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;sg tail copy failure in hash block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sep_write_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">small_buf</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">msg_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_end_msg</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="n">msg_offset</span><span class="p">);</span>

	<span class="n">are_we_done_yet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sep_crypto_take_sep</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sep_hash_digest take sep failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now we sit and wait up to a fixed time for completion */</span>
	<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">WAIT_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="cm">/* Done waiting; still not done yet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">are_we_done_yet</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;hash digest job never got done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sep_crypto_release</span><span class="p">(</span><span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * This is what is called by each of the API&#39;s provided</span>
<span class="cm"> * in the kernel crypto descriptors. It is run in a process</span>
<span class="cm"> * context using the kernel workqueues. Therefore it can</span>
<span class="cm"> * be put to sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_dequeuer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_queue</span> <span class="o">*</span><span class="n">this_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_async_request</span> <span class="o">*</span><span class="n">async_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_async_request</span> <span class="o">*</span><span class="n">backlog</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">cypher_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">hash_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_ahash</span> <span class="o">*</span><span class="n">hash_tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span><span class="p">;</span>


	<span class="n">this_queue</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">crypto_queue</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">backlog</span> <span class="o">=</span> <span class="n">crypto_get_backlog</span><span class="p">(</span><span class="n">this_queue</span><span class="p">);</span>
	<span class="n">async_req</span> <span class="o">=</span> <span class="n">crypto_dequeue_request</span><span class="p">(</span><span class="n">this_queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue is empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">backlog</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto backlog set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">backlog</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
			<span class="n">backlog</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">backlog</span><span class="p">,</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">);</span>
		<span class="n">backlog</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async_req</span><span class="o">-&gt;</span><span class="n">tfm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue null tfm</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async_req</span><span class="o">-&gt;</span><span class="n">tfm</span><span class="o">-&gt;</span><span class="n">__crt_alg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue null __crt_alg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async_req</span><span class="o">-&gt;</span><span class="n">tfm</span><span class="o">-&gt;</span><span class="n">__crt_alg</span><span class="o">-&gt;</span><span class="n">cra_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue null cra_type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we have stuff in the queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">async_req</span><span class="o">-&gt;</span><span class="n">tfm</span><span class="o">-&gt;</span><span class="n">__crt_alg</span><span class="o">-&gt;</span><span class="n">cra_type</span> <span class="o">!=</span>
		<span class="o">&amp;</span><span class="n">crypto_ahash_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is for a cypher */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue doing cipher</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cypher_req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">async_req</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ablkcipher_request</span><span class="p">,</span>
			<span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cypher_req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue null cypher_req</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sep_crypto_block</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cypher_req</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* This is a hash */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue doing hash</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/**</span>
<span class="cm">		 * This is a bit more complex than cipher; we</span>
<span class="cm">		 * need to figure out what type of operation</span>
<span class="cm">		 */</span>
		<span class="n">hash_req</span> <span class="o">=</span> <span class="n">ahash_request_cast</span><span class="p">(</span><span class="n">async_req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash_req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue null hash_req</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hash_tfm</span> <span class="o">=</span> <span class="n">crypto_ahash_reqtfm</span><span class="p">(</span><span class="n">hash_req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash_tfm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue null hash_tfm</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ahash_ctx</span><span class="p">(</span><span class="n">hash_tfm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue null sctx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">hash_req</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">==</span> <span class="n">HASH_INIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue hash init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_hash_init</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hash_req</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">==</span> <span class="n">HASH_UPDATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue hash update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_hash_update</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hash_req</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">==</span> <span class="n">HASH_FINISH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue hash final</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_hash_final</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hash_req</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">==</span> <span class="n">HASH_DIGEST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue hash digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_hash_digest</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hash_req</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">==</span> <span class="n">HASH_FINUP_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue hash digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_hash_update</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hash_req</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">==</span> <span class="n">HASH_FINUP_FINISH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue hash digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sep_hash_final</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hash_req</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep crypto queue hash oops nothing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha1_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha1 init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_INIT</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha1_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha1 update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_UPDATE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha1_final</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha1 final</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINISH</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha1_digest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha1 digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_DIGEST</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha1_finup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha1 finup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA1</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINUP_DATA</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_md5_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing md5 init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_INIT</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_md5_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing md5 update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_UPDATE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_md5_final</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing md5 final</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINISH</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_md5_digest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing md5 digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_DIGEST</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_md5_finup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing md5 finup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_MD5</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINUP_DATA</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha224_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha224 init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_INIT</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha224_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha224 update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_UPDATE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha224_final</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha224 final</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINISH</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha224_digest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha224 digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_DIGEST</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha224_finup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha224 finup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA224</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINUP_DATA</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha256_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha256 init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_INIT</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha256_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha256 update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_UPDATE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha256_final</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha256 final</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINISH</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha256_digest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha256 digest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_DIGEST</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_sha256_finup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ahash_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing sha256 finup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">hash_opmode</span> <span class="o">=</span> <span class="n">SEP_HASH_SHA256</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_stage</span> <span class="o">=</span> <span class="n">HASH_FINUP_DATA</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_crypto_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_tfm</span> <span class="o">*</span><span class="n">tfm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alg_name</span> <span class="o">=</span> <span class="n">crypto_tfm_alg_name</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alg_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_crypto_init alg is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_crypto_init alg is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alg_name</span><span class="p">);</span>

	<span class="n">tfm</span><span class="o">-&gt;</span><span class="n">crt_ablkcipher</span><span class="p">.</span><span class="n">reqsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_crypto_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_tfm</span> <span class="o">*</span><span class="n">tfm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep_crypto_exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_aes_setkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep aes setkey</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tfm is %p sctx is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tfm</span><span class="p">,</span> <span class="n">sctx</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">keylen</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEP_AES_KEY_128_SIZE</span>:
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_key_size</span> <span class="o">=</span> <span class="n">AES_128</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEP_AES_KEY_192_SIZE</span>:
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_key_size</span> <span class="o">=</span> <span class="n">AES_192</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEP_AES_KEY_256_SIZE</span>:
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_key_size</span> <span class="o">=</span> <span class="n">AES_256</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEP_AES_KEY_512_SIZE</span>:
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">aes_key_size</span> <span class="o">=</span> <span class="n">AES_512</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid sep aes key size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">keylen</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">aes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span>
		<span class="n">SEP_AES_MAX_KEY_SIZE_WORDS</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">aes</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keylen</span><span class="p">);</span>
	<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">keylen</span> <span class="o">=</span> <span class="n">keylen</span><span class="p">;</span>
	<span class="cm">/* Indicate to encrypt/decrypt function to send key to SEP */</span>
	<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_aes_ecb_encrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing aes ecb encrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">AES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_encmode</span> <span class="o">=</span> <span class="n">SEP_AES_ENCRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">=</span> <span class="n">SEP_AES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_aes_ecb_decrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing aes ecb decrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">AES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_encmode</span> <span class="o">=</span> <span class="n">SEP_AES_DECRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">=</span> <span class="n">SEP_AES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_aes_cbc_encrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span>
		<span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing aes cbc encrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tfm is %p sctx is %p and ta_ctx is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">);</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">AES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_encmode</span> <span class="o">=</span> <span class="n">SEP_AES_ENCRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">=</span> <span class="n">SEP_AES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_aes_cbc_decrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span>
		<span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing aes cbc decrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tfm is %p sctx is %p and ta_ctx is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">crypto_ablkcipher_reqtfm</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="n">sctx</span><span class="p">,</span> <span class="n">ta_ctx</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">AES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_encmode</span> <span class="o">=</span> <span class="n">SEP_AES_DECRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">aes_opmode</span> <span class="o">=</span> <span class="n">SEP_AES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_AES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_des_setkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_ablkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_system_ctx</span> <span class="o">*</span><span class="n">sctx</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_ctx</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">crypto_tfm</span> <span class="o">*</span><span class="n">ctfm</span> <span class="o">=</span> <span class="n">crypto_ablkcipher_tfm</span><span class="p">(</span><span class="n">tfm</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">flags</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctfm</span><span class="o">-&gt;</span><span class="n">crt_flags</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep des setkey</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">keylen</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DES_KEY_SIZE</span>:
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_nbr_keys</span> <span class="o">=</span> <span class="n">DES_KEY_1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DES_KEY_SIZE</span> <span class="o">*</span> <span class="mi">2</span>:
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_nbr_keys</span> <span class="o">=</span> <span class="n">DES_KEY_2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DES_KEY_SIZE</span> <span class="o">*</span> <span class="mi">3</span>:
		<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">des_nbr_keys</span> <span class="o">=</span> <span class="n">DES_KEY_3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid key size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">keylen</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CRYPTO_TFM_REQ_WEAK_KEY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">sep_weak_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">keylen</span><span class="p">)))</span> <span class="p">{</span>

		<span class="o">*</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CRYPTO_TFM_RES_WEAK_KEY</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;weak key</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">des</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_des_key</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">des</span><span class="p">.</span><span class="n">key1</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keylen</span><span class="p">);</span>
	<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">keylen</span> <span class="o">=</span> <span class="n">keylen</span><span class="p">;</span>
	<span class="cm">/* Indicate to encrypt/decrypt function to send key to SEP */</span>
	<span class="n">sctx</span><span class="o">-&gt;</span><span class="n">key_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_des_ebc_encrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing des ecb encrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">DES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_encmode</span> <span class="o">=</span> <span class="n">SEP_DES_ENCRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">=</span> <span class="n">SEP_DES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_des_ebc_decrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing des ecb decrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">DES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_encmode</span> <span class="o">=</span> <span class="n">SEP_DES_DECRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">=</span> <span class="n">SEP_DES_ECB</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_des_cbc_encrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing des cbc encrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">DES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_encmode</span> <span class="o">=</span> <span class="n">SEP_DES_ENCRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">=</span> <span class="n">SEP_DES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_des_cbc_decrypt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ablkcipher_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">this_task_ctx</span> <span class="o">*</span><span class="n">ta_ctx</span> <span class="o">=</span> <span class="n">ablkcipher_request_ctx</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;sep - doing des ecb decrypt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear out task context */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ta_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">this_task_ctx</span><span class="p">));</span>

	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_request</span> <span class="o">=</span> <span class="n">DES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_hash_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">current_cypher_req</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_encmode</span> <span class="o">=</span> <span class="n">SEP_DES_DECRYPT</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">des_opmode</span> <span class="o">=</span> <span class="n">SEP_DES_CBC</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">init_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_INIT_OPCODE</span><span class="p">;</span>
	<span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">block_opcode</span> <span class="o">=</span> <span class="n">SEP_DES_BLOCK_OPCODE</span><span class="p">;</span>

	<span class="cm">/* lock necessary so that only one entity touches the queues */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">crypto_enqueue_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - crypto enqueue failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error</span><span class="p">);</span>
	<span class="n">error1</span> <span class="o">=</span> <span class="n">sep_submit_work</span><span class="p">(</span><span class="n">ta_ctx</span><span class="o">-&gt;</span><span class="n">sep_used</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span>
		<span class="n">sep_dequeuer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error1</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; sep - workqueue submit failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* We return result of crypto enqueue */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ahash_alg</span> <span class="n">hash_algs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">sep_sha1_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update</span>		<span class="o">=</span> <span class="n">sep_sha1_update</span><span class="p">,</span>
	<span class="p">.</span><span class="n">final</span>		<span class="o">=</span> <span class="n">sep_sha1_final</span><span class="p">,</span>
	<span class="p">.</span><span class="n">digest</span>		<span class="o">=</span> <span class="n">sep_sha1_digest</span><span class="p">,</span>
	<span class="p">.</span><span class="n">finup</span>		<span class="o">=</span> <span class="n">sep_sha1_finup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">halg</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">digestsize</span>	<span class="o">=</span> <span class="n">SHA1_DIGEST_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">base</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;sha1&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;sha1-sep&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_AHASH</span> <span class="o">|</span>
						<span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">SHA1_BLOCK_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
		<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_hash_cra_init</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_hash_cra_exit</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">sep_md5_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update</span>		<span class="o">=</span> <span class="n">sep_md5_update</span><span class="p">,</span>
	<span class="p">.</span><span class="n">final</span>		<span class="o">=</span> <span class="n">sep_md5_final</span><span class="p">,</span>
	<span class="p">.</span><span class="n">digest</span>		<span class="o">=</span> <span class="n">sep_md5_digest</span><span class="p">,</span>
	<span class="p">.</span><span class="n">finup</span>		<span class="o">=</span> <span class="n">sep_md5_finup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">halg</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">digestsize</span>	<span class="o">=</span> <span class="n">MD5_DIGEST_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">base</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;md5&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;md5-sep&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_AHASH</span> <span class="o">|</span>
						<span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">SHA1_BLOCK_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
		<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_hash_cra_init</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_hash_cra_exit</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">sep_sha224_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update</span>		<span class="o">=</span> <span class="n">sep_sha224_update</span><span class="p">,</span>
	<span class="p">.</span><span class="n">final</span>		<span class="o">=</span> <span class="n">sep_sha224_final</span><span class="p">,</span>
	<span class="p">.</span><span class="n">digest</span>		<span class="o">=</span> <span class="n">sep_sha224_digest</span><span class="p">,</span>
	<span class="p">.</span><span class="n">finup</span>		<span class="o">=</span> <span class="n">sep_sha224_finup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">halg</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">digestsize</span>	<span class="o">=</span> <span class="n">SHA224_DIGEST_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">base</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;sha224&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;sha224-sep&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_AHASH</span> <span class="o">|</span>
						<span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">SHA224_BLOCK_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
		<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_hash_cra_init</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_hash_cra_exit</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">sep_sha256_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update</span>		<span class="o">=</span> <span class="n">sep_sha256_update</span><span class="p">,</span>
	<span class="p">.</span><span class="n">final</span>		<span class="o">=</span> <span class="n">sep_sha256_final</span><span class="p">,</span>
	<span class="p">.</span><span class="n">digest</span>		<span class="o">=</span> <span class="n">sep_sha256_digest</span><span class="p">,</span>
	<span class="p">.</span><span class="n">finup</span>		<span class="o">=</span> <span class="n">sep_sha256_finup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">halg</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">digestsize</span>	<span class="o">=</span> <span class="n">SHA256_DIGEST_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">base</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;sha256&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;sha256-sep&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_AHASH</span> <span class="o">|</span>
						<span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">SHA256_BLOCK_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
		<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_hash_cra_init</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_hash_cra_exit</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">crypto_alg</span> <span class="n">crypto_algs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;ecb(aes)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;ecb-aes-sep&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_ABLKCIPHER</span> <span class="o">|</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">AES_BLOCK_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
	<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">crypto_ablkcipher_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_crypto_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_crypto_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_u</span><span class="p">.</span><span class="n">ablkcipher</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">min_keysize</span>	<span class="o">=</span> <span class="n">AES_MIN_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_keysize</span>	<span class="o">=</span> <span class="n">AES_MAX_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">setkey</span>		<span class="o">=</span> <span class="n">sep_aes_setkey</span><span class="p">,</span>
		<span class="p">.</span><span class="n">encrypt</span>	<span class="o">=</span> <span class="n">sep_aes_ecb_encrypt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">decrypt</span>	<span class="o">=</span> <span class="n">sep_aes_ecb_decrypt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;cbc(aes)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;cbc-aes-sep&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_ABLKCIPHER</span> <span class="o">|</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">AES_BLOCK_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
	<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">crypto_ablkcipher_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_crypto_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_crypto_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_u</span><span class="p">.</span><span class="n">ablkcipher</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">min_keysize</span>	<span class="o">=</span> <span class="n">AES_MIN_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_keysize</span>	<span class="o">=</span> <span class="n">AES_MAX_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">setkey</span>		<span class="o">=</span> <span class="n">sep_aes_setkey</span><span class="p">,</span>
		<span class="p">.</span><span class="n">encrypt</span>	<span class="o">=</span> <span class="n">sep_aes_cbc_encrypt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ivsize</span>		<span class="o">=</span> <span class="n">AES_BLOCK_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">decrypt</span>	<span class="o">=</span> <span class="n">sep_aes_cbc_decrypt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;ebc(des)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;ebc-des-sep&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_ABLKCIPHER</span> <span class="o">|</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">DES_BLOCK_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
	<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">crypto_ablkcipher_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_crypto_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_crypto_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_u</span><span class="p">.</span><span class="n">ablkcipher</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">min_keysize</span>	<span class="o">=</span> <span class="n">DES_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_keysize</span>	<span class="o">=</span> <span class="n">DES_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">setkey</span>		<span class="o">=</span> <span class="n">sep_des_setkey</span><span class="p">,</span>
		<span class="p">.</span><span class="n">encrypt</span>	<span class="o">=</span> <span class="n">sep_des_ebc_encrypt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">decrypt</span>	<span class="o">=</span> <span class="n">sep_des_ebc_decrypt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;cbc(des)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;cbc-des-sep&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_ABLKCIPHER</span> <span class="o">|</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">DES_BLOCK_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
	<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">crypto_ablkcipher_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_crypto_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_crypto_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_u</span><span class="p">.</span><span class="n">ablkcipher</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">min_keysize</span>	<span class="o">=</span> <span class="n">DES_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_keysize</span>	<span class="o">=</span> <span class="n">DES_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">setkey</span>		<span class="o">=</span> <span class="n">sep_des_setkey</span><span class="p">,</span>
		<span class="p">.</span><span class="n">encrypt</span>	<span class="o">=</span> <span class="n">sep_des_cbc_encrypt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ivsize</span>		<span class="o">=</span> <span class="n">DES_BLOCK_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">decrypt</span>	<span class="o">=</span> <span class="n">sep_des_cbc_decrypt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;ebc(des3-ede)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;ebc-des3-ede-sep&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_ABLKCIPHER</span> <span class="o">|</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">DES_BLOCK_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
	<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">crypto_ablkcipher_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_crypto_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_crypto_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_u</span><span class="p">.</span><span class="n">ablkcipher</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">min_keysize</span>	<span class="o">=</span> <span class="n">DES3_EDE_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_keysize</span>	<span class="o">=</span> <span class="n">DES3_EDE_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">setkey</span>		<span class="o">=</span> <span class="n">sep_des_setkey</span><span class="p">,</span>
		<span class="p">.</span><span class="n">encrypt</span>	<span class="o">=</span> <span class="n">sep_des_ebc_encrypt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">decrypt</span>	<span class="o">=</span> <span class="n">sep_des_ebc_decrypt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">cra_name</span>		<span class="o">=</span> <span class="s">&quot;cbc(des3-ede)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_driver_name</span>	<span class="o">=</span> <span class="s">&quot;cbc-des3--ede-sep&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_priority</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_flags</span>		<span class="o">=</span> <span class="n">CRYPTO_ALG_TYPE_ABLKCIPHER</span> <span class="o">|</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_blocksize</span>		<span class="o">=</span> <span class="n">DES_BLOCK_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_ctxsize</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_system_ctx</span><span class="p">),</span>
	<span class="p">.</span><span class="n">cra_alignmask</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_type</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">crypto_ablkcipher_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_init</span>		<span class="o">=</span> <span class="n">sep_crypto_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_exit</span>		<span class="o">=</span> <span class="n">sep_crypto_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cra_u</span><span class="p">.</span><span class="n">ablkcipher</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">min_keysize</span>	<span class="o">=</span> <span class="n">DES3_EDE_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_keysize</span>	<span class="o">=</span> <span class="n">DES3_EDE_KEY_SIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">setkey</span>		<span class="o">=</span> <span class="n">sep_des_setkey</span><span class="p">,</span>
		<span class="p">.</span><span class="n">encrypt</span>	<span class="o">=</span> <span class="n">sep_des_cbc_encrypt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">decrypt</span>	<span class="o">=</span> <span class="n">sep_des_cbc_decrypt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sep_crypto_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">finish_tasklet</span><span class="p">,</span> <span class="n">sep_finish</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sep_dev</span><span class="p">);</span>

	<span class="n">crypto_init_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_queue</span><span class="p">,</span> <span class="n">SEP_QUEUE_LENGTH</span><span class="p">);</span>

	<span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span>
		<span class="s">&quot;sep_crypto_workqueue&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cant create workqueue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">hash_algs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_register_ahash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash_algs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_algs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">crypto_algs</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_register_alg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypto_algs</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_crypto_algs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">err_algs:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">crypto_unregister_ahash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash_algs</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">err_crypto_algs:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">crypto_unregister_alg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypto_algs</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
	<span class="k">goto</span> <span class="n">err_algs</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sep_crypto_takedown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">hash_algs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">crypto_unregister_ahash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash_algs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">crypto_algs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">crypto_unregister_alg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crypto_algs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">finish_tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
