<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › sep › sep_driver_api.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sep_driver_api.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *  sep_driver_api.h - Security Processor Driver api definitions</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright(c) 2009-2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *  Contributions(c) 2009-2011 Discretix. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> *  Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> *  more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> *  this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *  CONTACTS:</span>
<span class="cm"> *</span>
<span class="cm"> *  Mark Allyn		mark.a.allyn@intel.com</span>
<span class="cm"> *  Jayant Mangalampalli jayant.mangalampalli@intel.com</span>
<span class="cm"> *</span>
<span class="cm"> *  CHANGES:</span>
<span class="cm"> *</span>
<span class="cm"> *  2010.09.14  Upgrade to Medfield</span>
<span class="cm"> *  2011.02.22  Enable kernel crypto</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __SEP_DRIVER_API_H__</span>
<span class="cp">#define __SEP_DRIVER_API_H__</span>

<span class="cm">/* Type of request from device */</span>
<span class="cp">#define SEP_DRIVER_SRC_REPLY		1</span>
<span class="cp">#define SEP_DRIVER_SRC_REQ		2</span>
<span class="cp">#define SEP_DRIVER_SRC_PRINTF		3</span>

<span class="cm">/* Power state */</span>
<span class="cp">#define SEP_DRIVER_POWERON		1</span>
<span class="cp">#define SEP_DRIVER_POWEROFF		2</span>

<span class="cm">/* Following enums are used only for kernel crypto api */</span>
<span class="k">enum</span> <span class="n">type_of_request</span> <span class="p">{</span>
	<span class="n">NO_REQUEST</span><span class="p">,</span>
	<span class="n">AES_CBC</span><span class="p">,</span>
	<span class="n">AES_ECB</span><span class="p">,</span>
	<span class="n">DES_CBC</span><span class="p">,</span>
	<span class="n">DES_ECB</span><span class="p">,</span>
	<span class="n">DES3_ECB</span><span class="p">,</span>
	<span class="n">DES3_CBC</span><span class="p">,</span>
	<span class="n">SHA1</span><span class="p">,</span>
	<span class="n">MD5</span><span class="p">,</span>
	<span class="n">SHA224</span><span class="p">,</span>
	<span class="n">SHA256</span>
	<span class="p">};</span>

<span class="k">enum</span> <span class="n">hash_stage</span> <span class="p">{</span>
	<span class="n">HASH_INIT</span><span class="p">,</span>
	<span class="n">HASH_UPDATE</span><span class="p">,</span>
	<span class="n">HASH_FINISH</span><span class="p">,</span>
	<span class="n">HASH_DIGEST</span><span class="p">,</span>
	<span class="n">HASH_FINUP_DATA</span><span class="p">,</span>
	<span class="n">HASH_FINUP_FINISH</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">  structure that represents DCB</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="p">{</span>
	<span class="cm">/* physical address of the first input mlli */</span>
	<span class="n">u32</span>	<span class="n">input_mlli_address</span><span class="p">;</span>
	<span class="cm">/* num of entries in the first input mlli */</span>
	<span class="n">u32</span>	<span class="n">input_mlli_num_entries</span><span class="p">;</span>
	<span class="cm">/* size of data in the first input mlli */</span>
	<span class="n">u32</span>	<span class="n">input_mlli_data_size</span><span class="p">;</span>
	<span class="cm">/* physical address of the first output mlli */</span>
	<span class="n">u32</span>	<span class="n">output_mlli_address</span><span class="p">;</span>
	<span class="cm">/* num of entries in the first output mlli */</span>
	<span class="n">u32</span>	<span class="n">output_mlli_num_entries</span><span class="p">;</span>
	<span class="cm">/* size of data in the first output mlli */</span>
	<span class="n">u32</span>	<span class="n">output_mlli_data_size</span><span class="p">;</span>
	<span class="cm">/* pointer to the output virtual tail */</span>
	<span class="n">aligned_u64</span> <span class="n">out_vr_tail_pt</span><span class="p">;</span>
	<span class="cm">/* size of tail data */</span>
	<span class="n">u32</span>	<span class="n">tail_data_size</span><span class="p">;</span>
	<span class="cm">/* input tail data array */</span>
	<span class="n">u8</span>	<span class="n">tail_data</span><span class="p">[</span><span class="mi">68</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">	command structure for building dcb block (currently for ext app only</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">build_dcb_struct</span> <span class="p">{</span>
	<span class="cm">/* address value of the data in */</span>
	<span class="n">aligned_u64</span> <span class="n">app_in_address</span><span class="p">;</span>
	<span class="cm">/* size of data in */</span>
	<span class="n">u32</span>  <span class="n">data_in_size</span><span class="p">;</span>
	<span class="cm">/* address of the data out */</span>
	<span class="n">aligned_u64</span> <span class="n">app_out_address</span><span class="p">;</span>
	<span class="cm">/* the size of the block of the operation - if needed,</span>
<span class="cm">	every table will be modulo this parameter */</span>
	<span class="n">u32</span>  <span class="n">block_size</span><span class="p">;</span>
	<span class="cm">/* the size of the block of the operation - if needed,</span>
<span class="cm">	every table will be modulo this parameter */</span>
	<span class="n">u32</span>  <span class="n">tail_block_size</span><span class="p">;</span>

	<span class="cm">/* which application calls the driver DX or applet */</span>
	<span class="n">u32</span>  <span class="n">is_applet</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">	command structure for building dcb block for kernel crypto</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">build_dcb_struct_kernel</span> <span class="p">{</span>
	<span class="cm">/* address value of the data in */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">app_in_address</span><span class="p">;</span>
	<span class="cm">/* size of data in */</span>
	<span class="kt">ssize_t</span>  <span class="n">data_in_size</span><span class="p">;</span>
	<span class="cm">/* address of the data out */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">app_out_address</span><span class="p">;</span>
	<span class="cm">/* the size of the block of the operation - if needed,</span>
<span class="cm">	every table will be modulo this parameter */</span>
	<span class="n">u32</span>  <span class="n">block_size</span><span class="p">;</span>
	<span class="cm">/* the size of the block of the operation - if needed,</span>
<span class="cm">	every table will be modulo this parameter */</span>
	<span class="n">u32</span>  <span class="n">tail_block_size</span><span class="p">;</span>

	<span class="cm">/* which application calls the driver DX or applet */</span>
	<span class="n">u32</span>  <span class="n">is_applet</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">src_sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dst_sg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @struct sep_dma_map</span>
<span class="cm"> *</span>
<span class="cm"> * Structure that contains all information needed for mapping the user pages</span>
<span class="cm"> *	     or kernel buffers for dma operations</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="p">{</span>
	<span class="cm">/* mapped dma address */</span>
	<span class="n">dma_addr_t</span>    <span class="n">dma_addr</span><span class="p">;</span>
	<span class="cm">/* size of the mapped data */</span>
	<span class="kt">size_t</span>        <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sep_dma_resource</span> <span class="p">{</span>
	<span class="cm">/* array of pointers to the pages that represent</span>
<span class="cm">	input data for the synchronic DMA action */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">in_page_array</span><span class="p">;</span>

	<span class="cm">/* array of pointers to the pages that represent out</span>
<span class="cm">	data for the synchronic DMA action */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">out_page_array</span><span class="p">;</span>

	<span class="cm">/* number of pages in the sep_in_page_array */</span>
	<span class="n">u32</span> <span class="n">in_num_pages</span><span class="p">;</span>

	<span class="cm">/* number of pages in the sep_out_page_array */</span>
	<span class="n">u32</span> <span class="n">out_num_pages</span><span class="p">;</span>

	<span class="cm">/* map array of the input data */</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">*</span><span class="n">in_map_array</span><span class="p">;</span>

	<span class="cm">/* map array of the output data */</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">*</span><span class="n">out_map_array</span><span class="p">;</span>

	<span class="cm">/* number of entries of the input mapp array */</span>
	<span class="n">u32</span> <span class="n">in_map_num_entries</span><span class="p">;</span>

	<span class="cm">/* number of entries of the output mapp array */</span>
	<span class="n">u32</span> <span class="n">out_map_num_entries</span><span class="p">;</span>

	<span class="cm">/* Scatter list for kernel operations */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">src_sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dst_sg</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* command struct for translating rar handle to bus address</span>
<span class="cm">   and setting it at predefined location */</span>
<span class="k">struct</span> <span class="n">rar_hndl_to_bus_struct</span> <span class="p">{</span>

	<span class="cm">/* rar handle */</span>
	<span class="n">aligned_u64</span> <span class="n">rar_handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">  structure that represent one entry in the DMA LLI table</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="p">{</span>
	<span class="cm">/* physical address */</span>
	<span class="n">u32</span> <span class="n">bus_address</span><span class="p">;</span>

	<span class="cm">/* block size */</span>
	<span class="n">u32</span> <span class="n">block_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * header format for each fastcall write operation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sep_fastcall_hdr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secure_dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_dcbs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * structure used in file pointer&#39;s private data field</span>
<span class="cm"> * to track the status of the calls to the various</span>
<span class="cm"> * driver interface</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * format of dma context buffer used to store all DMA-related</span>
<span class="cm"> * context information of a particular transaction</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="p">{</span>
	<span class="cm">/* number of data control blocks */</span>
	<span class="n">u32</span> <span class="n">nr_dcb_creat</span><span class="p">;</span>
	<span class="cm">/* number of the lli tables created in the current transaction */</span>
	<span class="n">u32</span> <span class="n">num_lli_tables_created</span><span class="p">;</span>
	<span class="cm">/* size of currently allocated dma tables region */</span>
	<span class="n">u32</span> <span class="n">dmatables_len</span><span class="p">;</span>
	<span class="cm">/* size of input data */</span>
	<span class="n">u32</span> <span class="n">input_data_len</span><span class="p">;</span>
	<span class="cm">/* secure dma use (for imr memory restriced area in output */</span>
	<span class="n">bool</span> <span class="n">secure_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_resource</span> <span class="n">dma_res_arr</span><span class="p">[</span><span class="n">SEP_MAX_NUM_SYNC_DMA_OPS</span><span class="p">];</span>
	<span class="cm">/* Scatter gather for kernel crypto */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">src_sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dst_sg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * format for file pointer&#39;s private_data field</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">*</span><span class="n">my_queue_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="n">call_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Functions used by sep_crypto */</span>

<span class="cm">/**</span>
<span class="cm"> * sep_queue_status_remove - Removes transaction from status queue</span>
<span class="cm"> * @sep: SEP device</span>
<span class="cm"> * @sep_queue_info: pointer to status queue</span>
<span class="cm"> *</span>
<span class="cm"> * This function will removes information about transaction from the queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sep_queue_status_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">**</span><span class="n">queue_elem</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * sep_queue_status_add - Adds transaction to status queue</span>
<span class="cm"> * @sep: SEP device</span>
<span class="cm"> * @opcode: transaction opcode</span>
<span class="cm"> * @size: input data size</span>
<span class="cm"> * @pid: pid of current process</span>
<span class="cm"> * @name: current process name</span>
<span class="cm"> * @name_len: length of name (current process)</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds information about about transaction started to the status</span>
<span class="cm"> * queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">*</span><span class="n">sep_queue_status_add</span><span class="p">(</span>
						<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">opcode</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">pid</span><span class="p">,</span>
						<span class="n">u8</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">name_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_create_dcb_dmatables_context_kernel - Creates DCB &amp; MLLI/DMA table context</span>
<span class="cm"> *      for kernel crypto</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@dcb_region: DCB region buf to create for current transaction</span>
<span class="cm"> *	@dmatables_region: MLLI/DMA tables buf to create for current transaction</span>
<span class="cm"> *	@dma_ctx: DMA context buf to create for current transaction</span>
<span class="cm"> *	@user_dcb_args: User arguments for DCB/MLLI creation</span>
<span class="cm"> *	@num_dcbs: Number of DCBs to create</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sep_create_dcb_dmatables_context_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">**</span><span class="n">dcb_region</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">build_dcb_struct_kernel</span> <span class="o">*</span><span class="n">dcb_data</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="n">num_dcbs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_activate_dcb_dmatables_context - Takes DCB &amp; DMA tables</span>
<span class="cm"> *						contexts into use</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@dcb_region: DCB region copy</span>
<span class="cm"> *	@dmatables_region: MLLI/DMA tables copy</span>
<span class="cm"> *	@dma_ctx: DMA context for current transaction</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="n">sep_activate_dcb_dmatables_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">**</span><span class="n">dcb_region</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sep_prepare_input_output_dma_table_in_dcb - prepare control blocks</span>
<span class="cm"> * @app_in_address: unsigned long; for data buffer in (user space)</span>
<span class="cm"> * @app_out_address: unsigned long; for data buffer out (user space)</span>
<span class="cm"> * @data_in_size: u32; for size of data</span>
<span class="cm"> * @block_size: u32; for block size</span>
<span class="cm"> * @tail_block_size: u32; for size of tail block</span>
<span class="cm"> * @isapplet: bool; to indicate external app</span>
<span class="cm"> * @is_kva: bool; kernel buffer; only used for kernel crypto module</span>
<span class="cm"> * @secure_dma; indicates whether this is secure_dma using IMR</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares the linked DMA tables and puts the</span>
<span class="cm"> * address for the linked list of tables inta a DCB (data control</span>
<span class="cm"> * block) the address of which is known by the SEP hardware</span>
<span class="cm"> * Note that all bus addresses that are passed to the SEP</span>
<span class="cm"> * are in 32 bit format; the SEP is a 32 bit device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sep_prepare_input_output_dma_table_in_dcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">app_in_address</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">app_out_address</span><span class="p">,</span>
	<span class="n">u32</span>  <span class="n">data_in_size</span><span class="p">,</span>
	<span class="n">u32</span>  <span class="n">block_size</span><span class="p">,</span>
	<span class="n">u32</span>  <span class="n">tail_block_size</span><span class="p">,</span>
	<span class="n">bool</span> <span class="n">isapplet</span><span class="p">,</span>
	<span class="n">bool</span>	<span class="n">is_kva</span><span class="p">,</span>
	<span class="n">bool</span>    <span class="n">secure_dma</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">*</span><span class="n">dcb_region</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">src_sg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dst_sg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sep_free_dma_table_data_handler - free DMA table</span>
<span class="cm"> * @sep: pointere to struct sep_device</span>
<span class="cm"> * @dma_ctx: dma context</span>
<span class="cm"> *</span>
<span class="cm"> * Handles the request to  free DMA table for synchronic actions</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sep_free_dma_table_data_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * sep_send_command_handler - kick off a command</span>
<span class="cm"> * @sep: SEP being signalled</span>
<span class="cm"> *</span>
<span class="cm"> * This function raises interrupt to SEP that signals that is has a new</span>
<span class="cm"> * command from the host</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function does fall under the ioctl lock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sep_send_command_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_wait_transaction - Used for synchronizing transactions</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sep_wait_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * IOCTL command defines</span>
<span class="cm"> */</span>
<span class="cm">/* magic number 1 of the sep IOCTL command */</span>
<span class="cp">#define SEP_IOC_MAGIC_NUMBER	&#39;s&#39;</span>

<span class="cm">/* sends interrupt to sep that message is ready */</span>
<span class="cp">#define SEP_IOCSENDSEPCOMMAND	 \</span>
<span class="cp">	_IO(SEP_IOC_MAGIC_NUMBER, 0)</span>

<span class="cm">/* end transaction command */</span>
<span class="cp">#define SEP_IOCENDTRANSACTION	 \</span>
<span class="cp">	_IO(SEP_IOC_MAGIC_NUMBER, 15)</span>

<span class="cp">#define SEP_IOCPREPAREDCB					\</span>
<span class="cp">	_IOW(SEP_IOC_MAGIC_NUMBER, 35, struct build_dcb_struct)</span>

<span class="cp">#define SEP_IOCFREEDCB					\</span>
<span class="cp">	_IO(SEP_IOC_MAGIC_NUMBER, 36)</span>

<span class="k">struct</span> <span class="n">sep_device</span><span class="p">;</span>

<span class="cp">#define SEP_IOCPREPAREDCB_SECURE_DMA	\</span>
<span class="cp">	_IOW(SEP_IOC_MAGIC_NUMBER, 38, struct build_dcb_struct)</span>

<span class="cp">#define SEP_IOCFREEDCB_SECURE_DMA	\</span>
<span class="cp">	_IO(SEP_IOC_MAGIC_NUMBER, 39)</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
