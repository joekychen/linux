<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › sep › sep_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sep_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *  sep_main.c - Security Processor Driver main group of functions</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright(c) 2009-2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *  Contributions(c) 2009-2011 Discretix. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> *  Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> *  more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> *  this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *  CONTACTS:</span>
<span class="cm"> *</span>
<span class="cm"> *  Mark Allyn		mark.a.allyn@intel.com</span>
<span class="cm"> *  Jayant Mangalampalli jayant.mangalampalli@intel.com</span>
<span class="cm"> *</span>
<span class="cm"> *  CHANGES:</span>
<span class="cm"> *</span>
<span class="cm"> *  2009.06.26	Initial publish</span>
<span class="cm"> *  2010.09.14  Upgrade to Medfield</span>
<span class="cm"> *  2011.01.21  Move to sep_main.c to allow for sep_crypto.c</span>
<span class="cm"> *  2011.02.22  Enable kernel crypto operation</span>
<span class="cm"> *</span>
<span class="cm"> *  Please note that this driver is based on information in the Discretix</span>
<span class="cm"> *  CryptoCell 5.2 Driver Implementation Guide; the Discretix CryptoCell 5.2</span>
<span class="cm"> *  Integration Intel Medfield appendix; the Discretix CryptoCell 5.2</span>
<span class="cm"> *  Linux Driver Integration Guide; and the Discretix CryptoCell 5.2 System</span>
<span class="cm"> *  Overview and Integration Guide.</span>
<span class="cm"> */</span>
<span class="cm">/* #define DEBUG */</span>
<span class="cm">/* #define SEP_PERF_DEBUG */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;crypto/internal/hash.h&gt;</span>
<span class="cp">#include &lt;crypto/scatterwalk.h&gt;</span>
<span class="cp">#include &lt;crypto/sha.h&gt;</span>
<span class="cp">#include &lt;crypto/md5.h&gt;</span>
<span class="cp">#include &lt;crypto/aes.h&gt;</span>
<span class="cp">#include &lt;crypto/des.h&gt;</span>
<span class="cp">#include &lt;crypto/hash.h&gt;</span>

<span class="cp">#include &quot;sep_driver_hw_defs.h&quot;</span>
<span class="cp">#include &quot;sep_driver_config.h&quot;</span>
<span class="cp">#include &quot;sep_driver_api.h&quot;</span>
<span class="cp">#include &quot;sep_dev.h&quot;</span>
<span class="cp">#include &quot;sep_crypto.h&quot;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &quot;sep_trace_events.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Let&#39;s not spend cycles iterating over message</span>
<span class="cm"> * area contents if debugging not enabled</span>
<span class="cm"> */</span>
<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define sep_dump_message(sep)	_sep_dump_message(sep)</span>
<span class="cp">#else</span>
<span class="cp">#define sep_dump_message(sep)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Currenlty, there is only one SEP device per platform;</span>
<span class="cm"> * In event platforms in the future have more than one SEP</span>
<span class="cm"> * device, this will be a linked list</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep_dev</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * sep_queue_status_remove - Removes transaction from status queue</span>
<span class="cm"> * @sep: SEP device</span>
<span class="cm"> * @sep_queue_info: pointer to status queue</span>
<span class="cm"> *</span>
<span class="cm"> * This function will removes information about transaction from the queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sep_queue_status_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">**</span><span class="n">queue_elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lck_flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_queue_status_remove</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_elem</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">queue_elem</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PID%d %s null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">,</span> <span class="n">lck_flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">queue_elem</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_num</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">,</span> <span class="n">lck_flags</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">queue_elem</span><span class="p">);</span>
	<span class="o">*</span><span class="n">queue_elem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_queue_status_remove return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_queue_status_add - Adds transaction to status queue</span>
<span class="cm"> * @sep: SEP device</span>
<span class="cm"> * @opcode: transaction opcode</span>
<span class="cm"> * @size: input data size</span>
<span class="cm"> * @pid: pid of current process</span>
<span class="cm"> * @name: current process name</span>
<span class="cm"> * @name_len: length of name (current process)</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds information about about transaction started to the status</span>
<span class="cm"> * queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">*</span><span class="nf">sep_queue_status_add</span><span class="p">(</span>
						<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">opcode</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">pid</span><span class="p">,</span>
						<span class="n">u8</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">name_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lck_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">*</span><span class="n">my_elem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">my_elem</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_queue_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_elem</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] kzalloc ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="n">my_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="n">my_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">my_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">&gt;</span> <span class="n">TASK_COMM_LEN</span><span class="p">)</span>
		<span class="n">name_len</span> <span class="o">=</span> <span class="n">TASK_COMM_LEN</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">,</span> <span class="n">lck_flags</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_elem</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_status</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_num</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">,</span> <span class="n">lck_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">my_elem</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_allocate_dmatables_region - Allocates buf for the MLLI/DMA tables</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@dmatables_region: Destination pointer for the buffer</span>
<span class="cm"> *	@dma_ctx: DMA context for the transaction</span>
<span class="cm"> *	@table_count: Number of MLLI/DMA tables to create</span>
<span class="cm"> *	The buffer created will not work as-is for DMA operations,</span>
<span class="cm"> *	it needs to be copied over to the appropriate place in the</span>
<span class="cm"> *	shared area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_allocate_dmatables_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">u32</span> <span class="n">table_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">new_len</span> <span class="o">=</span>
		<span class="n">SYNCHRONIC_DMA_TABLES_AREA_SIZE_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">tmp_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] dma_ctx = 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] dmatables_region = 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">dmatables_region</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_ctx</span> <span class="o">||</span> <span class="o">!</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] dma context/region uninitialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] newlen = 0x%08zX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] oldlen = 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_len</span><span class="p">);</span>
	<span class="n">tmp_region</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">new_len</span> <span class="o">+</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] no mem for dma tables region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Were there any previous tables that need to be preserved ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_region</span><span class="p">,</span> <span class="o">*</span><span class="n">dmatables_region</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_len</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">dmatables_region</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dmatables_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">dmatables_region</span> <span class="o">=</span> <span class="n">tmp_region</span><span class="p">;</span>

	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_len</span> <span class="o">+=</span> <span class="n">new_len</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_wait_transaction - Used for synchronizing transactions</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sep_wait_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">SEP_TRANSACTION_STARTED_LOCK_BIT</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] no transactions, returning</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function_setpid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Looping needed even for exclusive waitq entries</span>
<span class="cm">	 * due to process wakeup latencies, previous process</span>
<span class="cm">	 * might have already created another transaction.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Exclusive waitq entry, so that only one process is</span>
<span class="cm">		 * woken up from the queue at a time.</span>
<span class="cm">		 */</span>
		<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_transactions</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
					  <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">SEP_TRANSACTION_STARTED_LOCK_BIT</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] no transactions, breaking</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] transactions ongoing, sleeping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] woken up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] received signal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">end_function_setpid:</span>
	<span class="cm">/*</span>
<span class="cm">	 * The pid_doing_transaction indicates that this process</span>
<span class="cm">	 * now owns the facilities to performa a transaction with</span>
<span class="cm">	 * the SEP. While this process is performing a transaction,</span>
<span class="cm">	 * no other process who has the SEP device open can perform</span>
<span class="cm">	 * any transactions. This method allows more than one process</span>
<span class="cm">	 * to have the device open at any given time, which provides</span>
<span class="cm">	 * finer granularity for device utilization by multiple</span>
<span class="cm">	 * processes.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Only one process is able to progress here at a time */</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">pid_doing_transaction</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

<span class="nl">end_function:</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_transactions</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_check_transaction_owner - Checks if current process owns transaction</span>
<span class="cm"> * @sep: SEP device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sep_check_transaction_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] transaction pid = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">pid_doing_transaction</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pid_doing_transaction</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">pid_doing_transaction</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We own the transaction */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>

<span class="cm">/**</span>
<span class="cm"> * sep_dump_message - dump the message that is pending</span>
<span class="cm"> * @sep: SEP device</span>
<span class="cm"> * This will only print dump if DEBUG is set; it does</span>
<span class="cm"> * follow kernel debug print enabling</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_sep_dump_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] Word %d of the message is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">count</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * sep_map_and_alloc_shared_area -allocate shared block</span>
<span class="cm"> * @sep: security processor</span>
<span class="cm"> * @size: size of shared area</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_map_and_alloc_shared_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_size</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] shared memory dma_alloc_coherent failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] shared_addr %zx bytes @%p (bus %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_size</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_unmap_and_free_shared_area - free shared block</span>
<span class="cm"> * @sep: security processor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_unmap_and_free_shared_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_size</span><span class="p">,</span>
				<span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>

<span class="cm">/**</span>
<span class="cm"> * sep_shared_bus_to_virt - convert bus/virt addresses</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @bus_address: address to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns virtual address inside the shared area according</span>
<span class="cm"> * to the bus address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sep_shared_bus_to_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
						<span class="n">dma_addr_t</span> <span class="n">bus_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">bus_address</span> <span class="o">-</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * sep_open - device open method</span>
<span class="cm"> * @inode: inode of SEP device</span>
<span class="cm"> * @filp: file handle to SEP device</span>
<span class="cm"> *</span>
<span class="cm"> * Open method for the SEP device. Called when userspace opens</span>
<span class="cm"> * the SEP device node.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success otherwise an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the SEP device structure and use it for the</span>
<span class="cm">	 * private_data field in filp for other methods</span>
<span class="cm">	 */</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">sep</span><span class="p">;</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] priv is 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* Anyone can open; locking takes place at transaction level */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_free_dma_table_data_handler - free DMA table</span>
<span class="cm"> * @sep: pointere to struct sep_device</span>
<span class="cm"> * @dma_ctx: dma context</span>
<span class="cm"> *</span>
<span class="cm"> * Handles the request to  free DMA table for synchronic actions</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sep_free_dma_table_data_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dcb_counter</span><span class="p">;</span>
	<span class="cm">/* Pointer to the current dma_resource struct */</span>
	<span class="k">struct</span> <span class="n">sep_dma_resource</span> <span class="o">*</span><span class="n">dma</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] sep_free_dma_table_data_handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_ctx</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* No context or context already freed */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] no DMA context or context already freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] (*dma_ctx)-&gt;nr_dcb_creat 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
					<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">dcb_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">dcb_counter</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">;</span> <span class="n">dcb_counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dcb_counter</span><span class="p">];</span>

		<span class="cm">/* Unmap and free input map array */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_array</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_num_pages</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span>
					<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
					<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_array</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/**</span>
<span class="cm">		 * Output is handled different. If</span>
<span class="cm">		 * this was a secure dma into restricted memory,</span>
<span class="cm">		 * then we skip this step altogether as restricted</span>
<span class="cm">		 * memory is not available to the o/s at all.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">secure_dma</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_map_array</span><span class="p">))</span> <span class="p">{</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_num_pages</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_map_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span>
					<span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_map_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
					<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_map_array</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Free page cache for output */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_page_array</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_num_pages</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_page_array</span><span class="p">[</span><span class="n">count</span><span class="p">]);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_page_array</span><span class="p">[</span><span class="n">count</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_page_array</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Again, we do this only for non secure dma */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">secure_dma</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_page_array</span><span class="p">))</span> <span class="p">{</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_num_pages</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_page_array</span><span class="p">[</span><span class="n">count</span><span class="p">]))</span>

					<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span>
					<span class="n">out_page_array</span><span class="p">[</span><span class="n">count</span><span class="p">]);</span>

				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_page_array</span><span class="p">[</span><span class="n">count</span><span class="p">]);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_page_array</span><span class="p">[</span><span class="n">count</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_page_array</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/**</span>
<span class="cm">		 * Note that here we use in_map_num_entries because we</span>
<span class="cm">		 * don&#39;t have a page array; the page array is generated</span>
<span class="cm">		 * only in the lock_user_pages, which is not called</span>
<span class="cm">		 * for kernel crypto, which is what the sg (scatter gather</span>
<span class="cm">		 * is used for exclusively</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">,</span>
				<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_num_entries</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="n">dma</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">,</span>
				<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_num_entries</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">dma</span><span class="o">-&gt;</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Reset all the values */</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_num_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_num_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_map_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">in_map_num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">out_map_num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] sep_free_dma_table_data_handler end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_end_transaction_handler - end transaction</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @dma_ctx: DMA context</span>
<span class="cm"> * @call_status: Call status</span>
<span class="cm"> *</span>
<span class="cm"> * This API handles the end transaction request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_end_transaction_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sep_call_status</span> <span class="o">*</span><span class="n">call_status</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">**</span><span class="n">my_queue_elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] ending transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extraneous transaction clearing would mess up PM</span>
<span class="cm">	 * device usage counters and SEP would get suspended</span>
<span class="cm">	 * just before we send a command to SEP in the next</span>
<span class="cm">	 * transaction</span>
<span class="cm">	 * */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep_check_transaction_owner</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] not transaction owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update queue status */</span>
	<span class="n">sep_queue_status_remove</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">my_queue_elem</span><span class="p">);</span>

	<span class="cm">/* Check that all the DMA resources were freed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ctx</span><span class="p">)</span>
		<span class="n">sep_free_dma_table_data_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>

	<span class="cm">/* Reset call status for next transaction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">call_status</span><span class="p">)</span>
		<span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear the message area to avoid next transaction reading</span>
<span class="cm">	 * sensitive results from previous transaction */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="cm">/* start suspend delay */</span>
<span class="cp">#ifdef SEP_ENABLE_RUNTIME_PM</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pm_runtime_mark_last_busy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_put_autosuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SEP_WORKING_LOCK_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">pid_doing_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Now it&#39;s safe for next process to proceed */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] waking up next transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SEP_TRANSACTION_STARTED_LOCK_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_transactions</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sep_release - close a SEP device</span>
<span class="cm"> * @inode: inode of SEP device</span>
<span class="cm"> * @filp: file handle being closed</span>
<span class="cm"> *</span>
<span class="cm"> * Called on the final close of a SEP device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="o">*</span> <span class="k">const</span> <span class="n">private_data</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="o">*</span><span class="n">call_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">private_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">**</span><span class="n">my_queue_elem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">my_queue_elem</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] release</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="n">sep_end_transaction_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">,</span> <span class="n">call_status</span><span class="p">,</span>
		<span class="n">my_queue_elem</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_mmap -  maps the shared area to user space</span>
<span class="cm"> * @filp: pointer to struct file</span>
<span class="cm"> * @vma: pointer to vm_area_struct</span>
<span class="cm"> *</span>
<span class="cm"> * Called on an mmap of our space via the normal SEP device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="o">*</span> <span class="k">const</span> <span class="n">private_data</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="o">*</span><span class="n">call_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">private_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">**</span><span class="n">my_queue_elem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">my_queue_elem</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_mmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="cm">/* Set the transaction busy (own the device) */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Problem for multithreaded applications is that here we&#39;re</span>
<span class="cm">	 * possibly going to sleep while holding a write lock on</span>
<span class="cm">	 * current-&gt;mm-&gt;mmap_sem, which will cause deadlock for ongoing</span>
<span class="cm">	 * transaction trying to create DMA tables</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_wait_transaction</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="cm">/* Interrupted by signal, don&#39;t clear transaction */</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

	<span class="cm">/* Clear the message area to avoid next transaction reading</span>
<span class="cm">	 * sensitive results from previous transaction */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that the size of the mapped range is as the size of the message</span>
<span class="cm">	 * shared area</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SEP_DRIVER_MMMAP_AREA_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_with_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] shared_addr is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">);</span>

	<span class="cm">/* Get bus address */</span>
	<span class="n">bus_addr</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">bus_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] remap_page_range failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_with_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update call status */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_MMAP_DONE_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

<span class="nl">end_function_with_error:</span>
	<span class="cm">/* Clear our transaction */</span>
	<span class="n">sep_end_transaction_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">call_status</span><span class="p">,</span>
		<span class="n">my_queue_elem</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_poll - poll handler</span>
<span class="cm"> * @filp:	pointer to struct file</span>
<span class="cm"> * @wait:	pointer to poll_table</span>
<span class="cm"> *</span>
<span class="cm"> * Called by the OS when the kernel is asked to do a poll on</span>
<span class="cm"> * a SEP file handle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="o">*</span> <span class="k">const</span> <span class="n">private_data</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="o">*</span><span class="n">call_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">private_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">retval2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_irq_flag</span><span class="p">;</span>

	<span class="cm">/* Am I the process that owns the transaction? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep_check_transaction_owner</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] poll pid not owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">POLLERR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if send command or send_reply were activated previously */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_SENDMSG_DONE_OFFSET</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sendmsg not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">POLLERR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Add the event to the polling wait table */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] poll: calling wait sep_event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_interrupt</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] poll: send_ct is %lx reply ct is %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">);</span>

	<span class="cm">/* Check if error occurred during poll */</span>
	<span class="n">retval2</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR3_REG_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval2</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval2</span> <span class="o">!=</span> <span class="mh">0x8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] poll; poll error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">retval2</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLERR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">,</span> <span class="n">lock_irq_flag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span> <span class="o">==</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">,</span> <span class="n">lock_irq_flag</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR2_REG_ADDR</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] poll: data ready check (GPR2)  %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

		<span class="cm">/* Check if printf request  */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] poll: SEP printf request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check if the this is SEP reply or request */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] poll: SEP request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] poll: normal return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">sep_dump_message</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] poll; SEP reply POLLIN|POLLRDNORM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_POLL_DONE_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">,</span> <span class="n">lock_irq_flag</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] poll; no reply; returning mask of 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_time_address - address in SEP memory of time</span>
<span class="cm"> * @sep: SEP device we want the address from</span>
<span class="cm"> *</span>
<span class="cm"> * Return the address of the two dwords in memory used for time</span>
<span class="cm"> * setting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="o">*</span><span class="nf">sep_time_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
		<span class="n">SEP_DRIVER_SYSTEM_TIME_MEMORY_OFFSET_IN_BYTES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_set_time - set the SEP time</span>
<span class="cm"> * @sep: the SEP we are setting the time for</span>
<span class="cm"> *</span>
<span class="cm"> * Calculates time and sets it at the predefined address.</span>
<span class="cm"> * Called with the SEP mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sep_set_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">time_addr</span><span class="p">;</span>	<span class="cm">/* Address of time as seen by the kernel */</span>


	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time</span><span class="p">);</span>

	<span class="cm">/* Set value in the SYSTEM MEMORY offset */</span>
	<span class="n">time_addr</span> <span class="o">=</span> <span class="n">sep_time_address</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="n">time_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SEP_TIME_VAL_TOKEN</span><span class="p">;</span>
	<span class="n">time_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] time.tv_sec is %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] time_addr is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">time_addr</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep-&gt;shared_addr is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_send_command_handler - kick off a command</span>
<span class="cm"> * @sep: SEP being signalled</span>
<span class="cm"> *</span>
<span class="cm"> * This function raises interrupt to SEP that signals that is has a new</span>
<span class="cm"> * command from the host</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function does fall under the ioctl lock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sep_send_command_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_irq_flag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">msg_pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Basic sanity check; set msg pool to start of shared area */</span>
	<span class="n">msg_pool</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">;</span>
	<span class="n">msg_pool</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Look for start msg token */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_pool</span> <span class="o">!=</span> <span class="n">SEP_START_MSG_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;start message token not present</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we have a reasonable size? */</span>
	<span class="n">msg_pool</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">msg_pool</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="o">*</span><span class="n">msg_pool</span> <span class="o">&gt;</span> <span class="n">SEP_DRIVER_MAX_MESSAGE_SIZE_IN_BYTES</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid message size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Does the command look reasonable? */</span>
	<span class="n">msg_pool</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_pool</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid message opcode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if defined(CONFIG_PM_RUNTIME) &amp;&amp; defined(SEP_ENABLE_RUNTIME_PM)</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] before pm sync status 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
					<span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">runtime_status</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* device is about to be used */</span>
	<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">SEP_WORKING_LOCK_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* device is about to be used */</span>
	<span class="n">sep_set_time</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="n">sep_dump_message</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="cm">/* Update counter */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">,</span> <span class="n">lock_irq_flag</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">,</span> <span class="n">lock_irq_flag</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] sep_send_command_handler send_ct %lx reply_ct %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">);</span>

	<span class="cm">/* Send interrupt to SEP */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_HOST_SEP_GPR0_REG_ADDR</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_crypto_dma -</span>
<span class="cm"> *	@sep: pointer to struct sep_device</span>
<span class="cm"> *	@sg: pointer to struct scatterlist</span>
<span class="cm"> *	@direction:</span>
<span class="cm"> *	@dma_maps: pointer to place a pointer to array of dma maps</span>
<span class="cm"> *	 This is filled in; anything previous there will be lost</span>
<span class="cm"> *	 The structure for dma maps is sep_dma_map</span>
<span class="cm"> *	@returns number of dma maps on success; negative on error</span>
<span class="cm"> *</span>
<span class="cm"> *	This creates the dma table from the scatterlist</span>
<span class="cm"> *	It is used only for kernel crypto as it works with scatterlists</span>
<span class="cm"> *	representation of data buffers</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_crypto_dma</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">**</span><span class="n">dma_maps</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">temp_sg</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">count_segment</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count_mapped</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">*</span><span class="n">sep_dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ct1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Count the segments */</span>
	<span class="n">temp_sg</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="n">count_segment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">temp_sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count_segment</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">temp_sg</span> <span class="o">=</span> <span class="n">scatterwalk_sg_next</span><span class="p">(</span><span class="n">temp_sg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;There are (hex) %x segments in sg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count_segment</span><span class="p">);</span>

	<span class="cm">/* DMA map segments */</span>
	<span class="n">count_mapped</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span>
		<span class="n">count_segment</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;There are (hex) %x maps in sg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count_mapped</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count_mapped</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot dma_map_sg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_dma</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dma_map</span><span class="p">)</span> <span class="o">*</span>
		<span class="n">count_mapped</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_dma</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate dma_maps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">temp_sg</span><span class="p">,</span> <span class="n">count_mapped</span><span class="p">,</span> <span class="n">ct1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_dma</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">temp_sg</span><span class="p">);</span>
		<span class="n">sep_dma</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">temp_sg</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(all hex) map %x dma %lx len %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ct1</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sep_dma</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sep_dma</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="o">*</span><span class="n">dma_maps</span> <span class="o">=</span> <span class="n">sep_dma</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count_mapped</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_crypto_lli -</span>
<span class="cm"> *	@sep: pointer to struct sep_device</span>
<span class="cm"> *	@sg: pointer to struct scatterlist</span>
<span class="cm"> *	@data_size: total data size</span>
<span class="cm"> *	@direction:</span>
<span class="cm"> *	@dma_maps: pointer to place a pointer to array of dma maps</span>
<span class="cm"> *	 This is filled in; anything previous there will be lost</span>
<span class="cm"> *	 The structure for dma maps is sep_dma_map</span>
<span class="cm"> *	@lli_maps: pointer to place a pointer to array of lli maps</span>
<span class="cm"> *	 This is filled in; anything previous there will be lost</span>
<span class="cm"> *	 The structure for dma maps is sep_dma_map</span>
<span class="cm"> *	@returns number of dma maps on success; negative on error</span>
<span class="cm"> *</span>
<span class="cm"> *	This creates the LLI table from the scatterlist</span>
<span class="cm"> *	It is only used for kernel crypto as it works exclusively</span>
<span class="cm"> *	with scatterlists (struct scatterlist) representation of</span>
<span class="cm"> *	data buffers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_crypto_lli</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">**</span><span class="n">maps</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">**</span><span class="n">llis</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_size</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">ct1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">sep_lli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">*</span><span class="n">sep_map</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">nbr_ents</span><span class="p">;</span>

	<span class="n">nbr_ents</span> <span class="o">=</span> <span class="n">sep_crypto_dma</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">maps</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbr_ents</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;crypto_dma failed %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">nbr_ents</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">nbr_ents</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep_map</span> <span class="o">=</span> <span class="o">*</span><span class="n">maps</span><span class="p">;</span>

	<span class="n">sep_lli</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">nbr_ents</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_lli</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate lli_maps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">maps</span><span class="p">);</span>
		<span class="o">*</span><span class="n">maps</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ct1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">&lt;</span> <span class="n">nbr_ents</span><span class="p">;</span> <span class="n">ct1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_lli</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">sep_map</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">;</span>

		<span class="cm">/* Maximum for page is total data size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sep_map</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">data_size</span><span class="p">)</span>
			<span class="n">sep_map</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">;</span>

		<span class="n">sep_lli</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">sep_map</span><span class="p">[</span><span class="n">ct1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">llis</span> <span class="o">=</span> <span class="n">sep_lli</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nbr_ents</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_lock_kernel_pages - map kernel pages for DMA</span>
<span class="cm"> *	@sep: pointer to struct sep_device</span>
<span class="cm"> *	@kernel_virt_addr: address of data buffer in kernel</span>
<span class="cm"> *	@data_size: size of data</span>
<span class="cm"> *	@lli_array_ptr: lli array</span>
<span class="cm"> *	@in_out_flag: input into device or output from device</span>
<span class="cm"> *</span>
<span class="cm"> *	This function locks all the physical pages of the kernel virtual buffer</span>
<span class="cm"> *	and construct a basic lli  array, where each entry holds the physical</span>
<span class="cm"> *	page address and the size that application data holds in this page</span>
<span class="cm"> *	This function is used only during kernel crypto mod calls from within</span>
<span class="cm"> *	the kernel (when ioctl is not used)</span>
<span class="cm"> *</span>
<span class="cm"> *	This is used only for kernel crypto. Kernel pages</span>
<span class="cm"> *	are handled differently as they are done via</span>
<span class="cm"> *	scatter gather lists (struct scatterlist)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_lock_kernel_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_virt_addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_size</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">**</span><span class="n">lli_array_ptr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">in_out_flag</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span>

<span class="p">{</span>
	<span class="n">u32</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="cm">/* Array of lli */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_array</span><span class="p">;</span>
	<span class="cm">/* Map array */</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">*</span><span class="n">map_array</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">;</span>

	<span class="n">lli_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">map_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_out_flag</span> <span class="o">==</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">sep_crypto_lli</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_array</span><span class="p">,</span>
		<span class="n">data_size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep_crypto_lli returned error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">num_pages</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Put mapped kernel sg into kernel resource array */</span>

	<span class="cm">/* Set output params according to the in_out flag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_out_flag</span> <span class="o">==</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lli_array_ptr</span> <span class="o">=</span> <span class="n">lli_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_num_pages</span> <span class="o">=</span>
								<span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span> <span class="o">=</span>
								<span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_array</span> <span class="o">=</span>
								<span class="n">map_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_num_entries</span> <span class="o">=</span>
								<span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">src_sg</span> <span class="o">=</span>
			<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lli_array_ptr</span> <span class="o">=</span> <span class="n">lli_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_num_pages</span> <span class="o">=</span>
								<span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_page_array</span> <span class="o">=</span>
								<span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_map_array</span> <span class="o">=</span>
								<span class="n">map_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span>
					<span class="n">out_map_num_entries</span> <span class="o">=</span> <span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">dst_sg</span> <span class="o">=</span>
			<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_lock_user_pages - lock and map user pages for DMA</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @app_virt_addr: user memory data buffer</span>
<span class="cm"> * @data_size: size of data buffer</span>
<span class="cm"> * @lli_array_ptr: lli array</span>
<span class="cm"> * @in_out_flag: input or output to device</span>
<span class="cm"> *</span>
<span class="cm"> * This function locks all the physical pages of the application</span>
<span class="cm"> * virtual buffer and construct a basic lli  array, where each entry</span>
<span class="cm"> * holds the physical page address and the size that application</span>
<span class="cm"> * data holds in this physical pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_lock_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">app_virt_addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_size</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">**</span><span class="n">lli_array_ptr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">in_out_flag</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span>

<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="cm">/* The the page of the end address of the user space buffer */</span>
	<span class="n">u32</span> <span class="n">end_page</span><span class="p">;</span>
	<span class="cm">/* The page of the start address of the user space buffer */</span>
	<span class="n">u32</span> <span class="n">start_page</span><span class="p">;</span>
	<span class="cm">/* The range in pages */</span>
	<span class="n">u32</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="cm">/* Array of pointers to page */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">page_array</span><span class="p">;</span>
	<span class="cm">/* Array of lli */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_array</span><span class="p">;</span>
	<span class="cm">/* Map array */</span>
	<span class="k">struct</span> <span class="n">sep_dma_map</span> <span class="o">*</span><span class="n">map_array</span><span class="p">;</span>

	<span class="cm">/* Set start and end pages  and num pages */</span>
	<span class="n">end_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">+</span> <span class="n">data_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">start_page</span> <span class="o">=</span> <span class="n">app_virt_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">end_page</span> <span class="o">-</span> <span class="n">start_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] lock user pages app_virt_addr is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">app_virt_addr</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] data_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] start_page is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">start_page</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] end_page is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">end_page</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] num_pages is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>

	<span class="cm">/* Allocate array of pages structure pointers */</span>
	<span class="n">page_array</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pages</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">map_array</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dma_map</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pages</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] kmalloc for map_array failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_with_error1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lli_array</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pages</span><span class="p">,</span>
		<span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lli_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] kmalloc for lli_array failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_with_error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Convert the application virtual address into a set of physical */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">app_virt_addr</span><span class="p">,</span>
		<span class="n">num_pages</span><span class="p">,</span>
		<span class="p">((</span><span class="n">in_out_flag</span> <span class="o">==</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">page_array</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="cm">/* Check the number of pages locked - if not all then exit with error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] not all pages locked by get_user_pages, &quot;</span>
			<span class="s">&quot;result 0x%X, num_pages 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_with_error3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] get_user_pages succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill the array using page array data and</span>
<span class="cm">	 * map the pages - this action will also flush the cache as needed</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fill the map array */</span>
		<span class="n">map_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">dma_addr</span> <span class="o">=</span>
			<span class="n">dma_map_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">page_array</span><span class="p">[</span><span class="n">count</span><span class="p">],</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

		<span class="n">map_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="cm">/* Fill the lli array entry */</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">map_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">;</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_array[%x].bus_address is %08lx, &quot;</span>
			<span class="s">&quot;lli_array[%x].block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">bus_address</span><span class="p">,</span>
			<span class="n">count</span><span class="p">,</span> <span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">block_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check the offset for the first page */</span>
	<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">=</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">+</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>

	<span class="cm">/* Check that not all the data is in the first page only */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)))</span> <span class="o">&gt;=</span> <span class="n">data_size</span><span class="p">)</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span>
			<span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] After check if page 0 has all data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_array[0].bus_address is (hex) %08lx, &quot;</span>
			<span class="s">&quot;lli_array[0].block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bus_address</span><span class="p">,</span>
			<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">block_size</span><span class="p">);</span>


	<span class="cm">/* Check the size of the last page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] After last page size adjustment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_array[%x].bus_address is (hex) %08lx, &quot;</span>
			<span class="s">&quot;lli_array[%x].block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">bus_address</span><span class="p">,</span>
			<span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set output params according to the in_out flag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_out_flag</span> <span class="o">==</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lli_array_ptr</span> <span class="o">=</span> <span class="n">lli_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_num_pages</span> <span class="o">=</span>
								<span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span> <span class="o">=</span>
								<span class="n">page_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_array</span> <span class="o">=</span>
								<span class="n">map_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_num_entries</span> <span class="o">=</span>
								<span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">src_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lli_array_ptr</span> <span class="o">=</span> <span class="n">lli_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_num_pages</span> <span class="o">=</span>
								<span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_page_array</span> <span class="o">=</span>
								<span class="n">page_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_map_array</span> <span class="o">=</span>
								<span class="n">map_array</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span>
					<span class="n">out_map_num_entries</span> <span class="o">=</span> <span class="n">num_pages</span><span class="p">;</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

<span class="nl">end_function_with_error3:</span>
	<span class="cm">/* Free lli array */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lli_array</span><span class="p">);</span>

<span class="nl">end_function_with_error2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map_array</span><span class="p">);</span>

<span class="nl">end_function_with_error1:</span>
	<span class="cm">/* Free page array */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">page_array</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_lli_table_secure_dma - get lli array for IMR addresses</span>
<span class="cm"> *	@sep: pointer to struct sep_device</span>
<span class="cm"> *	@app_virt_addr: user memory data buffer</span>
<span class="cm"> *	@data_size: size of data buffer</span>
<span class="cm"> *	@lli_array_ptr: lli array</span>
<span class="cm"> *	@in_out_flag: not used</span>
<span class="cm"> *	@dma_ctx: pointer to struct sep_dma_context</span>
<span class="cm"> *</span>
<span class="cm"> *	This function creates lli tables for outputting data to</span>
<span class="cm"> *	IMR memory, which is memory that cannot be accessed by the</span>
<span class="cm"> *	the x86 processor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_lli_table_secure_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">app_virt_addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_size</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">**</span><span class="n">lli_array_ptr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">in_out_flag</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span>

<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/* The the page of the end address of the user space buffer */</span>
	<span class="n">u32</span> <span class="n">end_page</span><span class="p">;</span>
	<span class="cm">/* The page of the start address of the user space buffer */</span>
	<span class="n">u32</span> <span class="n">start_page</span><span class="p">;</span>
	<span class="cm">/* The range in pages */</span>
	<span class="n">u32</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="cm">/* Array of lli */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_array</span><span class="p">;</span>

	<span class="cm">/* Set start and end pages  and num pages */</span>
	<span class="n">end_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">+</span> <span class="n">data_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">start_page</span> <span class="o">=</span> <span class="n">app_virt_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">end_page</span> <span class="o">-</span> <span class="n">start_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] lock user pages&quot;</span>
		<span class="s">&quot; app_virt_addr is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">app_virt_addr</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] data_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] start_page is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">start_page</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] end_page is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">end_page</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] num_pages is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>

	<span class="n">lli_array</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_pages</span><span class="p">,</span>
		<span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lli_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] kmalloc for lli_array failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill the lli_array</span>
<span class="cm">	 */</span>
	<span class="n">start_page</span> <span class="o">=</span> <span class="n">start_page</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fill the lli array entry */</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">=</span> <span class="n">start_page</span><span class="p">;</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">start_page</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_array[%x].bus_address is %08lx, &quot;</span>
			<span class="s">&quot;lli_array[%x].block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">bus_address</span><span class="p">,</span>
			<span class="n">count</span><span class="p">,</span> <span class="n">lli_array</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">block_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check the offset for the first page */</span>
	<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">=</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">+</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>

	<span class="cm">/* Check that not all the data is in the first page only */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)))</span> <span class="o">&gt;=</span> <span class="n">data_size</span><span class="p">)</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span>
			<span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] After check if page 0 has all data</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;lli_array[0].bus_address is (hex) %08lx, &quot;</span>
		<span class="s">&quot;lli_array[0].block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bus_address</span><span class="p">,</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">block_size</span><span class="p">);</span>

	<span class="cm">/* Check the size of the last page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">app_virt_addr</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] After last page size adjustment</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;lli_array[%x].bus_address is (hex) %08lx, &quot;</span>
			<span class="s">&quot;lli_array[%x].block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">bus_address</span><span class="p">,</span>
			<span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">lli_array</span><span class="p">[</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">block_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">lli_array_ptr</span> <span class="o">=</span> <span class="n">lli_array</span><span class="p">;</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_num_pages</span> <span class="o">=</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_map_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_map_num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_calculate_lli_table_max_size - size the LLI table</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @lli_in_array_ptr</span>
<span class="cm"> * @num_array_entries</span>
<span class="cm"> * @last_table_flag</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates the size of data that can be inserted into</span>
<span class="cm"> * the lli table from this array, such that either the table is full</span>
<span class="cm"> * (all entries are entered), or there are no more entries in the</span>
<span class="cm"> * lli array</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">sep_calculate_lli_table_max_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_in_array_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">num_array_entries</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">last_table_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">counter</span><span class="p">;</span>
	<span class="cm">/* Table data size */</span>
	<span class="n">u32</span> <span class="n">table_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Data size for the next table */</span>
	<span class="n">u32</span> <span class="n">next_table_data_size</span><span class="p">;</span>

	<span class="o">*</span><span class="n">last_table_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the data in the out lli table till we fill the whole</span>
<span class="cm">	 * table or till the data has ended</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">num_array_entries</span><span class="p">);</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span>
		<span class="n">table_data_size</span> <span class="o">+=</span> <span class="n">lli_in_array_ptr</span><span class="p">[</span><span class="n">counter</span><span class="p">].</span><span class="n">block_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we reached the last entry,</span>
<span class="cm">	 * meaning this ia the last table to build,</span>
<span class="cm">	 * and no need to check the block alignment</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="n">num_array_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the last table flag */</span>
		<span class="o">*</span><span class="n">last_table_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the data size of the next table.</span>
<span class="cm">	 * Stop if no entries left or if data size is more the DMA restriction</span>
<span class="cm">	 */</span>
	<span class="n">next_table_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">num_array_entries</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next_table_data_size</span> <span class="o">+=</span> <span class="n">lli_in_array_ptr</span><span class="p">[</span><span class="n">counter</span><span class="p">].</span><span class="n">block_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_table_data_size</span> <span class="o">&gt;=</span> <span class="n">SEP_DRIVER_MIN_DATA_SIZE_PER_TABLE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the next table data size is less then DMA rstriction.</span>
<span class="cm">	 * if it is - recalculate the current table size, so that the next</span>
<span class="cm">	 * table data size will be adaquete for DMA</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_table_data_size</span> <span class="o">&amp;&amp;</span>
		<span class="n">next_table_data_size</span> <span class="o">&lt;</span> <span class="n">SEP_DRIVER_MIN_DATA_SIZE_PER_TABLE</span><span class="p">)</span>

		<span class="n">table_data_size</span> <span class="o">-=</span> <span class="p">(</span><span class="n">SEP_DRIVER_MIN_DATA_SIZE_PER_TABLE</span> <span class="o">-</span>
			<span class="n">next_table_data_size</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">table_data_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_build_lli_table - build an lli array for the given table</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @lli_array_ptr: pointer to lli array</span>
<span class="cm"> * @lli_table_ptr: pointer to lli table</span>
<span class="cm"> * @num_processed_entries_ptr: pointer to number of entries</span>
<span class="cm"> * @num_table_entries_ptr: pointer to number of tables</span>
<span class="cm"> * @table_data_size: total data size</span>
<span class="cm"> *</span>
<span class="cm"> * Builds ant lli table from the lli_array according to</span>
<span class="cm"> * the given size of data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_build_lli_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span>	<span class="o">*</span><span class="n">lli_array_ptr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span>	<span class="o">*</span><span class="n">lli_table_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">num_processed_entries_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">num_table_entries_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">table_data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Current table data size */</span>
	<span class="n">u32</span> <span class="n">curr_table_data_size</span><span class="p">;</span>
	<span class="cm">/* Counter of lli array entry */</span>
	<span class="n">u32</span> <span class="n">array_counter</span><span class="p">;</span>

	<span class="cm">/* Init current table data size and lli array entry counter */</span>
	<span class="n">curr_table_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">array_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">num_table_entries_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] build lli table table_data_size: (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">table_data_size</span><span class="p">);</span>

	<span class="cm">/* Fill the table till table size reaches the needed amount */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">curr_table_data_size</span> <span class="o">&lt;</span> <span class="n">table_data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Update the number of entries in table */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">num_table_entries_ptr</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

		<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lli_array_ptr</span><span class="p">[</span><span class="n">array_counter</span><span class="p">].</span><span class="n">bus_address</span><span class="p">);</span>

		<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lli_array_ptr</span><span class="p">[</span><span class="n">array_counter</span><span class="p">].</span><span class="n">block_size</span><span class="p">);</span>

		<span class="n">curr_table_data_size</span> <span class="o">+=</span> <span class="n">lli_array_ptr</span><span class="p">[</span><span class="n">array_counter</span><span class="p">].</span><span class="n">block_size</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_table_ptr is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">lli_table_ptr</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_table_ptr-&gt;bus_address: %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_table_ptr-&gt;block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>

		<span class="cm">/* Check for overflow of the table data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_table_data_size</span> <span class="o">&gt;</span> <span class="n">table_data_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] curr_table_data_size too large</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="cm">/* Update the size of block in the table */</span>
			<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">)</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">curr_table_data_size</span> <span class="o">-</span> <span class="n">table_data_size</span><span class="p">);</span>

			<span class="cm">/* Update the physical address in the lli array */</span>
			<span class="n">lli_array_ptr</span><span class="p">[</span><span class="n">array_counter</span><span class="p">].</span><span class="n">bus_address</span> <span class="o">+=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>

			<span class="cm">/* Update the block size left in the lli array */</span>
			<span class="n">lli_array_ptr</span><span class="p">[</span><span class="n">array_counter</span><span class="p">].</span><span class="n">block_size</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">curr_table_data_size</span> <span class="o">-</span> <span class="n">table_data_size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* Advance to the next entry in the lli_array */</span>
			<span class="n">array_counter</span><span class="o">++</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_table_ptr-&gt;bus_address is %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli_table_ptr-&gt;block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>

		<span class="cm">/* Move to the next entry in table */</span>
		<span class="n">lli_table_ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the info entry to default */</span>
	<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the output parameter */</span>
	<span class="o">*</span><span class="n">num_processed_entries_ptr</span> <span class="o">+=</span> <span class="n">array_counter</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_shared_area_virt_to_bus - map shared area to bus address</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @virt_address: virtual address to convert</span>
<span class="cm"> *</span>
<span class="cm"> * This functions returns the physical address inside shared area according</span>
<span class="cm"> * to the virtual address. It can be either on the externa RAM device</span>
<span class="cm"> * (ioremapped), or on the system RAM</span>
<span class="cm"> * This implementation is for the external RAM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">sep_shared_area_virt_to_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sh virt to phys v %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">virt_address</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sh virt to phys p %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span> <span class="o">+</span> <span class="p">(</span><span class="n">virt_address</span> <span class="o">-</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span> <span class="o">+</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">virt_address</span> <span class="o">-</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_shared_area_bus_to_virt - map shared area bus address to kernel</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @bus_address: bus address to convert</span>
<span class="cm"> *</span>
<span class="cm"> * This functions returns the virtual address inside shared area</span>
<span class="cm"> * according to the physical address. It can be either on the</span>
<span class="cm"> * externa RAM device (ioremapped), or on the system RAM</span>
<span class="cm"> * This implementation is for the external RAM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sep_shared_area_bus_to_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="n">bus_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] shared bus to virt b=%lx v=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bus_address</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
			<span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">bus_address</span> <span class="o">-</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">)));</span>

	<span class="k">return</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span>	<span class="o">+</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">bus_address</span> <span class="o">-</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_debug_print_lli_tables - dump LLI table</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @lli_table_ptr: pointer to sep_lli_entry</span>
<span class="cm"> * @num_table_entries: number of entries</span>
<span class="cm"> * @table_data_size: total data size</span>
<span class="cm"> *</span>
<span class="cm"> * Walk the the list of the print created tables and print all the data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_debug_print_lli_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_table_ptr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_table_entries</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">table_data_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">table_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entries_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_debug_print_lli_tables start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_table_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] no table to print</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] lli table %08lx, &quot;</span>
			<span class="s">&quot;table_data_size is (hex) %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">table_count</span><span class="p">,</span> <span class="n">table_data_size</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] num_table_entries is (hex) %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">num_table_entries</span><span class="p">);</span>

		<span class="cm">/* Print entries of the table (without info entry) */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">entries_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entries_count</span> <span class="o">&lt;</span> <span class="n">num_table_entries</span><span class="p">;</span>
			<span class="n">entries_count</span><span class="o">++</span><span class="p">,</span> <span class="n">lli_table_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] lli_table_ptr address is %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">lli_table_ptr</span><span class="p">);</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] phys address is %08lx &quot;</span>
				<span class="s">&quot;block size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">,</span>
				<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Point to the info entry */</span>
		<span class="n">lli_table_ptr</span><span class="o">--</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] phys lli_table_ptr-&gt;block_size &quot;</span>
			<span class="s">&quot;is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] phys lli_table_ptr-&gt;physical_address &quot;</span>
			<span class="s">&quot;is %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">);</span>


		<span class="n">table_data_size</span> <span class="o">=</span> <span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
		<span class="n">num_table_entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] phys table_data_size is &quot;</span>
			<span class="s">&quot;(hex) %lx num_table_entries is&quot;</span>
			<span class="s">&quot; %lx bus_address is%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="n">table_data_size</span><span class="p">,</span>
				<span class="n">num_table_entries</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">)</span>
			<span class="n">lli_table_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">sep_shared_bus_to_virt</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">);</span>

		<span class="n">table_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_debug_print_lli_tables end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sep_prepare_empty_lli_table - create a blank LLI table</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @lli_table_addr_ptr: pointer to lli table</span>
<span class="cm"> * @num_entries_ptr: pointer to number of entries</span>
<span class="cm"> * @table_data_size_ptr: point to table data size</span>
<span class="cm"> * @dmatables_region: Optional buffer for DMA tables</span>
<span class="cm"> * @dma_ctx: DMA context</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates empty lli tables when there is no data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_prepare_empty_lli_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">lli_table_addr_ptr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">num_entries_ptr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">table_data_size_ptr</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_table_ptr</span><span class="p">;</span>

	<span class="cm">/* Find the area for new table */</span>
	<span class="n">lli_table_ptr</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
		<span class="n">SYNCHRONIC_DMA_TABLES_AREA_OFFSET_BYTES</span> <span class="o">+</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmatables_region</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dmatables_region</span><span class="p">)</span>
		<span class="n">lli_table_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">dmatables_region</span><span class="p">;</span>

	<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lli_table_ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">lli_table_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the output parameter value */</span>
	<span class="o">*</span><span class="n">lli_table_addr_ptr</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span> <span class="o">+</span>
		<span class="n">SYNCHRONIC_DMA_TABLES_AREA_OFFSET_BYTES</span> <span class="o">+</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
		<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">;</span>

	<span class="cm">/* Set the num of entries and table data size for empty table */</span>
	<span class="o">*</span><span class="n">num_entries_ptr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="o">*</span><span class="n">table_data_size_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Update the number of created tables */</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_prepare_input_dma_table - prepare input DMA mappings</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @data_size:</span>
<span class="cm"> * @block_size:</span>
<span class="cm"> * @lli_table_ptr:</span>
<span class="cm"> * @num_entries_ptr:</span>
<span class="cm"> * @table_data_size_ptr:</span>
<span class="cm"> * @is_kva: set for kernel data (kernel cryptio call)</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares only input DMA table for synhronic symmetric</span>
<span class="cm"> * operations (HASH)</span>
<span class="cm"> * Note that all bus addresses that are passed to the SEP</span>
<span class="cm"> * are in 32 bit format; the SEP is a 32 bit device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_prepare_input_dma_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">app_virt_addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_size</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">block_size</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">lli_table_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">num_entries_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">table_data_size_ptr</span><span class="p">,</span>
	<span class="n">bool</span> <span class="n">is_kva</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Pointer to the info entry of the table - the last entry */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">info_entry_ptr</span><span class="p">;</span>
	<span class="cm">/* Array of pointers to page */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_array_ptr</span><span class="p">;</span>
	<span class="cm">/* Points to the first entry to be processed in the lli_in_array */</span>
	<span class="n">u32</span> <span class="n">current_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Num entries in the virtual buffer */</span>
	<span class="n">u32</span> <span class="n">sep_lli_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Lli table pointer */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">in_lli_table_ptr</span><span class="p">;</span>
	<span class="cm">/* The total data in one table */</span>
	<span class="n">u32</span> <span class="n">table_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Flag for last table */</span>
	<span class="n">u32</span> <span class="n">last_table_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Number of entries in lli table */</span>
	<span class="n">u32</span> <span class="n">num_entries_in_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Next table address */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">lli_table_alloc_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dma_lli_table_alloc_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dma_in_lli_table_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] prepare intput dma &quot;</span>
				 <span class="s">&quot;tbl data size: (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] block_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>

	<span class="cm">/* Initialize the pages pointers */</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_num_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the kernel address for first table to be allocated */</span>
	<span class="n">lli_table_alloc_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
		<span class="n">SYNCHRONIC_DMA_TABLES_AREA_OFFSET_BYTES</span> <span class="o">+</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
		<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sep_allocate_dmatables_region</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
						<span class="n">dmatables_region</span><span class="p">,</span>
						<span class="n">dma_ctx</span><span class="p">,</span>
						<span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Special case  - create meptu table - 2 entries, zero data */</span>
		<span class="n">sep_prepare_empty_lli_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">lli_table_ptr</span><span class="p">,</span>
				<span class="n">num_entries_ptr</span><span class="p">,</span> <span class="n">table_data_size_ptr</span><span class="p">,</span>
				<span class="n">dmatables_region</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">update_dcb_counter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if the pages are in Kernel Virtual Address layout */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_kva</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_lock_kernel_pages</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">app_virt_addr</span><span class="p">,</span>
			<span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_array_ptr</span><span class="p">,</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">,</span>
			<span class="n">dma_ctx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/*</span>
<span class="cm">		 * Lock the pages of the user buffer</span>
<span class="cm">		 * and translate them to pages</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_lock_user_pages</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">app_virt_addr</span><span class="p">,</span>
			<span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_array_ptr</span><span class="p">,</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">,</span>
			<span class="n">dma_ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] output sep_in_num_pages is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_num_pages</span><span class="p">);</span>

	<span class="n">current_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info_entry_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sep_lli_entries</span> <span class="o">=</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_num_pages</span><span class="p">;</span>

	<span class="n">dma_lli_table_alloc_addr</span> <span class="o">=</span> <span class="n">lli_table_alloc_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_allocate_dmatables_region</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
					<span class="n">dmatables_region</span><span class="p">,</span>
					<span class="n">dma_ctx</span><span class="p">,</span>
					<span class="n">sep_lli_entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">lli_table_alloc_addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">dmatables_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Loop till all the entries in in array are processed */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">current_entry</span> <span class="o">&lt;</span> <span class="n">sep_lli_entries</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Set the new input and output tables */</span>
		<span class="n">in_lli_table_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">lli_table_alloc_addr</span><span class="p">;</span>
		<span class="n">dma_in_lli_table_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">dma_lli_table_alloc_addr</span><span class="p">;</span>

		<span class="n">lli_table_alloc_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">;</span>
		<span class="n">dma_lli_table_alloc_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dma_lli_table_alloc_addr</span> <span class="o">&gt;</span>
			<span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
			<span class="n">SYNCHRONIC_DMA_TABLES_AREA_OFFSET_BYTES</span> <span class="o">+</span>
			<span class="n">SYNCHRONIC_DMA_TABLES_AREA_SIZE_BYTES</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="cm">/* Update the number of created tables */</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Calculate the maximum size of data for input table */</span>
		<span class="n">table_data_size</span> <span class="o">=</span> <span class="n">sep_calculate_lli_table_max_size</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">lli_array_ptr</span><span class="p">[</span><span class="n">current_entry</span><span class="p">],</span>
			<span class="p">(</span><span class="n">sep_lli_entries</span> <span class="o">-</span> <span class="n">current_entry</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">last_table_flag</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this is not the last table -</span>
<span class="cm">		 * then align it to the block size</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_table_flag</span><span class="p">)</span>
			<span class="n">table_data_size</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">table_data_size</span> <span class="o">/</span> <span class="n">block_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] output table_data_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="n">table_data_size</span><span class="p">);</span>

		<span class="cm">/* Construct input lli table */</span>
		<span class="n">sep_build_lli_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_array_ptr</span><span class="p">[</span><span class="n">current_entry</span><span class="p">],</span>
			<span class="n">in_lli_table_ptr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">current_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_entries_in_table</span><span class="p">,</span> <span class="n">table_data_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info_entry_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Set the output parameters to physical addresses */</span>
			<span class="o">*</span><span class="n">lli_table_ptr</span> <span class="o">=</span> <span class="n">sep_shared_area_virt_to_bus</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="n">dma_in_lli_table_ptr</span><span class="p">);</span>
			<span class="o">*</span><span class="n">num_entries_ptr</span> <span class="o">=</span> <span class="n">num_entries_in_table</span><span class="p">;</span>
			<span class="o">*</span><span class="n">table_data_size_ptr</span> <span class="o">=</span> <span class="n">table_data_size</span><span class="p">;</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] output lli_table_in_ptr is %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">lli_table_ptr</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Update the info entry of the previous in table */</span>
			<span class="n">info_entry_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">=</span>
				<span class="n">sep_shared_area_virt_to_bus</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
							<span class="n">dma_in_lli_table_ptr</span><span class="p">);</span>
			<span class="n">info_entry_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span>
				<span class="p">((</span><span class="n">num_entries_in_table</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">table_data_size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Save the pointer to the info entry of the current tables */</span>
		<span class="n">info_entry_ptr</span> <span class="o">=</span> <span class="n">in_lli_table_ptr</span> <span class="o">+</span> <span class="n">num_entries_in_table</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Print input tables */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_debug_print_lli_tables</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sep_shared_area_bus_to_virt</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">*</span><span class="n">lli_table_ptr</span><span class="p">),</span>
			<span class="o">*</span><span class="n">num_entries_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">table_data_size_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The array of the pages */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lli_array_ptr</span><span class="p">);</span>

<span class="nl">update_dcb_counter:</span>
	<span class="cm">/* Update DCB counter */</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="o">++</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

<span class="nl">end_function_error:</span>
	<span class="cm">/* Free all the allocated resources */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_array</span><span class="p">);</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lli_array_ptr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span><span class="p">);</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_construct_dma_tables_from_lli - prepare AES/DES mappings</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @lli_in_array:</span>
<span class="cm"> * @sep_in_lli_entries:</span>
<span class="cm"> * @lli_out_array:</span>
<span class="cm"> * @sep_out_lli_entries</span>
<span class="cm"> * @block_size</span>
<span class="cm"> * @lli_table_in_ptr</span>
<span class="cm"> * @lli_table_out_ptr</span>
<span class="cm"> * @in_num_entries_ptr</span>
<span class="cm"> * @out_num_entries_ptr</span>
<span class="cm"> * @table_data_size_ptr</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates the input and output DMA tables for</span>
<span class="cm"> * symmetric operations (AES/DES) according to the block</span>
<span class="cm"> * size from LLI arays</span>
<span class="cm"> * Note that all bus addresses that are passed to the SEP</span>
<span class="cm"> * are in 32 bit format; the SEP is a 32 bit device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_construct_dma_tables_from_lli</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_in_array</span><span class="p">,</span>
	<span class="n">u32</span>	<span class="n">sep_in_lli_entries</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_out_array</span><span class="p">,</span>
	<span class="n">u32</span>	<span class="n">sep_out_lli_entries</span><span class="p">,</span>
	<span class="n">u32</span>	<span class="n">block_size</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">lli_table_in_ptr</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">lli_table_out_ptr</span><span class="p">,</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">in_num_entries_ptr</span><span class="p">,</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">out_num_entries_ptr</span><span class="p">,</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">table_data_size_ptr</span><span class="p">,</span>
	<span class="kt">void</span>	<span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Points to the area where next lli table can be allocated */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">lli_table_alloc_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Points to the area in shared region where next lli table</span>
<span class="cm">	 * can be allocated</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dma_lli_table_alloc_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Input lli table in dmatables_region or shared region */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">in_lli_table_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Input lli table location in the shared region */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">dma_in_lli_table_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Output lli table in dmatables_region or shared region */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">out_lli_table_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Output lli table location in the shared region */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">dma_out_lli_table_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Pointer to the info entry of the table - the last entry */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">info_in_entry_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Pointer to the info entry of the table - the last entry */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">info_out_entry_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Points to the first entry to be processed in the lli_in_array */</span>
	<span class="n">u32</span> <span class="n">current_in_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Points to the first entry to be processed in the lli_out_array */</span>
	<span class="n">u32</span> <span class="n">current_out_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Max size of the input table */</span>
	<span class="n">u32</span> <span class="n">in_table_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Max size of the output table */</span>
	<span class="n">u32</span> <span class="n">out_table_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Flag te signifies if this is the last tables build */</span>
	<span class="n">u32</span> <span class="n">last_table_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* The data size that should be in table */</span>
	<span class="n">u32</span> <span class="n">table_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Number of etnries in the input table */</span>
	<span class="n">u32</span> <span class="n">num_entries_in_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Number of etnries in the output table */</span>
	<span class="n">u32</span> <span class="n">num_entries_out_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA context uninitialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initiate to point after the message area */</span>
	<span class="n">lli_table_alloc_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
		<span class="n">SYNCHRONIC_DMA_TABLES_AREA_OFFSET_BYTES</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span> <span class="o">*</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
		<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">)));</span>
	<span class="n">dma_lli_table_alloc_addr</span> <span class="o">=</span> <span class="n">lli_table_alloc_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 2 for both in+out table */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sep_allocate_dmatables_region</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
					<span class="n">dmatables_region</span><span class="p">,</span>
					<span class="n">dma_ctx</span><span class="p">,</span>
					<span class="mi">2</span><span class="o">*</span><span class="n">sep_in_lli_entries</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">lli_table_alloc_addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">dmatables_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Loop till all the entries in in array are not processed */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">current_in_entry</span> <span class="o">&lt;</span> <span class="n">sep_in_lli_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the new input and output tables */</span>
		<span class="n">in_lli_table_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">lli_table_alloc_addr</span><span class="p">;</span>
		<span class="n">dma_in_lli_table_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">dma_lli_table_alloc_addr</span><span class="p">;</span>

		<span class="n">lli_table_alloc_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">;</span>
		<span class="n">dma_lli_table_alloc_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">;</span>

		<span class="cm">/* Set the first output tables */</span>
		<span class="n">out_lli_table_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">lli_table_alloc_addr</span><span class="p">;</span>
		<span class="n">dma_out_lli_table_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">dma_lli_table_alloc_addr</span><span class="p">;</span>

		<span class="cm">/* Check if the DMA table area limit was overrun */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dma_lli_table_alloc_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
			<span class="n">SYNCHRONIC_DMA_TABLES_AREA_OFFSET_BYTES</span> <span class="o">+</span>
			<span class="n">SYNCHRONIC_DMA_TABLES_AREA_SIZE_BYTES</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dma table limit overrun</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Update the number of the lli tables created */</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">num_lli_tables_created</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">lli_table_alloc_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">;</span>
		<span class="n">dma_lli_table_alloc_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">;</span>

		<span class="cm">/* Calculate the maximum size of data for input table */</span>
		<span class="n">in_table_data_size</span> <span class="o">=</span>
			<span class="n">sep_calculate_lli_table_max_size</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">lli_in_array</span><span class="p">[</span><span class="n">current_in_entry</span><span class="p">],</span>
			<span class="p">(</span><span class="n">sep_in_lli_entries</span> <span class="o">-</span> <span class="n">current_in_entry</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">last_table_flag</span><span class="p">);</span>

		<span class="cm">/* Calculate the maximum size of data for output table */</span>
		<span class="n">out_table_data_size</span> <span class="o">=</span>
			<span class="n">sep_calculate_lli_table_max_size</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">lli_out_array</span><span class="p">[</span><span class="n">current_out_entry</span><span class="p">],</span>
			<span class="p">(</span><span class="n">sep_out_lli_entries</span> <span class="o">-</span> <span class="n">current_out_entry</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">last_table_flag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_table_flag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">in_table_data_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_table_data_size</span> <span class="o">/</span>
				<span class="n">block_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">;</span>
			<span class="n">out_table_data_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_table_data_size</span> <span class="o">/</span>
				<span class="n">block_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">table_data_size</span> <span class="o">=</span> <span class="n">in_table_data_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table_data_size</span> <span class="o">&gt;</span> <span class="n">out_table_data_size</span><span class="p">)</span>
			<span class="n">table_data_size</span> <span class="o">=</span> <span class="n">out_table_data_size</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] construct tables from lli&quot;</span>
			<span class="s">&quot; in_table_data_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="n">in_table_data_size</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] construct tables from lli&quot;</span>
			<span class="s">&quot;out_table_data_size is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="n">out_table_data_size</span><span class="p">);</span>

		<span class="cm">/* Construct input lli table */</span>
		<span class="n">sep_build_lli_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_in_array</span><span class="p">[</span><span class="n">current_in_entry</span><span class="p">],</span>
			<span class="n">in_lli_table_ptr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">current_in_entry</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">num_entries_in_table</span><span class="p">,</span>
			<span class="n">table_data_size</span><span class="p">);</span>

		<span class="cm">/* Construct output lli table */</span>
		<span class="n">sep_build_lli_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_out_array</span><span class="p">[</span><span class="n">current_out_entry</span><span class="p">],</span>
			<span class="n">out_lli_table_ptr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">current_out_entry</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">num_entries_out_table</span><span class="p">,</span>
			<span class="n">table_data_size</span><span class="p">);</span>

		<span class="cm">/* If info entry is null - this is the first table built */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info_in_entry_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set the output parameters to physical addresses */</span>
			<span class="o">*</span><span class="n">lli_table_in_ptr</span> <span class="o">=</span>
			<span class="n">sep_shared_area_virt_to_bus</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_in_lli_table_ptr</span><span class="p">);</span>

			<span class="o">*</span><span class="n">in_num_entries_ptr</span> <span class="o">=</span> <span class="n">num_entries_in_table</span><span class="p">;</span>

			<span class="o">*</span><span class="n">lli_table_out_ptr</span> <span class="o">=</span>
				<span class="n">sep_shared_area_virt_to_bus</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="n">dma_out_lli_table_ptr</span><span class="p">);</span>

			<span class="o">*</span><span class="n">out_num_entries_ptr</span> <span class="o">=</span> <span class="n">num_entries_out_table</span><span class="p">;</span>
			<span class="o">*</span><span class="n">table_data_size_ptr</span> <span class="o">=</span> <span class="n">table_data_size</span><span class="p">;</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] output lli_table_in_ptr is %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">lli_table_in_ptr</span><span class="p">);</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] output lli_table_out_ptr is %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">lli_table_out_ptr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Update the info entry of the previous in table */</span>
			<span class="n">info_in_entry_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">=</span>
				<span class="n">sep_shared_area_virt_to_bus</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="n">dma_in_lli_table_ptr</span><span class="p">);</span>

			<span class="n">info_in_entry_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span>
				<span class="p">((</span><span class="n">num_entries_in_table</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">table_data_size</span><span class="p">);</span>

			<span class="cm">/* Update the info entry of the previous in table */</span>
			<span class="n">info_out_entry_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span> <span class="o">=</span>
				<span class="n">sep_shared_area_virt_to_bus</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="n">dma_out_lli_table_ptr</span><span class="p">);</span>

			<span class="n">info_out_entry_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span>
				<span class="p">((</span><span class="n">num_entries_out_table</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">table_data_size</span><span class="p">);</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] output lli_table_in_ptr:%08lx %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">info_in_entry_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">,</span>
				<span class="n">info_in_entry_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] output lli_table_out_ptr:&quot;</span>
				<span class="s">&quot;%08lx  %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">info_out_entry_ptr</span><span class="o">-&gt;</span><span class="n">bus_address</span><span class="p">,</span>
				<span class="n">info_out_entry_ptr</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Save the pointer to the info entry of the current tables */</span>
		<span class="n">info_in_entry_ptr</span> <span class="o">=</span> <span class="n">in_lli_table_ptr</span> <span class="o">+</span>
			<span class="n">num_entries_in_table</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">info_out_entry_ptr</span> <span class="o">=</span> <span class="n">out_lli_table_ptr</span> <span class="o">+</span>
			<span class="n">num_entries_out_table</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] output num_entries_out_table is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">num_entries_out_table</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] output info_in_entry_ptr is %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">info_in_entry_ptr</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] output info_out_entry_ptr is %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">info_out_entry_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print input tables */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_debug_print_lli_tables</span><span class="p">(</span>
			<span class="n">sep</span><span class="p">,</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sep_shared_area_bus_to_virt</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">*</span><span class="n">lli_table_in_ptr</span><span class="p">),</span>
			<span class="o">*</span><span class="n">in_num_entries_ptr</span><span class="p">,</span>
			<span class="o">*</span><span class="n">table_data_size_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print output tables */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep_debug_print_lli_tables</span><span class="p">(</span>
			<span class="n">sep</span><span class="p">,</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sep_shared_area_bus_to_virt</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">*</span><span class="n">lli_table_out_ptr</span><span class="p">),</span>
			<span class="o">*</span><span class="n">out_num_entries_ptr</span><span class="p">,</span>
			<span class="o">*</span><span class="n">table_data_size_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_prepare_input_output_dma_table - prepare DMA I/O table</span>
<span class="cm"> * @app_virt_in_addr:</span>
<span class="cm"> * @app_virt_out_addr:</span>
<span class="cm"> * @data_size:</span>
<span class="cm"> * @block_size:</span>
<span class="cm"> * @lli_table_in_ptr:</span>
<span class="cm"> * @lli_table_out_ptr:</span>
<span class="cm"> * @in_num_entries_ptr:</span>
<span class="cm"> * @out_num_entries_ptr:</span>
<span class="cm"> * @table_data_size_ptr:</span>
<span class="cm"> * @is_kva: set for kernel data; used only for kernel crypto module</span>
<span class="cm"> *</span>
<span class="cm"> * This function builds input and output DMA tables for synhronic</span>
<span class="cm"> * symmetric operations (AES, DES, HASH). It also checks that each table</span>
<span class="cm"> * is of the modular block size</span>
<span class="cm"> * Note that all bus addresses that are passed to the SEP</span>
<span class="cm"> * are in 32 bit format; the SEP is a 32 bit device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_prepare_input_output_dma_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">app_virt_in_addr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">app_virt_out_addr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">data_size</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">block_size</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">lli_table_in_ptr</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">lli_table_out_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">in_num_entries_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">out_num_entries_ptr</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">table_data_size_ptr</span><span class="p">,</span>
	<span class="n">bool</span> <span class="n">is_kva</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span>

<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Array of pointers of page */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_in_array</span><span class="p">;</span>
	<span class="cm">/* Array of pointers of page */</span>
	<span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="n">lli_out_array</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Prepare empty table for input and output */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dmatables_region</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sep_allocate_dmatables_region</span><span class="p">(</span>
					<span class="n">sep</span><span class="p">,</span>
					<span class="n">dmatables_region</span><span class="p">,</span>
					<span class="n">dma_ctx</span><span class="p">,</span>
					<span class="mi">2</span><span class="p">);</span>
		  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sep_prepare_empty_lli_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">lli_table_in_ptr</span><span class="p">,</span>
			<span class="n">in_num_entries_ptr</span><span class="p">,</span> <span class="n">table_data_size_ptr</span><span class="p">,</span>
			<span class="n">dmatables_region</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>

		<span class="n">sep_prepare_empty_lli_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">lli_table_out_ptr</span><span class="p">,</span>
			<span class="n">out_num_entries_ptr</span><span class="p">,</span> <span class="n">table_data_size_ptr</span><span class="p">,</span>
			<span class="n">dmatables_region</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">update_dcb_counter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the pages pointers */</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Lock the pages of the buffer and translate them to pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_kva</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] Locking kernel input pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_lock_kernel_pages</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">app_virt_in_addr</span><span class="p">,</span>
				<span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_in_array</span><span class="p">,</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] sep_lock_kernel_pages for input &quot;</span>
				<span class="s">&quot;virtual buffer failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] Locking kernel output pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_lock_kernel_pages</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">app_virt_out_addr</span><span class="p">,</span>
				<span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_out_array</span><span class="p">,</span> <span class="n">SEP_DRIVER_OUT_FLAG</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] sep_lock_kernel_pages for output &quot;</span>
				<span class="s">&quot;virtual buffer failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">end_function_free_lli_in</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] Locking user input pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_lock_user_pages</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">app_virt_in_addr</span><span class="p">,</span>
				<span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_in_array</span><span class="p">,</span> <span class="n">SEP_DRIVER_IN_FLAG</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] sep_lock_user_pages for input &quot;</span>
				<span class="s">&quot;virtual buffer failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">secure_dma</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* secure_dma requires use of non accessible memory */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] in secure_dma</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sep_lli_table_secure_dma</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="n">app_virt_out_addr</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_out_array</span><span class="p">,</span>
				<span class="n">SEP_DRIVER_OUT_FLAG</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;[PID%d] secure dma table setup &quot;</span>
					<span class="s">&quot; for output virtual buffer failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

				<span class="k">goto</span> <span class="n">end_function_free_lli_in</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* For normal, non-secure dma */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] not in secure_dma</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] Locking user output pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">sep_lock_user_pages</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">app_virt_out_addr</span><span class="p">,</span>
				<span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lli_out_array</span><span class="p">,</span> <span class="n">SEP_DRIVER_OUT_FLAG</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;[PID%d] sep_lock_user_pages&quot;</span>
					<span class="s">&quot; for output virtual buffer failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

				<span class="k">goto</span> <span class="n">end_function_free_lli_in</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] After lock; prep input output dma &quot;</span>
		<span class="s">&quot;table sep_in_num_pages is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_num_pages</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_out_num_pages is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_num_pages</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP&quot;</span>
		<span class="s">&quot; is (hex) %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="n">SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP</span><span class="p">);</span>

	<span class="cm">/* Call the fucntion that creates table from the lli arrays */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] calling create table from lli</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_construct_dma_tables_from_lli</span><span class="p">(</span>
			<span class="n">sep</span><span class="p">,</span> <span class="n">lli_in_array</span><span class="p">,</span>
			<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span>
								<span class="n">in_num_pages</span><span class="p">,</span>
			<span class="n">lli_out_array</span><span class="p">,</span>
			<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span>
								<span class="n">out_num_pages</span><span class="p">,</span>
			<span class="n">block_size</span><span class="p">,</span> <span class="n">lli_table_in_ptr</span><span class="p">,</span> <span class="n">lli_table_out_ptr</span><span class="p">,</span>
			<span class="n">in_num_entries_ptr</span><span class="p">,</span> <span class="n">out_num_entries_ptr</span><span class="p">,</span>
			<span class="n">table_data_size_ptr</span><span class="p">,</span> <span class="n">dmatables_region</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] sep_construct_dma_tables_from_lli failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function_with_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">lli_out_array</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lli_in_array</span><span class="p">);</span>

<span class="nl">update_dcb_counter:</span>
	<span class="cm">/* Update DCB counter */</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="o">++</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

<span class="nl">end_function_with_error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_map_array</span><span class="p">);</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_map_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_page_array</span><span class="p">);</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">out_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lli_out_array</span><span class="p">);</span>


<span class="nl">end_function_free_lli_in:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_array</span><span class="p">);</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_map_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span><span class="p">);</span>
	<span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dma_res_arr</span><span class="p">[</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">].</span><span class="n">in_page_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lli_in_array</span><span class="p">);</span>

<span class="nl">end_function:</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_prepare_input_output_dma_table_in_dcb - prepare control blocks</span>
<span class="cm"> * @app_in_address: unsigned long; for data buffer in (user space)</span>
<span class="cm"> * @app_out_address: unsigned long; for data buffer out (user space)</span>
<span class="cm"> * @data_in_size: u32; for size of data</span>
<span class="cm"> * @block_size: u32; for block size</span>
<span class="cm"> * @tail_block_size: u32; for size of tail block</span>
<span class="cm"> * @isapplet: bool; to indicate external app</span>
<span class="cm"> * @is_kva: bool; kernel buffer; only used for kernel crypto module</span>
<span class="cm"> * @secure_dma; indicates whether this is secure_dma using IMR</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares the linked DMA tables and puts the</span>
<span class="cm"> * address for the linked list of tables inta a DCB (data control</span>
<span class="cm"> * block) the address of which is known by the SEP hardware</span>
<span class="cm"> * Note that all bus addresses that are passed to the SEP</span>
<span class="cm"> * are in 32 bit format; the SEP is a 32 bit device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sep_prepare_input_output_dma_table_in_dcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">app_in_address</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">app_out_address</span><span class="p">,</span>
	<span class="n">u32</span>  <span class="n">data_in_size</span><span class="p">,</span>
	<span class="n">u32</span>  <span class="n">block_size</span><span class="p">,</span>
	<span class="n">u32</span>  <span class="n">tail_block_size</span><span class="p">,</span>
	<span class="n">bool</span> <span class="n">isapplet</span><span class="p">,</span>
	<span class="n">bool</span>	<span class="n">is_kva</span><span class="p">,</span>
	<span class="n">bool</span>	<span class="n">secure_dma</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">*</span><span class="n">dcb_region</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">src_sg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dst_sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Size of tail */</span>
	<span class="n">u32</span> <span class="n">tail_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Address of the created DCB table */</span>
	<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">*</span><span class="n">dcb_table_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* The physical address of the first input DMA table */</span>
	<span class="n">dma_addr_t</span> <span class="n">in_first_mlli_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Number of entries in the first input DMA table */</span>
	<span class="n">u32</span>  <span class="n">in_first_num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* The physical address of the first output DMA table */</span>
	<span class="n">dma_addr_t</span>  <span class="n">out_first_mlli_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Number of entries in the first output DMA table */</span>
	<span class="n">u32</span>  <span class="n">out_first_num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Data in the first input/output table */</span>
	<span class="n">u32</span>  <span class="n">first_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] app_in_address %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">app_in_address</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] app_out_address %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">app_out_address</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] data_in_size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">data_in_size</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] block_size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] tail_block_size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">tail_block_size</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] isapplet %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">isapplet</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] is_kva %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">is_kva</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] src_sg %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">src_sg</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] dst_sg %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">dst_sg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] no DMA context pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In case there are multiple DCBs for this transaction */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] DMA context already set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">**</span><span class="n">dma_ctx</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] Not enough memory for DMA context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		  <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		  <span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] Created DMA context addr at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">secure_dma</span> <span class="o">=</span> <span class="n">secure_dma</span><span class="p">;</span>

	<span class="cm">/* these are for kernel crypto only */</span>
	<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_sg</span> <span class="o">=</span> <span class="n">src_sg</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dst_sg</span> <span class="o">=</span> <span class="n">dst_sg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span> <span class="o">==</span> <span class="n">SEP_MAX_NUM_SYNC_DMA_OPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No more DCBs to allocate */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] no more DCBs available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate new DCB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dcb_table_ptr</span> <span class="o">=</span> <span class="n">dcb_region</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dcb_table_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">*</span><span class="p">)(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
			<span class="n">SEP_DRIVER_SYSTEM_DCB_MEMORY_OFFSET_IN_BYTES</span> <span class="o">+</span>
			<span class="p">((</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span> <span class="o">*</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="cm">/* Set the default values in the DCB */</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">input_mlli_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">input_mlli_num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">input_mlli_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">output_mlli_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">output_mlli_num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">output_mlli_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">out_vr_tail_pt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isapplet</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Check if there is enough data for DMA operation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_in_size</span> <span class="o">&lt;</span> <span class="n">SEP_DRIVER_MIN_DATA_SIZE_PER_TABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_kva</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">app_in_address</span><span class="p">,</span>
					<span class="n">data_in_size</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data_size</span> <span class="o">=</span> <span class="n">data_in_size</span><span class="p">;</span>

			<span class="cm">/* Set the output user-space address for mem2mem op */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">app_out_address</span><span class="p">)</span>
				<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">out_vr_tail_pt</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">aligned_u64</span><span class="p">)</span><span class="n">app_out_address</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Update both data length parameters in order to avoid</span>
<span class="cm">			 * second data copy and allow building of empty mlli</span>
<span class="cm">			 * tables</span>
<span class="cm">			 */</span>
			<span class="n">tail_size</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
			<span class="n">data_in_size</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">app_out_address</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tail_size</span> <span class="o">=</span> <span class="n">data_in_size</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tail_size</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">tail_block_size</span> <span class="o">==</span> <span class="n">block_size</span><span class="p">)</span>
						<span class="n">tail_size</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">tail_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tail_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tail_size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_kva</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* We have tail data - copy it to DCB */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">app_in_address</span> <span class="o">+</span>
					<span class="n">data_in_size</span> <span class="o">-</span> <span class="n">tail_size</span><span class="p">),</span> <span class="n">tail_size</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">app_out_address</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * Calculate the output address</span>
<span class="cm">				 * according to tail data size</span>
<span class="cm">				 */</span>
				<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">out_vr_tail_pt</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">aligned_u64</span><span class="p">)</span><span class="n">app_out_address</span> <span class="o">+</span>
					<span class="n">data_in_size</span> <span class="o">-</span> <span class="n">tail_size</span><span class="p">;</span>

			<span class="cm">/* Save the real tail data size */</span>
			<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data_size</span> <span class="o">=</span> <span class="n">tail_size</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Update the data size without the tail</span>
<span class="cm">			 * data size AKA data for the dma</span>
<span class="cm">			 */</span>
			<span class="n">data_in_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_in_size</span> <span class="o">-</span> <span class="n">tail_size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Check if we need to build only input table or input/output */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">app_out_address</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Prepare input/output tables */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_prepare_input_output_dma_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="n">app_in_address</span><span class="p">,</span>
				<span class="n">app_out_address</span><span class="p">,</span>
				<span class="n">data_in_size</span><span class="p">,</span>
				<span class="n">block_size</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">in_first_mlli_address</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">out_first_mlli_address</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">in_first_num_entries</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">out_first_num_entries</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">first_data_size</span><span class="p">,</span>
				<span class="n">is_kva</span><span class="p">,</span>
				<span class="n">dmatables_region</span><span class="p">,</span>
				<span class="o">*</span><span class="n">dma_ctx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Prepare input tables */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_prepare_input_dma_table</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="n">app_in_address</span><span class="p">,</span>
				<span class="n">data_in_size</span><span class="p">,</span>
				<span class="n">block_size</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">in_first_mlli_address</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">in_first_num_entries</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">first_data_size</span><span class="p">,</span>
				<span class="n">is_kva</span><span class="p">,</span>
				<span class="n">dmatables_region</span><span class="p">,</span>
				<span class="o">*</span><span class="n">dma_ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;prepare DMA table call failed &quot;</span>
			<span class="s">&quot;from prepare DCB call</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the DCB values */</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">input_mlli_address</span> <span class="o">=</span> <span class="n">in_first_mlli_address</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">input_mlli_num_entries</span> <span class="o">=</span> <span class="n">in_first_num_entries</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">input_mlli_data_size</span> <span class="o">=</span> <span class="n">first_data_size</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">output_mlli_address</span> <span class="o">=</span> <span class="n">out_first_mlli_address</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">output_mlli_num_entries</span> <span class="o">=</span> <span class="n">out_first_num_entries</span><span class="p">;</span>
	<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">output_mlli_data_size</span> <span class="o">=</span> <span class="n">first_data_size</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

<span class="nl">end_function_error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sep_free_dma_tables_and_dcb - free DMA tables and DCBs</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @isapplet: indicates external application (used for kernel access)</span>
<span class="cm"> * @is_kva: indicates kernel addresses (only used for kernel crypto)</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees the DMA tables and DCB</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_free_dma_tables_and_dcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="n">bool</span> <span class="n">isapplet</span><span class="p">,</span>
	<span class="n">bool</span> <span class="n">is_kva</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">*</span><span class="n">dcb_table_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pt_hold</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tail_pt</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error_temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_free_dma_tables_and_dcb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">secure_dma</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">isapplet</span> <span class="o">==</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] handling applet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

		<span class="cm">/* Tail stuff is only for non secure_dma */</span>
		<span class="cm">/* Set pointer to first DCB table */</span>
		<span class="n">dcb_table_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
			<span class="n">SEP_DRIVER_SYSTEM_DCB_MEMORY_OFFSET_IN_BYTES</span><span class="p">);</span>

		<span class="cm">/**</span>
<span class="cm">		 * Go over each DCB and see if</span>
<span class="cm">		 * tail pointer must be updated</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dma_ctx</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dma_ctx</span> <span class="o">&amp;&amp;</span>
			<span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">dcb_table_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">out_vr_tail_pt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pt_hold</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dcb_table_ptr</span><span class="o">-&gt;</span>
					<span class="n">out_vr_tail_pt</span><span class="p">;</span>
				<span class="n">tail_pt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pt_hold</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_kva</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">error_temp</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span>
						<span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">tail_pt</span><span class="p">,</span>
						<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data</span><span class="p">,</span>
						<span class="n">dcb_table_ptr</span><span class="o">-&gt;</span><span class="n">tail_data_size</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error_temp</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Release the DMA resource */</span>
					<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Free the output pages, if any */</span>
	<span class="n">sep_free_dma_table_data_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep_free_dma_tables_and_dcb end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_prepare_dcb_handler - prepare a control block</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> * @arg: pointer to user parameters</span>
<span class="cm"> * @secure_dma: indicate whether we are using secure_dma on IMR</span>
<span class="cm"> *</span>
<span class="cm"> * This function will retrieve the RAR buffer physical addresses, type</span>
<span class="cm"> * &amp; size corresponding to the RAR handles provided in the buffers vector.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_prepare_dcb_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">secure_dma</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/* Command arguments */</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">build_dcb_struct</span> <span class="n">command_args</span><span class="p">;</span>

	<span class="cm">/* Get the command arguments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_args</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">build_dcb_struct</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] prep dcb handler app_in_address is %08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">command_args</span><span class="p">.</span><span class="n">app_in_address</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] app_out_address is %08llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">command_args</span><span class="p">.</span><span class="n">app_out_address</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] data_size is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">command_args</span><span class="p">.</span><span class="n">data_in_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] block_size is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">command_args</span><span class="p">.</span><span class="n">block_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] tail block_size is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">command_args</span><span class="p">.</span><span class="n">tail_block_size</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;[PID%d] is_applet is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">command_args</span><span class="p">.</span><span class="n">is_applet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">command_args</span><span class="p">.</span><span class="n">app_in_address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] null app_in_address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_prepare_input_output_dma_table_in_dcb</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">command_args</span><span class="p">.</span><span class="n">app_in_address</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">command_args</span><span class="p">.</span><span class="n">app_out_address</span><span class="p">,</span>
			<span class="n">command_args</span><span class="p">.</span><span class="n">data_in_size</span><span class="p">,</span> <span class="n">command_args</span><span class="p">.</span><span class="n">block_size</span><span class="p">,</span>
			<span class="n">command_args</span><span class="p">.</span><span class="n">tail_block_size</span><span class="p">,</span>
			<span class="n">command_args</span><span class="p">.</span><span class="n">is_applet</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
			<span class="n">secure_dma</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_free_dcb_handler - free control block resources</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees the DCB resources and updates the needed</span>
<span class="cm"> * user-space buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_free_dcb_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_ctx</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] no dma context defined, nothing to free</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] free dcbs num of DCBs %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
		<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sep_free_dma_tables_and_dcb</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_ioctl - ioctl handler for sep device</span>
<span class="cm"> * @filp: pointer to struct file</span>
<span class="cm"> * @cmd: command</span>
<span class="cm"> * @arg: pointer to argument structure</span>
<span class="cm"> *</span>
<span class="cm"> * Implement the ioctl methods available on the SEP device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">sep_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="o">*</span> <span class="k">const</span> <span class="n">private_data</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="o">*</span><span class="n">call_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">private_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">**</span><span class="n">my_queue_elem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">my_queue_elem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] ioctl cmd 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] dma context addr 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">);</span>

	<span class="cm">/* Make sure we own this device */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_check_transaction_owner</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] ioctl pid is not owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that sep_mmap has been called before */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_MMAP_DONE_OFFSET</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] mmap not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that the command is for SEP device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SEP_IOC_MAGIC_NUMBER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEP_IOCSENDSEPCOMMAND</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] SEP_IOCSENDSEPCOMMAND start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_SENDMSG_DONE_OFFSET</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] send msg already done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Send command to SEP */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_send_command_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_SENDMSG_DONE_OFFSET</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] SEP_IOCSENDSEPCOMMAND end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEP_IOCENDTRANSACTION</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] SEP_IOCENDTRANSACTION start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_end_transaction_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">,</span> <span class="n">call_status</span><span class="p">,</span>
						    <span class="n">my_queue_elem</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] SEP_IOCENDTRANSACTION end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEP_IOCPREPAREDCB</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] SEP_IOCPREPAREDCB start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SEP_IOCPREPAREDCB_SECURE_DMA</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] SEP_IOCPREPAREDCB_SECURE_DMA start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_LEGACY_SENDMSG_DONE_OFFSET</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] dcb prep needed before send msg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] dcb null arg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SEP_IOCPREPAREDCB</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No secure dma */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] SEP_IOCPREPAREDCB (no secure_dma)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">sep_prepare_dcb_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Secure dma */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;[PID%d] SEP_IOC_POC (with secure_dma)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">sep_prepare_dcb_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] dcb&#39;s end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEP_IOCFREEDCB</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] SEP_IOCFREEDCB start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SEP_IOCFREEDCB_SECURE_DMA</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;[PID%d] SEP_IOCFREEDCB_SECURE_DMA start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_free_dcb_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] SEP_IOCFREEDCB end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] default end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end_function:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] ioctl end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_inthandler - interrupt handler for sep device</span>
<span class="cm"> * @irq: interrupt</span>
<span class="cm"> * @dev_id: device id</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">sep_inthandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_irq_flag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_val</span><span class="p">,</span> <span class="n">reg_val2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">int_error</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="cm">/* Are we in power save? */</span>
<span class="cp">#if defined(CONFIG_PM_RUNTIME) &amp;&amp; defined(SEP_ENABLE_RUNTIME_PM)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">runtime_status</span> <span class="o">!=</span> <span class="n">RPM_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;interrupt during pwr save</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_WORKING_LOCK_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;interrupt while nobody using sep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read the IRR register to check if this is SEP interrupt */</span>
	<span class="n">reg_val</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_IRR_REG_ADDR</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep int: IRR REG val: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Lock and update the counter of reply messages */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">,</span> <span class="n">lock_irq_flag</span><span class="p">);</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">,</span> <span class="n">lock_irq_flag</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep int: send_ct %lx reply_ct %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">);</span>

		<span class="cm">/* Is this a kernel client request */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_kernel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">finish_tasklet</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">finished_interrupt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Is this printf or daemon request? */</span>
		<span class="n">reg_val2</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR2_REG_ADDR</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;SEP Interrupt - GPR2 is %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_val2</span><span class="p">);</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SEP_WORKING_LOCK_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">reg_val2</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;int: printf request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_val2</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;int: daemon request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;int: SEP reply</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_interrupt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;int: not SEP interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">int_error</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">finished_interrupt:</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_error</span> <span class="o">==</span> <span class="n">IRQ_HANDLED</span><span class="p">)</span>
		<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_ICR_REG_ADDR</span><span class="p">,</span> <span class="n">reg_val</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">int_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_reconfig_shared_area - reconfigure shared area</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> *</span>
<span class="cm"> * Reconfig the shared area between HOST and SEP - needed in case</span>
<span class="cm"> * the DX_CC_Init function was called before OS loading.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_reconfig_shared_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* use to limit waiting for SEP */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span><span class="p">;</span>

	<span class="cm">/* Send the new SHARED MESSAGE AREA to the SEP */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reconfig shared; sending %08llx to sep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">);</span>

	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_HOST_SEP_GPR1_REG_ADDR</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">);</span>

	<span class="cm">/* Poll for SEP response */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR1_REG_ADDR</span><span class="p">);</span>

	<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">WAIT_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">end_time</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">))</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR1_REG_ADDR</span><span class="p">);</span>

	<span class="cm">/* Check the return value (register) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not reconfig shared area</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;result was %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret_val</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reconfig shared area end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_activate_dcb_dmatables_context - Takes DCB &amp; DMA tables</span>
<span class="cm"> *						contexts into use</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@dcb_region: DCB region copy</span>
<span class="cm"> *	@dmatables_region: MLLI/DMA tables copy</span>
<span class="cm"> *	@dma_ctx: DMA context for current transaction</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">sep_activate_dcb_dmatables_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">**</span><span class="n">dcb_region</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dmaregion_free_start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dmaregion_free_end</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dcbregion_free_start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dcbregion_free_end</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] activating dcb/dma region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] invalid number of dcbs to activate 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dmaregion_free_start</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span>
				<span class="o">+</span> <span class="n">SYNCHRONIC_DMA_TABLES_AREA_OFFSET_BYTES</span><span class="p">;</span>
	<span class="n">dmaregion_free_end</span> <span class="o">=</span> <span class="n">dmaregion_free_start</span>
				<span class="o">+</span> <span class="n">SYNCHRONIC_DMA_TABLES_AREA_SIZE_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmaregion_free_start</span>
	     <span class="o">+</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_len</span> <span class="o">&gt;</span> <span class="n">dmaregion_free_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dmaregion_free_start</span><span class="p">,</span>
	       <span class="o">*</span><span class="n">dmatables_region</span><span class="p">,</span>
	       <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">dmatables_len</span><span class="p">);</span>
	<span class="cm">/* Free MLLI table copy */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">dmatables_region</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dmatables_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Copy thread&#39;s DCB  table copy to DCB table region */</span>
	<span class="n">dcbregion_free_start</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span> <span class="o">+</span>
				<span class="n">SEP_DRIVER_SYSTEM_DCB_MEMORY_OFFSET_IN_BYTES</span><span class="p">;</span>
	<span class="n">dcbregion_free_end</span> <span class="o">=</span> <span class="n">dcbregion_free_start</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">SEP_MAX_NUM_SYNC_DMA_OPS</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcbregion_free_start</span>
	     <span class="o">+</span> <span class="p">(</span><span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span><span class="p">))</span>
	     <span class="o">&gt;</span> <span class="n">dcbregion_free_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dcbregion_free_start</span><span class="p">,</span>
	       <span class="o">*</span><span class="n">dcb_region</span><span class="p">,</span>
	       <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">nr_dcb_creat</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span><span class="p">));</span>

	<span class="cm">/* Print the tables */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;activate: input table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sep_debug_print_lli_tables</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">sep_shared_area_bus_to_virt</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
		<span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">input_mlli_address</span><span class="p">),</span>
		<span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">input_mlli_num_entries</span><span class="p">,</span>
		<span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">input_mlli_data_size</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;activate: output table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sep_debug_print_lli_tables</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">sep_lli_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">sep_shared_area_bus_to_virt</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
		<span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">output_mlli_address</span><span class="p">),</span>
		<span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">output_mlli_num_entries</span><span class="p">,</span>
		<span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">output_mlli_data_size</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		 <span class="s">&quot;[PID%d] printing activated tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">dmatables_region</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dmatables_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dcb_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_create_dcb_dmatables_context - Creates DCB &amp; MLLI/DMA table context</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@dcb_region: DCB region buf to create for current transaction</span>
<span class="cm"> *	@dmatables_region: MLLI/DMA tables buf to create for current transaction</span>
<span class="cm"> *	@dma_ctx: DMA context buf to create for current transaction</span>
<span class="cm"> *	@user_dcb_args: User arguments for DCB/MLLI creation</span>
<span class="cm"> *	@num_dcbs: Number of DCBs to create</span>
<span class="cm"> *	@secure_dma: Indicate use of IMR restricted memory secure dma</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sep_create_dcb_dmatables_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">**</span><span class="n">dcb_region</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">build_dcb_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_dcb_args</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="n">num_dcbs</span><span class="p">,</span> <span class="n">bool</span> <span class="n">secure_dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">build_dcb_struct</span> <span class="o">*</span><span class="n">dcb_args</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] creating dcb/dma region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcb_region</span> <span class="o">||</span> <span class="o">!</span><span class="n">dma_ctx</span> <span class="o">||</span> <span class="o">!</span><span class="n">dmatables_region</span> <span class="o">||</span> <span class="o">!</span><span class="n">user_dcb_args</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SEP_MAX_NUM_SYNC_DMA_OPS</span> <span class="o">&lt;</span> <span class="n">num_dcbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] invalid number of dcbs 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">num_dcbs</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dcb_args</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num_dcbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">build_dcb_struct</span><span class="p">),</span>
			   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcb_args</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] no memory for dcb args</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">dcb_args</span><span class="p">,</span>
			<span class="n">user_dcb_args</span><span class="p">,</span>
			<span class="n">num_dcbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">build_dcb_struct</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate thread-specific memory for DCB */</span>
	<span class="o">*</span><span class="n">dcb_region</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num_dcbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span><span class="p">),</span>
			      <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prepare DCB and MLLI table into the allocated regions */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_dcbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_prepare_input_output_dma_table_in_dcb</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">app_in_address</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">app_out_address</span><span class="p">,</span>
				<span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data_in_size</span><span class="p">,</span>
				<span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">block_size</span><span class="p">,</span>
				<span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tail_block_size</span><span class="p">,</span>
				<span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_applet</span><span class="p">,</span>
				<span class="nb">false</span><span class="p">,</span> <span class="n">secure_dma</span><span class="p">,</span>
				<span class="o">*</span><span class="n">dcb_region</span><span class="p">,</span> <span class="n">dmatables_region</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;[PID%d] dma table creation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">app_in_address</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">dma_ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">input_data_len</span> <span class="o">+=</span> <span class="n">dcb_args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data_in_size</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end_function:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dcb_args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_create_dcb_dmatables_context_kernel - Creates DCB &amp; MLLI/DMA table context</span>
<span class="cm"> *      for kernel crypto</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@dcb_region: DCB region buf to create for current transaction</span>
<span class="cm"> *	@dmatables_region: MLLI/DMA tables buf to create for current transaction</span>
<span class="cm"> *	@dma_ctx: DMA context buf to create for current transaction</span>
<span class="cm"> *	@user_dcb_args: User arguments for DCB/MLLI creation</span>
<span class="cm"> *	@num_dcbs: Number of DCBs to create</span>
<span class="cm"> *	This does that same thing as sep_create_dcb_dmatables_context</span>
<span class="cm"> *	except that it is used only for the kernel crypto operation. It is</span>
<span class="cm"> *	separate because there is no user data involved; the dcb data structure</span>
<span class="cm"> *	is specific for kernel crypto (build_dcb_struct_kernel)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sep_create_dcb_dmatables_context_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">**</span><span class="n">dcb_region</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">**</span><span class="n">dmatables_region</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">build_dcb_struct_kernel</span> <span class="o">*</span><span class="n">dcb_data</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="n">num_dcbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] creating dcb/dma region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcb_region</span> <span class="o">||</span> <span class="o">!</span><span class="n">dma_ctx</span> <span class="o">||</span> <span class="o">!</span><span class="n">dmatables_region</span> <span class="o">||</span> <span class="o">!</span><span class="n">dcb_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SEP_MAX_NUM_SYNC_DMA_OPS</span> <span class="o">&lt;</span> <span class="n">num_dcbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] invalid number of dcbs 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">num_dcbs</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] num_dcbs is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">num_dcbs</span><span class="p">);</span>

	<span class="cm">/* Allocate thread-specific memory for DCB */</span>
	<span class="o">*</span><span class="n">dcb_region</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num_dcbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_dcblock</span><span class="p">),</span>
			      <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dcb_region</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prepare DCB and MLLI table into the allocated regions */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_dcbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_prepare_input_output_dma_table_in_dcb</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">app_in_address</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">app_out_address</span><span class="p">,</span>
				<span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">data_in_size</span><span class="p">,</span>
				<span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">,</span>
				<span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">tail_block_size</span><span class="p">,</span>
				<span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">is_applet</span><span class="p">,</span>
				<span class="nb">true</span><span class="p">,</span>
				<span class="nb">false</span><span class="p">,</span>
				<span class="o">*</span><span class="n">dcb_region</span><span class="p">,</span> <span class="n">dmatables_region</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">,</span>
				<span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">src_sg</span><span class="p">,</span>
				<span class="n">dcb_data</span><span class="o">-&gt;</span><span class="n">dst_sg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;[PID%d] dma table creation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_activate_msgarea_context - Takes the message area context into use</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@msg_region: Message area context buf</span>
<span class="cm"> *	@msg_len: Message area context buffer size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sep_activate_msgarea_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="o">**</span><span class="n">msg_region</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">msg_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] activating msg region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_region</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">msg_region</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span> <span class="o">&lt;</span> <span class="n">msg_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] invalid act msgarea len 0x%08zX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">msg_region</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_create_msgarea_context - Creates message area context</span>
<span class="cm"> *	@sep: SEP device</span>
<span class="cm"> *	@msg_region: Msg area region buf to create for current transaction</span>
<span class="cm"> *	@msg_user: Content for msg area region from user</span>
<span class="cm"> *	@msg_len: Message area size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sep_create_msgarea_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">**</span><span class="n">msg_region</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">msg_user</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">msg_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] creating msg region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_region</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">msg_user</span> <span class="o">||</span>
	    <span class="n">SEP_DRIVER_MAX_MESSAGE_SIZE_IN_BYTES</span> <span class="o">&lt;</span> <span class="n">msg_len</span> <span class="o">||</span>
	    <span class="n">SEP_DRIVER_MIN_MESSAGE_SIZE_IN_BYTES</span> <span class="o">&gt;</span> <span class="n">msg_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] invalid creat msgarea len 0x%08zX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate thread-specific memory for message buffer */</span>
	<span class="o">*</span><span class="n">msg_region</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">msg_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">msg_region</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] no mem for msgarea context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy input data to write() to allocated message buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">*</span><span class="n">msg_region</span><span class="p">,</span> <span class="n">msg_user</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end_function:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">msg_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">msg_region</span><span class="p">);</span>
		<span class="o">*</span><span class="n">msg_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	sep_read - Returns results of an operation for fastcall interface</span>
<span class="cm"> *	@filp: File pointer</span>
<span class="cm"> *	@buf_user: User buffer for storing results</span>
<span class="cm"> *	@count_user: User buffer size</span>
<span class="cm"> *	@offset: File offset, not supported</span>
<span class="cm"> *</span>
<span class="cm"> *	The implementation does not support reading in chunks, all data must be</span>
<span class="cm"> *	consumed during a single read system call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sep_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf_user</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count_user</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="o">*</span> <span class="k">const</span> <span class="n">private_data</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="o">*</span><span class="n">call_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">private_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">**</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">dma_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">**</span><span class="n">my_queue_elem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">my_queue_elem</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error_tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Am I the process that owns the transaction? */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_check_transaction_owner</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] read pid is not owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Checks that user has called necessarry apis */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_FASTCALL_WRITE_DONE_OFFSET</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] fastcall write not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] null user buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Wait for SEP to finish */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_interrupt</span><span class="p">,</span>
		   <span class="n">test_bit</span><span class="p">(</span><span class="n">SEP_WORKING_LOCK_BIT</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use_flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">sep_dump_message</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] count_user = 0x%08zX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">count_user</span><span class="p">);</span>

	<span class="cm">/* In case user has allocated bigger buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count_user</span> <span class="o">&gt;</span> <span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">)</span>
		<span class="n">count_user</span> <span class="o">=</span> <span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf_user</span><span class="p">,</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_addr</span><span class="p">,</span> <span class="n">count_user</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] read succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">count_user</span><span class="p">;</span>

<span class="nl">end_function_error:</span>
	<span class="cm">/* Copy possible tail data to user and free DCB and MLLIs */</span>
	<span class="n">error_tmp</span> <span class="o">=</span> <span class="n">sep_free_dcb_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error_tmp</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] dcb free failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="cm">/* End the transaction, wakeup pending ones */</span>
	<span class="n">error_tmp</span> <span class="o">=</span> <span class="n">sep_end_transaction_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">dma_ctx</span><span class="p">,</span> <span class="n">call_status</span><span class="p">,</span>
		<span class="n">my_queue_elem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error_tmp</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] ending transaction failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_fastcall_args_get - Gets fastcall params from user</span>
<span class="cm"> *	sep: SEP device</span>
<span class="cm"> *	@args: Parameters buffer</span>
<span class="cm"> *	@buf_user: User buffer for operation parameters</span>
<span class="cm"> *	@count_user: User buffer size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">sep_fastcall_args_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sep_fastcall_hdr</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf_user</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">count_user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">actual_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] null user buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count_user</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_fastcall_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] too small message size 0x%08zX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">count_user</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">buf_user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_fastcall_hdr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SEP_FC_MAGIC</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] invalid fastcall magic 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] fastcall hdr num of DCBs 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">num_dcbs</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] fastcall hdr msg len 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">msg_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SEP_DRIVER_MAX_MESSAGE_SIZE_IN_BYTES</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">msg_len</span> <span class="o">||</span>
	    <span class="n">SEP_DRIVER_MIN_MESSAGE_SIZE_IN_BYTES</span> <span class="o">&gt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">msg_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] invalid message length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">actual_count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_fastcall_hdr</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">msg_len</span>
			<span class="o">+</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">num_dcbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">build_dcb_struct</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">actual_count</span> <span class="o">!=</span> <span class="n">count_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;[PID%d] inconsistent message &quot;</span>
			 <span class="s">&quot;sizes 0x%08zX vs 0x%08zX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">actual_count</span><span class="p">,</span> <span class="n">count_user</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sep_write - Starts an operation for fastcall interface</span>
<span class="cm"> *	@filp: File pointer</span>
<span class="cm"> *	@buf_user: User buffer for operation parameters</span>
<span class="cm"> *	@count_user: User buffer size</span>
<span class="cm"> *	@offset: File offset, not supported</span>
<span class="cm"> *</span>
<span class="cm"> *	The implementation does not support writing in chunks,</span>
<span class="cm"> *	all data must be given during a single write system call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sep_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf_user</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count_user</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_private_data</span> <span class="o">*</span> <span class="k">const</span> <span class="n">private_data</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_call_status</span> <span class="o">*</span><span class="n">call_status</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">call_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">private_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dma_context</span> <span class="o">*</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_fastcall_hdr</span> <span class="n">call_hdr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">msg_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dmatables_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_dcblock</span> <span class="o">*</span><span class="n">dcb_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">*</span><span class="n">my_queue_elem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">my_secure_dma</span><span class="p">;</span> <span class="cm">/* are we using secure_dma (IMR)? */</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] sep dev is 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] private_data is 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">private_data</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_fastcall_args_get</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_hdr</span><span class="p">,</span> <span class="n">buf_user</span><span class="p">,</span> <span class="n">count_user</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

	<span class="n">buf_user</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_fastcall_hdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">call_hdr</span><span class="p">.</span><span class="n">secure_dma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">my_secure_dma</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">my_secure_dma</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Controlling driver memory usage by limiting amount of</span>
<span class="cm">	 * buffers created. Only SEP_DOUBLEBUF_USERS_LIMIT number</span>
<span class="cm">	 * of threads can progress further at a time</span>
<span class="cm">	 */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] waiting for double buffering &quot;</span>
				 <span class="s">&quot;region access</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_doublebuf</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] double buffering region start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Signal received */</span>
		<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * Prepare contents of the shared area regions for</span>
<span class="cm">	 * the operation into temporary buffers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">call_hdr</span><span class="p">.</span><span class="n">num_dcbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_create_dcb_dmatables_context</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dcb_region</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dmatables_region</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dma_ctx</span><span class="p">,</span>
				<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">build_dcb_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
					<span class="n">buf_user</span><span class="p">,</span>
				<span class="n">call_hdr</span><span class="p">.</span><span class="n">num_dcbs</span><span class="p">,</span> <span class="n">my_secure_dma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_function_error_doublebuf</span><span class="p">;</span>

		<span class="n">buf_user</span> <span class="o">+=</span> <span class="n">call_hdr</span><span class="p">.</span><span class="n">num_dcbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">build_dcb_struct</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_create_msgarea_context</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">msg_region</span><span class="p">,</span>
					   <span class="n">buf_user</span><span class="p">,</span>
					   <span class="n">call_hdr</span><span class="p">.</span><span class="n">msg_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_function_error_doublebuf</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] updating queue status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">my_queue_elem</span> <span class="o">=</span> <span class="n">sep_queue_status_add</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="p">((</span><span class="k">struct</span> <span class="n">sep_msgarea_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_region</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span>
				<span class="p">(</span><span class="n">dma_ctx</span><span class="p">)</span> <span class="o">?</span> <span class="n">dma_ctx</span><span class="o">-&gt;</span><span class="n">input_data_len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				     <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_queue_elem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] updating queue&quot;</span>
					<span class="s">&quot;status error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_error_doublebuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait until current process gets the transaction */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_wait_transaction</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Interrupted by signal, don&#39;t clear transaction */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] interrupted by signal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">sep_queue_status_remove</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_queue_elem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function_error_doublebuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] saving queue element</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">private_data</span><span class="o">-&gt;</span><span class="n">my_queue_elem</span> <span class="o">=</span> <span class="n">my_queue_elem</span><span class="p">;</span>

	<span class="cm">/* Activate shared area regions for the transaction */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_activate_msgarea_context</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_region</span><span class="p">,</span>
					     <span class="n">call_hdr</span><span class="p">.</span><span class="n">msg_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_function_error_clear_transact</span><span class="p">;</span>

	<span class="n">sep_dump_message</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">call_hdr</span><span class="p">.</span><span class="n">num_dcbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sep_activate_dcb_dmatables_context</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dcb_region</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dmatables_region</span><span class="p">,</span>
				<span class="n">dma_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_function_error_clear_transact</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send command to SEP */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_send_command_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_function_error_clear_transact</span><span class="p">;</span>

	<span class="cm">/* Store DMA context for the transaction */</span>
	<span class="n">private_data</span><span class="o">-&gt;</span><span class="n">dma_ctx</span> <span class="o">=</span> <span class="n">dma_ctx</span><span class="p">;</span>
	<span class="cm">/* Update call status */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SEP_FASTCALL_WRITE_DONE_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_status</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">count_user</span><span class="p">;</span>

	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_doublebuf</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] double buffering region end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

<span class="nl">end_function_error_clear_transact:</span>
	<span class="n">sep_end_transaction_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_ctx</span><span class="p">,</span> <span class="n">call_status</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">my_queue_elem</span><span class="p">);</span>

<span class="nl">end_function_error_doublebuf:</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_doublebuf</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[PID%d] double buffering region end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

<span class="nl">end_function_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ctx</span><span class="p">)</span>
		<span class="n">sep_free_dma_table_data_handler</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_ctx</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dcb_region</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dmatables_region</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msg_region</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> *	sep_seek - Handler for seek system call</span>
<span class="cm"> *	@filp: File pointer</span>
<span class="cm"> *	@offset: File offset</span>
<span class="cm"> *	@origin: Options for offset</span>
<span class="cm"> *</span>
<span class="cm"> *	Fastcall interface does not support seeking, all reads</span>
<span class="cm"> *	and writes are from/to offset zero</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">sep_seek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/**</span>
<span class="cm"> * sep_file_operations - file operation on sep device</span>
<span class="cm"> * @sep_ioctl:	ioctl handler from user space call</span>
<span class="cm"> * @sep_poll:	poll handler</span>
<span class="cm"> * @sep_open:	handles sep device open request</span>
<span class="cm"> * @sep_release:handles sep device release request</span>
<span class="cm"> * @sep_mmap:	handles memory mapping requests</span>
<span class="cm"> * @sep_read:	handles read request on sep device</span>
<span class="cm"> * @sep_write:	handles write request on sep device</span>
<span class="cm"> * @sep_seek:	handles seek request on sep device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">sep_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">sep_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">sep_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sep_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">sep_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">sep_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">sep_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sep_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">sep_seek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sep_sysfs_read - read sysfs entry per gives arguments</span>
<span class="cm"> * @filp: file pointer</span>
<span class="cm"> * @kobj: kobject pointer</span>
<span class="cm"> * @attr: binary file attributes</span>
<span class="cm"> * @buf: read to this buffer</span>
<span class="cm"> * @pos: offset to read</span>
<span class="cm"> * @count: amount of data to read</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to read sysfs entries for sep driver per given arguments.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sep_sysfs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lck_flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">nleft</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_queue_info</span> <span class="o">*</span><span class="n">queue_elem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">queue_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">,</span> <span class="n">lck_flags</span><span class="p">);</span>

	<span class="n">queue_num</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_num</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_num</span> <span class="o">&gt;</span> <span class="n">SEP_DOUBLEBUF_USERS_LIMIT</span><span class="p">)</span>
		<span class="n">queue_num</span> <span class="o">=</span> <span class="n">SEP_DOUBLEBUF_USERS_LIMIT</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queue_num</span><span class="p">)</span>
			<span class="o">+</span> <span class="p">(</span><span class="n">queue_num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_queue_data</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">,</span> <span class="n">lck_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue_num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queue_num</span><span class="p">));</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queue_num</span><span class="p">);</span>
	<span class="n">nleft</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queue_num</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">queue_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_status</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">queue_num</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queue_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
		<span class="n">nleft</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queue_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">queue_elem</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">,</span> <span class="n">lck_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span> <span class="o">-</span> <span class="n">nleft</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bin_attributes - defines attributes for queue_status</span>
<span class="cm"> * @attr: attributes (name &amp; permissions)</span>
<span class="cm"> * @read: function pointer to read this file</span>
<span class="cm"> * @size: maxinum size of binary attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">queue_status</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;queue_status&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0444</span><span class="p">},</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">sep_sysfs_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span>
		<span class="o">+</span> <span class="p">(</span><span class="n">SEP_DOUBLEBUF_USERS_LIMIT</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_queue_data</span><span class="p">)),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sep_register_driver_with_fs - register misc devices</span>
<span class="cm"> * @sep: pointer to struct sep_device</span>
<span class="cm"> *</span>
<span class="cm"> * This function registers the driver with the file system</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_register_driver_with_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">miscdev_sep</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">miscdev_sep</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">SEP_DEV_NAME</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">miscdev_sep</span><span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sep_file_operations</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">miscdev_sep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;misc reg fails for SEP %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret_val</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">device_create_bin_file</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">miscdev_sep</span><span class="p">.</span><span class="n">this_device</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">queue_status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sysfs attribute1 fails for SEP %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret_val</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *sep_probe - probe a matching PCI device</span>
<span class="cm"> *@pdev:	pci_device</span>
<span class="cm"> *@ent:	pci_device_id</span>
<span class="cm"> *</span>
<span class="cm"> *Attempt to set up and configure a SEP device that has been</span>
<span class="cm"> *discovered by the PCI layer. Allocates all required resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sep_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;only one SEP supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable the device */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error enabling pci device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate the sep_device structure for this device */</span>
	<span class="n">sep_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sep_device</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;can&#39;t kmalloc the sep_device structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re going to use another variable for actually</span>
<span class="cm">	 * working with the device; this way, if we have</span>
<span class="cm">	 * multiple devices in the future, it would be easier</span>
<span class="cm">	 * to make appropriate changes</span>
<span class="cm">	 */</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_dev_get</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_transactions</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">event_interrupt</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">snd_rply_lck</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_lock</span><span class="p">);</span>
	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_doublebuf</span><span class="p">,</span> <span class="n">SEP_DOUBLEBUF_USERS_LIMIT</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">sep_queue_status</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sep probe: PCI obtained, &quot;</span>
		<span class="s">&quot;device being prepared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Set up our register area */</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error getting register start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_free_sep_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_end</span> <span class="o">=</span> <span class="n">pci_resource_end</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error getting register end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_free_sep_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_addr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_addr</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_end</span> <span class="o">-</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error getting register virtual</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_function_free_sep_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Register area start %llx end %llx virtual %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_addr</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_physical_end</span><span class="p">,</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_addr</span><span class="p">);</span>

	<span class="cm">/* Allocate the shared area */</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">shared_size</span> <span class="o">=</span> <span class="n">SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES</span> <span class="o">+</span>
		<span class="n">SYNCHRONIC_DMA_TABLES_AREA_SIZE_BYTES</span> <span class="o">+</span>
		<span class="n">SEP_DRIVER_DATA_POOL_SHARED_AREA_SIZE_IN_BYTES</span> <span class="o">+</span>
		<span class="n">SEP_DRIVER_STATIC_AREA_SIZE_IN_BYTES</span> <span class="o">+</span>
		<span class="n">SEP_DRIVER_SYSTEM_DATA_MEMORY_SIZE_IN_BYTES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep_map_and_alloc_shared_area</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="cm">/* Allocation failed */</span>
		<span class="k">goto</span> <span class="n">end_function_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear ICR register */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_ICR_REG_ADDR</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="cm">/* Set the IMR register - open only GPR 2 */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_IMR_REG_ADDR</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)));</span>

	<span class="cm">/* Read send/receive counters from SEP */</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR2_REG_ADDR</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span> <span class="o">&amp;=</span> <span class="mh">0x3FFFFFFF</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">;</span>

	<span class="cm">/* Get the interrupt line */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sep_inthandler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
		<span class="s">&quot;sep_driver&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_function_deallocate_sep_shared_area</span><span class="p">;</span>

	<span class="cm">/* The new chip requires a shared area reconfigure */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_reconfig_shared_area</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_function_free_irq</span><span class="p">;</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Finally magic up the device nodes */</span>
	<span class="cm">/* Register driver with the fs */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_register_driver_with_fs</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error registering dev file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* through touching the device */</span>
<span class="cp">#ifdef SEP_ENABLE_RUNTIME_PM</span>
	<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_allow</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_autosuspend_delay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">SUSPEND_DELAY</span><span class="p">);</span>
	<span class="n">pm_runtime_use_autosuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_mark_last_busy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">power_save_setup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* register kernel crypto driver */</span>
<span class="cp">#if defined(CONFIG_CRYPTO) || defined(CONFIG_CRYPTO_MODULE)</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sep_crypto_setup</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;crypto setup failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_function_free_irq</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">goto</span> <span class="n">end_function</span><span class="p">;</span>

<span class="nl">end_function_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>

<span class="nl">end_function_deallocate_sep_shared_area:</span>
	<span class="cm">/* De-allocate shared area */</span>
	<span class="n">sep_unmap_and_free_shared_area</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

<span class="nl">end_function_error:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">reg_addr</span><span class="p">);</span>

<span class="nl">end_function_free_sep_dev:</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
	<span class="n">sep_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">end_function_disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">end_function:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_remove -	handles removing device from pci subsystem</span>
<span class="cm"> * @pdev:	pointer to pci device</span>
<span class="cm"> *</span>
<span class="cm"> * This function will handle removing our sep device from pci subsystem on exit</span>
<span class="cm"> * or unloading this module. It should free up all used resources, and unmap if</span>
<span class="cm"> * any memory regions mapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sep_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="cm">/* Unregister from fs */</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">miscdev_sep</span><span class="p">);</span>

	<span class="cm">/* Unregister from kernel crypto */</span>
<span class="cp">#if defined(CONFIG_CRYPTO) || defined(CONFIG_CRYPTO_MODULE)</span>
	<span class="n">sep_crypto_takedown</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="cm">/* Free the irq */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>

	<span class="cm">/* Free the shared area  */</span>
	<span class="n">sep_unmap_and_free_shared_area</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">reg_addr</span><span class="p">);</span>

<span class="cp">#ifdef SEP_ENABLE_RUNTIME_PM</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pm_runtime_forbid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">sep_dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sep_dev</span><span class="p">);</span>
	<span class="n">sep_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize struct pci_device_id for our driver */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">sep_pci_id_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0826</span><span class="p">)},</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x08e9</span><span class="p">)},</span>
 	<span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Export our pci_device_id structure to user space */</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">sep_pci_id_tbl</span><span class="p">);</span>

<span class="cp">#ifdef SEP_ENABLE_RUNTIME_PM</span>

<span class="cm">/**</span>
<span class="cm"> * sep_pm_resume - rsume routine while waking up from S3 state</span>
<span class="cm"> * @dev:	pointer to sep device</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to be used to wake up sep driver while system awakes from S3</span>
<span class="cm"> * state i.e. suspend to ram. The RAM in intact.</span>
<span class="cm"> * Notes - revisit with more understanding of pm, ICR/IMR &amp; counters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci resume called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">power_state</span> <span class="o">==</span> <span class="n">SEP_DRIVER_POWERON</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear ICR register */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_ICR_REG_ADDR</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="cm">/* Set the IMR register - open only GPR 2 */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_IMR_REG_ADDR</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)));</span>

	<span class="cm">/* Read send/receive counters from SEP */</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR2_REG_ADDR</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span> <span class="o">&amp;=</span> <span class="mh">0x3FFFFFFF</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">;</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">SEP_DRIVER_POWERON</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_pm_suspend - suspend routine while going to S3 state</span>
<span class="cm"> * @dev:	pointer to sep device</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to be used to suspend sep driver while system goes to S3</span>
<span class="cm"> * state i.e. suspend to ram. The RAM in intact and ON during this suspend.</span>
<span class="cm"> * Notes - revisit with more understanding of pm, ICR/IMR</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci suspend called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">SEP_DRIVER_POWEROFF</span><span class="p">;</span>

	<span class="cm">/* Clear ICR register */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_ICR_REG_ADDR</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="cm">/* Set the IMR to block all */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_IMR_REG_ADDR</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_pm_runtime_resume - runtime resume routine</span>
<span class="cm"> * @dev:	pointer to sep device</span>
<span class="cm"> *</span>
<span class="cm"> * Notes - revisit with more understanding of pm, ICR/IMR &amp; counters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_pm_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">u32</span> <span class="n">retval2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delay_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pm runtime resume called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * Wait until the SCU boot is ready</span>
<span class="cm">	 * This is done by iterating SCU_DELAY_ITERATION (10</span>
<span class="cm">	 * microseconds each) up to SCU_DELAY_MAX (50) times.</span>
<span class="cm">	 * This bit can be set in a random time that is less</span>
<span class="cm">	 * than 500 microseconds after each power resume</span>
<span class="cm">	 */</span>
	<span class="n">retval2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="n">retval2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">delay_count</span> <span class="o">&lt;</span> <span class="n">SCU_DELAY_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval2</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR3_REG_ADDR</span><span class="p">);</span>
		<span class="n">retval2</span> <span class="o">&amp;=</span> <span class="mh">0x00000008</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">SCU_DELAY_ITERATION</span><span class="p">);</span>
			<span class="n">delay_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;scu boot bit not set at resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear ICR register */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_ICR_REG_ADDR</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="cm">/* Set the IMR register - open only GPR 2 */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_IMR_REG_ADDR</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)));</span>

	<span class="cm">/* Read send/receive counters from SEP */</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span> <span class="o">=</span> <span class="n">sep_read_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_SEP_HOST_GPR2_REG_ADDR</span><span class="p">);</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span> <span class="o">&amp;=</span> <span class="mh">0x3FFFFFFF</span><span class="p">;</span>
	<span class="n">sep</span><span class="o">-&gt;</span><span class="n">send_ct</span> <span class="o">=</span> <span class="n">sep</span><span class="o">-&gt;</span><span class="n">reply_ct</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_pm_runtime_suspend - runtime suspend routine</span>
<span class="cm"> * @dev:	pointer to sep device</span>
<span class="cm"> *</span>
<span class="cm"> * Notes - revisit with more understanding of pm</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sep_pm_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sep_device</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="n">sep_dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pm runtime suspend called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear ICR register */</span>
	<span class="n">sep_write_reg</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">HW_HOST_ICR_REG_ADDR</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sep_pm - power management for sep driver</span>
<span class="cm"> * @sep_pm_runtime_resume:	resume- no communication with cpu &amp; main memory</span>
<span class="cm"> * @sep_pm_runtime_suspend:	suspend- no communication with cpu &amp; main memory</span>
<span class="cm"> * @sep_pci_suspend:		suspend - main memory is still ON</span>
<span class="cm"> * @sep_pci_resume:		resume - main memory is still ON</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">sep_pm</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">runtime_resume</span> <span class="o">=</span> <span class="n">sep_pm_runtime_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_suspend</span> <span class="o">=</span> <span class="n">sep_pm_runtime_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">sep_pci_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">sep_pci_suspend</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* SEP_ENABLE_RUNTIME_PM */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * sep_pci_driver - registers this device with pci subsystem</span>
<span class="cm"> * @name:	name identifier for this driver</span>
<span class="cm"> * @sep_pci_id_tbl:	pointer to struct pci_device_id table</span>
<span class="cm"> * @sep_probe:	pointer to probe function in PCI driver</span>
<span class="cm"> * @sep_remove:	pointer to remove function in PCI driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">sep_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef SEP_ENABLE_RUNTIME_PM</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sep_pm</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;sep_sec_driver&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">sep_pci_id_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">sep_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">sep_remove</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sep_init - init function</span>
<span class="cm"> *</span>
<span class="cm"> * Module load time. Register the PCI device driver.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sep_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_pci_driver</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sep_exit - called to unload driver</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister the driver The device will perform all the cleanup required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">sep_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sep_pci_driver</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">sep_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">sep_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
