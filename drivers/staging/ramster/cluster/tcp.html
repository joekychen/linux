<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › ramster › cluster › tcp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tcp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> *</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * ----</span>
<span class="cm"> *</span>
<span class="cm"> * Callers for this were originally written against a very simple synchronus</span>
<span class="cm"> * API.  This implementation reflects those simple callers.  Some day I&#39;m sure</span>
<span class="cm"> * we&#39;ll need to move to a more robust posting/callback mechanism.</span>
<span class="cm"> *</span>
<span class="cm"> * Transmit calls pass in kernel virtual addresses and block copying this into</span>
<span class="cm"> * the socket&#39;s tx buffers via a usual blocking sendmsg.  They&#39;ll block waiting</span>
<span class="cm"> * for a failed socket to timeout.  TX callers can also pass in a poniter to an</span>
<span class="cm"> * &#39;int&#39; which gets filled with an errno off the wire in response to the</span>
<span class="cm"> * message they send.</span>
<span class="cm"> *</span>
<span class="cm"> * Handlers for unsolicited messages are registered.  Each socket has a page</span>
<span class="cm"> * that incoming data is copied into.  First the header, then the data.</span>
<span class="cm"> * Handlers are called from only one thread with a reference to this per-socket</span>
<span class="cm"> * page.  This page is destroyed after the handler call, so it can&#39;t be</span>
<span class="cm"> * referenced beyond the call.  Handlers may block but are discouraged from</span>
<span class="cm"> * doing so.</span>
<span class="cm"> *</span>
<span class="cm"> * Any framing errors (bad magic, large payload lengths) close a connection.</span>
<span class="cm"> *</span>
<span class="cm"> * Our sock_container holds the state we associate with a socket.  It&#39;s current</span>
<span class="cm"> * framing state is held there as well as the refcounting we do around when it</span>
<span class="cm"> * is safe to tear down the socket.  The socket is only finally torn down from</span>
<span class="cm"> * the container when the container loses all of its references -- so as long</span>
<span class="cm"> * as you hold a ref on the container you can trust that the socket is valid</span>
<span class="cm"> * for use with kernel socket APIs.</span>
<span class="cm"> *</span>
<span class="cm"> * Connections are initiated between a pair of nodes when the node with the</span>
<span class="cm"> * higher node number gets a heartbeat callback which indicates that the lower</span>
<span class="cm"> * numbered node has started heartbeating.  The lower numbered node is passive</span>
<span class="cm"> * and only accepts the connection if the higher numbered node is heartbeating.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>


<span class="cp">#include &quot;heartbeat.h&quot;</span>
<span class="cp">#include &quot;tcp.h&quot;</span>
<span class="cp">#include &quot;nodemanager.h&quot;</span>
<span class="cp">#define MLOG_MASK_PREFIX ML_TCP</span>
<span class="cp">#include &quot;masklog.h&quot;</span>

<span class="cp">#include &quot;tcp_internal.h&quot;</span>

<span class="cp">#define SC_NODEF_FMT &quot;node %s (num %u) at %pI4:%u&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * In the following two log macros, the whitespace after the &#39;,&#39; just</span>
<span class="cm"> * before ##args is intentional. Otherwise, gcc 2.95 will eat the</span>
<span class="cm"> * previous token if args expands to nothing.</span>
<span class="cm"> */</span>
<span class="cp">#define msglog(hdr, fmt, args...) do {					\</span>
<span class="cp">	typeof(hdr) __hdr = (hdr);					\</span>
<span class="cp">	mlog(ML_MSG, &quot;[mag %u len %u typ %u stat %d sys_stat %d &quot;	\</span>
<span class="cp">	     &quot;key %08x num %u] &quot; fmt,					\</span>
<span class="cp">	be16_to_cpu(__hdr-&gt;magic), be16_to_cpu(__hdr-&gt;data_len),	\</span>
<span class="cp">	     be16_to_cpu(__hdr-&gt;msg_type), be32_to_cpu(__hdr-&gt;status),	\</span>
<span class="cp">	     be32_to_cpu(__hdr-&gt;sys_status), be32_to_cpu(__hdr-&gt;key),	\</span>
<span class="cp">	     be32_to_cpu(__hdr-&gt;msg_num) ,  ##args);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define sclog(sc, fmt, args...) do {					\</span>
<span class="cp">	typeof(sc) __sc = (sc);						\</span>
<span class="cp">	mlog(ML_SOCKET, &quot;[sc %p refs %d sock %p node %u page %p &quot;	\</span>
<span class="cp">	     &quot;pg_off %zu] &quot; fmt, __sc,					\</span>
<span class="cp">	     atomic_read(&amp;__sc-&gt;sc_kref.refcount), __sc-&gt;sc_sock,	\</span>
<span class="cp">	    __sc-&gt;sc_node-&gt;nd_num, __sc-&gt;sc_page, __sc-&gt;sc_page_off ,	\</span>
<span class="cp">	    ##args);							\</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">r2net_handler_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">r2net_handler_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">r2net_node</span> <span class="n">r2net_nodes</span><span class="p">[</span><span class="n">R2NM_MAX_NODES</span><span class="p">];</span>

<span class="cm">/* XXX someday we&#39;ll need better accounting */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">r2net_listen_sock</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * listen work is only queued by the listening socket callbacks on the</span>
<span class="cm"> * r2net_wq.  teardown detaches the callbacks before destroying the workqueue.</span>
<span class="cm"> * quorum work is queued as sock containers are shutdown.. stop_listening</span>
<span class="cm"> * tears down all the node&#39;s sock containers, preventing future shutdowns</span>
<span class="cm"> * and queued quorum work, before canceling delayed quorum work and</span>
<span class="cm"> * destroying the work queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">r2net_wq</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="n">r2net_listen_work</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">r2hb_callback_func</span> <span class="n">r2net_hb_up</span><span class="p">,</span> <span class="n">r2net_hb_down</span><span class="p">;</span>
<span class="cp">#define R2NET_HB_PRI 0x1</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">r2net_handshake</span> <span class="o">*</span><span class="n">r2net_hand</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">r2net_keep_req</span><span class="p">,</span> <span class="o">*</span><span class="n">r2net_keep_resp</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">r2net_sys_err_translations</span><span class="p">[</span><span class="n">R2NET_ERR_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">R2NET_ERR_NONE</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">[</span><span class="n">R2NET_ERR_NO_HNDLR</span><span class="p">]</span>	<span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">,</span>
		<span class="p">[</span><span class="n">R2NET_ERR_OVERFLOW</span><span class="p">]</span>	<span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">,</span>
		<span class="p">[</span><span class="n">R2NET_ERR_DIED</span><span class="p">]</span>	<span class="o">=</span> <span class="o">-</span><span class="n">EHOSTDOWN</span><span class="p">,};</span>

<span class="cm">/* can&#39;t quite avoid *all* internal declarations :/ */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_sc_connect_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_rx_until_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_shutdown_sc</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_listen_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_sc_send_keep_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_idle_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_sc_postpone_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">r2net_sc_reset_idle_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_init_nst</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="o">*</span><span class="n">nst</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msgtype</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">msgkey</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_net_debug_item</span><span class="p">);</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_msg_type</span> <span class="o">=</span> <span class="n">msgtype</span><span class="p">;</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_msg_key</span> <span class="o">=</span> <span class="n">msgkey</span><span class="p">;</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_nst_sock_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="o">*</span><span class="n">nst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_sock_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_nst_send_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="o">*</span><span class="n">nst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_send_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_nst_status_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="o">*</span><span class="n">nst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_status_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_nst_sock_container</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="o">*</span><span class="n">nst</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_sc</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_nst_msg_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="o">*</span><span class="n">nst</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">msg_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_id</span> <span class="o">=</span> <span class="n">msg_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_sock_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_timer</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_data_ready_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_data_ready</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_advance_start_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_advance_start</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_advance_stop_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_advance_stop</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_func_start_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_func_start</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">r2net_set_func_stop_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_func_stop</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else  </span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>
<span class="cp"># define r2net_init_nst(a, b, c, d, e)</span>
<span class="cp"># define r2net_set_nst_sock_time(a)</span>
<span class="cp"># define r2net_set_nst_send_time(a)</span>
<span class="cp"># define r2net_set_nst_status_time(a)</span>
<span class="cp"># define r2net_set_nst_sock_container(a, b)</span>
<span class="cp"># define r2net_set_nst_msg_id(a, b)</span>
<span class="cp"># define r2net_set_sock_timer(a)</span>
<span class="cp"># define r2net_set_data_ready_time(a)</span>
<span class="cp"># define r2net_set_advance_start_time(a)</span>
<span class="cp"># define r2net_set_advance_stop_time(a)</span>
<span class="cp"># define r2net_set_func_start_time(a)</span>
<span class="cp"># define r2net_set_func_stop_time(a)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_RAMSTER_FS_STATS</span>
<span class="k">static</span> <span class="n">ktime_t</span> <span class="nf">r2net_get_func_run_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_func_stop</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_func_start</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_update_send_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="o">*</span><span class="n">nst</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_status_total</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_status_total</span><span class="p">,</span>
					   <span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span>
						     <span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_status_time</span><span class="p">));</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_send_total</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_send_total</span><span class="p">,</span>
					 <span class="n">ktime_sub</span><span class="p">(</span><span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_status_time</span><span class="p">,</span>
						   <span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_send_time</span><span class="p">));</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_acquiry_total</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_acquiry_total</span><span class="p">,</span>
					    <span class="n">ktime_sub</span><span class="p">(</span><span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_send_time</span><span class="p">,</span>
						      <span class="n">nst</span><span class="o">-&gt;</span><span class="n">st_sock_time</span><span class="p">));</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_update_recv_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_process_total</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_process_total</span><span class="p">,</span>
					    <span class="n">r2net_get_func_run_time</span><span class="p">(</span><span class="n">sc</span><span class="p">));</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_recv_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp"># define r2net_update_send_stats(a, b)</span>

<span class="cp"># define r2net_update_recv_stats(sc)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_RAMSTER_FS_STATS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">r2net_reconnect_delay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">r2nm_single_cluster</span><span class="o">-&gt;</span><span class="n">cl_reconnect_delay_ms</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">r2net_keepalive_delay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">r2nm_single_cluster</span><span class="o">-&gt;</span><span class="n">cl_keepalive_delay_ms</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">r2net_idle_timeout</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">r2nm_single_cluster</span><span class="o">-&gt;</span><span class="n">cl_idle_timeout_ms</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">r2net_sys_err_to_errno</span><span class="p">(</span><span class="k">enum</span> <span class="n">r2net_system_error</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">trans</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="n">R2NET_ERR_MAX</span><span class="p">);</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">r2net_sys_err_translations</span><span class="p">[</span><span class="n">err</span><span class="p">];</span>

	<span class="cm">/* Just in case we mess up the translation table above */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">R2NET_ERR_NONE</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">trans</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="nf">r2net_nn_from_num</span><span class="p">(</span><span class="n">u8</span> <span class="n">node_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node_num</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">r2net_nodes</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">r2net_nodes</span><span class="p">[</span><span class="n">node_num</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">r2net_num_from_nn</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nn</span> <span class="o">-</span> <span class="n">r2net_nodes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_prep_nsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_status_wait</span> <span class="o">*</span><span class="n">nsw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_idr</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_idr</span><span class="p">,</span> <span class="n">nsw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_node_item</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_wq</span><span class="p">);</span>
		<span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_sys_status</span> <span class="o">=</span> <span class="n">R2NET_ERR_NONE</span><span class="p">;</span>
		<span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_complete_nsw_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">r2net_status_wait</span> <span class="o">*</span><span class="n">nsw</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">r2net_system_error</span> <span class="n">sys_status</span><span class="p">,</span>
				      <span class="n">s32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_node_item</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_node_item</span><span class="p">);</span>
		<span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_sys_status</span> <span class="o">=</span> <span class="n">sys_status</span><span class="p">;</span>
		<span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_idr</span><span class="p">,</span> <span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_id</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_wq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_complete_nsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">r2net_status_wait</span> <span class="o">*</span><span class="n">nsw</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">id</span><span class="p">,</span> <span class="k">enum</span> <span class="n">r2net_system_error</span> <span class="n">sys_status</span><span class="p">,</span>
			       <span class="n">s32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">nsw</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r2net_complete_nsw_locked</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">nsw</span><span class="p">,</span> <span class="n">sys_status</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_complete_nodes_nsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_status_wait</span> <span class="o">*</span><span class="n">nsw</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_kills</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">nsw</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_list</span><span class="p">,</span> <span class="n">ns_node_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r2net_complete_nsw_locked</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">nsw</span><span class="p">,</span> <span class="n">R2NET_ERR_DIED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">num_kills</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;completed %d messages for node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_kills</span><span class="p">,</span>
	     <span class="n">r2net_num_from_nn</span><span class="p">(</span><span class="n">nn</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_nsw_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">r2net_status_wait</span> <span class="o">*</span><span class="n">nsw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">completed</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="n">completed</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsw</span><span class="o">-&gt;</span><span class="n">ns_node_item</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">completed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sc_kref_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">r2net_sock_container</span><span class="p">,</span> <span class="n">sc_kref</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_idle_timeout</span><span class="p">));</span>

	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;releasing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">);</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r2nm_undepend_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_item</span><span class="p">);</span>
	<span class="n">r2nm_node_put</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">r2net_debug_del_sc</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;put</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_kref</span><span class="p">,</span> <span class="n">sc_kref_release</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;get</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_kref</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="nf">sc_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sc</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_kref</span><span class="p">);</span>
	<span class="n">r2nm_node_get</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* pin the node item of the remote node */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">r2nm_depend_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
		<span class="n">r2nm_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_connect_work</span><span class="p">,</span> <span class="n">r2net_sc_connect_completed</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_rx_work</span><span class="p">,</span> <span class="n">r2net_rx_until_empty</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_shutdown_work</span><span class="p">,</span> <span class="n">r2net_shutdown_sc</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_keepalive_work</span><span class="p">,</span> <span class="n">r2net_sc_send_keep_req</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_idle_timeout</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_idle_timeout</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">r2net_idle_timer</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_idle_timeout</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sc</span><span class="p">;</span>

	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;alloced</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">r2net_debug_add_sc</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sc_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc_get</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_work</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">,</span> <span class="n">work</span><span class="p">))</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sc_queue_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sc_get</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">delay</span><span class="p">))</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sc_cancel_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="n">work</span><span class="p">))</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">r2net_connected_peers</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">r2net_num_connected_peers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_connected_peers</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_set_nn_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="n">valid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">was_valid</span> <span class="o">=</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_valid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_err</span> <span class="o">=</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">old_sc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_sc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sc</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_connected_peers</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_sc</span> <span class="o">&amp;&amp;</span> <span class="n">sc</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_connected_peers</span><span class="p">);</span>

	<span class="cm">/* the node num comparison and single connect/accept path should stop</span>
<span class="cm">	 * an non-null sc from being overwritten with another */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sc</span> <span class="o">&amp;&amp;</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span> <span class="o">&amp;&amp;</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span> <span class="o">!=</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">mlog_bug_on_msg</span><span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">valid</span><span class="p">,</span> <span class="s">&quot;err %d valid %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">valid</span><span class="p">);</span>
	<span class="n">mlog_bug_on_msg</span><span class="p">(</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;valid %u sc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_CONN</span><span class="p">,</span> <span class="s">&quot;node %u sc: %p -&gt; %p, valid %u -&gt; %u, err %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">r2net_num_from_nn</span><span class="p">(</span><span class="n">nn</span><span class="p">),</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_valid</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span>
	     <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>
	<span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* mirrors r2net_tx_can_proceed() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span> <span class="o">||</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_valid</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_err</span> <span class="o">&amp;&amp;</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_still_up</span><span class="p">,</span>
				   <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">R2NET_QUORUM_DELAY_MS</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: No longer connected to &quot;</span>
		       <span class="n">SC_NODEF_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">old_sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span> <span class="n">old_sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">old_sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">old_sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">));</span>
		<span class="n">r2net_complete_nodes_nsw</span><span class="p">(</span><span class="n">nn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_valid</span> <span class="o">&amp;&amp;</span> <span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_connect_expired</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: %s &quot;</span> <span class="n">SC_NODEF_FMT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">r2nm_this_node</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span> <span class="o">?</span>
		       <span class="s">&quot;Connected to&quot;</span> <span class="o">:</span> <span class="s">&quot;Accepted connection from&quot;</span><span class="p">,</span>
		       <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* trigger the connecting worker func as long as we&#39;re not valid,</span>
<span class="cm">	 * it will back off if it shouldn&#39;t connect.  This can be called</span>
<span class="cm">	 * from node config teardown and so needs to be careful about</span>
<span class="cm">	 * the work queue actually being up. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">r2net_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">;</span>
		<span class="cm">/* delay if we&#39;re within a RECONNECT_DELAY of the</span>
<span class="cm">		 * last attempt */</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_last_connect_attempt</span> <span class="o">+</span>
			 <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">r2net_reconnect_delay</span><span class="p">()))</span>
			<span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">&gt;</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">r2net_reconnect_delay</span><span class="p">()))</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_CONN</span><span class="p">,</span> <span class="s">&quot;queueing conn attempt in %lu jiffies</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_connect_work</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Delay the expired work after idle timeout.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We might have lots of failed connection attempts that run</span>
<span class="cm">		 * through here but we only cancel the connect_expired work when</span>
<span class="cm">		 * a connection attempt succeeds.  So only the first enqueue of</span>
<span class="cm">		 * the connect_expired work will do anything.  The rest will see</span>
<span class="cm">		 * that it&#39;s already queued and do nothing.</span>
<span class="cm">		 */</span>
		<span class="n">delay</span> <span class="o">+=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">r2net_idle_timeout</span><span class="p">());</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_connect_expired</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* keep track of the nn&#39;s sc ref for the caller */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">old_sc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sc</span><span class="p">)</span>
		<span class="n">sc_get</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_sc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">old_sc</span> <span class="o">!=</span> <span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r2net_sc_queue_work</span><span class="p">(</span><span class="n">old_sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_sc</span><span class="o">-&gt;</span><span class="n">sc_shutdown_work</span><span class="p">);</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">old_sc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* see r2net_register_callbacks() */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span><span class="p">;</span>
		<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;data_ready hit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">r2net_set_data_ready_time</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">r2net_sc_queue_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_rx_work</span><span class="p">);</span>
		<span class="n">ready</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_ready</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ready</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="n">ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* see r2net_register_callbacks() */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">state_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">state_change</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;state_change to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">);</span>

	<span class="n">state_change</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_state_change</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* ignore connecting sockets as they make progress */</span>
	<span class="k">case</span> <span class="n">TCP_SYN_SENT</span>:
	<span class="k">case</span> <span class="n">TCP_SYN_RECV</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_ESTABLISHED</span>:
		<span class="n">r2net_sc_queue_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_connect_work</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ramster: Connection to &quot;</span>
			<span class="n">SC_NODEF_FMT</span> <span class="s">&quot; shutdown, state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">);</span>
		<span class="n">r2net_sc_queue_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_shutdown_work</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * we register callbacks so we can queue work on events before calling</span>
<span class="cm"> * the original callbacks.  our callbacks are careful to test user_data</span>
<span class="cm"> * to discover when they&#39;ve reaced with r2net_unregister_callbacks().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_register_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="cm">/* accepted sockets inherit the old listen socket data ready */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">==</span> <span class="n">r2net_listen_data_ready</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>
	<span class="n">sc_get</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_ready</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_state_change</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">r2net_data_ready</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span> <span class="o">=</span> <span class="n">r2net_state_change</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_lock</span><span class="p">);</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_unregister_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">==</span> <span class="n">sc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_ready</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_state_change</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is a little helper that is called by callers who have seen a problem</span>
<span class="cm"> * with an sc and want to detach it from the nn if someone already hasn&#39;t beat</span>
<span class="cm"> * them to it.  if an error is given then the shutdown will be persistent</span>
<span class="cm"> * and pending transmits will be canceled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_ensure_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span> <span class="o">==</span> <span class="n">sc</span><span class="p">)</span>
		<span class="n">r2net_set_nn_state</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This work queue function performs the blocking parts of socket shutdown.  A</span>
<span class="cm"> * few paths lead here.  set_nn_state will trigger this callback if it sees an</span>
<span class="cm"> * sc detached from the nn.  state_change will also trigger this callback</span>
<span class="cm"> * directly when it sees errors.  In that case we need to call set_nn_state</span>
<span class="cm"> * ourselves as state_change couldn&#39;t get the nn_lock and call set_nn_state</span>
<span class="cm"> * itself.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_shutdown_sc</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_sock_container</span><span class="p">,</span>
			     <span class="n">sc_shutdown_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">);</span>

	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;shutting down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* drop the callbacks ref and call shutdown only once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r2net_unregister_callbacks</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we shouldn&#39;t flush as we&#39;re in the thread, the</span>
<span class="cm">		 * races with pending sc work structs are harmless */</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_idle_timeout</span><span class="p">);</span>
		<span class="n">r2net_sc_cancel_delayed_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_keepalive_work</span><span class="p">);</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">kernel_sock_shutdown</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span> <span class="n">SHUT_RDWR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* not fatal so failed connects before the other guy has our</span>
<span class="cm">	 * heartbeat can be retried */</span>
	<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_handler_cmp</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msg_type</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_msg_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg_type</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span>
<span class="nf">r2net_handler_tree_lookup</span><span class="p">(</span><span class="n">u32</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">***</span><span class="n">ret_p</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">ret_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r2net_handler_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">nmh</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_msg_handler</span><span class="p">,</span> <span class="n">nh_node</span><span class="p">);</span>
		<span class="n">cmp</span> <span class="o">=</span> <span class="n">r2net_handler_cmp</span><span class="p">(</span><span class="n">nmh</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">nmh</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ret_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ret_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_handler_kref_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span><span class="p">;</span>
	<span class="n">nmh</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_msg_handler</span><span class="p">,</span> <span class="n">nh_kref</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">nmh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_handler_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_kref</span><span class="p">,</span> <span class="n">r2net_handler_kref_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* max_len is protection for the handler func.  incoming messages won&#39;t</span>
<span class="cm"> * be given to the handler if their payload is longer than the max. */</span>
<span class="kt">int</span> <span class="nf">r2net_register_handler</span><span class="p">(</span><span class="n">u32</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_len</span><span class="p">,</span>
			   <span class="n">r2net_msg_handler_func</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="n">r2net_post_msg_handler_func</span> <span class="o">*</span><span class="n">post_func</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">unreg_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">&gt;</span> <span class="n">R2NET_MAX_PAYLOAD_BYTES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;max_len for message handler out of range: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">max_len</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;no message type provided: %u, %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;no message handler provided: %u, %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">msg_type</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nmh</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg_handler</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_func_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_post_func</span> <span class="o">=</span> <span class="n">post_func</span><span class="p">;</span>
	<span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_msg_type</span> <span class="o">=</span> <span class="n">msg_type</span><span class="p">;</span>
	<span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_max_len</span> <span class="o">=</span> <span class="n">max_len</span><span class="p">;</span>
	<span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="cm">/* the tree and list get this ref.. they&#39;re both removed in</span>
<span class="cm">	 * unregister when this ref is dropped */</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_kref</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_unregister_item</span><span class="p">);</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_handler_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r2net_handler_tree_lookup</span><span class="p">(</span><span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2net_handler_tree</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_unregister_item</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">);</span>

		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_TCP</span><span class="p">,</span> <span class="s">&quot;registered handler func %p type %u key %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">func</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="cm">/* we&#39;ve had some trouble with handlers seemingly vanishing. */</span>
		<span class="n">mlog_bug_on_msg</span><span class="p">(</span><span class="n">r2net_handler_tree_lookup</span><span class="p">(</span><span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="s">&quot;couldn&#39;t find handler we *just* registered &quot;</span>
				<span class="s">&quot;for type %u key %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_handler_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nmh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">r2net_register_handler</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">r2net_unregister_handler_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_handler_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">nmh</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">nh_unregister_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_TCP</span><span class="p">,</span> <span class="s">&quot;unregistering handler func %p type %u key %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_func</span><span class="p">,</span> <span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_msg_type</span><span class="p">,</span> <span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_key</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2net_handler_tree</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_unregister_item</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_kref</span><span class="p">,</span> <span class="n">r2net_handler_kref_release</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_handler_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">r2net_unregister_handler_list</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="nf">r2net_handler_get</span><span class="p">(</span><span class="n">u32</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_handler_lock</span><span class="p">);</span>
	<span class="n">nmh</span> <span class="o">=</span> <span class="n">r2net_handler_tree_lookup</span><span class="p">(</span><span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmh</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_kref</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_handler_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nmh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_recv_tcp_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span>
		<span class="p">.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">get_ds</span><span class="p">());</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_recvmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">msg_flags</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_send_tcp_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">veclen</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="p">,</span>
		<span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="n">veclen</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">get_ds</span><span class="p">());</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">total</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;sendmsg returned %d instead of %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		     <span class="n">total</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span> <span class="cm">/* should be smarter, I bet */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;returning error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">kmalloced_virt</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sendpage</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span>
					<span class="n">virt_to_page</span><span class="p">(</span><span class="n">kmalloced_virt</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">kmalloced_virt</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span>
					<span class="n">size</span><span class="p">,</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;sendpage of size %zu to &quot;</span> <span class="n">SC_NODEF_FMT</span>
			     <span class="s">&quot; returned EAGAIN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
				<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
				<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">));</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;sendpage of size %zu to &quot;</span> <span class="n">SC_NODEF_FMT</span>
		     <span class="s">&quot; failed with %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_init_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data_len</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">));</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">R2NET_MSG_MAGIC</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">msg_type</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">sys_status</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">R2NET_ERR_NONE</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_tx_can_proceed</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">**</span><span class="n">sc_ret</span><span class="p">,</span>
				<span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">sc_ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span><span class="o">-&gt;</span><span class="n">sc_kref</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">sc_ret</span> <span class="o">=</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span><span class="p">;</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get a map of all nodes to which this node is currently connected to */</span>
<span class="kt">void</span> <span class="nf">r2net_fill_node_map</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">R2NM_MAX_NODES</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)));</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">R2NM_MAX_NODES</span><span class="p">;</span> <span class="o">++</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r2net_tx_can_proceed</span><span class="p">(</span><span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
			<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">r2net_fill_node_map</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">r2net_send_message_vec</span><span class="p">(</span><span class="n">u32</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">caller_vec</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">caller_veclen</span><span class="p">,</span> <span class="n">u8</span> <span class="n">target_node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">veclen</span><span class="p">,</span> <span class="n">caller_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">target_node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">r2net_status_wait</span> <span class="n">nsw</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ns_node_item</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">nsw</span><span class="p">.</span><span class="n">ns_node_item</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="n">nst</span><span class="p">;</span>

	<span class="cm">/* this may be a general bug fix */</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsw</span><span class="p">.</span><span class="n">ns_wq</span><span class="p">);</span>

	<span class="n">r2net_init_nst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">target_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r2net_wq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;attempt to tx without r2netd running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">caller_veclen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;bad kvec array length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">caller_bytes</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">((</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">caller_vec</span><span class="p">,</span> <span class="n">caller_veclen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">caller_bytes</span> <span class="o">&gt;</span> <span class="n">R2NET_MAX_PAYLOAD_BYTES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;total payload len %zu too large</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">caller_bytes</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target_node</span> <span class="o">==</span> <span class="n">r2nm_this_node</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r2net_debug_add_nst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">);</span>

	<span class="n">r2net_set_nst_sock_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">);</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_wq</span><span class="p">,</span> <span class="n">r2net_tx_can_proceed</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">r2net_set_nst_sock_container</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="n">veclen</span> <span class="o">=</span> <span class="n">caller_veclen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vec</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span><span class="p">)</span> <span class="o">*</span> <span class="n">veclen</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;failed to %zu element kvec!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">veclen</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;failed to allocate a r2net_msg!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r2net_init_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">caller_bytes</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">);</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">caller_vec</span><span class="p">,</span> <span class="n">caller_veclen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_prep_nsw</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nsw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_num</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">nsw</span><span class="p">.</span><span class="n">ns_id</span><span class="p">);</span>
	<span class="n">r2net_set_nst_msg_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">,</span> <span class="n">nsw</span><span class="p">.</span><span class="n">ns_id</span><span class="p">);</span>

	<span class="n">r2net_set_nst_send_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">);</span>

	<span class="cm">/* finally, convert the message header to network byte-order</span>
<span class="cm">	 * and send */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_send_tcp_msg</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">veclen</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">caller_bytes</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_lock</span><span class="p">);</span>
	<span class="n">msglog</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;sending returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;error returned from r2net_send_tcp_msg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wait on other node&#39;s handler */</span>
	<span class="n">r2net_set_nst_status_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">);</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">nsw</span><span class="p">.</span><span class="n">ns_wq</span><span class="p">,</span> <span class="n">r2net_nsw_completed</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nsw</span><span class="p">));</span>

	<span class="n">r2net_update_send_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="cm">/* Note that we avoid overwriting the callers status return</span>
<span class="cm">	 * variable if a system error was reported on the other</span>
<span class="cm">	 * side. Callers beware. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_sys_err_to_errno</span><span class="p">(</span><span class="n">nsw</span><span class="p">.</span><span class="n">ns_sys_status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">nsw</span><span class="p">.</span><span class="n">ns_status</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;woken, returning system status %d, user status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ret</span><span class="p">,</span> <span class="n">nsw</span><span class="p">.</span><span class="n">ns_status</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">r2net_debug_del_nst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nst</span><span class="p">);</span> <span class="cm">/* must be before dropping sc and node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="p">)</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">r2net_complete_nsw</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nsw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">r2net_send_message_vec</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">r2net_send_message</span><span class="p">(</span><span class="n">u32</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span>
		       <span class="n">u8</span> <span class="n">target_node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
		<span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">r2net_send_message_vec</span><span class="p">(</span><span class="n">msg_type</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="n">target_node</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">r2net_send_message</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_send_status_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">r2net_system_error</span> <span class="n">syserr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">syserr</span> <span class="o">&gt;=</span> <span class="n">R2NET_ERR_MAX</span><span class="p">);</span>

	<span class="cm">/* leave other fields intact from the incoming message, msg_num</span>
<span class="cm">	 * in particular */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sys_status</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">syserr</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="cm">/* twiddle the magic */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">R2NET_MSG_STATUS_MAGIC</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">msglog</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&quot;about to send status magic %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="cm">/* hdr has been in host byteorder this whole time */</span>
	<span class="k">return</span> <span class="n">r2net_send_tcp_msg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;data magic&quot; is a long version of &quot;status magic&quot; where the message</span>
<span class="cm"> * payload actually contains data to be passed in reply to certain messages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_send_data_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">data_len</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">r2net_system_error</span> <span class="n">syserr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">);</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">syserr</span> <span class="o">&gt;=</span> <span class="n">R2NET_ERR_MAX</span><span class="p">);</span>

	<span class="cm">/* leave other fields intact from the incoming message, msg_num</span>
<span class="cm">	 * in particular */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sys_status</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">syserr</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">R2NET_MSG_DATA_MAGIC</span><span class="p">);</span>  <span class="cm">/* twiddle magic */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">data_len</span><span class="p">);</span>

	<span class="n">msglog</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&quot;about to send data magic %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="cm">/* hdr has been in host byteorder this whole time */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_send_tcp_msg</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called by a message handler to convert an otherwise normal reply</span>
<span class="cm"> * message into a &quot;data magic&quot; message</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">r2net_force_data_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">msgtype</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msgkey</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">R2NET_MSG_DATA_MAGIC</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">msgtype</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">msgkey</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this returns -errno if the header was unknown or too large, etc.</span>
<span class="cm"> * after this is called the buffer us reused for the next message */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_process_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">handler_status</span><span class="p">;</span>
	<span class="k">enum</span>  <span class="n">r2net_system_error</span> <span class="n">syserr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="o">*</span><span class="n">nmh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">msglog</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&quot;processing message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">r2net_sc_postpone_idle</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">))</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">R2NET_MSG_STATUS_MAGIC</span>:
		<span class="cm">/* special type for returning message status */</span>
		<span class="n">r2net_complete_nsw</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">msg_num</span><span class="p">),</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sys_status</span><span class="p">),</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R2NET_MSG_KEEP_REQ_MAGIC</span>:
		<span class="n">r2net_sendpage</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">r2net_keep_resp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">r2net_keep_resp</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R2NET_MSG_KEEP_RESP_MAGIC</span>:
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R2NET_MSG_MAGIC</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R2NET_MSG_DATA_MAGIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * unlike a normal status magic, a data magic DOES</span>
<span class="cm">		 * (MUST) have a handler, so the control flow is</span>
<span class="cm">		 * a little funky here as a result</span>
<span class="cm">		 */</span>
		<span class="n">data_magic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">msglog</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&quot;bad magic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* find a handler for it */</span>
	<span class="n">handler_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nmh</span> <span class="o">=</span> <span class="n">r2net_handler_get</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span><span class="p">),</span>
				<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nmh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_TCP</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t find handler for type %u key %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span><span class="p">),</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="n">syserr</span> <span class="o">=</span> <span class="n">R2NET_ERR_NO_HNDLR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_respond</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">syserr</span> <span class="o">=</span> <span class="n">R2NET_ERR_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_max_len</span><span class="p">)</span>
		<span class="n">syserr</span> <span class="o">=</span> <span class="n">R2NET_ERR_OVERFLOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">syserr</span> <span class="o">!=</span> <span class="n">R2NET_ERR_NONE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_respond</span><span class="p">;</span>

	<span class="n">r2net_set_func_start_time</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_msg_key</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_msg_type</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span><span class="p">);</span>
	<span class="n">handler_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_func</span><span class="p">)(</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">)</span> <span class="o">+</span>
					     <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">),</span>
					<span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_func_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_magic</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * handler handled data sent in reply to request</span>
<span class="cm">		 * so complete the transaction</span>
<span class="cm">		 */</span>
		<span class="n">r2net_complete_nsw</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">msg_num</span><span class="p">),</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sys_status</span><span class="p">),</span> <span class="n">handler_status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * handler changed magic to DATA_MAGIC to reply to request for data,</span>
<span class="cm">	 * implies ret_data points to data to return and handler_status</span>
<span class="cm">	 * is the number of bytes of data</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="o">==</span> <span class="n">R2NET_MSG_DATA_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_send_data_magic</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span>
						<span class="n">ret_data</span><span class="p">,</span> <span class="n">handler_status</span><span class="p">,</span>
						<span class="n">syserr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;sending data reply %d, syserr %d returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">handler_status</span><span class="p">,</span> <span class="n">syserr</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">r2net_set_func_stop_time</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

		<span class="n">r2net_update_recv_stats</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">r2net_set_func_stop_time</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="n">r2net_update_recv_stats</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

<span class="nl">out_respond:</span>
	<span class="cm">/* this destroys the hdr, so don&#39;t use it after this */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_send_status_magic</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">syserr</span><span class="p">,</span>
				      <span class="n">handler_status</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_send_lock</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;sending handler status %d, syserr %d returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">handler_status</span><span class="p">,</span> <span class="n">syserr</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret_data</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_post_func</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_post_func</span><span class="p">)</span>
			<span class="p">(</span><span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_post_func</span><span class="p">)(</span><span class="n">handler_status</span><span class="p">,</span> <span class="n">nmh</span><span class="o">-&gt;</span><span class="n">nh_func_data</span><span class="p">,</span>
					    <span class="n">ret_data</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmh</span><span class="p">)</span>
		<span class="n">r2net_handler_put</span><span class="p">(</span><span class="n">nmh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_check_handshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_handshake</span> <span class="o">*</span><span class="n">hand</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">protocol_version</span> <span class="o">!=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">R2NET_PROTOCOL_VERSION</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: &quot;</span> <span class="n">SC_NODEF_FMT</span> <span class="s">&quot; Advertised net &quot;</span>
		       <span class="s">&quot;protocol version %llu but %llu is required. &quot;</span>
		       <span class="s">&quot;Disconnecting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">protocol_version</span><span class="p">),</span>
		       <span class="n">R2NET_PROTOCOL_VERSION</span><span class="p">);</span>

		<span class="cm">/* don&#39;t bother reconnecting if its the wrong version. */</span>
		<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure timeouts are consistent with other nodes, otherwise</span>
<span class="cm">	 * we can end up with one node thinking that the other must be down,</span>
<span class="cm">	 * but isn&#39;t. This can ultimately cause corruption.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">r2net_idle_timeout_ms</span><span class="p">)</span> <span class="o">!=</span>
				<span class="n">r2net_idle_timeout</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: &quot;</span> <span class="n">SC_NODEF_FMT</span> <span class="s">&quot; uses a network &quot;</span>
		       <span class="s">&quot;idle timeout of %u ms, but we use %u ms locally. &quot;</span>
		       <span class="s">&quot;Disconnecting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span>
		       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">r2net_idle_timeout_ms</span><span class="p">),</span>
		       <span class="n">r2net_idle_timeout</span><span class="p">());</span>
		<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">r2net_keepalive_delay_ms</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">r2net_keepalive_delay</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: &quot;</span> <span class="n">SC_NODEF_FMT</span> <span class="s">&quot; uses a keepalive &quot;</span>
		       <span class="s">&quot;delay of %u ms, but we use %u ms locally. &quot;</span>
		       <span class="s">&quot;Disconnecting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span>
		       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">r2net_keepalive_delay_ms</span><span class="p">),</span>
		       <span class="n">r2net_keepalive_delay</span><span class="p">());</span>
		<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">r2hb_heartbeat_timeout_ms</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">R2HB_MAX_WRITE_TIMEOUT_MS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: &quot;</span> <span class="n">SC_NODEF_FMT</span> <span class="s">&quot; uses a heartbeat &quot;</span>
		       <span class="s">&quot;timeout of %u ms, but we use %u ms locally. &quot;</span>
		       <span class="s">&quot;Disconnecting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span>
		       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hand</span><span class="o">-&gt;</span><span class="n">r2hb_heartbeat_timeout_ms</span><span class="p">),</span>
		       <span class="n">R2HB_MAX_WRITE_TIMEOUT_MS</span><span class="p">);</span>
		<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_handshake_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="cm">/* set valid and queue the idle timers only if it hasn&#39;t been</span>
<span class="cm">	 * shut down already */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span> <span class="o">==</span> <span class="n">sc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r2net_sc_reset_idle_timer</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">r2net_set_nn_state</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="cm">/* shift everything up as though it wasn&#39;t there */</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_handshake</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">)</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">hand</span><span class="p">,</span> <span class="n">hand</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this demuxes the queued rx bytes into header or payload bits and calls</span>
<span class="cm"> * handlers as each full message is read off the socket.  it returns -error,</span>
<span class="cm"> * == 0 eof, or &gt; 0 for progress made.*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_advance_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_msg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">datalen</span><span class="p">;</span>

	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;receiving</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">r2net_set_advance_start_time</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_handshake_ok</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_handshake</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">;</span>
			<span class="n">datalen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_handshake</span><span class="p">)</span> <span class="o">-</span>
							<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_recv_tcp_msg</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_handshake</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r2net_check_handshake</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_handshake_ok</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do we need more header? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">;</span>
		<span class="n">datalen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">)</span> <span class="o">-</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_recv_tcp_msg</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="cm">/* only swab incoming here.. we can</span>
<span class="cm">			 * only get here once as we cross from</span>
<span class="cm">			 * being under to over */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">hdr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">&gt;</span>
				    <span class="n">R2NET_MAX_PAYLOAD_BYTES</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* oof, still don&#39;t have a header */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this was swabbed above when we first read it */</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page</span><span class="p">);</span>

	<span class="n">msglog</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&quot;at page_off %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">);</span>

	<span class="cm">/* do we need more payload? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">)</span> <span class="o">&lt;</span>
					<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* need more payload */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">;</span>
		<span class="n">datalen</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">))</span> <span class="o">-</span>
				<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_recv_tcp_msg</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">)</span> <span class="o">==</span>
						<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we can only get here once, the first time we read</span>
<span class="cm">		 * the payload.. so set ret to progress if the handler</span>
<span class="cm">		 * works out. after calling this the message is toast */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_process_message</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_page_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;ret = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">r2net_set_advance_stop_time</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this work func is triggerd by data ready.  it reads until it can read no</span>
<span class="cm"> * more.  it interprets 0, eof, as fatal.  if data_ready hits while we&#39;re doing</span>
<span class="cm"> * our work the work struct will be marked and we&#39;ll be called again. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_rx_until_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_sock_container</span><span class="p">,</span> <span class="n">sc_rx_work</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_advance_rx</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">);</span>
		<span class="n">sclog</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&quot;saw error %d, closing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="cm">/* not permanent so read failed handshake can retry */</span>
		<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_set_nodelay</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span><span class="p">;</span>

	<span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dear unsuspecting programmer,</span>
<span class="cm">	 *</span>
<span class="cm">	 * Don&#39;t use sock_setsockopt() for SOL_TCP.  It doesn&#39;t check its level</span>
<span class="cm">	 * argument and assumes SOL_SOCKET so, say, your TCP_NODELAY will</span>
<span class="cm">	 * silently turn into SO_DEBUG.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Yours,</span>
<span class="cm">	 * Keeper of hilariously fragile interfaces.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_initialize_handshake</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">r2net_hand</span><span class="o">-&gt;</span><span class="n">r2hb_heartbeat_timeout_ms</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
		<span class="n">R2HB_MAX_WRITE_TIMEOUT_MS</span><span class="p">);</span>
	<span class="n">r2net_hand</span><span class="o">-&gt;</span><span class="n">r2net_idle_timeout_ms</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">r2net_idle_timeout</span><span class="p">());</span>
	<span class="n">r2net_hand</span><span class="o">-&gt;</span><span class="n">r2net_keepalive_delay_ms</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
		<span class="n">r2net_keepalive_delay</span><span class="p">());</span>
	<span class="n">r2net_hand</span><span class="o">-&gt;</span><span class="n">r2net_reconnect_delay_ms</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
		<span class="n">r2net_reconnect_delay</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="cm">/* called when a connect completes and after a sock is accepted.  the</span>
<span class="cm"> * rx path will see the response and mark the sc valid */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sc_connect_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_sock_container</span><span class="p">,</span>
			     <span class="n">sc_connect_work</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_MSG</span><span class="p">,</span> <span class="s">&quot;sc sending handshake with ver %llu id %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">R2NET_PROTOCOL_VERSION</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">r2net_hand</span><span class="o">-&gt;</span><span class="n">connector_id</span><span class="p">));</span>

	<span class="n">r2net_initialize_handshake</span><span class="p">();</span>
	<span class="n">r2net_sendpage</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">r2net_hand</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">r2net_hand</span><span class="p">));</span>
	<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this is called as a work_struct func. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sc_send_keep_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_sock_container</span><span class="p">,</span>
			     <span class="n">sc_keepalive_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">r2net_sendpage</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">r2net_keep_req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">r2net_keep_req</span><span class="p">));</span>
	<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* socket shutdown does a del_timer_sync against this as it tears down.</span>
<span class="cm"> * we can&#39;t start this timer until we&#39;ve got to the point in sc buildup</span>
<span class="cm"> * where shutdown is going to be involved */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_idle_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msecs</span> <span class="o">=</span> <span class="n">ktime_to_ms</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">())</span> <span class="o">-</span>
		<span class="n">ktime_to_ms</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_tv_timer</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msecs</span> <span class="o">=</span> <span class="n">r2net_idle_timeout</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: Connection to &quot;</span> <span class="n">SC_NODEF_FMT</span> <span class="s">&quot; has been &quot;</span>
	       <span class="s">&quot;idle for %lu.%lu secs, shutting it down.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span>
	       <span class="n">msecs</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">msecs</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the nn_timeout so that the next connection attempt</span>
<span class="cm">	 * will continue in r2net_start_connect.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Avoid spurious shutdowns... not sure if this is still necessary */</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster_idle_timer, skipping shutdown work</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* old code used to do these two lines */</span>
<span class="c">	atomic_set(&amp;nn-&gt;nn_timeout, 1);</span>
<span class="c">	r2net_sc_queue_work(sc, &amp;sc-&gt;sc_shutdown_work);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sc_reset_idle_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">r2net_sc_cancel_delayed_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_keepalive_work</span><span class="p">);</span>
	<span class="n">r2net_sc_queue_delayed_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_keepalive_work</span><span class="p">,</span>
		      <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">r2net_keepalive_delay</span><span class="p">()));</span>
	<span class="n">r2net_set_sock_timer</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_idle_timeout</span><span class="p">,</span>
	       <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">r2net_idle_timeout</span><span class="p">()));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_sc_postpone_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only push out an existing timer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_idle_timeout</span><span class="p">))</span>
		<span class="n">r2net_sc_reset_idle_timer</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this work func is kicked whenever a path sets the nn state which doesn&#39;t</span>
<span class="cm"> * have valid set.  This includes seeing hb come up, losing a connection,</span>
<span class="cm"> * having a connect attempt fail, etc. This centralizes the logic which decides</span>
<span class="cm"> * if a connect attempt should be made or if we should give up and all future</span>
<span class="cm"> * transmit attempts should fail */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_start_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_node</span><span class="p">,</span> <span class="n">nn_connect_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">mynode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">myaddr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">},</span> <span class="n">remoteaddr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* if we&#39;re greater we initiate tx, otherwise we accept */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r2nm_this_node</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">r2net_num_from_nn</span><span class="p">(</span><span class="n">nn</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* watch for racing with tearing a node down */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">r2nm_get_node_by_num</span><span class="p">(</span><span class="n">r2net_num_from_nn</span><span class="p">(</span><span class="n">nn</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mynode</span> <span class="o">=</span> <span class="n">r2nm_get_node_by_num</span><span class="p">(</span><span class="n">r2nm_this_node</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * see if we already have one pending or have given up.</span>
<span class="cm">	 * For nn_timeout, it is set when we close the connection</span>
<span class="cm">	 * because of the idle time out. So it means that we have</span>
<span class="cm">	 * at least connected to that node successfully once,</span>
<span class="cm">	 * now try to connect to it again.</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_timeout</span><span class="p">);</span>
	<span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOTCONN</span> <span class="o">||</span> <span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stop</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_last_connect_attempt</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">sc_alloc</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t allocate sc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;can&#39;t create socket: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span> <span class="cm">/* freed by sc_kref_release */</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span><span class="p">;</span>

	<span class="n">myaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">myaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">mynode</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">;</span>
	<span class="n">myaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* any port */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myaddr</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">myaddr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bind failed with %d at address %pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mynode</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_set_nodelay</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;setting TCP_NODELAY failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r2net_register_callbacks</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="cm">/* handshake completion will set nn-&gt;nn_sc_valid */</span>
	<span class="n">r2net_set_nn_state</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="n">remoteaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">remoteaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">;</span>
	<span class="n">remoteaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">remoteaddr</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">remoteaddr</span><span class="p">),</span>
					<span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: Connect attempt to &quot;</span> <span class="n">SC_NODEF_FMT</span>
		       <span class="s">&quot; failed with errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
		<span class="cm">/* 0 err so that another will be queued and attempted</span>
<span class="cm">		 * from set_nn_state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="p">)</span>
			<span class="n">r2net_ensure_shutdown</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="p">)</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">r2nm_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mynode</span><span class="p">)</span>
		<span class="n">r2nm_node_put</span><span class="p">(</span><span class="n">mynode</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_connect_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">r2net_node</span><span class="p">,</span> <span class="n">nn_connect_expired</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: No connection established with &quot;</span>
		       <span class="s">&quot;node %u after %u.%u seconds, giving up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">r2net_num_from_nn</span><span class="p">(</span><span class="n">nn</span><span class="p">),</span>
		     <span class="n">r2net_idle_timeout</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
		     <span class="n">r2net_idle_timeout</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">);</span>

		<span class="n">r2net_set_nn_state</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_still_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="kt">void</span> <span class="nf">r2net_disconnect_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">);</span>

	<span class="cm">/* don&#39;t reconnect until it&#39;s heartbeating again */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">r2net_set_nn_state</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r2net_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_connect_expired</span><span class="p">);</span>
		<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_connect_work</span><span class="p">);</span>
		<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_still_up</span><span class="p">);</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_hb_node_down_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node_num</span> <span class="o">!=</span> <span class="n">r2nm_this_node</span><span class="p">())</span>
		<span class="n">r2net_disconnect_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_connected_peers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_hb_node_up_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">node_num</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* ensure an immediate connect attempt */</span>
	<span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_last_connect_attempt</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">r2net_reconnect_delay</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node_num</span> <span class="o">!=</span> <span class="n">r2nm_this_node</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* believe it or not, accept and node hearbeating testing</span>
<span class="cm">		 * can succeed for this node before we got here.. so</span>
<span class="cm">		 * only use set_nn_state to clear the persistent error</span>
<span class="cm">		 * if that hasn&#39;t already happened */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span><span class="p">)</span>
			<span class="n">r2net_set_nn_state</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">r2net_unregister_hb_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">r2hb_unregister_callback</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2net_hb_up</span><span class="p">);</span>
	<span class="n">r2hb_unregister_callback</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2net_hb_down</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">r2net_register_hb_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">r2hb_setup_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_hb_down</span><span class="p">,</span> <span class="n">R2HB_NODE_DOWN_CB</span><span class="p">,</span>
			    <span class="n">r2net_hb_node_down_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">R2NET_HB_PRI</span><span class="p">);</span>
	<span class="n">r2hb_setup_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_hb_up</span><span class="p">,</span> <span class="n">R2HB_NODE_UP_CB</span><span class="p">,</span>
			    <span class="n">r2net_hb_node_up_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">R2NET_HB_PRI</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2hb_register_callback</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2net_hb_up</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">r2hb_register_callback</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2net_hb_down</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">r2net_unregister_hb_callbacks</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_accept_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">slen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">new_sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">local_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_create_lite</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span>
			       <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">new_sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">new_sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">new_sock</span><span class="p">,</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">new_sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_set_nodelay</span><span class="p">(</span><span class="n">new_sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;setting TCP_NODELAY failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">new_sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">(</span><span class="n">new_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">slen</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">r2nm_get_node_by_ip</span><span class="p">(</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: Attempt to connect from unknown &quot;</span>
		       <span class="s">&quot;node at %pI4:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span>
		       <span class="n">ntohs</span><span class="p">(</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r2nm_this_node</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_node</span> <span class="o">=</span> <span class="n">r2nm_get_node_by_num</span><span class="p">(</span><span class="n">r2nm_this_node</span><span class="p">());</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: Unexpected connect attempt seen &quot;</span>
		       <span class="s">&quot;at node &#39;%s&#39; (%u, %pI4:%d) from node &#39;%s&#39; (%u, &quot;</span>
		       <span class="s">&quot;%pI4:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">local_node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span> <span class="n">local_node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="p">(</span><span class="n">local_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">),</span>
		       <span class="n">ntohs</span><span class="p">(</span><span class="n">local_node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span>
		       <span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this happens all the time when the other node sees our heartbeat</span>
<span class="cm">	 * and tries to connect before we see their heartbeat */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r2hb_check_node_heartbeating_from_callback</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_CONN</span><span class="p">,</span> <span class="s">&quot;attempt to connect from node &#39;%s&#39; at &quot;</span>
		     <span class="s">&quot;%pI4:%d but it isn&#39;t heartbeating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span>
		     <span class="n">ntohs</span><span class="p">(</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_num</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ramster: Attempt to connect from node &#39;%s&#39; &quot;</span>
		       <span class="s">&quot;at %pI4:%d but it already has an open connection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span>
		       <span class="n">ntohs</span><span class="p">(</span><span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">sc_alloc</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span> <span class="o">=</span> <span class="n">new_sock</span><span class="p">;</span>
	<span class="n">new_sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">r2net_set_nn_state</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>

	<span class="n">r2net_register_callbacks</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">r2net_sc_queue_work</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_rx_work</span><span class="p">);</span>

	<span class="n">r2net_initialize_handshake</span><span class="p">();</span>
	<span class="n">r2net_sendpage</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">r2net_hand</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">r2net_hand</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_sock</span><span class="p">)</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">new_sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">r2nm_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_node</span><span class="p">)</span>
		<span class="n">r2nm_node_put</span><span class="p">(</span><span class="n">local_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="p">)</span>
		<span class="n">sc_put</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_accept_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">r2net_listen_sock</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">r2net_accept_one</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cond_resched</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">r2net_listen_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">ready</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ready</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* check for teardown race */</span>
		<span class="n">ready</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* -&gt;sk_data_ready is also called for a newly established child socket</span>
<span class="cm">	 * before it has been accepted and the acceptor has set up their</span>
<span class="cm">	 * data_ready.. we only want to queue listen work for our listening</span>
<span class="cm">	 * socket */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_TCP</span><span class="p">,</span> <span class="s">&quot;bytes: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2net_listen_work</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">r2net_open_listening_sock</span><span class="p">(</span><span class="n">__be32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sin_addr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ramster: Error %d while creating socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">;</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">r2net_listen_data_ready</span><span class="p">;</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="n">r2net_listen_sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2net_listen_work</span><span class="p">,</span> <span class="n">r2net_accept_many</span><span class="p">);</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">=</span> <span class="n">SK_CAN_REUSE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ramster: Error %d while binding socket at &quot;</span>
			<span class="s">&quot;%pI4:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ramster: Error %d while listening on %pI4:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r2net_listen_sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span>
			<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called from node manager when we should bring up our network listening</span>
<span class="cm"> * socket.  node manager handles all the serialization to only call this</span>
<span class="cm"> * once and to match it with r2net_stop_listening().  note,</span>
<span class="cm"> * r2nm_this_node() doesn&#39;t work yet as we&#39;re being called while it</span>
<span class="cm"> * is being set up.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">r2net_start_listening</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">r2net_wq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">r2net_listen_sock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_KTHREAD</span><span class="p">,</span> <span class="s">&quot;starting r2net thread...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">r2net_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;r2net&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r2net_wq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;unable to launch r2net thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span> <span class="cm">/* ? */</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">r2net_open_listening_sock</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_address</span><span class="p">,</span>
					<span class="n">node</span><span class="o">-&gt;</span><span class="n">nd_ipv4_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">);</span>
		<span class="n">r2net_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* again, r2nm_this_node() doesn&#39;t work here as we&#39;re involved in</span>
<span class="cm"> * tearing it down */</span>
<span class="kt">void</span> <span class="nf">r2net_stop_listening</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">r2net_listen_sock</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">r2net_wq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">r2net_listen_sock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* stop the listening socket from generating work */</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span><span class="p">;</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">r2net_nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">r2nm_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">r2nm_get_node_by_num</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r2net_disconnect_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">r2nm_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* finish all work and tear down the work queue */</span>
	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_KTHREAD</span><span class="p">,</span> <span class="s">&quot;waiting for r2net thread to exit....</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">r2net_wq</span><span class="p">);</span>
	<span class="n">r2net_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sock_release</span><span class="p">(</span><span class="n">r2net_listen_sock</span><span class="p">);</span>
	<span class="n">r2net_listen_sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">r2net_hb_node_up_manual</span><span class="p">(</span><span class="kt">int</span> <span class="n">node_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">r2nm_node</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r2nm_single_cluster</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: cluster not alive, node_up_manual ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">r2hb_manual_set_node_heartbeating</span><span class="p">(</span><span class="n">node_num</span><span class="p">);</span>
		<span class="n">r2net_hb_node_up_cb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------ */</span>

<span class="kt">int</span> <span class="nf">r2net_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r2net_debugfs_init</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">r2net_hand</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_handshake</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">r2net_keep_req</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">r2net_keep_resp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">r2net_msg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r2net_hand</span> <span class="o">||</span> <span class="o">!</span><span class="n">r2net_keep_req</span> <span class="o">||</span> <span class="o">!</span><span class="n">r2net_keep_resp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">r2net_hand</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">r2net_keep_req</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">r2net_keep_resp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r2net_hand</span><span class="o">-&gt;</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">R2NET_PROTOCOL_VERSION</span><span class="p">);</span>
	<span class="n">r2net_hand</span><span class="o">-&gt;</span><span class="n">connector_id</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">r2net_keep_req</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">R2NET_MSG_KEEP_REQ_MAGIC</span><span class="p">);</span>
	<span class="n">r2net_keep_resp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">R2NET_MSG_KEEP_RESP_MAGIC</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">r2net_nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">r2net_node</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">r2net_nn_from_num</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_lock</span><span class="p">);</span>
		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_connect_work</span><span class="p">,</span> <span class="n">r2net_start_connect</span><span class="p">);</span>
		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_connect_expired</span><span class="p">,</span>
				  <span class="n">r2net_connect_expired</span><span class="p">);</span>
		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_still_up</span><span class="p">,</span> <span class="n">r2net_still_up</span><span class="p">);</span>
		<span class="cm">/* until we see hb from a node we&#39;ll return einval */</span>
		<span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_persistent_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_sc_wq</span><span class="p">);</span>
		<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_idr</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nn</span><span class="o">-&gt;</span><span class="n">nn_status_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">r2net_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">r2net_hand</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">r2net_keep_req</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">r2net_keep_resp</span><span class="p">);</span>
	<span class="n">r2net_debugfs_exit</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
