<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › ramster › cluster › tcp_internal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tcp_internal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef R2CLUSTER_TCP_INTERNAL_H</span>
<span class="cp">#define R2CLUSTER_TCP_INTERNAL_H</span>

<span class="cp">#define R2NET_MSG_MAGIC           ((u16)0xfa55)</span>
<span class="cp">#define R2NET_MSG_STATUS_MAGIC    ((u16)0xfa56)</span>
<span class="cp">#define R2NET_MSG_KEEP_REQ_MAGIC  ((u16)0xfa57)</span>
<span class="cp">#define R2NET_MSG_KEEP_RESP_MAGIC ((u16)0xfa58)</span>
<span class="cm">/*</span>
<span class="cm"> * &quot;data magic&quot; is a long version of &quot;status magic&quot; where the message</span>
<span class="cm"> * payload actually contains data to be passed in reply to certain messages</span>
<span class="cm"> */</span>
<span class="cp">#define R2NET_MSG_DATA_MAGIC      ((u16)0xfa59)</span>

<span class="cm">/* we&#39;re delaying our quorum decision so that heartbeat will have timed</span>
<span class="cm"> * out truly dead nodes by the time we come around to making decisions</span>
<span class="cm"> * on their number */</span>
<span class="cp">#define R2NET_QUORUM_DELAY_MS	\</span>
<span class="cp">		((r2hb_dead_threshold + 2) * R2HB_REGION_TIMEOUT_MS)</span>

<span class="cm">/*</span>
<span class="cm"> * This version number represents quite a lot, unfortunately.  It not</span>
<span class="cm"> * only represents the raw network message protocol on the wire but also</span>
<span class="cm"> * locking semantics of the file system using the protocol.  It should</span>
<span class="cm"> * be somewhere else, I&#39;m sure, but right now it isn&#39;t.</span>
<span class="cm"> *</span>
<span class="cm"> * With version 11, we separate out the filesystem locking portion.  The</span>
<span class="cm"> * filesystem now has a major.minor version it negotiates.  Version 11</span>
<span class="cm"> * introduces this negotiation to the r2dlm protocol, and as such the</span>
<span class="cm"> * version here in tcp_internal.h should not need to be bumped for</span>
<span class="cm"> * filesystem locking changes.</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 11</span>
<span class="cm"> *	- Negotiation of filesystem locking in the dlm join.</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 10:</span>
<span class="cm"> *	- Meta/data locks combined</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 9:</span>
<span class="cm"> *	- All votes removed</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 8:</span>
<span class="cm"> *	- Replace delete inode votes with a cluster lock</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 7:</span>
<span class="cm"> *	- DLM join domain includes the live nodemap</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 6:</span>
<span class="cm"> *	- DLM lockres remote refcount fixes.</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 5:</span>
<span class="cm"> *	- Network timeout checking protocol</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 4:</span>
<span class="cm"> *	- Remove i_generation from lock names for better stat performance.</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 3:</span>
<span class="cm"> *	- Replace dentry votes with a cluster lock</span>
<span class="cm"> *</span>
<span class="cm"> * New in version 2:</span>
<span class="cm"> *	- full 64 bit i_size in the metadata lock lvbs</span>
<span class="cm"> *	- introduction of &quot;rw&quot; lock and pushing meta/data locking down</span>
<span class="cm"> */</span>
<span class="cp">#define R2NET_PROTOCOL_VERSION 11ULL</span>
<span class="k">struct</span> <span class="n">r2net_handshake</span> <span class="p">{</span>
	<span class="n">__be64</span>	<span class="n">protocol_version</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">connector_id</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">r2hb_heartbeat_timeout_ms</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">r2net_idle_timeout_ms</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">r2net_keepalive_delay_ms</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">r2net_reconnect_delay_ms</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">r2net_node</span> <span class="p">{</span>
	<span class="cm">/* this is never called from int/bh */</span>
	<span class="n">spinlock_t</span>			<span class="n">nn_lock</span><span class="p">;</span>

	<span class="cm">/* set the moment an sc is allocated and a connect is started */</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span>	<span class="o">*</span><span class="n">nn_sc</span><span class="p">;</span>
	<span class="cm">/* _valid is only set after the handshake passes and tx can happen */</span>
	<span class="kt">unsigned</span>			<span class="n">nn_sc_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* if this is set tx just returns it */</span>
	<span class="kt">int</span>				<span class="n">nn_persistent_error</span><span class="p">;</span>
	<span class="cm">/* It is only set to 1 after the idle time out. */</span>
	<span class="n">atomic_t</span>			<span class="n">nn_timeout</span><span class="p">;</span>

	<span class="cm">/* threads waiting for an sc to arrive wait on the wq for generation</span>
<span class="cm">	 * to increase.  it is increased when a connecting socket succeeds</span>
<span class="cm">	 * or fails or when an accepted socket is attached. */</span>
	<span class="n">wait_queue_head_t</span>		<span class="n">nn_sc_wq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">idr</span>			<span class="n">nn_status_idr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">nn_status_list</span><span class="p">;</span>

	<span class="cm">/* connects are attempted from when heartbeat comes up until either hb</span>
<span class="cm">	 * goes down, the node is unconfigured, no connect attempts succeed</span>
<span class="cm">	 * before R2NET_CONN_IDLE_DELAY, or a connect succeeds.  connect_work</span>
<span class="cm">	 * is queued from set_nn_state both from hb up and from itself if a</span>
<span class="cm">	 * connect attempt fails and so can be self-arming.  shutdown is</span>
<span class="cm">	 * careful to first mark the nn such that no connects will be attempted</span>
<span class="cm">	 * before canceling delayed connect work and flushing the queue. */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>		<span class="n">nn_connect_work</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">nn_last_connect_attempt</span><span class="p">;</span>

	<span class="cm">/* this is queued as nodes come up and is canceled when a connection is</span>
<span class="cm">	 * established.  this expiring gives up on the node and errors out</span>
<span class="cm">	 * transmits */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>		<span class="n">nn_connect_expired</span><span class="p">;</span>

	<span class="cm">/* after we give up on a socket we wait a while before deciding</span>
<span class="cm">	 * that it is still heartbeating and that we should do some</span>
<span class="cm">	 * quorum work */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>		<span class="n">nn_still_up</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">r2net_sock_container</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">sc_kref</span><span class="p">;</span>
	<span class="cm">/* the next two are valid for the life time of the sc */</span>
	<span class="k">struct</span> <span class="n">socket</span>		<span class="o">*</span><span class="n">sc_sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2nm_node</span>	<span class="o">*</span><span class="n">sc_node</span><span class="p">;</span>

	<span class="cm">/* all of these sc work structs hold refs on the sc while they are</span>
<span class="cm">	 * queued.  they should not be able to ref a freed sc.  the teardown</span>
<span class="cm">	 * race is with r2net_wq destruction in r2net_stop_listening() */</span>

	<span class="cm">/* rx and connect work are generated from socket callbacks.  sc</span>
<span class="cm">	 * shutdown removes the callbacks and then flushes the work queue */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">sc_rx_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">sc_connect_work</span><span class="p">;</span>
	<span class="cm">/* shutdown work is triggered in two ways.  the simple way is</span>
<span class="cm">	 * for a code path calls ensure_shutdown which gets a lock, removes</span>
<span class="cm">	 * the sc from the nn, and queues the work.  in this case the</span>
<span class="cm">	 * work is single-shot.  the work is also queued from a sock</span>
<span class="cm">	 * callback, though, and in this case the work will find the sc</span>
<span class="cm">	 * still on the nn and will call ensure_shutdown itself.. this</span>
<span class="cm">	 * ends up triggering the shutdown work again, though nothing</span>
<span class="cm">	 * will be done in that second iteration.  so work queue teardown</span>
<span class="cm">	 * has to be careful to remove the sc from the nn before waiting</span>
<span class="cm">	 * on the work queue so that the shutdown work doesn&#39;t remove the</span>
<span class="cm">	 * sc and rearm itself.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">sc_shutdown_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">sc_idle_timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">sc_keepalive_work</span><span class="p">;</span>

	<span class="kt">unsigned</span>		<span class="n">sc_handshake_ok</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">sc_page</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">sc_page_off</span><span class="p">;</span>

	<span class="cm">/* original handlers for the sockets */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">sc_state_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">sc_data_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="n">u32</span>			<span class="n">sc_msg_key</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">sc_msg_type</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">sc_net_debug_item</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_timer</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_data_ready</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_advance_start</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_advance_stop</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_func_start</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_func_stop</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_RAMSTER_FS_STATS</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_acquiry_total</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_send_total</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_status_total</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">sc_send_count</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">sc_recv_count</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sc_tv_process_total</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">sc_send_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">r2net_msg_handler</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">nh_node</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">nh_max_len</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">nh_msg_type</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">nh_key</span><span class="p">;</span>
	<span class="n">r2net_msg_handler_func</span>	<span class="o">*</span><span class="n">nh_func</span><span class="p">;</span>
	<span class="n">r2net_msg_handler_func</span>	<span class="o">*</span><span class="n">nh_func_data</span><span class="p">;</span>
	<span class="n">r2net_post_msg_handler_func</span>
				<span class="o">*</span><span class="n">nh_post_func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">nh_kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">nh_unregister_item</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">r2net_system_error</span> <span class="p">{</span>
	<span class="n">R2NET_ERR_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">R2NET_ERR_NO_HNDLR</span><span class="p">,</span>
	<span class="n">R2NET_ERR_OVERFLOW</span><span class="p">,</span>
	<span class="n">R2NET_ERR_DIED</span><span class="p">,</span>
	<span class="n">R2NET_ERR_MAX</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">r2net_status_wait</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">r2net_system_error</span>	<span class="n">ns_sys_status</span><span class="p">;</span>
	<span class="n">s32</span>			<span class="n">ns_status</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ns_id</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">ns_wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ns_node_item</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="cm">/* just for state dumps */</span>
<span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">st_net_debug_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>		<span class="o">*</span><span class="n">st_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">r2net_sock_container</span>	<span class="o">*</span><span class="n">st_sc</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">st_id</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">st_msg_type</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">st_msg_key</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">st_node</span><span class="p">;</span>
	<span class="n">ktime_t</span>				<span class="n">st_sock_time</span><span class="p">;</span>
	<span class="n">ktime_t</span>				<span class="n">st_send_time</span><span class="p">;</span>
	<span class="n">ktime_t</span>				<span class="n">st_status_time</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">r2net_send_tracking</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dummy</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* R2CLUSTER_TCP_INTERNAL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
