<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › ramster › zcache-main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>zcache-main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * zcache.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2010-2012, Dan Magenheimer, Oracle Corp.</span>
<span class="cm"> * Copyright (c) 2010,2011, Nitin Gupta</span>
<span class="cm"> *</span>
<span class="cm"> * Zcache provides an in-kernel &quot;host implementation&quot; for transcendent memory</span>
<span class="cm"> * and, thus indirectly, for cleancache and frontswap.  Zcache includes two</span>
<span class="cm"> * page-accessible memory [1] interfaces, both utilizing lzo1x compression:</span>
<span class="cm"> * 1) &quot;compression buddies&quot; (&quot;zbud&quot;) is used for ephemeral pages</span>
<span class="cm"> * 2) xvmalloc is used for persistent pages.</span>
<span class="cm"> * Xvmalloc (based on the TLSF allocator) has very low fragmentation</span>
<span class="cm"> * so maximizes space efficiency, while zbud allows pairs (and potentially,</span>
<span class="cm"> * in the future, more than a pair of) compressed pages to be closely linked</span>
<span class="cm"> * so that reclaiming can be done via the kernel&#39;s physical-page-oriented</span>
<span class="cm"> * &quot;shrinker&quot; interface.</span>
<span class="cm"> *</span>
<span class="cm"> * [1] For a definition of page-accessible memory (aka PAM), see:</span>
<span class="cm"> *   http://marc.info/?l=linux-mm&amp;m=127811271605009</span>
<span class="cm"> *  RAMSTER TODO:</span>
<span class="cm"> *   - handle remotifying of buddied pages (see zbud_remotify_zbpg)</span>
<span class="cm"> *   - kernel boot params: nocleancache/nofrontswap don&#39;t always work?!?</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/lzo.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &quot;tmem.h&quot;</span>
<span class="cp">#include &quot;zcache.h&quot;</span>
<span class="cp">#include &quot;ramster.h&quot;</span>
<span class="cp">#include &quot;cluster/tcp.h&quot;</span>

<span class="cp">#include &quot;xvmalloc.h&quot;	</span><span class="cm">/* temporary until change to zsmalloc */</span><span class="cp"></span>

<span class="cp">#define	RAMSTER_TESTING</span>

<span class="cp">#if (!defined(CONFIG_CLEANCACHE) &amp;&amp; !defined(CONFIG_FRONTSWAP))</span>
<span class="cp">#error &quot;ramster is useless without CONFIG_CLEANCACHE or CONFIG_FRONTSWAP&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CLEANCACHE</span>
<span class="cp">#include &lt;linux/cleancache.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
<span class="cp">#include &lt;linux/frontswap.h&gt;</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">ramster_remotify_op</span> <span class="p">{</span>
	<span class="n">RAMSTER_REMOTIFY_EPH_PUT</span><span class="p">,</span>
	<span class="n">RAMSTER_REMOTIFY_PERS_PUT</span><span class="p">,</span>
	<span class="n">RAMSTER_REMOTIFY_FLUSH_PAGE</span><span class="p">,</span>
	<span class="n">RAMSTER_REMOTIFY_FLUSH_OBJ</span><span class="p">,</span>
	<span class="n">RAMSTER_INTRANSIT_PERS</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ramster_remotify_hdr</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ramster_remotify_op</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ZBH_SENTINEL  0x43214321</span>
<span class="cp">#define ZBPG_SENTINEL  0xdeadbeef</span>

<span class="cp">#define ZBUD_MAX_BUDS 2</span>

<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ramster_remotify_hdr</span> <span class="n">rem_op</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">client_id</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">pool_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">size</span><span class="p">;</span> <span class="cm">/* compressed size in bytes, zero means unused */</span>
	<span class="n">DECL_SENTINEL</span>
<span class="p">};</span>

<span class="cp">#define ZVH_SENTINEL  0x43214321</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">zv_max_page_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">zv_hdr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ramster_remotify_hdr</span> <span class="n">rem_op</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">client_id</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">pool_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">DECL_SENTINEL</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ramster_remotify_hdr</span> <span class="n">rem_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_xhandle</span> <span class="n">xh</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ramster_remotify_hdr</span> <span class="n">rem_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zv_hdr</span> <span class="n">zv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="n">zbud</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="n">flist</span><span class="p">;</span>
<span class="p">}</span> <span class="n">remotify_list_node</span><span class="p">;</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">zcache_rem_op_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* this is more aggressive but may cause other problems? */</span>
<span class="c">#define ZCACHE_GFP_MASK	(GFP_ATOMIC | __GFP_NORETRY | __GFP_NOWARN)</span>
<span class="cp">#else</span>
<span class="cp">#define ZCACHE_GFP_MASK \</span>
<span class="cp">	(__GFP_FS | __GFP_NORETRY | __GFP_NOWARN | __GFP_NOMEMALLOC)</span>
<span class="cp">#endif</span>

<span class="cp">#define MAX_POOLS_PER_CLIENT 16</span>

<span class="cp">#define MAX_CLIENTS 16</span>
<span class="cp">#define LOCAL_CLIENT ((uint16_t)-1)</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">zcache_client</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">MAX_POOLS_PER_CLIENT</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">xv_pool</span> <span class="o">*</span><span class="n">xvpool</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">refcount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">zcache_client</span> <span class="n">zcache_host</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">zcache_client</span> <span class="n">zcache_clients</span><span class="p">[</span><span class="n">MAX_CLIENTS</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint16_t</span> <span class="nf">get_client_id_from_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cli</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">zcache_host</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LOCAL_CLIENT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cli</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">zcache_clients</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_local_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cli</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">zcache_host</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********</span>
<span class="cm"> * Compression buddies (&quot;zbud&quot;) provides for packing two (or, possibly</span>
<span class="cm"> * in the future, more) compressed ephemeral pages into a single &quot;raw&quot;</span>
<span class="cm"> * (physical) page and tracking them with data structures so that</span>
<span class="cm"> * the raw pages can be easily reclaimed.</span>
<span class="cm"> *</span>
<span class="cm"> * A zbud page (&quot;zbpg&quot;) is an aligned page containing a list_head,</span>
<span class="cm"> * a lock, and two &quot;zbud headers&quot;.  The remainder of the physical</span>
<span class="cm"> * page is divided up into aligned 64-byte &quot;chunks&quot; which contain</span>
<span class="cm"> * the compressed data for zero, one, or two zbuds.  Each zbpg</span>
<span class="cm"> * resides on: (1) an &quot;unused list&quot; if it has no zbuds; (2) a</span>
<span class="cm"> * &quot;buddied&quot; list if it is fully populated  with two zbuds; or</span>
<span class="cm"> * (3) one of PAGE_SIZE/64 &quot;unbuddied&quot; lists indexed by how many chunks</span>
<span class="cm"> * the one unbuddied zbud uses.  The data inside a zbpg cannot be</span>
<span class="cm"> * read or written unless the zbpg&#39;s lock is held.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">zbud_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bud_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="n">buddy</span><span class="p">[</span><span class="n">ZBUD_MAX_BUDS</span><span class="p">];</span>
	<span class="n">DECL_SENTINEL</span>
	<span class="cm">/* followed by NUM_CHUNK aligned CHUNK_SIZE-byte chunks */</span>
<span class="p">};</span>

<span class="cp">#define CHUNK_SHIFT	6</span>
<span class="cp">#define CHUNK_SIZE	(1 &lt;&lt; CHUNK_SHIFT)</span>
<span class="cp">#define CHUNK_MASK	(~(CHUNK_SIZE-1))</span>
<span class="cp">#define NCHUNKS		(((PAGE_SIZE - sizeof(struct zbud_page)) &amp; \</span>
<span class="cp">				CHUNK_MASK) &gt;&gt; CHUNK_SHIFT)</span>
<span class="cp">#define MAX_CHUNK	(NCHUNKS-1)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">NCHUNKS</span><span class="p">];</span>
<span class="cm">/* list N contains pages with N chunks USED and NCHUNKS-N unused */</span>
<span class="cm">/* element 0 is never used but optimizing that isn&#39;t worth it */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zbud_cumul_chunk_counts</span><span class="p">[</span><span class="n">NCHUNKS</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">list_head</span> <span class="n">zbud_buddied_list</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_zbud_buddied_count</span><span class="p">;</span>

<span class="cm">/* protects the buddied list and all unbuddied lists */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zcache_zbud_curr_raw_pages</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zcache_zbud_curr_zpages</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_zbud_curr_zbytes</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_zbud_cumul_zpages</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_zbud_cumul_zbytes</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_compress_poor</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_policy_percent_exceeded</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_mean_compress_poor</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * RAMster counters</span>
<span class="cm"> * - Remote pages are pages with a local pampd but the data is remote</span>
<span class="cm"> * - Foreign pages are pages stored locally but belonging to another node</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">ramster_remote_pers_pages</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_pers_remotify_enable</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_eph_remotify_enable</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_eph_pages_remoted</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_eph_pages_remote_failed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_pers_pages_remoted</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_pers_pages_remote_failed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_pers_pages_remote_nomem</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_objects_flushed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_object_flushes_failed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_pages_flushed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_page_flushes_failed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_eph_pages_succ_get</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_pers_pages_succ_get</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_eph_pages_unsucc_get</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_remote_pers_pages_unsucc_get</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">ramster_curr_flnode_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_curr_flnode_count_max</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">ramster_foreign_eph_pampd_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_foreign_eph_pampd_count_max</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">ramster_foreign_pers_pampd_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_foreign_pers_pampd_count_max</span><span class="p">;</span>

<span class="cm">/* forward references */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">zcache_get_free_page</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">zcache_free_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * zbud helper functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">zbud_max_buddy_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MAX_CHUNK</span> <span class="o">&lt;&lt;</span> <span class="n">CHUNK_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">zbud_size_to_chunks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">zbud_max_buddy_size</span><span class="p">());</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CHUNK_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zbud_budnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">zh</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">budnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ZBUD_MAX_BUDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">zbpg</span><span class="p">),</span> <span class="n">buddy</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">budnum</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">budnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1U</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">budnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">zbud_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">budnum</span><span class="p">;</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
	<span class="n">budnum</span> <span class="o">=</span> <span class="n">zbud_budnum</span><span class="p">(</span><span class="n">zh</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">zbud_max_buddy_size</span><span class="p">());</span>
	<span class="n">zbpg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zbud_page</span><span class="p">,</span> <span class="n">buddy</span><span class="p">[</span><span class="n">budnum</span><span class="p">]);</span>
	<span class="n">ASSERT_SPINLOCK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zbpg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">budnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
							<span class="n">CHUNK_MASK</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">budnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">((</span><span class="n">size</span> <span class="o">+</span> <span class="n">CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CHUNK_MASK</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zbud_copy_from_pampd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">budnum</span><span class="p">;</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
	<span class="n">budnum</span> <span class="o">=</span> <span class="n">zbud_budnum</span><span class="p">(</span><span class="n">zh</span><span class="p">);</span>
	<span class="n">zbpg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zbud_page</span><span class="p">,</span> <span class="n">buddy</span><span class="p">[</span><span class="n">budnum</span><span class="p">]);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zbpg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">budnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
							<span class="n">CHUNK_MASK</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">budnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">((</span><span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CHUNK_MASK</span><span class="p">);</span>
	<span class="cm">/* client should be filled in by caller */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * zbud raw page management</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="nf">zbud_alloc_raw_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh0</span><span class="p">,</span> <span class="o">*</span><span class="n">zh1</span><span class="p">;</span>
		<span class="n">zbpg</span> <span class="o">=</span> <span class="n">zcache_get_free_page</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">zbpg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">);</span>
		<span class="n">zh0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">zh1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_zbud_curr_raw_pages</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">);</span>
		<span class="n">SET_SENTINEL</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="n">ZBPG</span><span class="p">);</span>
		<span class="n">zh0</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">zh1</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tmem_oid_set_invalid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zh0</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">);</span>
		<span class="n">tmem_oid_set_invalid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zh1</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">zbpg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zbud_free_raw_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">zh1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="n">ZBPG</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">));</span>
	<span class="n">ASSERT_SPINLOCK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zh0</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tmem_oid_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zh0</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zh1</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tmem_oid_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zh1</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">));</span>
	<span class="n">INVERT_SENTINEL</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="n">ZBPG</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_zbud_curr_raw_pages</span><span class="p">);</span>
	<span class="n">zcache_free_page</span><span class="p">(</span><span class="n">zbpg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * core zbud handling routines</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">zbud_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tmem_oid_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zh</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">zbud_max_buddy_size</span><span class="p">());</span>
	<span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tmem_oid_set_invalid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zh</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">);</span>
	<span class="n">INVERT_SENTINEL</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
	<span class="n">zcache_zbud_curr_zbytes</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_zbud_curr_zpages</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zbud_free_and_delist</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">chunks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh_other</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">budnum</span> <span class="o">=</span> <span class="n">zbud_budnum</span><span class="p">(</span><span class="n">zh</span><span class="p">),</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zbud_page</span><span class="p">,</span> <span class="n">buddy</span><span class="p">[</span><span class="n">budnum</span><span class="p">]);</span>

	<span class="cm">/* FIXME, should be BUG_ON, pool destruction path doesn&#39;t disable</span>
<span class="cm">	 * interrupts tmem_destroy_pool()-&gt;tmem_pampd_destroy_all_in_obj()-&gt;</span>
<span class="cm">	 * tmem_objnode_node_destroy()-&gt; zcache_pampd_free() */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* ignore zombie page... see zbud_evict_pages() */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">zbud_free</span><span class="p">(</span><span class="n">zh</span><span class="p">);</span>
	<span class="n">ASSERT_SPINLOCK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">zh_other</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[(</span><span class="n">budnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zh_other</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* was unbuddied: unlist and free */</span>
		<span class="n">chunks</span> <span class="o">=</span> <span class="n">zbud_size_to_chunks</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">chunks</span><span class="p">].</span><span class="n">list</span><span class="p">));</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">);</span>
		<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">chunks</span><span class="p">].</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">zbud_free_raw_page</span><span class="p">(</span><span class="n">zbpg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* was buddied: move remaining buddy to unbuddied list */</span>
		<span class="n">chunks</span> <span class="o">=</span> <span class="n">zbud_size_to_chunks</span><span class="p">(</span><span class="n">zh_other</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">);</span>
		<span class="n">zcache_zbud_buddied_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">chunks</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
		<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">chunks</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="nf">zbud_create</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">client_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">pool_id</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
					<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">cdata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh0</span><span class="p">,</span> <span class="o">*</span><span class="n">zh1</span><span class="p">,</span> <span class="o">*</span><span class="n">zh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">ztmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nchunks</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">found_good_buddy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nchunks</span> <span class="o">=</span> <span class="n">zbud_size_to_chunks</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">MAX_CHUNK</span> <span class="o">-</span> <span class="n">nchunks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="n">ztmp</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">,</span> <span class="n">bud_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">found_good_buddy</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">found_unbuddied</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* didn&#39;t find a good buddy, try allocating a new page */</span>
	<span class="n">zbpg</span> <span class="o">=</span> <span class="n">zbud_alloc_raw_page</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">zbpg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* ok, have a page, now compress the data before taking locks */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">nchunks</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
	<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">nchunks</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">zh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">goto</span> <span class="n">init_zh</span><span class="p">;</span>

<span class="nl">found_unbuddied:</span>
	<span class="n">ASSERT_SPINLOCK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">zh0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">zh1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">zh0</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">zh1</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zh0</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* buddy0 in use, buddy1 is vacant */</span>
		<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zh0</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
		<span class="n">zh</span> <span class="o">=</span> <span class="n">zh1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zh1</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* buddy1 in use, buddy0 is vacant */</span>
		<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zh1</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
		<span class="n">zh</span> <span class="o">=</span> <span class="n">zh0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">);</span>
	<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">found_good_buddy</span><span class="p">].</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_buddied_list</span><span class="p">);</span>
	<span class="n">zcache_zbud_buddied_count</span><span class="o">++</span><span class="p">;</span>

<span class="nl">init_zh:</span>
	<span class="n">SET_SENTINEL</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
	<span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">zh</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">zh</span><span class="o">-&gt;</span><span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="n">oid</span><span class="p">;</span>
	<span class="n">zh</span><span class="o">-&gt;</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">pool_id</span><span class="p">;</span>
	<span class="n">zh</span><span class="o">-&gt;</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">client_id</span><span class="p">;</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">zbud_data</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
	<span class="n">zbud_cumul_chunk_counts</span><span class="p">[</span><span class="n">nchunks</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_zbud_curr_zpages</span><span class="p">);</span>
	<span class="n">zcache_zbud_cumul_zpages</span><span class="o">++</span><span class="p">;</span>
	<span class="n">zcache_zbud_curr_zbytes</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">zcache_zbud_cumul_zbytes</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">zh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zbud_decompress</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">budnum</span> <span class="o">=</span> <span class="n">zbud_budnum</span><span class="p">(</span><span class="n">zh</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">out_len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">to_va</span><span class="p">,</span> <span class="o">*</span><span class="n">from_va</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">zbpg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zbud_page</span><span class="p">,</span> <span class="n">buddy</span><span class="p">[</span><span class="n">budnum</span><span class="p">]);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* ignore zombie page... see zbud_evict_pages() */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">ZBH</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">zbud_max_buddy_size</span><span class="p">());</span>
	<span class="n">to_va</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">from_va</span> <span class="o">=</span> <span class="n">zbud_data</span><span class="p">(</span><span class="n">zh</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lzo1x_decompress_safe</span><span class="p">(</span><span class="n">from_va</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">to_va</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">LZO_E_OK</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">out_len</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">to_va</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following routines handle shrinking of ephemeral pages by evicting</span>
<span class="cm"> * pages &quot;least valuable&quot; first.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_evicted_raw_pages</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_evicted_buddied_pages</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_evicted_unbuddied_pages</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">cli_id</span><span class="p">,</span>
						<span class="kt">uint16_t</span> <span class="n">poolid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">zcache_put_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Flush and free all zbuds in a zbpg, then free the pageframe</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zbud_evict_zbpg</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pool_id</span><span class="p">[</span><span class="n">ZBUD_MAX_BUDS</span><span class="p">],</span> <span class="n">client_id</span><span class="p">[</span><span class="n">ZBUD_MAX_BUDS</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">[</span><span class="n">ZBUD_MAX_BUDS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span><span class="p">[</span><span class="n">ZBUD_MAX_BUDS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ASSERT_SPINLOCK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ZBUD_MAX_BUDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">client_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">client_id</span><span class="p">;</span>
			<span class="n">pool_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">;</span>
			<span class="n">oid</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">;</span>
			<span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zh</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">client_id</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pool_id</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* these flushes should dispose of any local storage */</span>
		<span class="n">tmem_flush_page</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free nr pages.  This code is funky because we want to hold the locks</span>
<span class="cm"> * protecting various lists for as short a time as possible, and in some</span>
<span class="cm"> * circumstances the list may change asynchronously when the list lock is</span>
<span class="cm"> * not held.  In some cases we also trylock not only to avoid waiting on a</span>
<span class="cm"> * page in use by another cpu, but also to avoid potential deadlock due to</span>
<span class="cm"> * lock inversion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zbud_evict_pages</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">newly_unused_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="cm">/* now try freeing unbuddied pages, starting with least space avail */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CHUNK</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">retry_unbud_list_i:</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">,</span> <span class="n">bud_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
			<span class="n">zcache_evicted_unbuddied_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* want budlists unlocked when doing zbpg eviction */</span>
			<span class="n">zbud_evict_zbpg</span><span class="p">(</span><span class="n">zbpg</span><span class="p">);</span>
			<span class="n">newly_unused_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">local_bh_enable</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">evict_unused</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry_unbud_list_i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* as a last resort, free buddied pages */</span>
<span class="nl">retry_bud_list:</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_buddied_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">evict_unused</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_buddied_list</span><span class="p">,</span> <span class="n">bud_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">zcache_zbud_buddied_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">zcache_evicted_buddied_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* want budlists unlocked when doing zbpg eviction */</span>
		<span class="n">zbud_evict_zbpg</span><span class="p">(</span><span class="n">zbpg</span><span class="p">);</span>
		<span class="n">newly_unused_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">evict_unused</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry_bud_list</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>

<span class="nl">evict_unused:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">zcache_remoteputmem</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zbud_remotify_zbud</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_xhandle</span> <span class="o">*</span><span class="n">xh</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">remotenode</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cksum</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">cksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cksum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ramster_remote_put</span><span class="p">(</span><span class="n">xh</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remotenode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* data was successfully remoted so change the local version</span>
<span class="cm">		 * to point to the remote node where it landed */</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">xh</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* tmem_replace will also free up any local space */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">tmem_replace</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xh</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">,</span> <span class="n">xh</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
			<span class="n">pampd_make_remote</span><span class="p">(</span><span class="n">remotenode</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cksum</span><span class="p">));</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
		<span class="n">ramster_eph_pages_remoted</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ramster_eph_pages_remote_failed</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zbud_remotify_zbpg</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zh1</span><span class="p">,</span> <span class="o">*</span><span class="n">zh2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_xhandle</span> <span class="n">xh1</span><span class="p">,</span> <span class="n">xh2</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">data2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmpmem</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_remoteputmem</span><span class="p">);</span>

	<span class="n">ASSERT_SPINLOCK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">zh1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">zh1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">zh1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">zh2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">buddy</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="cm">/* don&#39;t remotify pages that are already remotified */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zh1</span><span class="o">-&gt;</span><span class="n">client_id</span> <span class="o">!=</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span>
		<span class="n">zh1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">zh2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">zh2</span><span class="o">-&gt;</span><span class="n">client_id</span> <span class="o">!=</span> <span class="n">LOCAL_CLIENT</span><span class="p">))</span>
		<span class="n">zh2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* copy the data and metadata so can release lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zh1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xh1</span><span class="p">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">zh1</span><span class="o">-&gt;</span><span class="n">client_id</span><span class="p">;</span>
		<span class="n">xh1</span><span class="p">.</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">zh1</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">;</span>
		<span class="n">xh1</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">zh1</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">;</span>
		<span class="n">xh1</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">zh1</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">size1</span> <span class="o">=</span> <span class="n">zh1</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">data1</span> <span class="o">=</span> <span class="n">zbud_data</span><span class="p">(</span><span class="n">zh1</span><span class="p">,</span> <span class="n">size1</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpmem</span><span class="p">,</span> <span class="n">zbud_data</span><span class="p">(</span><span class="n">zh1</span><span class="p">,</span> <span class="n">size1</span><span class="p">),</span> <span class="n">size1</span><span class="p">);</span>
		<span class="n">data1</span> <span class="o">=</span> <span class="n">tmpmem</span><span class="p">;</span>
		<span class="n">tmpmem</span> <span class="o">+=</span> <span class="n">size1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zh2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xh2</span><span class="p">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">zh2</span><span class="o">-&gt;</span><span class="n">client_id</span><span class="p">;</span>
		<span class="n">xh2</span><span class="p">.</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">zh2</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">;</span>
		<span class="n">xh2</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">zh2</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">;</span>
		<span class="n">xh2</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">zh2</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">size2</span> <span class="o">=</span> <span class="n">zh2</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpmem</span><span class="p">,</span> <span class="n">zbud_data</span><span class="p">(</span><span class="n">zh2</span><span class="p">,</span> <span class="n">size2</span><span class="p">),</span> <span class="n">size2</span><span class="p">);</span>
		<span class="n">data2</span> <span class="o">=</span> <span class="n">tmpmem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="cm">/* OK, no locks held anymore, remotify one or both zbuds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zh1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">zbud_remotify_zbud</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xh1</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">size1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zh2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">zbud_remotify_zbud</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xh2</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">size2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">zbud_remotify_pages</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zbud_page</span> <span class="o">*</span><span class="n">zbpg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for now just try remotifying unbuddied pages, starting with</span>
<span class="cm">	 * least space avail</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CHUNK</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">retry_unbud_list_i:</span>
		<span class="n">preempt_disable</span><span class="p">();</span>  <span class="cm">/* enable in zbud_remotify_zbpg */</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
			<span class="n">preempt_enable</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* next i in for loop */</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">,</span> <span class="n">bud_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span> <span class="cm">/* next list_for_each_entry */</span>
			<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="cm">/* want budlists unlocked when doing zbpg remotify */</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">zbud_remotify_zbpg</span><span class="p">(</span><span class="n">zbpg</span><span class="p">);</span>
			<span class="cm">/* preemption is re-enabled in zbud_remotify_zbpg */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry_unbud_list_i</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* if fail to remotify any page, quit */</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;TESTING zbud_remotify_pages failed on page,&quot;</span>
				<span class="s">&quot; trying to re-add</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
			<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;TESTING zbud_remotify_pages failed on page,&quot;</span>
				<span class="s">&quot; finished re-add</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">next_buddied_zbpg:</span>
	<span class="n">preempt_disable</span><span class="p">();</span>  <span class="cm">/* enable in zbud_remotify_zbpg */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_buddied_list</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">zbpg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_buddied_list</span><span class="p">,</span> <span class="n">bud_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* next list_for_each_entry */</span>
		<span class="n">zcache_zbud_buddied_count</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/* want budlists unlocked when doing zbpg remotify */</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">zbud_remotify_zbpg</span><span class="p">(</span><span class="n">zbpg</span><span class="p">);</span>
		<span class="cm">/* preemption is re-enabled in zbud_remotify_zbpg */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_buddied_zbpg</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* if fail to remotify any page, quit */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;TESTING zbud_remotify_pages failed on BUDDIED page,&quot;</span>
			<span class="s">&quot; trying to re-add</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">bud_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbud_buddied_list</span><span class="p">);</span>
		<span class="n">zcache_zbud_buddied_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;TESTING zbud_remotify_pages failed on BUDDIED page,&quot;</span>
			<span class="s">&quot; finished re-add</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock_out:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_budlists_spinlock</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the &quot;flush list&quot; asynchronously collects pages to remotely flush */</span>
<span class="cp">#define FLUSH_ENTIRE_OBJECT ((uint32_t)-1)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ramster_flnode_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_remote_flush_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_xhandle</span> <span class="o">*</span><span class="n">xh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remotenode</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">xh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">;</span>
	<span class="n">remotenode</span> <span class="o">=</span> <span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">client_id</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ramster_remote_flush</span><span class="p">(</span><span class="n">xh</span><span class="p">,</span> <span class="n">remotenode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ramster_remote_pages_flushed</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ramster_remote_page_flushes_failed</span><span class="o">++</span><span class="p">;</span>
	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="n">ramster_flnode_free</span><span class="p">(</span><span class="n">flnode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_remote_flush_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_xhandle</span> <span class="o">*</span><span class="n">xh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remotenode</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">xh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">;</span>
	<span class="n">remotenode</span> <span class="o">=</span> <span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">client_id</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ramster_remote_flush_object</span><span class="p">(</span><span class="n">xh</span><span class="p">,</span> <span class="n">remotenode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ramster_remote_objects_flushed</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ramster_remote_object_flushes_failed</span><span class="o">++</span><span class="p">;</span>
	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="n">ramster_flnode_free</span><span class="p">(</span><span class="n">flnode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_remote_eph_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="n">zbud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_remote_pers_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_xhandle</span> <span class="n">xh</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ephemeral</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remotenode</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cksum</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmpmem</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_remoteputmem</span><span class="p">);</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">client_id</span> <span class="o">!=</span> <span class="n">LOCAL_CLIENT</span><span class="p">);</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">xh</span><span class="p">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">zv</span><span class="o">-&gt;</span><span class="n">client_id</span><span class="p">;</span>
	<span class="n">xh</span><span class="p">.</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">zv</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">;</span>
	<span class="n">xh</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">zv</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">;</span>
	<span class="n">xh</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">zv</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">xv_get_object_size</span><span class="p">(</span><span class="n">zv</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">zv_max_page_size</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zv</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">cksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cksum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpmem</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">tmpmem</span><span class="p">;</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">client_id</span><span class="p">,</span> <span class="n">zv</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">);</span>
	<span class="n">ephemeral</span> <span class="o">=</span> <span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="cm">/* now OK to release lock set in caller */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ramster_remote_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xh</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ephemeral</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remotenode</span><span class="p">);</span>
	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is some form of a memory leak... if the remote put</span>
<span class="cm">		 * fails, there will never be another attempt to remotify</span>
<span class="cm">		 * this page.  But since we&#39;ve dropped the zv pointer,</span>
<span class="cm">		 * the page may have been freed or the data replaced</span>
<span class="cm">		 * so we can&#39;t just &quot;put it back&quot; in the remote op list.</span>
<span class="cm">		 * Even if we could, not sure where to put it in the list</span>
<span class="cm">		 * because there may be flushes that must be strictly</span>
<span class="cm">		 * ordered vs the put.  So leave this as a FIXME for now.</span>
<span class="cm">		 * But count them so we know if it becomes a problem.</span>
<span class="cm">		 */</span>
		<span class="n">ramster_pers_pages_remote_failed</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_remote_pers_pages</span><span class="p">);</span>
	<span class="n">ramster_pers_pages_remoted</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * data was successfully remoted so change the local version to</span>
<span class="cm">	 * point to the remote node where it landed</span>
<span class="cm">	 */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">xh</span><span class="p">.</span><span class="n">pool_id</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">tmem_replace</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xh</span><span class="p">.</span><span class="n">oid</span><span class="p">,</span> <span class="n">xh</span><span class="p">.</span><span class="n">index</span><span class="p">,</span>
			<span class="n">pampd_make_remote</span><span class="p">(</span><span class="n">remotenode</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cksum</span><span class="p">));</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_do_remotify_ops</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ramster_remotify_hdr</span> <span class="o">*</span><span class="n">rem_op</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">remotify_list_node</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rem_op</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ramster_remotify_hdr</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rem_op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rem_op</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">RAMSTER_REMOTIFY_PERS_PUT</span><span class="p">)</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
		<span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">remotify_list_node</span> <span class="o">*</span><span class="p">)</span><span class="n">rem_op</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rem_op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RAMSTER_REMOTIFY_EPH_PUT</span>:
<span class="n">BUG</span><span class="p">();</span>
			<span class="n">zcache_remote_eph_put</span><span class="p">((</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">rem_op</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RAMSTER_REMOTIFY_PERS_PUT</span>:
			<span class="n">zcache_remote_pers_put</span><span class="p">((</span><span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">rem_op</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RAMSTER_REMOTIFY_FLUSH_PAGE</span>:
			<span class="n">zcache_remote_flush_page</span><span class="p">((</span><span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="p">)</span><span class="n">u</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RAMSTER_REMOTIFY_FLUSH_OBJ</span>:
			<span class="n">zcache_remote_flush_object</span><span class="p">((</span><span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="p">)</span><span class="n">u</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Communicate interface revision with userspace</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;cluster/ramster_nodemanager.h&quot;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramster_interface_revision</span>  <span class="o">=</span> <span class="n">R2NM_API_VERSION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * For now, just push over a few pages every few seconds to</span>
<span class="cm"> * ensure that it basically works</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">ramster_remotify_workqueue</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ramster_remotify_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">ramster_remotify_worker</span><span class="p">,</span>
		<span class="n">ramster_remotify_process</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ramster_remotify_queue_delayed_work</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">ramster_remotify_workqueue</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">ramster_remotify_worker</span><span class="p">,</span> <span class="n">delay</span><span class="p">))</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster_remotify: bad workqueue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">use_frontswap</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">use_cleancache</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ramster_remote_target_nodenum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ramster_remotify_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">bool</span> <span class="n">remotify_in_progress</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remotify_in_progress</span><span class="p">)</span>
		<span class="n">ramster_remotify_queue_delayed_work</span><span class="p">(</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ramster_remote_target_nodenum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remotify_in_progress</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CLEANCACHE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_cleancache</span> <span class="o">&amp;&amp;</span> <span class="n">ramster_eph_remotify_enable</span><span class="p">)</span>
		<span class="n">zbud_remotify_pages</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span> <span class="cm">/* FIXME is this a good number? */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_frontswap</span> <span class="o">&amp;&amp;</span> <span class="n">ramster_pers_remotify_enable</span><span class="p">)</span>
		<span class="n">zcache_do_remotify_ops</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span> <span class="cm">/* FIXME is this a good number? */</span>
<span class="cp">#endif</span>
		<span class="n">remotify_in_progress</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">ramster_remotify_queue_delayed_work</span><span class="p">(</span><span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ramster_remotify_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">60UL</span><span class="p">;</span>
	<span class="n">ramster_remotify_workqueue</span> <span class="o">=</span>
		<span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;ramster_remotify&quot;</span><span class="p">);</span>
	<span class="n">ramster_remotify_queue_delayed_work</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">zbud_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_buddied_list</span><span class="p">);</span>
	<span class="n">zcache_zbud_buddied_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCHUNKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
		<span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="cm">/*</span>
<span class="cm"> * These sysfs routines show a nice distribution of how many zbpg&#39;s are</span>
<span class="cm"> * currently (and have ever been placed) in each unbuddied list.  It&#39;s fun</span>
<span class="cm"> * to watch but can probably go away before final merge.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zbud_show_unbuddied_list_counts</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCHUNKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%u &quot;</span><span class="p">,</span> <span class="n">zbud_unbuddied</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zbud_show_cumul_chunk_counts</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_total_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_chunks_lte_21</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_chunks_lte_32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_chunks_lte_42</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCHUNKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%lu &quot;</span><span class="p">,</span> <span class="n">zbud_cumul_chunk_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">chunks</span> <span class="o">+=</span> <span class="n">zbud_cumul_chunk_counts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">total_chunks</span> <span class="o">+=</span> <span class="n">zbud_cumul_chunk_counts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">sum_total_chunks</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">zbud_cumul_chunk_counts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">21</span><span class="p">)</span>
			<span class="n">total_chunks_lte_21</span> <span class="o">=</span> <span class="n">total_chunks</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span>
			<span class="n">total_chunks_lte_32</span> <span class="o">=</span> <span class="n">total_chunks</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">42</span><span class="p">)</span>
			<span class="n">total_chunks_lte_42</span> <span class="o">=</span> <span class="n">total_chunks</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;&lt;=21:%lu &lt;=32:%lu &lt;=42:%lu, mean:%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">total_chunks_lte_21</span><span class="p">,</span> <span class="n">total_chunks_lte_32</span><span class="p">,</span> <span class="n">total_chunks_lte_42</span><span class="p">,</span>
		<span class="n">chunks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sum_total_chunks</span> <span class="o">/</span> <span class="n">chunks</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**********</span>
<span class="cm"> * This &quot;zv&quot; PAM implementation combines the TLSF-based xvMalloc</span>
<span class="cm"> * with lzo1x compression to maximize the amount of data that can</span>
<span class="cm"> * be packed into a physical page.</span>
<span class="cm"> *</span>
<span class="cm"> * Zv represents a PAM page with the index and object (plus a &quot;size&quot; value</span>
<span class="cm"> * necessary for decompression) immediately preceding the compressed data.</span>
<span class="cm"> */</span>

<span class="cm">/* rudimentary policy limits */</span>
<span class="cm">/* total number of persistent pages may not exceed this percentage */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zv_page_count_policy_percent</span> <span class="o">=</span> <span class="mi">75</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * byte count defining poor compression; pages with greater zsize will be</span>
<span class="cm"> * rejected</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zv_max_zsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * byte count defining poor *mean* compression; pages with greater zsize</span>
<span class="cm"> * will be rejected until sufficient better-compressed pages are accepted</span>
<span class="cm"> * driving the mean below this threshold</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zv_max_mean_zsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zv_curr_dist_counts</span><span class="p">[</span><span class="n">NCHUNKS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zv_cumul_dist_counts</span><span class="p">[</span><span class="n">NCHUNKS</span><span class="p">];</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="nf">zv_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">pool_id</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">cdata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">clen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">CHUNK_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chunks</span> <span class="o">&gt;=</span> <span class="n">NCHUNKS</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xv_malloc</span><span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">xvpool</span><span class="p">,</span> <span class="n">clen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">ZCACHE_GFP_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_curr_dist_counts</span><span class="p">[</span><span class="n">chunks</span><span class="p">]);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_cumul_dist_counts</span><span class="p">[</span><span class="n">chunks</span><span class="p">]);</span>
	<span class="n">zv</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="n">oid</span><span class="p">;</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">pool_id</span><span class="p">;</span>
	<span class="n">SET_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">get_client_id_from_client</span><span class="p">(</span><span class="n">cli</span><span class="p">);</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">RAMSTER_REMOTIFY_PERS_PUT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">client_id</span> <span class="o">==</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zcache_rem_op_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zv</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span><span class="p">),</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">zv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* similar to zv_create, but just reserve space, no data yet */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="nf">zv_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_local_client</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xv_malloc</span><span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">xvpool</span><span class="p">,</span> <span class="n">clen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">ZCACHE_GFP_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">zv</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">SET_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">LOCAL_CLIENT</span><span class="p">;</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">RAMSTER_INTRANSIT_PERS</span><span class="p">;</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="n">oid</span><span class="p">;</span>
	<span class="n">zv</span><span class="o">-&gt;</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">;</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">zv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zv_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">xv_pool</span> <span class="o">*</span><span class="n">xvpool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">xv_get_object_size</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">CHUNK_SHIFT</span><span class="p">;</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chunks</span> <span class="o">&gt;=</span> <span class="n">NCHUNKS</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_curr_dist_counts</span><span class="p">[</span><span class="n">chunks</span><span class="p">]);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">xv_get_object_size</span><span class="p">(</span><span class="n">zv</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INVERT_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">list</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">zv</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">xv_free</span><span class="p">(</span><span class="n">xvpool</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zv_decompress</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">clen</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">to_va</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">xv_get_object_size</span><span class="p">(</span><span class="n">zv</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">to_va</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lzo1x_decompress_safe</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zv</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">),</span>
					<span class="n">size</span><span class="p">,</span> <span class="n">to_va</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clen</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">to_va</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">LZO_E_OK</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">clen</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zv_copy_from_pampd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">bufsize</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">xv_get_object_size</span><span class="p">(</span><span class="n">zv</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">zv_max_page_size</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">bufsize</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zv</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bufsize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zv_copy_to_pampd</span><span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">zv_size</span><span class="p">;</span>

	<span class="n">ASSERT_SENTINEL</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">ZVH</span><span class="p">);</span>
	<span class="n">zv_size</span> <span class="o">=</span> <span class="n">xv_get_object_size</span><span class="p">(</span><span class="n">zv</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zv_size</span> <span class="o">!=</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">zv_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">zv_size</span> <span class="o">&gt;</span> <span class="n">zv_max_page_size</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zv</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">zv</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="cm">/*</span>
<span class="cm"> * show a distribution of compression stats for zv pages.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zv_curr_dist_counts_show</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_total_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCHUNKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_curr_dist_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%lu &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">chunks</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">sum_total_chunks</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;mean:%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">chunks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sum_total_chunks</span> <span class="o">/</span> <span class="n">chunks</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zv_cumul_dist_counts_show</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_total_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCHUNKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_cumul_dist_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%lu &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">chunks</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">sum_total_chunks</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;mean:%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">chunks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sum_total_chunks</span> <span class="o">/</span> <span class="n">chunks</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setting zv_max_zsize via sysfs causes all persistent (e.g. swap)</span>
<span class="cm"> * pages that don&#39;t compress to less than this value (including metadata</span>
<span class="cm"> * overhead) to be rejected.  We don&#39;t allow the value to get too close</span>
<span class="cm"> * to PAGE_SIZE.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">zv_max_zsize_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">zv_max_zsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">zv_max_zsize_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">zv_max_zsize</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setting zv_max_mean_zsize via sysfs causes all persistent (e.g. swap)</span>
<span class="cm"> * pages that don&#39;t compress to less than this value (including metadata</span>
<span class="cm"> * overhead) to be rejected UNLESS the mean compression is also smaller</span>
<span class="cm"> * than this value.  In other words, we are load-balancing-by-zsize the</span>
<span class="cm"> * accepted pages.  Again, we don&#39;t allow the value to get too close</span>
<span class="cm"> * to PAGE_SIZE.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">zv_max_mean_zsize_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">zv_max_mean_zsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">zv_max_mean_zsize_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">zv_max_mean_zsize</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setting zv_page_count_policy_percent via sysfs sets an upper bound of</span>
<span class="cm"> * persistent (e.g. swap) pages that will be retained according to:</span>
<span class="cm"> *     (zv_page_count_policy_percent * totalram_pages) / 100)</span>
<span class="cm"> * when that limit is reached, further puts will be rejected (until</span>
<span class="cm"> * some pages have been flushed).  Note that, due to compression,</span>
<span class="cm"> * this number may exceed 100; it defaults to 75 and we set an</span>
<span class="cm"> * arbitrary limit of 150.  A poor choice will almost certainly result</span>
<span class="cm"> * in OOM&#39;s, so this value should only be changed prudently.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">zv_page_count_policy_percent_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
						 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">zv_page_count_policy_percent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">zv_page_count_policy_percent_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
						  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">150</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">zv_page_count_policy_percent</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">zcache_zv_max_zsize_attr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;zv_max_zsize&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">zv_max_zsize_show</span><span class="p">,</span>
		<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">zv_max_zsize_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">zcache_zv_max_mean_zsize_attr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;zv_max_mean_zsize&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">zv_max_mean_zsize_show</span><span class="p">,</span>
		<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">zv_max_mean_zsize_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">zcache_zv_page_count_policy_percent_attr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;zv_page_count_policy_percent&quot;</span><span class="p">,</span>
			  <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">zv_page_count_policy_percent_show</span><span class="p">,</span>
		<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">zv_page_count_policy_percent_store</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * zcache core code starts here</span>
<span class="cm"> */</span>

<span class="cm">/* useful stats not collected by cleancache or frontswap */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_flush_total</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_flush_found</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_flobj_total</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_flobj_found</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_failed_eph_puts</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_nonactive_puts</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_failed_pers_puts</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Tmem operations assume the poolid implies the invoking client.</span>
<span class="cm"> * Zcache only has one client (the kernel itself): LOCAL_CLIENT.</span>
<span class="cm"> * RAMster has each client numbered by cluster node, and a KVM version</span>
<span class="cm"> * of zcache would have one client per guest and each client might</span>
<span class="cm"> * have a poolid==N.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="nf">zcache_get_pool_by_id</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">poolid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cli_id</span> <span class="o">==</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_host</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cli_id</span> <span class="o">&gt;=</span> <span class="n">MAX_CLIENTS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_clients</span><span class="p">[</span><span class="n">cli_id</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">poolid</span> <span class="o">&lt;</span> <span class="n">MAX_POOLS_PER_CLIENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">cli</span><span class="o">-&gt;</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">poolid</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_put_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">cli</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_new_client</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">cli_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cli_id</span> <span class="o">==</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_host</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">cli_id</span> <span class="o">&lt;</span> <span class="n">MAX_CLIENTS</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_clients</span><span class="p">[</span><span class="n">cli_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cli</span><span class="o">-&gt;</span><span class="n">allocated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
	<span class="n">cli</span><span class="o">-&gt;</span><span class="n">xvpool</span> <span class="o">=</span> <span class="n">xv_create_pool</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">xvpool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* counters for debugging */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_failed_get_free_pages</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_failed_alloc</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_put_to_flush</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * for now, used named slabs so can easily track usage; later can</span>
<span class="cm"> * either just use kmalloc, or perhaps add a slab-like allocator</span>
<span class="cm"> * to more carefully manage total memory utilization</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">zcache_objnode_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">zcache_obj_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ramster_flnode_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zcache_curr_obj_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_curr_obj_count_max</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zcache_curr_objnode_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_curr_objnode_count_max</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * to avoid memory allocation recursion (e.g. due to direct reclaim), we</span>
<span class="cm"> * preload all necessary data structures so the hostops callbacks never</span>
<span class="cm"> * actually do a malloc</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_objnode</span> <span class="o">*</span><span class="n">objnodes</span><span class="p">[</span><span class="n">OBJNODE_TREE_MAX_PATH</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">zcache_preload</span><span class="p">,</span> <span class="n">zcache_preloads</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_do_preload</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_objnode</span> <span class="o">*</span><span class="n">objnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">zcache_objnode_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">zcache_obj_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">objnodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="n">objnode</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">zcache_objnode_cache</span><span class="p">,</span>
				<span class="n">ZCACHE_GFP_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">objnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">zcache_failed_alloc</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">objnodes</span><span class="p">))</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">objnodes</span><span class="p">[</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">objnode</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">zcache_objnode_cache</span><span class="p">,</span> <span class="n">objnode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="n">obj</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">zcache_obj_cache</span><span class="p">,</span> <span class="n">ZCACHE_GFP_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">zcache_failed_alloc</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">flnode</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ramster_flnode_cache</span><span class="p">,</span> <span class="n">ZCACHE_GFP_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">flnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">zcache_failed_alloc</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">ZCACHE_GFP_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">zcache_failed_get_free_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">zcache_obj_cache</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ramster_flnode_cache</span><span class="p">,</span> <span class="n">flnode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kp</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">zcache_obj_cache</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span> <span class="o">=</span> <span class="n">flnode</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ramster_flnode_cache</span><span class="p">,</span> <span class="n">flnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ramster_do_preload_flnode_only</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ramster_flnode_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
	<span class="n">flnode</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ramster_flnode_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">flnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>  <span class="cm">/* FIXME handle more gracefully, but how??? */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span> <span class="o">=</span> <span class="n">flnode</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ramster_flnode_cache</span><span class="p">,</span> <span class="n">flnode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">zcache_get_free_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kp</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_free_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * zcache implementation for tmem host ops</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tmem_objnode</span> <span class="o">*</span><span class="nf">zcache_objnode_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_objnode</span> <span class="o">*</span><span class="n">objnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">objnode</span> <span class="o">=</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">objnodes</span><span class="p">[</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">objnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kp</span><span class="o">-&gt;</span><span class="n">objnodes</span><span class="p">[</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">--</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_objnode_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">zcache_curr_objnode_count_max</span><span class="p">)</span>
		<span class="n">zcache_curr_objnode_count_max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">objnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_objnode_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_objnode</span> <span class="o">*</span><span class="n">objnode</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_objnode_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_objnode_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">zcache_objnode_cache</span><span class="p">,</span> <span class="n">objnode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="nf">zcache_obj_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
	<span class="n">obj</span> <span class="o">=</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kp</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_obj_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">zcache_curr_obj_count_max</span><span class="p">)</span>
		<span class="n">zcache_curr_obj_count_max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_obj_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_obj_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_obj_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">zcache_obj_cache</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="nf">ramster_flnode_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">);</span>
	<span class="n">flnode</span> <span class="o">=</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flnode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_curr_flnode_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">ramster_curr_flnode_count_max</span><span class="p">)</span>
		<span class="n">ramster_curr_flnode_count_max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">flnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ramster_flnode_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_curr_flnode_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_curr_flnode_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ramster_flnode_cache</span><span class="p">,</span> <span class="n">flnode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tmem_hostops</span> <span class="n">zcache_hostops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">obj_alloc</span> <span class="o">=</span> <span class="n">zcache_obj_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_free</span> <span class="o">=</span> <span class="n">zcache_obj_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">objnode_alloc</span> <span class="o">=</span> <span class="n">zcache_objnode_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">objnode_free</span> <span class="o">=</span> <span class="n">zcache_objnode_free</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * zcache implementations for PAM page descriptor ops</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dec_and_check</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">pvar</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="n">pvar</span><span class="p">);</span>
	<span class="cm">/* later when all accounting is fixed, make this a BUG */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">pvar</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zcache_curr_eph_pampd_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_curr_eph_pampd_count_max</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">zcache_curr_pers_pampd_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zcache_curr_pers_pampd_count_max</span><span class="p">;</span>

<span class="cm">/* forward reference */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">zcache_compress</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">out_va</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_pampd_eph_create</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">raw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
				<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">pampd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">clen</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">client_id</span> <span class="o">=</span> <span class="n">get_client_id_from_client</span><span class="p">(</span><span class="n">cli</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">zcache_compress</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">clen</span> <span class="o">&gt;</span> <span class="n">zbud_max_buddy_size</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">zcache_compress_poor</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pampd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">zbud_create</span><span class="p">(</span><span class="n">client_id</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">,</span> <span class="n">oid</span><span class="p">,</span>
					<span class="n">index</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pampd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_eph_pampd_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">zcache_curr_eph_pampd_count_max</span><span class="p">)</span>
		<span class="n">zcache_curr_eph_pampd_count_max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">client_id</span> <span class="o">!=</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_foreign_eph_pampd_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">ramster_foreign_eph_pampd_count_max</span><span class="p">)</span>
			<span class="n">ramster_foreign_eph_pampd_count_max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_pampd_pers_create</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">raw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
				<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">pampd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">clen</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zv_mean_zsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">curr_pers_pampd_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total_zsize</span><span class="p">;</span>
<span class="cp">#ifdef RAMSTER_TESTING</span>
	<span class="k">static</span> <span class="n">bool</span> <span class="n">pampd_neg_warned</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">curr_pers_pampd_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_pers_pampd_count</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_remote_pers_pages</span><span class="p">);</span>
<span class="cp">#ifdef RAMSTER_TESTING</span>
	<span class="cm">/* should always be positive, but warn if accounting is off */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pampd_neg_warned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ramster: bad accounting for curr_pers_pampd_count</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pampd_neg_warned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr_pers_pampd_count</span> <span class="o">&gt;</span>
		    <span class="p">(</span><span class="n">zv_page_count_policy_percent</span> <span class="o">*</span> <span class="n">totalram_pages</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zcache_policy_percent_exceeded</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ok_to_create</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zcache_compress</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* reject if compression is too poor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clen</span> <span class="o">&gt;</span> <span class="n">zv_max_zsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zcache_compress_poor</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* reject if mean compression is too poor */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clen</span> <span class="o">&gt;</span> <span class="n">zv_max_mean_zsize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">curr_pers_pampd_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">total_zsize</span> <span class="o">=</span> <span class="n">xv_get_total_size_bytes</span><span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">xvpool</span><span class="p">);</span>
		<span class="n">zv_mean_zsize</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">total_zsize</span><span class="p">,</span> <span class="n">curr_pers_pampd_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zv_mean_zsize</span> <span class="o">&gt;</span> <span class="n">zv_max_mean_zsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">zcache_mean_compress_poor</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">ok_to_create:</span>
	<span class="o">*</span><span class="n">pampd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">zv_create</span><span class="p">(</span><span class="n">cli</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">,</span> <span class="n">oid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pampd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_pers_pampd_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">zcache_curr_pers_pampd_count_max</span><span class="p">)</span>
		<span class="n">zcache_curr_pers_pampd_count_max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_local_client</span><span class="p">(</span><span class="n">cli</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">zv</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">**</span><span class="p">)</span><span class="n">pampd</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_foreign_pers_pampd_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">ramster_foreign_pers_pampd_count_max</span><span class="p">)</span>
		<span class="n">ramster_foreign_pers_pampd_count_max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">zcache_pampd_create</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">raw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eph</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
				<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pampd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ephemeral</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>
	<span class="n">ephemeral</span> <span class="o">=</span> <span class="p">(</span><span class="n">eph</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">eph</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ephemeral</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">zcache_pampd_eph_create</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span>
						<span class="n">oid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pampd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">zcache_pampd_pers_create</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span>
						<span class="n">oid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pampd</span><span class="p">);</span>
	<span class="cm">/* FIXME add some counters here for failed creates? */</span>
	<span class="k">return</span> <span class="n">pampd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fill the pageframe corresponding to the struct page with the data</span>
<span class="cm"> * from the passed pampd</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_pampd_get_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">bool</span> <span class="n">raw</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">pampd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span> <span class="cm">/* Fix later for shared pools? */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pampd_is_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw</span><span class="p">)</span>
		<span class="n">zv_copy_from_pampd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">pampd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">zv_decompress</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">pampd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_pampd_get_data_and_free</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">bool</span> <span class="n">raw</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">pampd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pampd_is_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw</span><span class="p">)</span>
			<span class="n">zbud_copy_from_pampd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">pampd</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">zbud_decompress</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">pampd</span><span class="p">);</span>
		<span class="n">zbud_free_and_delist</span><span class="p">((</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">pampd</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_local_client</span><span class="p">(</span><span class="n">cli</span><span class="p">))</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_foreign_eph_pampd_count</span><span class="p">);</span>
		<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_eph_pampd_count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_local_client</span><span class="p">(</span><span class="n">cli</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw</span><span class="p">)</span>
			<span class="n">zv_copy_from_pampd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">pampd</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">zv_decompress</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">pampd</span><span class="p">);</span>
		<span class="n">zv_free</span><span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">xvpool</span><span class="p">,</span> <span class="n">pampd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_local_client</span><span class="p">(</span><span class="n">cli</span><span class="p">))</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_foreign_pers_pampd_count</span><span class="p">);</span>
		<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_pers_pampd_count</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">zcache_pampd_is_remote</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pampd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pampd_is_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * free the pampd and remove it from any zcache lists</span>
<span class="cm"> * pampd must no longer be pointed to from any tmem data structures!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_pampd_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pampd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">bool</span> <span class="n">acct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">eph</span> <span class="o">=</span> <span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="n">zv</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pampd_is_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">acct</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * a NULL oid means to ignore this pampd free</span>
<span class="cm">			 * as the remote freeing will be handled elsewhere</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eph</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIXME remote flush optional but probably good idea */</span>
			<span class="cm">/* FIXME get these working properly again */</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_eph_pampd_count</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pampd_is_intransit</span><span class="p">(</span><span class="n">pampd</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* did a pers remote get_and_free, so just free local */</span>
			<span class="n">pampd</span> <span class="o">=</span> <span class="n">pampd_mask_intransit_and_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">local_pers</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span> <span class="o">=</span>
				<span class="n">ramster_flnode_alloc</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

			<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">pampd_remote_node</span><span class="p">(</span><span class="n">pampd</span><span class="p">);</span>
			<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">;</span>
			<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="n">oid</span><span class="p">;</span>
			<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">RAMSTER_REMOTIFY_FLUSH_PAGE</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flnode</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zcache_rem_op_list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_pers_pampd_count</span><span class="p">);</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_remote_pers_pages</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eph</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zbud_free_and_delist</span><span class="p">((</span><span class="k">struct</span> <span class="n">zbud_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">pampd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_local_client</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">))</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_foreign_eph_pampd_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acct</span><span class="p">)</span>
			<span class="cm">/* FIXME get these working properly again */</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_eph_pampd_count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">local_pers:</span>
		<span class="n">zv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">zv_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">pampd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_local_client</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">))</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_foreign_pers_pampd_count</span><span class="p">);</span>
		<span class="n">zv_free</span><span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">xvpool</span><span class="p">,</span> <span class="n">zv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acct</span><span class="p">)</span>
			<span class="cm">/* FIXME get these working properly again */</span>
			<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_curr_pers_pampd_count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_pampd_free_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">flushlist_node</span> <span class="o">*</span><span class="n">flnode</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pampd_is_remote</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">));</span>
	<span class="n">flnode</span> <span class="o">=</span> <span class="n">ramster_flnode_alloc</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">pampd_remote_node</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
	<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_id</span><span class="p">;</span>
	<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">oid</span><span class="p">;</span>
	<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">xh</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">FLUSH_ENTIRE_OBJECT</span><span class="p">;</span>
	<span class="n">flnode</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">RAMSTER_REMOTIFY_FLUSH_OBJ</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flnode</span><span class="o">-&gt;</span><span class="n">rem_op</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zcache_rem_op_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_rem_op_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">zcache_pampd_new_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">obj</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_pampd_replace_in_obj</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">new_pampd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_pampd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="n">new_pampd</span><span class="p">;</span>
		<span class="cm">/* enforce that all remote pages in an object reside</span>
<span class="cm">		 * in the same node! */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pampd_remote_node</span><span class="p">(</span><span class="n">new_pampd</span><span class="p">)</span> <span class="o">!=</span>
				<span class="n">pampd_remote_node</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">)))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by the message handler after a (still compressed) page has been</span>
<span class="cm"> * fetched from the remote machine in response to an &quot;is_remote&quot; tmem_get</span>
<span class="cm"> * or persistent tmem_localify.  For a tmem_get, &quot;extra&quot; is the address of</span>
<span class="cm"> * the page that is to be filled to successfully resolve the tmem_get; for</span>
<span class="cm"> * a (persistent) tmem_localify, &quot;extra&quot; is NULL (as the data is placed only</span>
<span class="cm"> * in the local zcache).  &quot;data&quot; points to &quot;size&quot; bytes of (compressed) data</span>
<span class="cm"> * passed in the message.  In the case of a persistent remote get, if</span>
<span class="cm"> * pre-allocation was successful (see zcache_repatriate_preload), the page</span>
<span class="cm"> * is placed into both local zcache and at &quot;extra&quot;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">zcache_localify</span><span class="p">(</span><span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oidp</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ephemeral</span><span class="p">,</span> <span class="n">delete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">clen</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pampd</span><span class="p">,</span> <span class="o">*</span><span class="n">saved_hb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

	<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="cm">/* pool doesn&#39;t exist anymore */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ephemeral</span> <span class="o">=</span> <span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>  <span class="cm">/* FIXME: maybe only disable softirqs? */</span>
	<span class="n">pampd</span> <span class="o">=</span> <span class="n">tmem_localify_get_pampd</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">oidp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saved_hb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pampd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* hmmm... must have been a flush while waiting */</span>
<span class="cp">#ifdef RAMSTER_TESTING</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;UNTESTED pampd==NULL in zcache_localify</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ephemeral</span><span class="p">)</span>
			<span class="n">ramster_remote_eph_pages_unsucc_get</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ramster_remote_pers_pages_unsucc_get</span><span class="o">++</span><span class="p">;</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pampd_is_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* hmmm... must have been a dup put while waiting */</span>
<span class="cp">#ifdef RAMSTER_TESTING</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;UNTESTED dup while waiting in zcache_localify</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ephemeral</span><span class="p">)</span>
			<span class="n">ramster_remote_eph_pages_unsucc_get</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ramster_remote_pers_pages_unsucc_get</span><span class="o">++</span><span class="p">;</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pampd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no remote data, delete the local is_remote pampd */</span>
		<span class="n">pampd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ephemeral</span><span class="p">)</span>
			<span class="n">ramster_remote_eph_pages_unsucc_get</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">delete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ephemeral</span> <span class="o">&amp;&amp;</span> <span class="n">pampd_is_intransit</span><span class="p">(</span><span class="n">pampd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* localify to zcache */</span>
		<span class="n">pampd</span> <span class="o">=</span> <span class="n">pampd_mask_intransit_and_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">);</span>
		<span class="n">zv_copy_to_pampd</span><span class="p">(</span><span class="n">pampd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pampd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extra</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* decompress direct-to-memory to complete remotify */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">lzo1x_decompress_safe</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">extra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clen</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">LZO_E_OK</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">clen</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ephemeral</span><span class="p">)</span>
		<span class="n">ramster_remote_eph_pages_succ_get</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ramster_remote_pers_pages_succ_get</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">finish:</span>
	<span class="n">tmem_localify_finish</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">pampd</span><span class="p">,</span> <span class="n">saved_hb</span><span class="p">,</span> <span class="n">delete</span><span class="p">);</span>
	<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called on a remote persistent tmem_get to attempt to preallocate</span>
<span class="cm"> * local storage for the data contained in the remote persistent page.</span>
<span class="cm"> * If successfully preallocated, returns the pampd, marked as remote and</span>
<span class="cm"> * in_transit.  Else returns NULL.  Note that the appropriate tmem data</span>
<span class="cm"> * structure must be locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">zcache_pampd_repatriate_preload</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pampd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
						<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span>
						<span class="n">bool</span> <span class="o">*</span><span class="n">intransit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">clen</span> <span class="o">=</span> <span class="n">pampd_remote_size</span><span class="p">(</span><span class="n">pampd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret_pampd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pampd_is_remote</span><span class="p">(</span><span class="n">pampd</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pampd_is_intransit</span><span class="p">(</span><span class="n">pampd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * to avoid multiple allocations (and maybe a memory leak)</span>
<span class="cm">		 * don&#39;t preallocate if already in the process of being</span>
<span class="cm">		 * repatriated</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">intransit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">intransit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ret_pampd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">zv_alloc</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">oid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_pampd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  a pampd is marked intransit if it is remote and space has</span>
<span class="cm">		 *  been allocated for it locally (note, only happens for</span>
<span class="cm">		 *  persistent pages, in which case the remote copy is freed)</span>
<span class="cm">		 */</span>
		<span class="n">ret_pampd</span> <span class="o">=</span> <span class="n">pampd_mark_intransit</span><span class="p">(</span><span class="n">ret_pampd</span><span class="p">);</span>
		<span class="n">dec_and_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramster_remote_pers_pages</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ramster_pers_pages_remote_nomem</span><span class="o">++</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_pampd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called on a remote tmem_get to invoke a message to fetch the page.</span>
<span class="cm"> * Might sleep so no tmem locks can be held.  &quot;extra&quot; is passed</span>
<span class="cm"> * all the way through the round-trip messaging to zcache_localify.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_pampd_repatriate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fake_pampd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">real_pampd</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">free</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_xhandle</span> <span class="n">xh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pampd_is_intransit</span><span class="p">(</span><span class="n">real_pampd</span><span class="p">))</span>
		<span class="cm">/* have local space pre-reserved, so free remote copy */</span>
		<span class="n">free</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">xh</span> <span class="o">=</span> <span class="n">tmem_xhandle_fill</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">oid</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="cm">/* unreliable request/response for now */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ramster_remote_async_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xh</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span>
					<span class="n">pampd_remote_node</span><span class="p">(</span><span class="n">fake_pampd</span><span class="p">),</span>
					<span class="n">pampd_remote_size</span><span class="p">(</span><span class="n">fake_pampd</span><span class="p">),</span>
					<span class="n">pampd_remote_cksum</span><span class="p">(</span><span class="n">fake_pampd</span><span class="p">),</span>
					<span class="n">extra</span><span class="p">);</span>
<span class="cp">#ifdef RAMSTER_TESTING</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;TESTING zcache_pampd_repatriate returns, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tmem_pamops</span> <span class="n">zcache_pamops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">zcache_pampd_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_data</span> <span class="o">=</span> <span class="n">zcache_pampd_get_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">zcache_pampd_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_data_and_free</span> <span class="o">=</span> <span class="n">zcache_pampd_get_data_and_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_obj</span> <span class="o">=</span> <span class="n">zcache_pampd_free_obj</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_remote</span> <span class="o">=</span> <span class="n">zcache_pampd_is_remote</span><span class="p">,</span>
	<span class="p">.</span><span class="n">repatriate_preload</span> <span class="o">=</span> <span class="n">zcache_pampd_repatriate_preload</span><span class="p">,</span>
	<span class="p">.</span><span class="n">repatriate</span> <span class="o">=</span> <span class="n">zcache_pampd_repatriate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">new_obj</span> <span class="o">=</span> <span class="n">zcache_pampd_new_obj</span><span class="p">,</span>
	<span class="p">.</span><span class="n">replace_in_obj</span> <span class="o">=</span> <span class="n">zcache_pampd_replace_in_obj</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * zcache compression/decompression and related per-cpu stuff</span>
<span class="cm"> */</span>

<span class="cp">#define LZO_WORKMEM_BYTES LZO1X_1_MEM_COMPRESS</span>
<span class="cp">#define LZO_DSTMEM_PAGE_ORDER 1</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">zcache_workmem</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">zcache_dstmem</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_compress</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">out_va</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">out_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dmem</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_dstmem</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">wmem</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">zcache_workmem</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">from_va</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dmem</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">wmem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>  <span class="cm">/* no buffer, so can&#39;t compress */</span>
	<span class="n">from_va</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lzo1x_1_compress</span><span class="p">(</span><span class="n">from_va</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">dmem</span><span class="p">,</span> <span class="n">out_len</span><span class="p">,</span> <span class="n">wmem</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">LZO_E_OK</span><span class="p">);</span>
	<span class="o">*</span><span class="n">out_va</span> <span class="o">=</span> <span class="n">dmem</span><span class="p">;</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">from_va</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_cpu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_preload</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_dstmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span>
			<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_REPEAT</span><span class="p">,</span>
			<span class="n">LZO_DSTMEM_PAGE_ORDER</span><span class="p">),</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_workmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="n">LZO1X_MEM_COMPRESS</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_REPEAT</span><span class="p">);</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_remoteputmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_REPEAT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
		<span class="n">kfree</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_remoteputmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_remoteputmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_dstmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
				<span class="n">LZO_DSTMEM_PAGE_ORDER</span><span class="p">);</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_dstmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_workmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_workmem</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">zcache_preloads</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">zcache_objnode_cache</span><span class="p">,</span>
					<span class="n">kp</span><span class="o">-&gt;</span><span class="n">objnodes</span><span class="p">[</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">objnodes</span><span class="p">[</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">zcache_obj_cache</span><span class="p">,</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">);</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ramster_flnode_cache</span><span class="p">,</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span><span class="p">);</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">flnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">zcache_cpu_notifier_block</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">zcache_cpu_notifier</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="cp">#define ZCACHE_SYSFS_RO(_name) \</span>
<span class="cp">	static ssize_t zcache_##_name##_show(struct kobject *kobj, \</span>
<span class="cp">				struct kobj_attribute *attr, char *buf) \</span>
<span class="cp">	{ \</span>
<span class="cp">		return sprintf(buf, &quot;%lu\n&quot;, zcache_##_name); \</span>
<span class="cp">	} \</span>
<span class="cp">	static struct kobj_attribute zcache_##_name##_attr = { \</span>
<span class="cp">		.attr = { .name = __stringify(_name), .mode = 0444 }, \</span>
<span class="cp">		.show = zcache_##_name##_show, \</span>
<span class="cp">	}</span>

<span class="cp">#define ZCACHE_SYSFS_RO_ATOMIC(_name) \</span>
<span class="cp">	static ssize_t zcache_##_name##_show(struct kobject *kobj, \</span>
<span class="cp">				struct kobj_attribute *attr, char *buf) \</span>
<span class="cp">	{ \</span>
<span class="cp">	    return sprintf(buf, &quot;%d\n&quot;, atomic_read(&amp;zcache_##_name)); \</span>
<span class="cp">	} \</span>
<span class="cp">	static struct kobj_attribute zcache_##_name##_attr = { \</span>
<span class="cp">		.attr = { .name = __stringify(_name), .mode = 0444 }, \</span>
<span class="cp">		.show = zcache_##_name##_show, \</span>
<span class="cp">	}</span>

<span class="cp">#define ZCACHE_SYSFS_RO_CUSTOM(_name, _func) \</span>
<span class="cp">	static ssize_t zcache_##_name##_show(struct kobject *kobj, \</span>
<span class="cp">				struct kobj_attribute *attr, char *buf) \</span>
<span class="cp">	{ \</span>
<span class="cp">	    return _func(buf); \</span>
<span class="cp">	} \</span>
<span class="cp">	static struct kobj_attribute zcache_##_name##_attr = { \</span>
<span class="cp">		.attr = { .name = __stringify(_name), .mode = 0444 }, \</span>
<span class="cp">		.show = zcache_##_name##_show, \</span>
<span class="cp">	}</span>

<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">curr_obj_count_max</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">curr_objnode_count_max</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">flush_total</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">flush_found</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">flobj_total</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">flobj_found</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">failed_eph_puts</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">nonactive_puts</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">failed_pers_puts</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">zbud_curr_zbytes</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">zbud_cumul_zpages</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">zbud_cumul_zbytes</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">zbud_buddied_count</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">evicted_raw_pages</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">evicted_unbuddied_pages</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">evicted_buddied_pages</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">failed_get_free_pages</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">failed_alloc</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">put_to_flush</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">compress_poor</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">mean_compress_poor</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO</span><span class="p">(</span><span class="n">policy_percent_exceeded</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">zbud_curr_raw_pages</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">zbud_curr_zpages</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">curr_obj_count</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">curr_objnode_count</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_CUSTOM</span><span class="p">(</span><span class="n">zbud_unbuddied_list_counts</span><span class="p">,</span>
			<span class="n">zbud_show_unbuddied_list_counts</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_CUSTOM</span><span class="p">(</span><span class="n">zbud_cumul_chunk_counts</span><span class="p">,</span>
			<span class="n">zbud_show_cumul_chunk_counts</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_CUSTOM</span><span class="p">(</span><span class="n">zv_curr_dist_counts</span><span class="p">,</span>
			<span class="n">zv_curr_dist_counts_show</span><span class="p">);</span>
<span class="n">ZCACHE_SYSFS_RO_CUSTOM</span><span class="p">(</span><span class="n">zv_cumul_dist_counts</span><span class="p">,</span>
			<span class="n">zv_cumul_dist_counts_show</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">zcache_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">zcache_curr_obj_count_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_curr_obj_count_max_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_curr_objnode_count_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_curr_objnode_count_max_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_flush_total_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_flobj_total_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_flush_found_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_flobj_found_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_failed_eph_puts_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_nonactive_puts_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_failed_pers_puts_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_policy_percent_exceeded_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_compress_poor_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_mean_compress_poor_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_curr_raw_pages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_curr_zpages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_curr_zbytes_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_cumul_zpages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_cumul_zbytes_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_buddied_count_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_evicted_raw_pages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_evicted_unbuddied_pages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_evicted_buddied_pages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_failed_get_free_pages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_failed_alloc_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_put_to_flush_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_unbuddied_list_counts_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zbud_cumul_chunk_counts_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zv_curr_dist_counts_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zv_cumul_dist_counts_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zv_max_zsize_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zv_max_mean_zsize_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">zcache_zv_page_count_policy_percent_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">zcache_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">zcache_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;zcache&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define RAMSTER_SYSFS_RO(_name) \</span>
<span class="cp">	static ssize_t ramster_##_name##_show(struct kobject *kobj, \</span>
<span class="cp">				struct kobj_attribute *attr, char *buf) \</span>
<span class="cp">	{ \</span>
<span class="cp">		return sprintf(buf, &quot;%lu\n&quot;, ramster_##_name); \</span>
<span class="cp">	} \</span>
<span class="cp">	static struct kobj_attribute ramster_##_name##_attr = { \</span>
<span class="cp">		.attr = { .name = __stringify(_name), .mode = 0444 }, \</span>
<span class="cp">		.show = ramster_##_name##_show, \</span>
<span class="cp">	}</span>

<span class="cp">#define RAMSTER_SYSFS_RW(_name) \</span>
<span class="cp">	static ssize_t ramster_##_name##_show(struct kobject *kobj, \</span>
<span class="cp">				struct kobj_attribute *attr, char *buf) \</span>
<span class="cp">	{ \</span>
<span class="cp">		return sprintf(buf, &quot;%lu\n&quot;, ramster_##_name); \</span>
<span class="cp">	} \</span>
<span class="cp">	static ssize_t ramster_##_name##_store(struct kobject *kobj, \</span>
<span class="cp">		struct kobj_attribute *attr, const char *buf, size_t count) \</span>
<span class="cp">	{ \</span>
<span class="cp">		int err; \</span>
<span class="cp">		unsigned long enable; \</span>
<span class="cp">		err = kstrtoul(buf, 10, &amp;enable); \</span>
<span class="cp">		if (err) \</span>
<span class="cp">			return -EINVAL; \</span>
<span class="cp">		ramster_##_name = enable; \</span>
<span class="cp">		return count; \</span>
<span class="cp">	} \</span>
<span class="cp">	static struct kobj_attribute ramster_##_name##_attr = { \</span>
<span class="cp">		.attr = { .name = __stringify(_name), .mode = 0644 }, \</span>
<span class="cp">		.show = ramster_##_name##_show, \</span>
<span class="cp">		.store = ramster_##_name##_store, \</span>
<span class="cp">	}</span>

<span class="cp">#define RAMSTER_SYSFS_RO_ATOMIC(_name) \</span>
<span class="cp">	static ssize_t ramster_##_name##_show(struct kobject *kobj, \</span>
<span class="cp">				struct kobj_attribute *attr, char *buf) \</span>
<span class="cp">	{ \</span>
<span class="cp">	    return sprintf(buf, &quot;%d\n&quot;, atomic_read(&amp;ramster_##_name)); \</span>
<span class="cp">	} \</span>
<span class="cp">	static struct kobj_attribute ramster_##_name##_attr = { \</span>
<span class="cp">		.attr = { .name = __stringify(_name), .mode = 0444 }, \</span>
<span class="cp">		.show = ramster_##_name##_show, \</span>
<span class="cp">	}</span>

<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">interface_revision</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">remote_pers_pages</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RW</span><span class="p">(</span><span class="n">pers_remotify_enable</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RW</span><span class="p">(</span><span class="n">eph_remotify_enable</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">eph_pages_remoted</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">eph_pages_remote_failed</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">pers_pages_remoted</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">pers_pages_remote_failed</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">pers_pages_remote_nomem</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_pages_flushed</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_page_flushes_failed</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_objects_flushed</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_object_flushes_failed</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_eph_pages_succ_get</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_eph_pages_unsucc_get</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_pers_pages_succ_get</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">remote_pers_pages_unsucc_get</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">foreign_eph_pampd_count</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">foreign_eph_pampd_count_max</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">foreign_pers_pampd_count</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">foreign_pers_pampd_count_max</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO_ATOMIC</span><span class="p">(</span><span class="n">curr_flnode_count</span><span class="p">);</span>
<span class="n">RAMSTER_SYSFS_RO</span><span class="p">(</span><span class="n">curr_flnode_count_max</span><span class="p">);</span>

<span class="cp">#define MANUAL_NODES 8</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">ramster_nodes_manual_up</span><span class="p">[</span><span class="n">MANUAL_NODES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ramster_manual_node_up_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MANUAL_NODES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ramster_nodes_manual_up</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ramster_manual_node_up_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_num</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: bad strtoul?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_num</span> <span class="o">&gt;=</span> <span class="n">MANUAL_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: bad node_num=%lu?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ramster_nodes_manual_up</span><span class="p">[</span><span class="n">node_num</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: node %d already up, ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">node_num</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ramster_nodes_manual_up</span><span class="p">[</span><span class="n">node_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">r2net_hb_node_up_manual</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">node_num</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">ramster_manual_node_up_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;manual_node_up&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">ramster_manual_node_up_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">ramster_manual_node_up_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ramster_remote_target_nodenum_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ramster_remote_target_nodenum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;unset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ramster_remote_target_nodenum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ramster_remote_target_nodenum_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_num</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: bad strtoul?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node_num</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: disabling all remotification, &quot;</span>
			<span class="s">&quot;data may still reside on remote nodes however</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node_num</span> <span class="o">&gt;=</span> <span class="n">MANUAL_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: bad node_num=%lu?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ramster_nodes_manual_up</span><span class="p">[</span><span class="n">node_num</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: node %d not up, ignoring setting &quot;</span>
			<span class="s">&quot;of remotification target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">node_num</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r2net_remote_target_node_set</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">node_num</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: node %d set as remotification target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">node_num</span><span class="p">);</span>
		<span class="n">ramster_remote_target_nodenum</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">node_num</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: bad num to node node_num=%d?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">node_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">ramster_remote_target_nodenum_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;remote_target_nodenum&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">ramster_remote_target_nodenum_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">ramster_remote_target_nodenum_store</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">ramster_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">ramster_interface_revision_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_pers_remotify_enable_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_eph_remotify_enable_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_pers_pages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_eph_pages_remoted_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_eph_pages_remote_failed_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_pers_pages_remoted_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_pers_pages_remote_failed_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_pers_pages_remote_nomem_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_pages_flushed_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_page_flushes_failed_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_objects_flushed_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_object_flushes_failed_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_eph_pages_succ_get_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_eph_pages_unsucc_get_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_pers_pages_succ_get_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_pers_pages_unsucc_get_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_foreign_eph_pampd_count_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_foreign_eph_pampd_count_max_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_foreign_pers_pampd_count_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_foreign_pers_pampd_count_max_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_curr_flnode_count_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_curr_flnode_count_max_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_manual_node_up_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ramster_remote_target_nodenum_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">ramster_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">ramster_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ramster&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * When zcache is disabled (&quot;frozen&quot;), pools can be created and destroyed,</span>
<span class="cm"> * but all puts (and thus all other operations that require memory allocation)</span>
<span class="cm"> * must fail.  If zcache is unfrozen, accepts puts, then frozen again,</span>
<span class="cm"> * data consistency requires all puts while frozen to be converted into</span>
<span class="cm"> * flushes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">zcache_freeze</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * zcache shrinker interface (only useful for ephemeral pages, so zbud only)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shrink_zcache_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">))</span>
			<span class="cm">/* does this case really need to be skipped? */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">zbud_evict_pages</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_zbud_curr_raw_pages</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">shrinker</span> <span class="n">zcache_shrinker</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">shrink</span> <span class="o">=</span> <span class="n">shrink_zcache_memory</span><span class="p">,</span>
	<span class="p">.</span><span class="n">seeks</span> <span class="o">=</span> <span class="n">DEFAULT_SEEKS</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * zcache shims between cleancache/frontswap ops and tmem</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">zcache_put</span><span class="p">(</span><span class="kt">int</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oidp</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">raw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ephemeral</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">cli_id</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zcache_freeze</span> <span class="o">&amp;&amp;</span> <span class="n">zcache_do_preload</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* preload does preempt_disable on success */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tmem_put</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">oidp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">ephemeral</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span>
				<span class="n">zcache_failed_eph_puts</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">zcache_failed_pers_puts</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">zcache_put_to_flush</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">obj_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* the put fails whether the flush succeeds or not */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">tmem_flush_page</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">oidp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_get</span><span class="p">(</span><span class="kt">int</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oidp</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">sizep</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">raw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get_and_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">eph</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_softirq</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">cli_id</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">);</span>
	<span class="n">eph</span> <span class="o">=</span> <span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pool</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">obj_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tmem_get</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">oidp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sizep</span><span class="p">,</span>
					<span class="n">raw</span><span class="p">,</span> <span class="n">get_and_free</span><span class="p">);</span>
		<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">WARN_ONCE</span><span class="p">((</span><span class="o">!</span><span class="n">eph</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)),</span> <span class="s">&quot;zcache_get fails on persistent pool, &quot;</span>
			  <span class="s">&quot;bad things are very likely to happen soon</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef RAMSTER_TESTING</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">&amp;&amp;</span> <span class="n">is_ephemeral</span><span class="p">(</span><span class="n">pool</span><span class="p">)))</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;TESTING zcache_get tmem_get returns ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span> <span class="cm">/* FIXME... don&#39;t need this anymore??? let&#39;s ensure */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_flush</span><span class="p">(</span><span class="kt">int</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oidp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">zcache_flush_total</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">cli_id</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">);</span>
	<span class="n">ramster_do_preload_flnode_only</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pool</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">obj_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tmem_flush_page</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">oidp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">zcache_flush_found</span><span class="o">++</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_flush_object</span><span class="p">(</span><span class="kt">int</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="n">oidp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">zcache_flobj_total</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">zcache_get_pool_by_id</span><span class="p">(</span><span class="n">cli_id</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">);</span>
	<span class="n">ramster_do_preload_flnode_only</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pool</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">obj_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tmem_flush_object</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">oidp</span><span class="p">);</span>
		<span class="n">zcache_put_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">zcache_flobj_found</span><span class="o">++</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_client_destroy_pool</span><span class="p">(</span><span class="kt">int</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pool_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli_id</span> <span class="o">==</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_host</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">cli_id</span> <span class="o">&lt;</span> <span class="n">MAX_CLIENTS</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_clients</span><span class="p">[</span><span class="n">cli_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">cli</span><span class="o">-&gt;</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">pool_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cli</span><span class="o">-&gt;</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">pool_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* wait for pool activity on other cpus to quiesce */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tmem_destroy_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: destroyed pool id=%d cli_id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">,</span> <span class="n">cli_id</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_destroy_pool</span><span class="p">(</span><span class="kt">int</span> <span class="n">pool_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zcache_client_destroy_pool</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_new_pool</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">poolid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cli_id</span> <span class="o">==</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_host</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">cli_id</span> <span class="o">&lt;</span> <span class="n">MAX_CLIENTS</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_clients</span><span class="p">[</span><span class="n">cli_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: pool creation failed: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">poolid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">poolid</span> <span class="o">&lt;</span> <span class="n">MAX_POOLS_PER_CLIENT</span><span class="p">;</span> <span class="n">poolid</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">poolid</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">poolid</span> <span class="o">&gt;=</span> <span class="n">MAX_POOLS_PER_CLIENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: pool creation failed: max exceeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
		<span class="n">poolid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span> <span class="o">=</span> <span class="n">cli</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">poolid</span><span class="p">;</span>
	<span class="n">tmem_new_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cli</span><span class="o">-&gt;</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">poolid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli_id</span> <span class="o">==</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: created %s tmem pool, id=%d, local client</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TMEM_POOL_PERSIST</span> <span class="o">?</span> <span class="s">&quot;persistent&quot;</span> <span class="o">:</span> <span class="s">&quot;ephemeral&quot;</span><span class="p">,</span>
			<span class="n">poolid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: created %s tmem pool, id=%d, client=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TMEM_POOL_PERSIST</span> <span class="o">?</span> <span class="s">&quot;persistent&quot;</span> <span class="o">:</span> <span class="s">&quot;ephemeral&quot;</span><span class="p">,</span>
			<span class="n">poolid</span><span class="p">,</span> <span class="n">cli_id</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">poolid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_local_new_pool</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">zcache_new_pool</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zcache_autocreate_pool</span><span class="p">(</span><span class="kt">int</span> <span class="n">cli_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ephemeral</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zcache_client</span> <span class="o">*</span><span class="n">cli</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">ephemeral</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">TMEM_POOL_PERSIST</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cli_id</span> <span class="o">==</span> <span class="n">LOCAL_CLIENT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool_id</span> <span class="o">&gt;=</span> <span class="n">MAX_POOLS_PER_CLIENT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">cli_id</span> <span class="o">&lt;</span> <span class="n">MAX_CLIENTS</span><span class="p">)</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_clients</span><span class="p">[</span><span class="n">cli_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ephemeral</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">use_cleancache</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">ephemeral</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">use_frontswap</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span> <span class="cm">/* FIXME, handle more gracefully later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zcache_new_client</span><span class="p">(</span><span class="n">cli_id</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span> <span class="cm">/* FIXME, handle more gracefully later */</span>
		<span class="n">cli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zcache_clients</span><span class="p">[</span><span class="n">cli_id</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">cli</span><span class="o">-&gt;</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">pool_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">persistent</span> <span class="o">&amp;&amp;</span> <span class="n">ephemeral</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;zcache_autocreate_pool: type mismatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_pool</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: pool creation failed: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">client</span> <span class="o">=</span> <span class="n">cli</span><span class="p">;</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">pool_id</span> <span class="o">=</span> <span class="n">pool_id</span><span class="p">;</span>
	<span class="n">tmem_new_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cli</span><span class="o">-&gt;</span><span class="n">tmem_pools</span><span class="p">[</span><span class="n">pool_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: AUTOcreated %s tmem poolid=%d, for remote client=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TMEM_POOL_PERSIST</span> <span class="o">?</span> <span class="s">&quot;persistent&quot;</span> <span class="o">:</span> <span class="s">&quot;ephemeral&quot;</span><span class="p">,</span>
		<span class="n">pool_id</span><span class="p">,</span> <span class="n">cli_id</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span> <span class="cm">/* FIXME, handle more gracefully later */</span>
		<span class="cm">/* pr_err(&quot;zcache_autocreate_pool: failed\n&quot;); */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cli</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cli</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********</span>
<span class="cm"> * Two kernel functionalities currently can be layered on top of tmem.</span>
<span class="cm"> * These are &quot;cleancache&quot; which is used as a second-chance cache for clean</span>
<span class="cm"> * page cache pages; and &quot;frontswap&quot; which is used for swap pages</span>
<span class="cm"> * to avoid writes to disk.  A generic &quot;shim&quot; is provided here for each</span>
<span class="cm"> * to translate in-kernel semantics to zcache semantics.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_CLEANCACHE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_cleancache_put_page</span><span class="p">(</span><span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cleancache_filekey</span> <span class="n">key</span><span class="p">,</span>
					<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">key</span><span class="p">;</span>

<span class="cp">#ifdef __PG_WAS_ACTIVE</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageWasActive</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">zcache_nonactive_puts</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">kva</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">zcache_put</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">kva</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_cleancache_get_page</span><span class="p">(</span><span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cleancache_filekey</span> <span class="n">key</span><span class="p">,</span>
					<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">kva</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">zcache_get</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">kva</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef __PG_WAS_ACTIVE</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">SetPageWasActive</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_cleancache_flush_page</span><span class="p">(</span><span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cleancache_filekey</span> <span class="n">key</span><span class="p">,</span>
					<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">index</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">zcache_flush</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oid</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_cleancache_flush_inode</span><span class="p">(</span><span class="kt">int</span> <span class="n">pool_id</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cleancache_filekey</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_oid</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">key</span><span class="p">;</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">zcache_flush_object</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">pool_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_cleancache_flush_fs</span><span class="p">(</span><span class="kt">int</span> <span class="n">pool_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool_id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">zcache_destroy_pool</span><span class="p">(</span><span class="n">pool_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_cleancache_init_fs</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">pagesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cleancache_filekey</span><span class="p">)</span> <span class="o">!=</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_oid</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pagesize</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">zcache_local_new_pool</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_cleancache_init_shared_fs</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uuid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pagesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* shared pools are unsupported and map to private */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cleancache_filekey</span><span class="p">)</span> <span class="o">!=</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_oid</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pagesize</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">zcache_local_new_pool</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cleancache_ops</span> <span class="n">zcache_cleancache_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">put_page</span> <span class="o">=</span> <span class="n">zcache_cleancache_put_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_page</span> <span class="o">=</span> <span class="n">zcache_cleancache_get_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidate_page</span> <span class="o">=</span> <span class="n">zcache_cleancache_flush_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidate_inode</span> <span class="o">=</span> <span class="n">zcache_cleancache_flush_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidate_fs</span> <span class="o">=</span> <span class="n">zcache_cleancache_flush_fs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_shared_fs</span> <span class="o">=</span> <span class="n">zcache_cleancache_init_shared_fs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_fs</span> <span class="o">=</span> <span class="n">zcache_cleancache_init_fs</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cleancache_ops</span> <span class="nf">zcache_cleancache_register_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cleancache_ops</span> <span class="n">old_ops</span> <span class="o">=</span>
		<span class="n">cleancache_register_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_cleancache_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old_ops</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
<span class="cm">/* a single tmem poolid is used for all frontswap &quot;types&quot; (swapfiles) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">zcache_frontswap_poolid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Swizzling increases objects per swaptype, increasing tmem concurrency</span>
<span class="cm"> * for heavy swaploads.  Later, larger nr_cpus -&gt; larger SWIZ_BITS</span>
<span class="cm"> */</span>
<span class="cp">#define SWIZ_BITS		8</span>
<span class="cp">#define SWIZ_MASK		((1 &lt;&lt; SWIZ_BITS) - 1)</span>
<span class="cp">#define _oswiz(_type, _ind)	((_type &lt;&lt; SWIZ_BITS) | (_ind &amp; SWIZ_MASK))</span>
<span class="cp">#define iswiz(_ind)		(_ind &gt;&gt; SWIZ_BITS)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tmem_oid</span> <span class="nf">oswiz</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>
	<span class="n">oid</span><span class="p">.</span><span class="n">oid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_oswiz</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">oid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_frontswap_store</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ind64</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="n">oswiz</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kva</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ind64</span> <span class="o">==</span> <span class="n">ind</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">kva</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">zcache_put</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">zcache_frontswap_poolid</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">oid</span><span class="p">,</span> <span class="n">iswiz</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">kva</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns 0 if the page was successfully gotten from frontswap, -1 if</span>
<span class="cm"> * was not present (should never happen!) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zcache_frontswap_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ind64</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="n">oswiz</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span> <span class="cm">/* FIXME, remove this? */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ind64</span> <span class="o">==</span> <span class="n">ind</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">kva</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">zcache_get</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">zcache_frontswap_poolid</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">oid</span><span class="p">,</span> <span class="n">iswiz</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">kva</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span> <span class="cm">/* FIXME, remove this? */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* flush a single page from frontswap */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_frontswap_flush_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ind64</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span> <span class="o">=</span> <span class="n">oswiz</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ind64</span> <span class="o">==</span> <span class="n">ind</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">zcache_flush</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span> <span class="n">zcache_frontswap_poolid</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">oid</span><span class="p">,</span> <span class="n">iswiz</span><span class="p">(</span><span class="n">ind</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* flush all pages from the passed swaptype */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_frontswap_flush_area</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tmem_oid</span> <span class="n">oid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ind</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ind</span> <span class="o">=</span> <span class="n">SWIZ_MASK</span><span class="p">;</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ind</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oid</span> <span class="o">=</span> <span class="n">oswiz</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">zcache_flush_object</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">,</span>
						<span class="n">zcache_frontswap_poolid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zcache_frontswap_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ignored</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* a single tmem poolid is used for all frontswap &quot;types&quot; (swapfiles) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zcache_frontswap_poolid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">zcache_frontswap_poolid</span> <span class="o">=</span>
				<span class="n">zcache_local_new_pool</span><span class="p">(</span><span class="n">TMEM_POOL_PERSIST</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">frontswap_ops</span> <span class="n">zcache_frontswap_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">zcache_frontswap_store</span><span class="p">,</span>
	<span class="p">.</span><span class="n">load</span> <span class="o">=</span> <span class="n">zcache_frontswap_load</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidate_page</span> <span class="o">=</span> <span class="n">zcache_frontswap_flush_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidate_area</span> <span class="o">=</span> <span class="n">zcache_frontswap_flush_area</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">zcache_frontswap_init</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">frontswap_ops</span> <span class="nf">zcache_frontswap_register_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">frontswap_ops</span> <span class="n">old_ops</span> <span class="o">=</span>
		<span class="n">frontswap_register_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_frontswap_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old_ops</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * frontswap selfshrinking</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
<span class="cm">/* In HZ, controls frequency of worker invocation. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selfshrink_interval</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">selfshrink_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">selfshrink_worker</span><span class="p">,</span> <span class="n">selfshrink_process</span><span class="p">);</span>

<span class="cm">/* Enable/disable with sysfs. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">frontswap_selfshrinking</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Enable/disable with kernel boot option. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">use_frontswap_selfshrink</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The default values for the following parameters were deemed reasonable</span>
<span class="cm"> * by experimentation, may be workload-dependent, and can all be</span>
<span class="cm"> * adjusted via sysfs.</span>
<span class="cm"> */</span>

<span class="cm">/* Control rate for frontswap shrinking. Higher hysteresis is slower. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frontswap_hysteresis</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Number of selfshrink worker invocations to wait before observing that</span>
<span class="cm"> * frontswap selfshrinking should commence. Note that selfshrinking does</span>
<span class="cm"> * not use a separate worker thread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frontswap_inertia</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="cm">/* Countdown to next invocation of frontswap_shrink() */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">frontswap_inertia_counter</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Invoked by the selfshrink worker thread, uses current number of pages</span>
<span class="cm"> * in frontswap (frontswap_curr_pages()), previous status, and control</span>
<span class="cm"> * values (hysteresis and inertia) to determine if frontswap should be</span>
<span class="cm"> * shrunk and what the new frontswap size should be.  Note that</span>
<span class="cm"> * frontswap_shrink is essentially a partial swapoff that immediately</span>
<span class="cm"> * transfers pages from the &quot;swap device&quot; (frontswap) back into kernel</span>
<span class="cm"> * RAM; despite the name, frontswap &quot;shrinking&quot; is very different from</span>
<span class="cm"> * the &quot;shrinker&quot; interface used by the kernel MM subsystem to reclaim</span>
<span class="cm"> * memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">frontswap_selfshrink</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur_frontswap_pages</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_frontswap_pages</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tgt_frontswap_pages</span><span class="p">;</span>

	<span class="n">last_frontswap_pages</span> <span class="o">=</span> <span class="n">cur_frontswap_pages</span><span class="p">;</span>
	<span class="n">cur_frontswap_pages</span> <span class="o">=</span> <span class="n">frontswap_curr_pages</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur_frontswap_pages</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">cur_frontswap_pages</span> <span class="o">&gt;</span> <span class="n">last_frontswap_pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">frontswap_inertia_counter</span> <span class="o">=</span> <span class="n">frontswap_inertia</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_inertia_counter</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">frontswap_inertia_counter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_frontswap_pages</span> <span class="o">&lt;=</span> <span class="n">frontswap_hysteresis</span><span class="p">)</span>
		<span class="n">tgt_frontswap_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tgt_frontswap_pages</span> <span class="o">=</span> <span class="n">cur_frontswap_pages</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">cur_frontswap_pages</span> <span class="o">/</span> <span class="n">frontswap_hysteresis</span><span class="p">);</span>
	<span class="n">frontswap_shrink</span><span class="p">(</span><span class="n">tgt_frontswap_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ramster_nofrontswap_selfshrink_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">use_frontswap_selfshrink</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noselfshrink&quot;</span><span class="p">,</span> <span class="n">ramster_nofrontswap_selfshrink_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">selfshrink_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_selfshrinking</span> <span class="o">&amp;&amp;</span> <span class="n">frontswap_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frontswap_selfshrink</span><span class="p">();</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selfshrink_worker</span><span class="p">,</span>
			<span class="n">selfshrink_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ramster_enabled</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ramster_selfshrink_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">frontswap_selfshrinking</span> <span class="o">=</span> <span class="n">ramster_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">use_frontswap_selfshrink</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_selfshrinking</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: Initializing frontswap &quot;</span>
					<span class="s">&quot;selfshrinking driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selfshrink_worker</span><span class="p">,</span> <span class="n">selfshrink_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">ramster_selfshrink_init</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * zcache initialization</span>
<span class="cm"> * NOTE FOR NOW ramster MUST BE PROVIDED AS A KERNEL BOOT PARAMETER OR</span>
<span class="cm"> * NOTHING HAPPENS!</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ramster_enabled</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">enable_ramster</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ramster_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ramster&quot;</span><span class="p">,</span> <span class="n">enable_ramster</span><span class="p">);</span>

<span class="cm">/* allow independent dynamic disabling of cleancache and frontswap */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">use_cleancache</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">no_cleancache</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;INIT no_cleancache called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">use_cleancache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: need to guarantee this gets checked before zcache_init is called</span>
<span class="cm"> * What is the correct way to achieve this?</span>
<span class="cm"> */</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nocleancache&quot;</span><span class="p">,</span> <span class="n">no_cleancache</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">use_frontswap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">no_frontswap</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;INIT no_frontswap called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">use_frontswap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nofrontswap&quot;</span><span class="p">,</span> <span class="n">no_frontswap</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">zcache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="n">mm_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zcache_attr_group</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="n">mm_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ramster_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: can&#39;t create sysfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>
<span class="cp">#if defined(CONFIG_CLEANCACHE) || defined(CONFIG_FRONTSWAP)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ramster_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">r2net_register_handlers</span><span class="p">();</span>
		<span class="n">tmem_register_hostops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_hostops</span><span class="p">);</span>
		<span class="n">tmem_register_pamops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_pamops</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_cpu_notifier_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ramster: can&#39;t register cpu notifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">pcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">cpu</span><span class="p">;</span>
			<span class="n">zcache_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_cpu_notifier_block</span><span class="p">,</span>
				<span class="n">CPU_UP_PREPARE</span><span class="p">,</span> <span class="n">pcpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">zcache_objnode_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;zcache_objnode&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_objnode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">zcache_obj_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;zcache_obj&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tmem_obj</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ramster_flnode_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;ramster_flnode&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">flushlist_node</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CLEANCACHE</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;INIT ramster_enabled=%d use_cleancache=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ramster_enabled</span><span class="p">,</span> <span class="n">use_cleancache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ramster_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">use_cleancache</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cleancache_ops</span> <span class="n">old_ops</span><span class="p">;</span>

		<span class="n">zbud_init</span><span class="p">();</span>
		<span class="n">register_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zcache_shrinker</span><span class="p">);</span>
		<span class="n">old_ops</span> <span class="o">=</span> <span class="n">zcache_cleancache_register_ops</span><span class="p">();</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: cleancache enabled using kernel &quot;</span>
			<span class="s">&quot;transcendent memory and compression buddies</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_ops</span><span class="p">.</span><span class="n">init_fs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;ramster: cleancache_ops overridden&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;INIT ramster_enabled=%d use_frontswap=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ramster_enabled</span><span class="p">,</span> <span class="n">use_frontswap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ramster_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">use_frontswap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">frontswap_ops</span> <span class="n">old_ops</span><span class="p">;</span>

		<span class="n">zcache_new_client</span><span class="p">(</span><span class="n">LOCAL_CLIENT</span><span class="p">);</span>
		<span class="n">old_ops</span> <span class="o">=</span> <span class="n">zcache_frontswap_register_ops</span><span class="p">();</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ramster: frontswap enabled using kernel &quot;</span>
			<span class="s">&quot;transcendent memory and xvmalloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_ops</span><span class="p">.</span><span class="n">init</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;ramster: frontswap_ops overridden&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ramster_enabled</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">use_frontswap</span> <span class="o">||</span> <span class="n">use_cleancache</span><span class="p">))</span>
		<span class="n">ramster_remotify_init</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">zcache_init</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
