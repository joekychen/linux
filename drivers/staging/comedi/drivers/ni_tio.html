<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › ni_tio.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ni_tio.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  comedi/drivers/ni_tio.c</span>
<span class="cm">  Support for NI general purpose counters</span>

<span class="cm">  Copyright (C) 2006 Frank Mori Hess &lt;fmhess@users.sourceforge.net&gt;</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify</span>
<span class="cm">  it under the terms of the GNU General Public License as published by</span>
<span class="cm">  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">  (at your option) any later version.</span>

<span class="cm">  This program is distributed in the hope that it will be useful,</span>
<span class="cm">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">  GNU General Public License for more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License</span>
<span class="cm">  along with this program; if not, write to the Free Software</span>
<span class="cm">  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Driver: ni_tio</span>
<span class="cm">Description: National Instruments general purpose counters</span>
<span class="cm">Devices:</span>
<span class="cm">Author: J.P. Mellor &lt;jpmellor@rose-hulman.edu&gt;,</span>
<span class="cm">	Herman.Bruyninckx@mech.kuleuven.ac.be,</span>
<span class="cm">	Wim.Meeussen@mech.kuleuven.ac.be,</span>
<span class="cm">	Klaas.Gadeyne@mech.kuleuven.ac.be,</span>
<span class="cm">	Frank Mori Hess &lt;fmhess@users.sourceforge.net&gt;</span>
<span class="cm">Updated: Thu Nov 16 09:50:32 EST 2006</span>
<span class="cm">Status: works</span>

<span class="cm">This module is not used directly by end-users.  Rather, it</span>
<span class="cm">is used by other drivers (for example ni_660x and ni_pcimio)</span>
<span class="cm">to provide support for NI&#39;s general purpose counters.  It was</span>
<span class="cm">originally based on the counter code from ni_660x.c and</span>
<span class="cm">ni_mio_common.c.</span>

<span class="cm">References:</span>
<span class="cm">DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)</span>
<span class="cm">DAQ 6601/6602 User Manual (NI 322137B-01)</span>
<span class="cm">340934b.pdf  DAQ-STC reference manual</span>

<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">TODO:</span>
<span class="cm">	Support use of both banks X and Y</span>
<span class="cm">*/</span>

<span class="cp">#include &quot;ni_tio_internal.h&quot;</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">ni_tio_clock_period_ps</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="n">generic_clock_source</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">ni_tio_generic_clock_src_select</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Comedi &lt;comedi@comedi.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Comedi support for NI general-purpose counters&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">Gi_Counting_Mode_Reg_Bits</span> <span class="nf">Gi_Alternate_Sync_Bit</span><span class="p">(</span><span class="k">enum</span>
								   <span class="n">ni_gpct_variant</span>
								   <span class="n">variant</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
		<span class="k">return</span> <span class="n">Gi_M_Series_Alternate_Sync_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
		<span class="k">return</span> <span class="n">Gi_660x_Alternate_Sync_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">Gi_Counting_Mode_Reg_Bits</span> <span class="nf">Gi_Prescale_X2_Bit</span><span class="p">(</span><span class="k">enum</span>
								<span class="n">ni_gpct_variant</span>
								<span class="n">variant</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
		<span class="k">return</span> <span class="n">Gi_M_Series_Prescale_X2_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
		<span class="k">return</span> <span class="n">Gi_660x_Prescale_X2_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">Gi_Counting_Mode_Reg_Bits</span> <span class="nf">Gi_Prescale_X8_Bit</span><span class="p">(</span><span class="k">enum</span>
								<span class="n">ni_gpct_variant</span>
								<span class="n">variant</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
		<span class="k">return</span> <span class="n">Gi_M_Series_Prescale_X8_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
		<span class="k">return</span> <span class="n">Gi_660x_Prescale_X8_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">Gi_Counting_Mode_Reg_Bits</span> <span class="nf">Gi_HW_Arm_Select_Mask</span><span class="p">(</span><span class="k">enum</span>
								   <span class="n">ni_gpct_variant</span>
								   <span class="n">variant</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
		<span class="k">return</span> <span class="n">Gi_M_Series_HW_Arm_Select_Mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
		<span class="k">return</span> <span class="n">Gi_660x_HW_Arm_Select_Mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* clock sources for ni_660x boards, get bits with Gi_Source_Select_Bits() */</span>
<span class="k">enum</span> <span class="n">ni_660x_clock_source</span> <span class="p">{</span>
	<span class="n">NI_660x_Timebase_1_Clock</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="cm">/* 20MHz */</span>
	<span class="n">NI_660x_Source_Pin_i_Clock</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">NI_660x_Next_Gate_Clock</span> <span class="o">=</span> <span class="mh">0xa</span><span class="p">,</span>
	<span class="n">NI_660x_Timebase_2_Clock</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>	<span class="cm">/* 100KHz */</span>
	<span class="n">NI_660x_Next_TC_Clock</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">NI_660x_Timebase_3_Clock</span> <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span>	<span class="cm">/* 80MHz */</span>
	<span class="n">NI_660x_Logic_Low_Clock</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ni_660x_max_rtsi_channel</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_660x_RTSI_Clock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">);</span>
	<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ni_660x_max_source_pin</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_660x_Source_Pin_Clock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_660x_max_source_pin</span><span class="p">);</span>
	<span class="k">return</span> <span class="mh">0x2</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* clock sources for ni e and m series boards, get bits with Gi_Source_Select_Bits() */</span>
<span class="k">enum</span> <span class="n">ni_m_series_clock_source</span> <span class="p">{</span>
	<span class="n">NI_M_Series_Timebase_1_Clock</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="cm">/* 20MHz */</span>
	<span class="n">NI_M_Series_Timebase_2_Clock</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>	<span class="cm">/* 100KHz */</span>
	<span class="n">NI_M_Series_Next_TC_Clock</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">NI_M_Series_Next_Gate_Clock</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>	<span class="cm">/* when Gi_Src_SubSelect = 0 */</span>
	<span class="n">NI_M_Series_PXI_Star_Trigger_Clock</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>	<span class="cm">/* when Gi_Src_SubSelect = 1 */</span>
	<span class="n">NI_M_Series_PXI10_Clock</span> <span class="o">=</span> <span class="mh">0x1d</span><span class="p">,</span>
	<span class="n">NI_M_Series_Timebase_3_Clock</span> <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span>	<span class="cm">/* 80MHz, when Gi_Src_SubSelect = 0 */</span>
	<span class="n">NI_M_Series_Analog_Trigger_Out_Clock</span> <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span>	<span class="cm">/* when Gi_Src_SubSelect = 1 */</span>
	<span class="n">NI_M_Series_Logic_Low_Clock</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ni_m_series_max_pfi_channel</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_M_Series_PFI_Clock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ni_m_series_max_rtsi_channel</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_M_Series_RTSI_Clock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
		<span class="k">return</span> <span class="mh">0x1b</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ni_660x_gate_select</span> <span class="p">{</span>
	<span class="n">NI_660x_Source_Pin_i_Gate_Select</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">NI_660x_Gate_Pin_i_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">NI_660x_Next_SRC_Gate_Select</span> <span class="o">=</span> <span class="mh">0xa</span><span class="p">,</span>
	<span class="n">NI_660x_Next_Out_Gate_Select</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">NI_660x_Logic_Low_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ni_660x_max_gate_pin</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_660x_Gate_Pin_Gate_Select</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_660x_max_gate_pin</span><span class="p">);</span>
	<span class="k">return</span> <span class="mh">0x2</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_660x_RTSI_Gate_Select</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">);</span>
	<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ni_m_series_gate_select</span> <span class="p">{</span>
	<span class="n">NI_M_Series_Timestamp_Mux_Gate_Select</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">NI_M_Series_AI_START2_Gate_Select</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>
	<span class="n">NI_M_Series_PXI_Star_Trigger_Gate_Select</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">NI_M_Series_Next_Out_Gate_Select</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">NI_M_Series_AI_START1_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1c</span><span class="p">,</span>
	<span class="n">NI_M_Series_Next_SRC_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1d</span><span class="p">,</span>
	<span class="n">NI_M_Series_Analog_Trigger_Out_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span>
	<span class="n">NI_M_Series_Logic_Low_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_M_Series_RTSI_Gate_Select</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
		<span class="k">return</span> <span class="mh">0x1b</span><span class="p">;</span>
	<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_M_Series_PFI_Gate_Select</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">Gi_Source_Select_Bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">source</span> <span class="o">&lt;&lt;</span> <span class="n">Gi_Source_Select_Shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Gi_Source_Select_Mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">Gi_Gate_Select_Bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gate_select</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">gate_select</span> <span class="o">&lt;&lt;</span> <span class="n">Gi_Gate_Select_Shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Gi_Gate_Select_Mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ni_660x_second_gate_select</span> <span class="p">{</span>
	<span class="n">NI_660x_Source_Pin_i_Second_Gate_Select</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">NI_660x_Up_Down_Pin_i_Second_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">NI_660x_Next_SRC_Second_Gate_Select</span> <span class="o">=</span> <span class="mh">0xa</span><span class="p">,</span>
	<span class="n">NI_660x_Next_Out_Second_Gate_Select</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">NI_660x_Selected_Gate_Second_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span>
	<span class="n">NI_660x_Logic_Low_Second_Gate_Select</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">ni_660x_max_up_down_pin</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_660x_Up_Down_Pin_Second_Gate_Select</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_660x_max_up_down_pin</span><span class="p">);</span>
	<span class="k">return</span> <span class="mh">0x2</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_660x_RTSI_Second_Gate_Select</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">);</span>
	<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counter_status_mask</span> <span class="o">=</span>
    <span class="n">COMEDI_COUNTER_ARMED</span> <span class="o">|</span> <span class="n">COMEDI_COUNTER_COUNTING</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ni_tio_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ni_tio_init_module</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ni_tio_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">ni_tio_cleanup_module</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="nf">ni_gpct_device_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_register</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span>
									<span class="n">ni_gpct</span>
									<span class="o">*</span>
									<span class="n">counter</span><span class="p">,</span>
									<span class="kt">unsigned</span>
									<span class="n">bits</span><span class="p">,</span>
									<span class="k">enum</span>
									<span class="n">ni_gpct_register</span>
									<span class="n">reg</span><span class="p">),</span>
						<span class="kt">unsigned</span> <span class="p">(</span><span class="o">*</span><span class="n">read_register</span><span class="p">)</span>
						<span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
						 <span class="k">enum</span> <span class="n">ni_gpct_register</span> <span class="n">reg</span><span class="p">),</span>
						<span class="k">enum</span> <span class="n">ni_gpct_variant</span> <span class="n">variant</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="n">num_counters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span>
	    <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">write_register</span> <span class="o">=</span> <span class="n">write_register</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">read_register</span> <span class="o">=</span> <span class="n">read_register</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span> <span class="o">=</span> <span class="n">variant</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_counters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span>
	    <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_counters</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter_dev</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">num_counters</span> <span class="o">=</span> <span class="n">num_counters</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">counter_dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_gpct_device_construct</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ni_gpct_device_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_gpct_device_destroy</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_tio_second_gate_registers_present</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct_device</span>
						<span class="o">*</span><span class="n">counter_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
	<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ni_tio_reset_count_and_disarm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">Gi_Reset_Bit</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
		       <span class="n">NITIO_Gxx_Joint_Reset_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ni_tio_init_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>

	<span class="n">ni_tio_reset_count_and_disarm</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
	<span class="cm">/* initialize counter registers */</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_Autoincrement_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)]</span> <span class="o">=</span>
	    <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
		       <span class="n">counter_dev</span><span class="o">-&gt;</span>
		       <span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_Autoincrement_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)],</span>
		       <span class="n">NITIO_Gi_Autoincrement_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">NITIO_Gi_Command_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">Gi_Synchronize_Gate_Bit</span><span class="p">);</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">NITIO_Gi_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">);</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadA_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
		       <span class="n">counter_dev</span><span class="o">-&gt;</span>
		       <span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadA_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)],</span>
		       <span class="n">NITIO_Gi_LoadA_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadB_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
		       <span class="n">counter_dev</span><span class="o">-&gt;</span>
		       <span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadB_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)],</span>
		       <span class="n">NITIO_Gi_LoadB_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">NITIO_Gi_Input_Select_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_counting_mode_registers_present</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				<span class="n">NITIO_Gi_Counting_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							   <span class="n">counter_index</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_second_gate_registers_present</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">counter_dev</span><span class="o">-&gt;</span>
		    <span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)]</span> <span class="o">=</span>
		    <span class="mh">0x0</span><span class="p">;</span>
		<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			       <span class="n">counter_dev</span><span class="o">-&gt;</span>
			       <span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_Second_Gate_Reg</span>
				    <span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)],</span>
			       <span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							<span class="n">counter_index</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">NITIO_Gi_DMA_Config_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
			<span class="mh">0x0</span><span class="p">);</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">NITIO_Gi_Interrupt_Enable_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_tio_init_counter</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ni_tio_counter_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">read_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
					    <span class="n">NITIO_Gxx_Status_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
								 <span class="n">counter_index</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">Gi_Armed_Bit</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">COMEDI_COUNTER_ARMED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">Gi_Counting_Bit</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">COMEDI_COUNTER_COUNTING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ni_tio_set_sync_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_alt_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">counting_mode_reg</span> <span class="o">=</span>
	    <span class="n">NITIO_Gi_Counting_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">min_normal_sync_period_ps</span> <span class="o">=</span> <span class="mi">25000</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">clock_period_ps</span> <span class="o">=</span> <span class="n">ni_tio_clock_period_ps</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
								<span class="n">ni_tio_generic_clock_src_select</span>
								<span class="p">(</span><span class="n">counter</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_counting_mode_registers_present</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ni_tio_get_soft_copy</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counting_mode_reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Gi_Counting_Mode_Mask</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">Gi_Counting_Mode_QuadratureX1_Bits</span>:
	<span class="k">case</span> <span class="n">Gi_Counting_Mode_QuadratureX2_Bits</span>:
	<span class="k">case</span> <span class="n">Gi_Counting_Mode_QuadratureX4_Bits</span>:
	<span class="k">case</span> <span class="n">Gi_Counting_Mode_Sync_Source_Bits</span>:
		<span class="n">force_alt_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* It&#39;s not clear what we should do if clock_period is unknown, so we are not</span>
<span class="cm">	   using the alt sync bit in that case, but allow the caller to decide by using the</span>
<span class="cm">	   force_alt_sync parameter. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force_alt_sync</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">clock_period_ps</span> <span class="o">&amp;&amp;</span> <span class="n">clock_period_ps</span> <span class="o">&lt;</span> <span class="n">min_normal_sync_period_ps</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counting_mode_reg</span><span class="p">,</span>
				<span class="n">Gi_Alternate_Sync_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">),</span>
				<span class="n">Gi_Alternate_Sync_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counting_mode_reg</span><span class="p">,</span>
				<span class="n">Gi_Alternate_Sync_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">),</span>
				<span class="mh">0x0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_tio_set_counter_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mode_reg_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mode_reg_values</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">input_select_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* these bits map directly on to the mode register */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">mode_reg_direct_mask</span> <span class="o">=</span>
	    <span class="n">NI_GPCT_GATE_ON_BOTH_EDGES_BIT</span> <span class="o">|</span> <span class="n">NI_GPCT_EDGE_GATE_MODE_MASK</span> <span class="o">|</span>
	    <span class="n">NI_GPCT_STOP_MODE_MASK</span> <span class="o">|</span> <span class="n">NI_GPCT_OUTPUT_MODE_MASK</span> <span class="o">|</span>
	    <span class="n">NI_GPCT_HARDWARE_DISARM_MASK</span> <span class="o">|</span> <span class="n">NI_GPCT_LOADING_ON_TC_BIT</span> <span class="o">|</span>
	    <span class="n">NI_GPCT_LOADING_ON_GATE_BIT</span> <span class="o">|</span> <span class="n">NI_GPCT_LOAD_B_SELECT_BIT</span><span class="p">;</span>

	<span class="n">mode_reg_mask</span> <span class="o">=</span> <span class="n">mode_reg_direct_mask</span> <span class="o">|</span> <span class="n">Gi_Reload_Source_Switching_Bit</span><span class="p">;</span>
	<span class="n">mode_reg_values</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">mode_reg_direct_mask</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_RELOAD_SOURCE_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_RELOAD_SOURCE_FIXED_BITS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS</span>:
		<span class="n">mode_reg_values</span> <span class="o">|=</span> <span class="n">Gi_Reload_Source_Switching_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS</span>:
		<span class="n">input_select_bits</span> <span class="o">|=</span> <span class="n">Gi_Gate_Select_Load_Source_Bit</span><span class="p">;</span>
		<span class="n">mode_reg_mask</span> <span class="o">|=</span> <span class="n">Gi_Gating_Mode_Mask</span><span class="p">;</span>
		<span class="n">mode_reg_values</span> <span class="o">|=</span> <span class="n">Gi_Level_Gating_Bits</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">NITIO_Gi_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="n">mode_reg_mask</span><span class="p">,</span> <span class="n">mode_reg_values</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_counting_mode_registers_present</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">counting_mode_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">counting_mode_bits</span> <span class="o">|=</span>
		    <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;&gt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">Gi_Counting_Mode_Mask</span><span class="p">;</span>
		<span class="n">counting_mode_bits</span> <span class="o">|=</span>
		    <span class="p">((</span><span class="n">mode</span> <span class="o">&gt;&gt;</span> <span class="n">NI_GPCT_INDEX_PHASE_BITSHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
		     <span class="n">Gi_Index_Phase_Bitshift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Gi_Index_Phase_Mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_INDEX_ENABLE_BIT</span><span class="p">)</span>
			<span class="n">counting_mode_bits</span> <span class="o">|=</span> <span class="n">Gi_Index_Mode_Bit</span><span class="p">;</span>
		<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				<span class="n">NITIO_Gi_Counting_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							   <span class="n">counter_index</span><span class="p">),</span>
				<span class="n">Gi_Counting_Mode_Mask</span> <span class="o">|</span> <span class="n">Gi_Index_Phase_Mask</span> <span class="o">|</span>
				<span class="n">Gi_Index_Mode_Bit</span><span class="p">,</span> <span class="n">counting_mode_bits</span><span class="p">);</span>
		<span class="n">ni_tio_set_sync_mode</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">NITIO_Gi_Command_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="n">Gi_Up_Down_Mask</span><span class="p">,</span>
			<span class="p">(</span><span class="n">mode</span> <span class="o">&gt;&gt;</span> <span class="n">NI_GPCT_COUNTING_DIRECTION_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			<span class="n">Gi_Up_Down_Shift</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_OR_GATE_BIT</span><span class="p">)</span>
		<span class="n">input_select_bits</span> <span class="o">|=</span> <span class="n">Gi_Or_Gate_Bit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_INVERT_OUTPUT_BIT</span><span class="p">)</span>
		<span class="n">input_select_bits</span> <span class="o">|=</span> <span class="n">Gi_Output_Polarity_Bit</span><span class="p">;</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">NITIO_Gi_Input_Select_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="n">Gi_Gate_Select_Load_Source_Bit</span> <span class="o">|</span> <span class="n">Gi_Or_Gate_Bit</span> <span class="o">|</span>
			<span class="n">Gi_Output_Polarity_Bit</span><span class="p">,</span> <span class="n">input_select_bits</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ni_tio_arm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">start_trigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">command_transient_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">start_trigger</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NI_GPCT_ARM_IMMEDIATE</span>:
			<span class="n">command_transient_bits</span> <span class="o">|=</span> <span class="n">Gi_Arm_Bit</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NI_GPCT_ARM_PAIRED_IMMEDIATE</span>:
			<span class="n">command_transient_bits</span> <span class="o">|=</span> <span class="n">Gi_Arm_Bit</span> <span class="o">|</span> <span class="n">Gi_Arm_Copy_Bit</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_counting_mode_registers_present</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">counting_mode_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">start_trigger</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">NI_GPCT_ARM_IMMEDIATE</span>:
			<span class="k">case</span> <span class="n">NI_GPCT_ARM_PAIRED_IMMEDIATE</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">start_trigger</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_ARM_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* pass-through the least significant bits so we can figure out what select later */</span>
					<span class="kt">unsigned</span> <span class="n">hw_arm_select_bits</span> <span class="o">=</span>
					    <span class="p">(</span><span class="n">start_trigger</span> <span class="o">&lt;&lt;</span>
					     <span class="n">Gi_HW_Arm_Select_Shift</span><span class="p">)</span> <span class="o">&amp;</span>
					    <span class="n">Gi_HW_Arm_Select_Mask</span>
					    <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">);</span>

					<span class="n">counting_mode_bits</span> <span class="o">|=</span>
					    <span class="n">Gi_HW_Arm_Enable_Bit</span> <span class="o">|</span>
					    <span class="n">hw_arm_select_bits</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
					<span class="n">NITIO_Gi_Counting_Mode_Reg</span>
					<span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
					<span class="n">Gi_HW_Arm_Select_Mask</span>
					<span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">Gi_HW_Arm_Enable_Bit</span><span class="p">,</span>
					<span class="n">counting_mode_bits</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">command_transient_bits</span> <span class="o">|=</span> <span class="n">Gi_Disarm_Bit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ni_tio_set_bits_transient</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				  <span class="n">NITIO_Gi_Command_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
				  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">command_transient_bits</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_tio_arm</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_660x_source_select_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ni_660x_clock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">clock_select_bits</span> <span class="o">=</span>
	    <span class="n">clock_source</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_CLOCK_SRC_SELECT_MASK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">clock_select_bits</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS</span>:
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Timebase_1_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS</span>:
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Timebase_2_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS</span>:
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Timebase_3_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS</span>:
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Logic_Low_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS</span>:
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Source_Pin_i_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS</span>:
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Next_Gate_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_TC_CLOCK_SRC_BITS</span>:
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Next_TC_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clock_select_bits</span> <span class="o">==</span> <span class="n">NI_GPCT_RTSI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_RTSI_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_source_pin</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clock_select_bits</span> <span class="o">==</span>
			    <span class="n">NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="n">NI_660x_Source_Pin_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_source_pin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ni_660x_clock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">Gi_Source_Select_Bits</span><span class="p">(</span><span class="n">ni_660x_clock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_m_series_source_select_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ni_m_series_clock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">clock_select_bits</span> <span class="o">=</span>
	    <span class="n">clock_source</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_CLOCK_SRC_SELECT_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">clock_select_bits</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_Timebase_1_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_Timebase_2_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_Timebase_3_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_Logic_Low_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_Next_Gate_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_TC_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_Next_TC_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_PXI10_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_PXI10_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_PXI_Star_Trigger_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS</span>:
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_Analog_Trigger_Out_Clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clock_select_bits</span> <span class="o">==</span> <span class="n">NI_GPCT_RTSI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_RTSI_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clock_select_bits</span> <span class="o">==</span> <span class="n">NI_GPCT_PFI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="n">NI_M_Series_PFI_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;invalid clock source 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">clock_source</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="n">ni_m_series_clock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">Gi_Source_Select_Bits</span><span class="p">(</span><span class="n">ni_m_series_clock</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ni_tio_set_source_subselect</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">second_gate_reg</span> <span class="o">=</span>
	    <span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span> <span class="o">!=</span> <span class="n">ni_gpct_variant_m_series</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">clock_source</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_CLOCK_SRC_SELECT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Gi_Source_Subselect is zero */</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS</span>:
		<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">Gi_Source_Subselect_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Gi_Source_Subselect is one */</span>
	<span class="k">case</span> <span class="n">NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS</span>:
		<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">Gi_Source_Subselect_Bit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Gi_Source_Subselect doesn&#39;t matter */</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">],</span>
		       <span class="n">second_gate_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_tio_set_clock_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_source</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">input_select_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">pico_per_nano</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="cm">/*FIXME: validate clock source */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
		<span class="n">input_select_bits</span> <span class="o">|=</span> <span class="n">ni_660x_source_select_bits</span><span class="p">(</span><span class="n">clock_source</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
	<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
		<span class="n">input_select_bits</span> <span class="o">|=</span>
		    <span class="n">ni_m_series_source_select_bits</span><span class="p">(</span><span class="n">clock_source</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clock_source</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_INVERT_CLOCK_SRC_BIT</span><span class="p">)</span>
		<span class="n">input_select_bits</span> <span class="o">|=</span> <span class="n">Gi_Source_Polarity_Bit</span><span class="p">;</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">NITIO_Gi_Input_Select_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="n">Gi_Source_Select_Mask</span> <span class="o">|</span> <span class="n">Gi_Source_Polarity_Bit</span><span class="p">,</span>
			<span class="n">input_select_bits</span><span class="p">);</span>
	<span class="n">ni_tio_set_source_subselect</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">clock_source</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_counting_mode_registers_present</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">prescaling_mode</span> <span class="o">=</span>
		    <span class="n">clock_source</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">counting_mode_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">prescaling_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS</span>:
			<span class="n">counting_mode_bits</span> <span class="o">|=</span>
			    <span class="n">Gi_Prescale_X2_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS</span>:
			<span class="n">counting_mode_bits</span> <span class="o">|=</span>
			    <span class="n">Gi_Prescale_X8_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				<span class="n">NITIO_Gi_Counting_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							   <span class="n">counter_index</span><span class="p">),</span>
				<span class="n">Gi_Prescale_X2_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">Gi_Prescale_X8_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">),</span>
				<span class="n">counting_mode_bits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">counter</span><span class="o">-&gt;</span><span class="n">clock_period_ps</span> <span class="o">=</span> <span class="n">pico_per_nano</span> <span class="o">*</span> <span class="n">period_ns</span><span class="p">;</span>
	<span class="n">ni_tio_set_sync_mode</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_tio_clock_src_modifiers</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">counting_mode_bits</span> <span class="o">=</span> <span class="n">ni_tio_get_soft_copy</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
								 <span class="n">NITIO_Gi_Counting_Mode_Reg</span>
								 <span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
								  <span class="n">counter_index</span><span class="p">));</span>
	<span class="kt">unsigned</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_get_soft_copy</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				 <span class="n">NITIO_Gi_Input_Select_Reg</span>
				 <span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">))</span> <span class="o">&amp;</span>
	    <span class="n">Gi_Source_Polarity_Bit</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">NI_GPCT_INVERT_CLOCK_SRC_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counting_mode_bits</span> <span class="o">&amp;</span> <span class="n">Gi_Prescale_X2_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">))</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counting_mode_bits</span> <span class="o">&amp;</span> <span class="n">Gi_Prescale_X8_Bit</span><span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">))</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_m_series_clock_src_select</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">second_gate_reg</span> <span class="o">=</span>
	    <span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">clock_source</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">input_select</span> <span class="o">=</span> <span class="p">(</span><span class="n">ni_tio_get_soft_copy</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
							    <span class="n">NITIO_Gi_Input_Select_Reg</span>
							    <span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">))</span>
				       <span class="o">&amp;</span> <span class="n">Gi_Source_Select_Mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
	    <span class="n">Gi_Source_Select_Shift</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">input_select</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Timebase_1_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Timebase_2_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Timebase_3_Clock</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;</span>
		    <span class="n">Gi_Source_Subselect_Bit</span><span class="p">)</span>
			<span class="n">clock_source</span> <span class="o">=</span>
			    <span class="n">NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Logic_Low_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Next_Gate_Clock</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;</span>
		    <span class="n">Gi_Source_Subselect_Bit</span><span class="p">)</span>
			<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_PXI10_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_PXI10_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Next_TC_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_NEXT_TC_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">input_select</span> <span class="o">==</span> <span class="n">NI_M_Series_RTSI_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_RTSI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">input_select</span> <span class="o">==</span> <span class="n">NI_M_Series_PFI_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_PFI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clock_source</span> <span class="o">|=</span> <span class="n">ni_tio_clock_src_modifiers</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">clock_source</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_660x_clock_src_select</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">clock_source</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">input_select</span> <span class="o">=</span> <span class="p">(</span><span class="n">ni_tio_get_soft_copy</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
							    <span class="n">NITIO_Gi_Input_Select_Reg</span>
							    <span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">))</span>
				       <span class="o">&amp;</span> <span class="n">Gi_Source_Select_Mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
	    <span class="n">Gi_Source_Select_Shift</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">input_select</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_660x_Timebase_1_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Timebase_2_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Timebase_3_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Logic_Low_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Source_Pin_i_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Next_Gate_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Next_TC_Clock</span>:
		<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_NEXT_TC_CLOCK_SRC_BITS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">input_select</span> <span class="o">==</span> <span class="n">NI_660x_RTSI_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">clock_source</span> <span class="o">=</span> <span class="n">NI_GPCT_RTSI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_source_pin</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">input_select</span> <span class="o">==</span> <span class="n">NI_660x_Source_Pin_Clock</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">clock_source</span> <span class="o">=</span>
				    <span class="n">NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_source_pin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clock_source</span> <span class="o">|=</span> <span class="n">ni_tio_clock_src_modifiers</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">clock_source</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_tio_generic_clock_src_select</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
	<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
		<span class="k">return</span> <span class="n">ni_m_series_clock_src_select</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
		<span class="k">return</span> <span class="n">ni_660x_clock_src_select</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">ni_tio_clock_period_ps</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="n">generic_clock_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">clock_period_ps</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">generic_clock_source</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_CLOCK_SRC_SELECT_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS</span>:
		<span class="n">clock_period_ps</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS</span>:
		<span class="n">clock_period_ps</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS</span>:
		<span class="n">clock_period_ps</span> <span class="o">=</span> <span class="mi">12500</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_PXI10_CLOCK_SRC_BITS</span>:
		<span class="n">clock_period_ps</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* clock period is specified by user with prescaling already taken into account. */</span>
		<span class="k">return</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">clock_period_ps</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">generic_clock_source</span> <span class="o">&amp;</span> <span class="n">NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS</span>:
		<span class="n">clock_period_ps</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS</span>:
		<span class="n">clock_period_ps</span> <span class="o">*=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">clock_period_ps</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ni_tio_get_clock_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">clock_source</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">period_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">pico_per_nano</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">temp64</span><span class="p">;</span>
	<span class="o">*</span><span class="n">clock_source</span> <span class="o">=</span> <span class="n">ni_tio_generic_clock_src_select</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
	<span class="n">temp64</span> <span class="o">=</span> <span class="n">ni_tio_clock_period_ps</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="o">*</span><span class="n">clock_source</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">temp64</span><span class="p">,</span> <span class="n">pico_per_nano</span><span class="p">);</span>
	<span class="o">*</span><span class="n">period_ns</span> <span class="o">=</span> <span class="n">temp64</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ni_tio_set_first_gate_modifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gate_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">mode_mask</span> <span class="o">=</span> <span class="n">Gi_Gate_Polarity_Bit</span> <span class="o">|</span> <span class="n">Gi_Gating_Mode_Mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mode_values</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gate_source</span> <span class="o">&amp;</span> <span class="n">CR_INVERT</span><span class="p">)</span>
		<span class="n">mode_values</span> <span class="o">|=</span> <span class="n">Gi_Gate_Polarity_Bit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gate_source</span> <span class="o">&amp;</span> <span class="n">CR_EDGE</span><span class="p">)</span>
		<span class="n">mode_values</span> <span class="o">|=</span> <span class="n">Gi_Rising_Edge_Gating_Bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mode_values</span> <span class="o">|=</span> <span class="n">Gi_Level_Gating_Bits</span><span class="p">;</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">NITIO_Gi_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="n">mode_mask</span><span class="p">,</span> <span class="n">mode_values</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_660x_set_first_gate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gate_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_gate</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">gate_source</span><span class="p">);</span>
	<span class="cm">/* bits of selected_gate that may be meaningful to input select register */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_gate_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ni_660x_gate_select</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">selected_gate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_SOURCE_GATE_SELECT</span>:
		<span class="n">ni_660x_gate_select</span> <span class="o">=</span> <span class="n">NI_660x_Next_SRC_Gate_Select</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_OUT_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_LOGIC_LOW_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_SOURCE_PIN_i_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_GATE_PIN_i_GATE_SELECT</span>:
		<span class="n">ni_660x_gate_select</span> <span class="o">=</span> <span class="n">selected_gate</span> <span class="o">&amp;</span> <span class="n">selected_gate_mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selected_gate</span> <span class="o">==</span> <span class="n">NI_GPCT_RTSI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_660x_gate_select</span> <span class="o">=</span>
				    <span class="n">selected_gate</span> <span class="o">&amp;</span> <span class="n">selected_gate_mask</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_gate_pin</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selected_gate</span> <span class="o">==</span> <span class="n">NI_GPCT_GATE_PIN_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_660x_gate_select</span> <span class="o">=</span>
				    <span class="n">selected_gate</span> <span class="o">&amp;</span> <span class="n">selected_gate_mask</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_gate_pin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">NITIO_Gi_Input_Select_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="n">Gi_Gate_Select_Mask</span><span class="p">,</span>
			<span class="n">Gi_Gate_Select_Bits</span><span class="p">(</span><span class="n">ni_660x_gate_select</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_m_series_set_first_gate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gate_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_gate</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">gate_source</span><span class="p">);</span>
	<span class="cm">/* bits of selected_gate that may be meaningful to input select register */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_gate_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ni_m_series_gate_select</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">selected_gate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_TIMESTAMP_MUX_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_AI_START2_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_OUT_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_AI_START1_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_SOURCE_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_LOGIC_LOW_GATE_SELECT</span>:
		<span class="n">ni_m_series_gate_select</span> <span class="o">=</span> <span class="n">selected_gate</span> <span class="o">&amp;</span> <span class="n">selected_gate_mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selected_gate</span> <span class="o">==</span> <span class="n">NI_GPCT_RTSI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_m_series_gate_select</span> <span class="o">=</span>
				    <span class="n">selected_gate</span> <span class="o">&amp;</span> <span class="n">selected_gate_mask</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selected_gate</span> <span class="o">==</span> <span class="n">NI_GPCT_PFI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_m_series_gate_select</span> <span class="o">=</span>
				    <span class="n">selected_gate</span> <span class="o">&amp;</span> <span class="n">selected_gate_mask</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">NITIO_Gi_Input_Select_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
			<span class="n">Gi_Gate_Select_Mask</span><span class="p">,</span>
			<span class="n">Gi_Gate_Select_Bits</span><span class="p">(</span><span class="n">ni_m_series_gate_select</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_660x_set_second_gate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gate_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">second_gate_reg</span> <span class="o">=</span>
	    <span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_second_gate</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">gate_source</span><span class="p">);</span>
	<span class="cm">/* bits of second_gate that may be meaningful to second gate register */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_second_gate_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ni_660x_second_gate_select</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">selected_second_gate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_GPCT_SOURCE_PIN_i_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_SELECTED_GATE_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_OUT_GATE_SELECT</span>:
	<span class="k">case</span> <span class="n">NI_GPCT_LOGIC_LOW_GATE_SELECT</span>:
		<span class="n">ni_660x_second_gate_select</span> <span class="o">=</span>
		    <span class="n">selected_second_gate</span> <span class="o">&amp;</span> <span class="n">selected_second_gate_mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_GPCT_NEXT_SOURCE_GATE_SELECT</span>:
		<span class="n">ni_660x_second_gate_select</span> <span class="o">=</span>
		    <span class="n">NI_660x_Next_SRC_Second_Gate_Select</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selected_second_gate</span> <span class="o">==</span> <span class="n">NI_GPCT_RTSI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_660x_second_gate_select</span> <span class="o">=</span>
				    <span class="n">selected_second_gate</span> <span class="o">&amp;</span>
				    <span class="n">selected_second_gate_mask</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_up_down_pin</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selected_second_gate</span> <span class="o">==</span>
			    <span class="n">NI_GPCT_UP_DOWN_PIN_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ni_660x_second_gate_select</span> <span class="o">=</span>
				    <span class="n">selected_second_gate</span> <span class="o">&amp;</span>
				    <span class="n">selected_second_gate_mask</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_up_down_pin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">Gi_Second_Gate_Mode_Bit</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">Gi_Second_Gate_Select_Mask</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">|=</span>
	    <span class="n">Gi_Second_Gate_Select_Bits</span><span class="p">(</span><span class="n">ni_660x_second_gate_select</span><span class="p">);</span>
	<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">],</span>
		       <span class="n">second_gate_reg</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_m_series_set_second_gate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gate_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">second_gate_reg</span> <span class="o">=</span>
	    <span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_second_gate</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">gate_source</span><span class="p">);</span>
	<span class="cm">/* bits of second_gate that may be meaningful to second gate register */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">selected_second_gate_mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ni_m_series_second_gate_select</span><span class="p">;</span>

	<span class="cm">/* FIXME: We don&#39;t know what the m-series second gate codes are, so we&#39;ll just pass</span>
<span class="cm">	   the bits through for now. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">selected_second_gate</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">ni_m_series_second_gate_select</span> <span class="o">=</span>
		    <span class="n">selected_second_gate</span> <span class="o">&amp;</span> <span class="n">selected_second_gate_mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">Gi_Second_Gate_Mode_Bit</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">Gi_Second_Gate_Select_Mask</span><span class="p">;</span>
	<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">|=</span>
	    <span class="n">Gi_Second_Gate_Select_Bits</span><span class="p">(</span><span class="n">ni_m_series_second_gate_select</span><span class="p">);</span>
	<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">],</span>
		       <span class="n">second_gate_reg</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ni_tio_set_gate_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">gate_index</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gate_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">second_gate_reg</span> <span class="o">=</span>
	    <span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">gate_index</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">gate_source</span><span class="p">)</span> <span class="o">==</span> <span class="n">NI_GPCT_DISABLED_GATE_SELECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
					<span class="n">NITIO_Gi_Mode_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							  <span class="n">counter_index</span><span class="p">),</span>
					<span class="n">Gi_Gating_Mode_Mask</span><span class="p">,</span>
					<span class="n">Gi_Gating_Disabled_Bits</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ni_tio_set_first_gate_modifiers</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">gate_source</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
			<span class="k">return</span> <span class="n">ni_m_series_set_first_gate</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">gate_source</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
			<span class="k">return</span> <span class="n">ni_660x_set_first_gate</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">gate_source</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ni_tio_second_gate_registers_present</span><span class="p">(</span><span class="n">counter_dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">gate_source</span><span class="p">)</span> <span class="o">==</span> <span class="n">NI_GPCT_DISABLED_GATE_SELECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;=</span>
			    <span class="o">~</span><span class="n">Gi_Second_Gate_Mode_Bit</span><span class="p">;</span>
			<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				       <span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">],</span>
				       <span class="n">second_gate_reg</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gate_source</span> <span class="o">&amp;</span> <span class="n">CR_INVERT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">|=</span>
			    <span class="n">Gi_Second_Gate_Polarity_Bit</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;=</span>
			    <span class="o">~</span><span class="n">Gi_Second_Gate_Polarity_Bit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
			<span class="k">return</span> <span class="n">ni_m_series_set_second_gate</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
							   <span class="n">gate_source</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
			<span class="k">return</span> <span class="n">ni_660x_set_second_gate</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">gate_source</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_tio_set_gate_src</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_tio_set_other_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span> <span class="o">==</span> <span class="n">ni_gpct_variant_m_series</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">abz_reg</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

		<span class="n">abz_reg</span> <span class="o">=</span> <span class="n">NITIO_Gi_ABZ_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NI_GPCT_SOURCE_ENCODER_A</span>:
			<span class="n">shift</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NI_GPCT_SOURCE_ENCODER_B</span>:
			<span class="n">shift</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NI_GPCT_SOURCE_ENCODER_Z</span>:
			<span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x1f</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">source</span> <span class="o">&gt;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Disable gate */</span>
			<span class="n">source</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">abz_reg</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">abz_reg</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">source</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">abz_reg</span><span class="p">],</span> <span class="n">abz_reg</span><span class="p">);</span>
<span class="cm">/* printk(&quot;%s %x %d %d\n&quot;, __func__, counter_dev-&gt;regs[abz_reg], index, source); */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_660x_first_gate_to_generic_gate_source</span><span class="p">(</span><span class="kt">unsigned</span>
							  <span class="n">ni_660x_gate_select</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ni_660x_gate_select</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_660x_Source_Pin_i_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_SOURCE_PIN_i_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Gate_Pin_i_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_GATE_PIN_i_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Next_SRC_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_NEXT_SOURCE_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Next_Out_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_NEXT_OUT_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Logic_Low_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_LOGIC_LOW_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ni_660x_gate_select</span> <span class="o">==</span> <span class="n">NI_660x_RTSI_Gate_Select</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">NI_GPCT_RTSI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_gate_pin</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ni_660x_gate_select</span> <span class="o">==</span>
			    <span class="n">NI_660x_Gate_Pin_Gate_Select</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">NI_GPCT_GATE_PIN_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_gate_pin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_m_series_first_gate_to_generic_gate_source</span><span class="p">(</span><span class="kt">unsigned</span>
							      <span class="n">ni_m_series_gate_select</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ni_m_series_gate_select</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Timestamp_Mux_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_TIMESTAMP_MUX_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_AI_START2_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_AI_START2_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_PXI_Star_Trigger_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Next_Out_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_NEXT_OUT_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_AI_START1_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_AI_START1_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Next_SRC_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_NEXT_SOURCE_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Analog_Trigger_Out_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_M_Series_Logic_Low_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_LOGIC_LOW_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ni_m_series_gate_select</span> <span class="o">==</span>
			    <span class="n">NI_M_Series_RTSI_Gate_Select</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">NI_GPCT_RTSI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ni_m_series_gate_select</span> <span class="o">==</span>
			    <span class="n">NI_M_Series_PFI_Gate_Select</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">NI_GPCT_PFI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_m_series_max_pfi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_660x_second_gate_to_generic_gate_source</span><span class="p">(</span><span class="kt">unsigned</span>
							   <span class="n">ni_660x_gate_select</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ni_660x_gate_select</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NI_660x_Source_Pin_i_Second_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_SOURCE_PIN_i_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Up_Down_Pin_i_Second_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Next_SRC_Second_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_NEXT_SOURCE_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Next_Out_Second_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_NEXT_OUT_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Selected_Gate_Second_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_SELECTED_GATE_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NI_660x_Logic_Low_Second_Gate_Select</span>:
		<span class="k">return</span> <span class="n">NI_GPCT_LOGIC_LOW_GATE_SELECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ni_660x_gate_select</span> <span class="o">==</span>
			    <span class="n">NI_660x_RTSI_Second_Gate_Select</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">NI_GPCT_RTSI_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_rtsi_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_up_down_pin</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ni_660x_gate_select</span> <span class="o">==</span>
			    <span class="n">NI_660x_Up_Down_Pin_Second_Gate_Select</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">NI_GPCT_UP_DOWN_PIN_GATE_SELECT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ni_660x_max_up_down_pin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_m_series_second_gate_to_generic_gate_source</span><span class="p">(</span><span class="kt">unsigned</span>
							       <span class="n">ni_m_series_gate_select</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*FIXME: the second gate sources for the m series are undocumented, so we just return</span>
<span class="cm">	 * the raw bits for now. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ni_m_series_gate_select</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">ni_m_series_gate_select</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ni_tio_get_gate_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">gate_index</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">gate_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">mode_bits</span> <span class="o">=</span> <span class="n">ni_tio_get_soft_copy</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
							<span class="n">NITIO_Gi_Mode_Reg</span>
							<span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							 <span class="n">counter_index</span><span class="p">));</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">second_gate_reg</span> <span class="o">=</span>
	    <span class="n">NITIO_Gi_Second_Gate_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">gate_select_bits</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">gate_index</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">mode_bits</span> <span class="o">&amp;</span> <span class="n">Gi_Gating_Mode_Mask</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">Gi_Gating_Disabled_Bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">=</span> <span class="n">NI_GPCT_DISABLED_GATE_SELECT</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">gate_select_bits</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">ni_tio_get_soft_copy</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
						  <span class="n">NITIO_Gi_Input_Select_Reg</span>
						  <span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">))</span> <span class="o">&amp;</span>
			     <span class="n">Gi_Gate_Select_Mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">Gi_Gate_Select_Shift</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">=</span>
			    <span class="n">ni_m_series_first_gate_to_generic_gate_source</span>
			    <span class="p">(</span><span class="n">gate_select_bits</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">=</span>
			    <span class="n">ni_660x_first_gate_to_generic_gate_source</span>
			    <span class="p">(</span><span class="n">gate_select_bits</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode_bits</span> <span class="o">&amp;</span> <span class="n">Gi_Gate_Polarity_Bit</span><span class="p">)</span>
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">|=</span> <span class="n">CR_INVERT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mode_bits</span> <span class="o">&amp;</span> <span class="n">Gi_Gating_Mode_Mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Gi_Level_Gating_Bits</span><span class="p">)</span>
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">|=</span> <span class="n">CR_EDGE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">mode_bits</span> <span class="o">&amp;</span> <span class="n">Gi_Gating_Mode_Mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">Gi_Gating_Disabled_Bits</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;</span>
			<span class="n">Gi_Second_Gate_Mode_Bit</span><span class="p">)</span>
		    <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">=</span> <span class="n">NI_GPCT_DISABLED_GATE_SELECT</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">gate_select_bits</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;</span>
			     <span class="n">Gi_Second_Gate_Select_Mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			    <span class="n">Gi_Second_Gate_Select_Shift</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_e_series</span>:
		<span class="k">case</span> <span class="n">ni_gpct_variant_m_series</span>:
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">=</span>
			    <span class="n">ni_m_series_second_gate_to_generic_gate_source</span>
			    <span class="p">(</span><span class="n">gate_select_bits</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ni_gpct_variant_660x</span>:
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">=</span>
			    <span class="n">ni_660x_second_gate_to_generic_gate_source</span>
			    <span class="p">(</span><span class="n">gate_select_bits</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">second_gate_reg</span><span class="p">]</span> <span class="o">&amp;</span>
		    <span class="n">Gi_Second_Gate_Polarity_Bit</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">|=</span> <span class="n">CR_INVERT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* second gate can&#39;t have edge/level mode set independently */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mode_bits</span> <span class="o">&amp;</span> <span class="n">Gi_Gating_Mode_Mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Gi_Level_Gating_Bits</span><span class="p">)</span>
			<span class="o">*</span><span class="n">gate_source</span> <span class="o">|=</span> <span class="n">CR_EDGE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ni_tio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_SET_COUNTER_MODE</span>:
		<span class="k">return</span> <span class="n">ni_tio_set_counter_mode</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_ARM</span>:
		<span class="k">return</span> <span class="n">ni_tio_arm</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DISARM</span>:
		<span class="n">ni_tio_arm</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_GET_COUNTER_STATUS</span>:
		<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ni_tio_counter_status</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter_status_mask</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_SET_CLOCK_SRC</span>:
		<span class="k">return</span> <span class="n">ni_tio_set_clock_src</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_GET_CLOCK_SRC</span>:
		<span class="n">ni_tio_get_clock_src</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_SET_GATE_SRC</span>:
		<span class="k">return</span> <span class="n">ni_tio_set_gate_src</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_GET_GATE_SRC</span>:
		<span class="k">return</span> <span class="n">ni_tio_get_gate_src</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_SET_OTHER_SRC</span>:
		<span class="k">return</span> <span class="n">ni_tio_set_other_src</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_RESET</span>:
		<span class="n">ni_tio_reset_count_and_disarm</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_tio_insn_config</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">ni_tio_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">first_read</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">second_read</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">correct_read</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				<span class="n">NITIO_Gi_Command_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
				<span class="n">Gi_Save_Trace_Bit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ni_tio_set_bits</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				<span class="n">NITIO_Gi_Command_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">),</span>
				<span class="n">Gi_Save_Trace_Bit</span><span class="p">,</span> <span class="n">Gi_Save_Trace_Bit</span><span class="p">);</span>
		<span class="cm">/* The count doesn&#39;t get latched until the next clock edge, so it is possible the count</span>
<span class="cm">		   may change (once) while we are reading.  Since the read of the SW_Save_Reg isn&#39;t</span>
<span class="cm">		   atomic (apparently even when it&#39;s a 32 bit register according to 660x docs),</span>
<span class="cm">		   we need to read twice and make sure the reading hasn&#39;t changed.  If it has,</span>
<span class="cm">		   a third read will be correct since the count value will definitely have latched by then. */</span>
		<span class="n">first_read</span> <span class="o">=</span>
		    <span class="n">read_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				  <span class="n">NITIO_Gi_SW_Save_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
		<span class="n">second_read</span> <span class="o">=</span>
		    <span class="n">read_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
				  <span class="n">NITIO_Gi_SW_Save_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_read</span> <span class="o">!=</span> <span class="n">second_read</span><span class="p">)</span>
			<span class="n">correct_read</span> <span class="o">=</span>
			    <span class="n">read_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
					  <span class="n">NITIO_Gi_SW_Save_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							       <span class="n">counter_index</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">correct_read</span> <span class="o">=</span> <span class="n">first_read</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_read</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">counter_dev</span><span class="o">-&gt;</span>
		    <span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadA_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">counter_dev</span><span class="o">-&gt;</span>
		    <span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadB_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_tio_rinsn</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">ni_tio_next_load_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">read_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
					    <span class="n">NITIO_Gxx_Status_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
								 <span class="n">counter_index</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">Gi_Next_Load_Source_Bit</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NITIO_Gi_LoadB_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">NITIO_Gi_LoadA_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ni_tio_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">ni_gpct</span> <span class="o">*</span><span class="n">counter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ni_gpct_device</span> <span class="o">*</span><span class="n">counter_dev</span> <span class="o">=</span> <span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">load_reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* Unsafe if counter is armed.  Should probably check status and return -EBUSY if armed. */</span>
		<span class="cm">/* Don&#39;t disturb load source select, just use whichever load register is already selected. */</span>
		<span class="n">load_reg</span> <span class="o">=</span> <span class="n">ni_tio_next_load_register</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>
		<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">load_reg</span><span class="p">);</span>
		<span class="n">ni_tio_set_bits_transient</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span>
					  <span class="n">NITIO_Gi_Command_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span>
							       <span class="n">counter_index</span><span class="p">),</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Gi_Load_Bit</span><span class="p">);</span>
		<span class="cm">/* restore state of load reg to whatever the user set last set it to */</span>
		<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">load_reg</span><span class="p">],</span> <span class="n">load_reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadA_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)]</span> <span class="o">=</span>
		    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">NITIO_Gi_LoadA_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">counter_dev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">NITIO_Gi_LoadB_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">)]</span> <span class="o">=</span>
		    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">write_register</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">NITIO_Gi_LoadB_Reg</span><span class="p">(</span><span class="n">counter</span><span class="o">-&gt;</span><span class="n">counter_index</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ni_tio_winsn</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
