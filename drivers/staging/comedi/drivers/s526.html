<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › s526.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>s526.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    comedi/drivers/s526.c</span>
<span class="cm">    Sensoray s526 Comedi driver</span>

<span class="cm">    COMEDI - Linux Control and Measurement Device Interface</span>
<span class="cm">    Copyright (C) 2000 David A. Schleef &lt;ds@schleef.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">Driver: s526</span>
<span class="cm">Description: Sensoray 526 driver</span>
<span class="cm">Devices: [Sensoray] 526 (s526)</span>
<span class="cm">Author: Richie</span>
<span class="cm">	Everett Wang &lt;everett.wang@everteq.com&gt;</span>
<span class="cm">Updated: Thu, 14 Sep. 2006</span>
<span class="cm">Status: experimental</span>

<span class="cm">Encoder works</span>
<span class="cm">Analog input works</span>
<span class="cm">Analog output works</span>
<span class="cm">PWM output works</span>
<span class="cm">Commands are not supported yet.</span>

<span class="cm">Configuration Options:</span>

<span class="cm">comedi_config /dev/comedi0 s526 0x2C0,0x3</span>

<span class="cm">*/</span>

<span class="cp">#include &quot;../comedidev.h&quot;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#define S526_SIZE 64</span>

<span class="cp">#define S526_START_AI_CONV	0</span>
<span class="cp">#define S526_AI_READ		0</span>

<span class="cm">/* Ports */</span>
<span class="cp">#define S526_IOSIZE 0x40</span>
<span class="cp">#define S526_NUM_PORTS 27</span>

<span class="cm">/* registers */</span>
<span class="cp">#define REG_TCR 0x00</span>
<span class="cp">#define REG_WDC 0x02</span>
<span class="cp">#define REG_DAC 0x04</span>
<span class="cp">#define REG_ADC 0x06</span>
<span class="cp">#define REG_ADD 0x08</span>
<span class="cp">#define REG_DIO 0x0A</span>
<span class="cp">#define REG_IER 0x0C</span>
<span class="cp">#define REG_ISR 0x0E</span>
<span class="cp">#define REG_MSC 0x10</span>
<span class="cp">#define REG_C0L 0x12</span>
<span class="cp">#define REG_C0H 0x14</span>
<span class="cp">#define REG_C0M 0x16</span>
<span class="cp">#define REG_C0C 0x18</span>
<span class="cp">#define REG_C1L 0x1A</span>
<span class="cp">#define REG_C1H 0x1C</span>
<span class="cp">#define REG_C1M 0x1E</span>
<span class="cp">#define REG_C1C 0x20</span>
<span class="cp">#define REG_C2L 0x22</span>
<span class="cp">#define REG_C2H 0x24</span>
<span class="cp">#define REG_C2M 0x26</span>
<span class="cp">#define REG_C2C 0x28</span>
<span class="cp">#define REG_C3L 0x2A</span>
<span class="cp">#define REG_C3H 0x2C</span>
<span class="cp">#define REG_C3M 0x2E</span>
<span class="cp">#define REG_C3C 0x30</span>
<span class="cp">#define REG_EED 0x32</span>
<span class="cp">#define REG_EEC 0x34</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">s526_ports</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">REG_TCR</span><span class="p">,</span>
	<span class="n">REG_WDC</span><span class="p">,</span>
	<span class="n">REG_DAC</span><span class="p">,</span>
	<span class="n">REG_ADC</span><span class="p">,</span>
	<span class="n">REG_ADD</span><span class="p">,</span>
	<span class="n">REG_DIO</span><span class="p">,</span>
	<span class="n">REG_IER</span><span class="p">,</span>
	<span class="n">REG_ISR</span><span class="p">,</span>
	<span class="n">REG_MSC</span><span class="p">,</span>
	<span class="n">REG_C0L</span><span class="p">,</span>
	<span class="n">REG_C0H</span><span class="p">,</span>
	<span class="n">REG_C0M</span><span class="p">,</span>
	<span class="n">REG_C0C</span><span class="p">,</span>
	<span class="n">REG_C1L</span><span class="p">,</span>
	<span class="n">REG_C1H</span><span class="p">,</span>
	<span class="n">REG_C1M</span><span class="p">,</span>
	<span class="n">REG_C1C</span><span class="p">,</span>
	<span class="n">REG_C2L</span><span class="p">,</span>
	<span class="n">REG_C2H</span><span class="p">,</span>
	<span class="n">REG_C2M</span><span class="p">,</span>
	<span class="n">REG_C2C</span><span class="p">,</span>
	<span class="n">REG_C3L</span><span class="p">,</span>
	<span class="n">REG_C3H</span><span class="p">,</span>
	<span class="n">REG_C3M</span><span class="p">,</span>
	<span class="n">REG_C3C</span><span class="p">,</span>
	<span class="n">REG_EED</span><span class="p">,</span>
	<span class="n">REG_EEC</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">counter_mode_register_t</span> <span class="p">{</span>
<span class="cp">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">coutSource</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">coutPolarity</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">autoLoadResetRcap</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">hwCtEnableSource</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ctEnableCtrl</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">clockSource</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">countDir</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">countDirCtrl</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">outputRegLatchCtrl</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">preloadRegSel</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
 <span class="cp">#elif defined(__BIG_ENDIAN_BITFIELD)</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">preloadRegSel</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">outputRegLatchCtrl</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">countDirCtrl</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">countDir</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">clockSource</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ctEnableCtrl</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">hwCtEnableSource</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">autoLoadResetRcap</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">coutPolarity</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">coutSource</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#error Unknown bit field order</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">cmReg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">counter_mode_register_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define MAX_GPCT_CONFIG_DATA 6</span>

<span class="cm">/* Different Application Classes for GPCT Subdevices */</span>
<span class="cm">/* The list is not exhaustive and needs discussion! */</span>
<span class="k">enum</span> <span class="n">S526_GPCT_APP_CLASS</span> <span class="p">{</span>
	<span class="n">CountingAndTimeMeasurement</span><span class="p">,</span>
	<span class="n">SinglePulseGeneration</span><span class="p">,</span>
	<span class="n">PulseTrainGeneration</span><span class="p">,</span>
	<span class="n">PositionMeasurement</span><span class="p">,</span>
	<span class="n">Miscellaneous</span>
<span class="p">};</span>

<span class="cm">/* Config struct for different GPCT subdevice Application Classes and</span>
<span class="cm">   their options</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">s526GPCTConfig</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">S526_GPCT_APP_CLASS</span> <span class="n">app</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_GPCT_CONFIG_DATA</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Board descriptions for two imaginary boards.  Describing the</span>
<span class="cm"> * boards in this way is optional, and completely driver-dependent.</span>
<span class="cm"> * Some drivers use arrays such as this, other do not.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">s526_board</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gpct_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gpct_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ad_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ad_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">da_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">da_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have_dio</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">s526_board</span> <span class="n">s526_boards</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;s526&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">gpct_chans</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">gpct_bits</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ad_chans</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ad_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">da_chans</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">da_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">have_dio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#define ADDR_REG(reg) (dev-&gt;iobase + (reg))</span>
<span class="cp">#define ADDR_CHAN_REG(reg, chan) (dev-&gt;iobase + (reg) + (chan) * 8)</span>

<span class="cm">/*</span>
<span class="cm"> * Useful for shorthand access to the particular board structure</span>
<span class="cm"> */</span>
<span class="cp">#define thisboard ((const struct s526_board *)dev-&gt;board_ptr)</span>

<span class="cm">/* this structure is for data unique to this hardware driver.  If</span>
<span class="cm">   several hardware drivers keep similar information in this structure,</span>
<span class="cm">   feel free to suggest moving the variable to the struct comedi_device</span>
<span class="cm">   struct.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">s526_private</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* would be useful for a PCI device */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>

	<span class="cm">/* Used for AO readback */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_readback</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">s526GPCTConfig</span> <span class="n">s526_gpct_config</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s526_ai_config</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * most drivers define the following macro to make it easy to</span>
<span class="cm"> * access the private structure.</span>
<span class="cm"> */</span>
<span class="cp">#define devpriv ((struct s526_private *)dev-&gt;private)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_gpct_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>			<span class="cm">/*  counts the Data */</span>
	<span class="kt">int</span> <span class="n">counter_channel</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">datalow</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">datahigh</span><span class="p">;</span>

	<span class="cm">/*  Check if (n &gt; 0) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s526: INSN_READ: n should be &gt; 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*  Read the low word first */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">datalow</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">counter_channel</span><span class="p">));</span>
		<span class="n">datahigh</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span> <span class="n">counter_channel</span><span class="p">));</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">datahigh</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">);</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">datalow</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="cm">/* printk(&quot;s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n&quot;,</span>
<span class="cm">		   counter_channel, data[i], datahigh, datalow); */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_gpct_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">subdev_channel</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>	<span class="cm">/*  Unpack chanspec */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cmReg</span> <span class="n">cmReg</span><span class="p">;</span>

	<span class="cm">/* printk(&quot;s526: GPCT_INSN_CONFIG: Configuring Channel %d\n&quot;,</span>
<span class="cm">						subdev_channel); */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_GPCT_CONFIG_DATA</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">].</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cm">/* printk(&quot;data[%d]=%x\n&quot;, i, insn-&gt;data[i]); */</span>
	<span class="p">}</span>

	<span class="cm">/*  Check what type of Counter the user requested, data[0] contains */</span>
	<span class="cm">/*  the Application type */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_GPCT_QUADRATURE_ENCODER</span>:
		<span class="cm">/*</span>
<span class="cm">		   data[0]: Application Type</span>
<span class="cm">		   data[1]: Counter Mode Register Value</span>
<span class="cm">		   data[2]: Pre-load Register Value</span>
<span class="cm">		   data[3]: Conter Control Register</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;s526: GPCT_INSN_CONFIG: Configuring Encoder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">].</span><span class="n">app</span> <span class="o">=</span>
		    <span class="n">PositionMeasurement</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/*  Example of Counter Application */</span>
<span class="c">		/* One-shot (software trigger) */</span>
<span class="c">		cmReg.reg.coutSource = 0;	/*  out RCAP */</span>
<span class="c">		cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */</span>
<span class="c">		cmReg.reg.autoLoadResetRcap = 0;/*  Auto load disabled */</span>
<span class="c">		cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */</span>
<span class="c">		cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */</span>
<span class="c">		cmReg.reg.clockSource = 2;	/*  Internal */</span>
<span class="c">		cmReg.reg.countDir = 1;	/*  Down */</span>
<span class="c">		cmReg.reg.countDirCtrl = 1;	/*  Software */</span>
<span class="c">		cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */</span>
<span class="c">		cmReg.reg.preloadRegSel = 0;	/*  PR0 */</span>
<span class="c">		cmReg.reg.reserved = 0;</span>

<span class="c">		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));</span>

<span class="c">		outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));</span>
<span class="c">		outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));</span>

<span class="c">		/*  Reset the counter */</span>
<span class="c">		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));</span>
<span class="c">		/*  Load the counter from PR0 */</span>
<span class="c">		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));</span>

<span class="c">		/*  Reset RCAP (fires one-shot) */</span>
<span class="c">		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));</span>

<span class="cp">#endif</span>

<span class="cp">#if 1</span>
		<span class="cm">/*  Set Counter Mode Register */</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>

<span class="cm">/* printk(&quot;s526: Counter Mode register=%x\n&quot;, cmReg.value); */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Reset the counter if it is software preload */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">autoLoadResetRcap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Reset the counter */</span>
			<span class="n">outw</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
			<span class="cm">/* Load the counter from PR0</span>
<span class="cm">			 * outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="cm">/*  0 quadrature, 1 software control */</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">countDirCtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*  data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">GPCT_X2</span><span class="p">)</span>
			<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">clockSource</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">GPCT_X4</span><span class="p">)</span>
			<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">clockSource</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">clockSource</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*  When to take into account the indexpulse: */</span>
		<span class="cm">/*if (insn-&gt;data[2] == GPCT_IndexPhaseLowLow) {</span>
<span class="cm">		} else if (insn-&gt;data[2] == GPCT_IndexPhaseLowHigh) {</span>
<span class="cm">		} else if (insn-&gt;data[2] == GPCT_IndexPhaseHighLow) {</span>
<span class="cm">		} else if (insn-&gt;data[2] == GPCT_IndexPhaseHighHigh) {</span>
<span class="cm">		}*/</span>
		<span class="cm">/*  Take into account the index pulse? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">GPCT_RESET_COUNTER_ON_INDEX</span><span class="p">)</span>
			<span class="cm">/*  Auto load with INDEX^ */</span>
			<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">autoLoadResetRcap</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="cm">/*  Set Counter Mode Register */</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register high word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)((</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register low word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Write the Counter Control Register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/*  Reset the counter if it is software preload */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">autoLoadResetRcap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Reset the counter */</span>
			<span class="n">outw</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
			<span class="cm">/*  Load the counter from PR0 */</span>
			<span class="n">outw</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR</span>:
		<span class="cm">/*</span>
<span class="cm">		   data[0]: Application Type</span>
<span class="cm">		   data[1]: Counter Mode Register Value</span>
<span class="cm">		   data[2]: Pre-load Register 0 Value</span>
<span class="cm">		   data[3]: Pre-load Register 1 Value</span>
<span class="cm">		   data[4]: Conter Control Register</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;s526: GPCT_INSN_CONFIG: Configuring SPG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">].</span><span class="n">app</span> <span class="o">=</span>
		    <span class="n">SinglePulseGeneration</span><span class="p">;</span>

		<span class="cm">/*  Set Counter Mode Register */</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">preloadRegSel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  PR0 */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 0 high word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)((</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 0 low word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Set Counter Mode Register */</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">preloadRegSel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/*  PR1 */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 1 high word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)((</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 1 low word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Write the Counter Control Register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR</span>:
		<span class="cm">/*</span>
<span class="cm">		   data[0]: Application Type</span>
<span class="cm">		   data[1]: Counter Mode Register Value</span>
<span class="cm">		   data[2]: Pre-load Register 0 Value</span>
<span class="cm">		   data[3]: Pre-load Register 1 Value</span>
<span class="cm">		   data[4]: Conter Control Register</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;s526: GPCT_INSN_CONFIG: Configuring PTG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">].</span><span class="n">app</span> <span class="o">=</span>
		    <span class="n">PulseTrainGeneration</span><span class="p">;</span>

		<span class="cm">/*  Set Counter Mode Register */</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">preloadRegSel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  PR0 */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 0 high word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)((</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 0 low word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Set Counter Mode Register */</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">preloadRegSel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/*  PR1 */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 1 high word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)((</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Load the pre-load register 1 low word */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>

		<span class="cm">/*  Write the Counter Control Register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s526: unsupported GPCT_insn_config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_gpct_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">subdev_channel</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>	<span class="cm">/*  Unpack chanspec */</span>
	<span class="kt">short</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cmReg</span> <span class="n">cmReg</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;s526: GPCT_INSN_WRITE on channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">subdev_channel</span><span class="p">);</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;s526: Counter Mode Register: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="cm">/*  Check what Application of Counter this channel is configured for */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">].</span><span class="n">app</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PositionMeasurement</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;S526: INSN_WRITE: PM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">),</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span>
							     <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SinglePulseGeneration</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;S526: INSN_WRITE: SPG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">),</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span>
							     <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0xFFFF</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PulseTrainGeneration</span>:
		<span class="cm">/* data[0] contains the PULSE_WIDTH</span>
<span class="cm">		   data[1] contains the PULSE_PERIOD</span>
<span class="cm">		   @pre PULSE_PERIOD &gt; PULSE_WIDTH &gt; 0</span>
<span class="cm">		   The above periods must be expressed as a multiple of the</span>
<span class="cm">		   pulse frequency on the selected source</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;S526: INSN_WRITE: PTG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">]).</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">]).</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s526: INSN_WRITE: PTG: Problem with Pulse params -&gt; %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)((</span><span class="o">*</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0H</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="o">*</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0L</span><span class="p">,</span> <span class="n">subdev_channel</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="cm">/*  Impossible */</span>
		<span class="n">printk</span>
		    <span class="p">(</span><span class="s">&quot;s526: INSN_WRITE: Functionality %d not implemented yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_gpct_config</span><span class="p">[</span><span class="n">subdev_channel</span><span class="p">].</span><span class="n">app</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*  return the number of samples written */</span>
	<span class="k">return</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ISR_ADC_DONE 0x4</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_ai_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>

	<span class="cm">/* data[0] : channels was set in relevant bits.</span>
<span class="cm">	   data[1] : delay</span>
<span class="cm">	 */</span>
	<span class="cm">/* COMMENT: abbotti 2008-07-24: I don&#39;t know why you&#39;d want to</span>
<span class="cm">	 * enable channels here.  The channel should be enabled in the</span>
<span class="cm">	 * INSN_READ handler. */</span>

	<span class="cm">/*  Enable ADC interrupt */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">ISR_ADC_DONE</span><span class="p">,</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_IER</span><span class="p">));</span>
<span class="cm">/* printk(&quot;s526: ADC current value: 0x%04x\n&quot;, inw(ADDR_REG(REG_ADC))); */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_ai_config</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_ai_config</span> <span class="o">|=</span> <span class="mh">0x8000</span><span class="p">;</span>	<span class="cm">/* set the delay */</span>

	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_ai_config</span> <span class="o">|=</span> <span class="mh">0x0001</span><span class="p">;</span>	<span class="cm">/*  ADC start bit. */</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;instructions&quot; read/write data in &quot;one-shot&quot; or &quot;software-triggered&quot;</span>
<span class="cm"> * mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_ai_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Set configured delay, enable channel for this channel only,</span>
<span class="cm">	 * select &quot;ADC read&quot; channel, set &quot;ADC start&quot; bit. */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">s526_ai_config</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">chan</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0001</span><span class="p">;</span>

	<span class="cm">/* convert n samples */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* trigger conversion */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_ADC</span><span class="p">));</span>
<span class="cm">/* printk(&quot;s526: Wrote 0x%04x to ADC\n&quot;, value); */</span>
<span class="cm">/* printk(&quot;s526: ADC reg=0x%04x\n&quot;, inw(ADDR_REG(REG_ADC))); */</span>

<span class="cp">#define TIMEOUT 100</span>
		<span class="cm">/* wait for conversion to end */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_ISR</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ISR_ADC_DONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">outw</span><span class="p">(</span><span class="n">ISR_ADC_DONE</span><span class="p">,</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_ISR</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* printk() should be used instead of printk()</span>
<span class="cm">			 * whenever the code can be called from real-time. */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s526: ADC(0x%04x) timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_ISR</span><span class="p">)));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* read data */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_ADD</span><span class="p">));</span>
<span class="cm">/* printk(&quot;AI[%d]=0x%04x\n&quot;, n, (unsigned short)(d &amp; 0xFFFF)); */</span>

		<span class="cm">/* munge data */</span>
		<span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span> <span class="o">^</span> <span class="mh">0x8000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">;</span>

<span class="cm">/* printk(&quot;s526_ao_winsn\n&quot;); */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">chan</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="cm">/* outw(val, dev-&gt;iobase + REG_DAC); */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_DAC</span><span class="p">));</span>

	<span class="cm">/* Writing a list of values to an AO channel is probably not</span>
<span class="cm">	 * very useful, but that&#39;s how the interface is defined. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* a typical programming sequence */</span>
		<span class="cm">/* write the data to preload register</span>
<span class="cm">		 * outw(data[i], dev-&gt;iobase + REG_ADD);</span>
<span class="cm">		 */</span>
		<span class="cm">/* write the data to preload register */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_ADD</span><span class="p">));</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cm">/* outw(val + 1, dev-&gt;iobase + REG_DAC);  starts the D/A conversion. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_DAC</span><span class="p">));</span> <span class="cm">/*starts the D/A conversion.*/</span>
	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* AO subdevices should have a read insn as well as a write insn.</span>
<span class="cm"> * Usually this means copying a value stored in devpriv. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DIO devices are slightly special.  Although it is possible to</span>
<span class="cm"> * implement the insn_read/insn_write interface, it is much more</span>
<span class="cm"> * useful to applications if you implement the insn_bits interface.</span>
<span class="cm"> * This allows packed reading/writing of the DIO channels.  The</span>
<span class="cm"> * comedi core can convert between insn_bits and insn_read/write */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_dio_insn_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* The insn data is a mask in data[0] and the new data</span>
<span class="cm">	 * in data[1], each channel cooresponding to a bit. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="cm">/* Write out the new digital output lines */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_DIO</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* on return, data[1] contains the value of the digital</span>
<span class="cm">	 * input and output lines. */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_DIO</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span> <span class="cm">/* low 8 bits are the data */</span>
	<span class="cm">/* or we could just return the software copy of the output values if</span>
<span class="cm">	 * it was a purely digital output subdevice */</span>
	<span class="cm">/* data[1]=s-&gt;state &amp; 0xFF; */</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_dio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;S526 DIO insn_config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* The input or output configuration of each digital line is</span>
<span class="cm">	 * configured by a special insn_config instruction.  chanspec</span>
<span class="cm">	 * contains the channel to be changed, and data[0] contains the</span>
<span class="cm">	 * value COMEDI_INPUT or COMEDI_OUTPUT. */</span>

	<span class="n">group</span> <span class="o">=</span> <span class="n">chan</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0xF</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">group</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DIO_OUTPUT</span>:
		<span class="cm">/* bit 10/11 set the group 1/2&#39;s mode */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">group</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DIO_INPUT</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">group</span> <span class="o">+</span> <span class="mi">10</span><span class="p">));</span> <span class="cm">/* 1 is output, 0 is input. */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DIO_QUERY</span>:
		<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">?</span> <span class="n">COMEDI_OUTPUT</span> <span class="o">:</span> <span class="n">COMEDI_INPUT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">ADDR_REG</span><span class="p">(</span><span class="n">REG_DIO</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s526_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
<span class="cm">/* short value; */</span>
<span class="cm">/* int subdev_channel = 0; */</span>
	<span class="k">union</span> <span class="n">cmReg</span> <span class="n">cmReg</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;comedi%d: s526: &quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iobase</span> <span class="o">||</span> <span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">S526_IOSIZE</span><span class="p">,</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;I/O port conflict&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iobase=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">);</span>

	<span class="cm">/*** make it a little quieter, exw, 8/29/06</span>
<span class="cm">	for (i = 0; i &lt; S526_NUM_PORTS; i++) {</span>
<span class="cm">		printk(&quot;0x%02x: 0x%04x\n&quot;, ADDR_REG(s526_ports[i]),</span>
<span class="cm">				inw(ADDR_REG(s526_ports[i])));</span>
<span class="cm">	}</span>
<span class="cm">	***/</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize dev-&gt;board_name.  Note that we can use the &quot;thisboard&quot;</span>
<span class="cm"> * macro now, since we just initialized it in the last line.</span>
<span class="cm"> */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s526_boards</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the private structure area.  alloc_private() is a</span>
<span class="cm"> * convenient macro defined in comedidev.h.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_private</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">s526_private</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the subdevice structures.  alloc_subdevice() is a</span>
<span class="cm"> * convenient macro defined in comedidev.h.</span>
<span class="cm"> */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_subdevices</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_subdevices</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_subdevices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_COUNTER</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_WRITABLE</span> <span class="o">|</span> <span class="n">SDF_LSAMPL</span><span class="p">;</span>
	<span class="cm">/* KG: What does SDF_LSAMPL (see multiq3.c) mean? */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">gpct_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mh">0x00ffffff</span><span class="p">;</span>	<span class="cm">/* 24 bit counter */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">s526_gpct_rinsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s526_gpct_insn_config</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="n">s526_gpct_winsn</span><span class="p">;</span>

	<span class="cm">/* Command are not implemented yet, however they are necessary to</span>
<span class="cm">	   allocate the necessary memory for the comedi_async struct (used</span>
<span class="cm">	   to trigger the GPCT in case of pulsegenerator function */</span>
	<span class="cm">/* s-&gt;do_cmd = s526_gpct_cmd; */</span>
	<span class="cm">/* s-&gt;do_cmdtest = s526_gpct_cmdtest; */</span>
	<span class="cm">/* s-&gt;cancel = s526_gpct_cancel; */</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* dev-&gt;read_subdev=s; */</span>
	<span class="cm">/* analog input subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AI</span><span class="p">;</span>
	<span class="cm">/* we support differential */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_DIFF</span><span class="p">;</span>
	<span class="cm">/* channels 0 to 7 are the regular differential inputs */</span>
	<span class="cm">/* channel 8 is &quot;reference 0&quot; (+10V), channel 9 is &quot;reference 1&quot; (0V) */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_bipolar10</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">len_chanlist</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* This is the maximum chanlist length that</span>
<span class="cm">				   the board can handle */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">s526_ai_rinsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s526_ai_insn_config</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* analog output subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_bipolar10</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="n">s526_ao_winsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">s526_ao_rinsn</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* digital i/o subdevice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">have_dio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_DIO</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_digital</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_bits</span> <span class="o">=</span> <span class="n">s526_dio_insn_bits</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s526_dio_insn_config</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_UNUSED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/*  Example of Counter Application */</span>
<span class="c">	/* One-shot (software trigger) */</span>
<span class="c">	cmReg.reg.coutSource = 0;	/*  out RCAP */</span>
<span class="c">	cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */</span>
<span class="c">	cmReg.reg.autoLoadResetRcap = 1;/*  Auto load 0:disabled, 1:enabled */</span>
<span class="c">	cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */</span>
<span class="c">	cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */</span>
<span class="c">	cmReg.reg.clockSource = 2;	/*  Internal */</span>
<span class="c">	cmReg.reg.countDir = 1;	/*  Down */</span>
<span class="c">	cmReg.reg.countDirCtrl = 1;	/*  Software */</span>
<span class="c">	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */</span>
<span class="c">	cmReg.reg.preloadRegSel = 0;	/*  PR0 */</span>
<span class="c">	cmReg.reg.reserved = 0;</span>

<span class="c">	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));</span>

<span class="c">	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));</span>
<span class="c">	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));</span>

<span class="c">	/*  Reset the counter */</span>
<span class="c">	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));</span>
<span class="c">	/*  Load the counter from PR0 */</span>
<span class="c">	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));</span>
<span class="c">	/*  Reset RCAP (fires one-shot) */</span>
<span class="c">	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));</span>

<span class="cp">#else</span>

	<span class="cm">/*  Set Counter Mode Register */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">coutSource</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  out RCAP */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">coutPolarity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  Polarity inverted */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">autoLoadResetRcap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  Auto load disabled */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">hwCtEnableSource</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/*  NOT RCAP */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">ctEnableCtrl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/*  1: Software,  &gt;1 : Hardware */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">clockSource</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/*  x4 */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">countDir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  up */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">countDirCtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  quadrature */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">outputRegLatchCtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  latch on read */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">preloadRegSel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*  PR0 */</span>
	<span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Mode reg=0x%04x, 0x%04lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Read back mode reg=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">inw</span><span class="p">(</span><span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">n</span><span class="p">)));</span>

	<span class="cm">/*  Load the pre-load register high word */</span>
<span class="cm">/* value = (short) (0x55); */</span>
<span class="cm">/* outw(value, ADDR_CHAN_REG(REG_C0H, n)); */</span>

	<span class="cm">/*  Load the pre-load register low word */</span>
<span class="cm">/* value = (short)(0xaa55); */</span>
<span class="cm">/* outw(value, ADDR_CHAN_REG(REG_C0L, n)); */</span>

	<span class="cm">/*  Write the Counter Control Register */</span>
<span class="cm">/* outw(value, ADDR_CHAN_REG(REG_C0C, 0)); */</span>

	<span class="cm">/*  Reset the counter if it is software preload */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">autoLoadResetRcap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  Reset the counter */</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
		<span class="cm">/*  Load the counter from PR0 */</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0C</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">cmReg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Read back mode reg=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">inw</span><span class="p">(</span><span class="n">ADDR_CHAN_REG</span><span class="p">(</span><span class="n">REG_C0M</span><span class="p">,</span> <span class="n">n</span><span class="p">)));</span>

<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Current registres:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">S526_NUM_PORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;0x%02lx: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ADDR_REG</span><span class="p">(</span><span class="n">s526_ports</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">inw</span><span class="p">(</span><span class="n">ADDR_REG</span><span class="p">(</span><span class="n">s526_ports</span><span class="p">[</span><span class="n">i</span><span class="p">])));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s526_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">,</span> <span class="n">S526_IOSIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">comedi_driver</span> <span class="n">s526_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver_name</span>	<span class="o">=</span> <span class="s">&quot;s526&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">s526_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach</span>		<span class="o">=</span> <span class="n">s526_detach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">board_name</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">s526_boards</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offset</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">s526_board</span><span class="p">),</span>
	<span class="p">.</span><span class="n">num_names</span>	<span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">s526_boards</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">module_comedi_driver</span><span class="p">(</span><span class="n">s526_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Comedi http://www.comedi.org&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Comedi low-level driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
