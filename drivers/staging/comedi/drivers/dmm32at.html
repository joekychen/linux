<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › dmm32at.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dmm32at.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    comedi/drivers/dmm32at.c</span>
<span class="cm">    Diamond Systems mm32at code for a Comedi driver</span>

<span class="cm">    COMEDI - Linux Control and Measurement Device Interface</span>
<span class="cm">    Copyright (C) 2000 David A. Schleef &lt;ds@schleef.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">Driver: dmm32at</span>
<span class="cm">Description: Diamond Systems mm32at driver.</span>
<span class="cm">Devices:</span>
<span class="cm">Author: Perry J. Piplani &lt;perry.j.piplani@nasa.gov&gt;</span>
<span class="cm">Updated: Fri Jun  4 09:13:24 CDT 2004</span>
<span class="cm">Status: experimental</span>

<span class="cm">This driver is for the Diamond Systems MM-32-AT board</span>
<span class="cm">http://www.diamondsystems.com/products/diamondmm32at It is being used</span>
<span class="cm">on serveral projects inside NASA, without problems so far. For analog</span>
<span class="cm">input commands, TRIG_EXT is not yet supported at all..</span>

<span class="cm">Configuration Options:</span>
<span class="cm">  comedi_config /dev/comedi0 dmm32at baseaddr,irq</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &quot;../comedidev.h&quot;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>

<span class="cm">/* Board register addresses */</span>

<span class="cp">#define DMM32AT_MEMSIZE 0x10</span>

<span class="cp">#define DMM32AT_CONV 0x00</span>
<span class="cp">#define DMM32AT_AILSB 0x00</span>
<span class="cp">#define DMM32AT_AUXDOUT 0x01</span>
<span class="cp">#define DMM32AT_AIMSB 0x01</span>
<span class="cp">#define DMM32AT_AILOW 0x02</span>
<span class="cp">#define DMM32AT_AIHIGH 0x03</span>

<span class="cp">#define DMM32AT_DACLSB 0x04</span>
<span class="cp">#define DMM32AT_DACSTAT 0x04</span>
<span class="cp">#define DMM32AT_DACMSB 0x05</span>

<span class="cp">#define DMM32AT_FIFOCNTRL 0x07</span>
<span class="cp">#define DMM32AT_FIFOSTAT 0x07</span>

<span class="cp">#define DMM32AT_CNTRL 0x08</span>
<span class="cp">#define DMM32AT_AISTAT 0x08</span>

<span class="cp">#define DMM32AT_INTCLOCK 0x09</span>

<span class="cp">#define DMM32AT_CNTRDIO 0x0a</span>

<span class="cp">#define DMM32AT_AICONF 0x0b</span>
<span class="cp">#define DMM32AT_AIRBACK 0x0b</span>

<span class="cp">#define DMM32AT_CLK1 0x0d</span>
<span class="cp">#define DMM32AT_CLK2 0x0e</span>
<span class="cp">#define DMM32AT_CLKCT 0x0f</span>

<span class="cp">#define DMM32AT_DIOA 0x0c</span>
<span class="cp">#define DMM32AT_DIOB 0x0d</span>
<span class="cp">#define DMM32AT_DIOC 0x0e</span>
<span class="cp">#define DMM32AT_DIOCONF 0x0f</span>

<span class="cp">#define dmm_inb(cdev, reg) inb((cdev-&gt;iobase)+reg)</span>
<span class="cp">#define dmm_outb(cdev, reg, valu) outb(valu, (cdev-&gt;iobase)+reg)</span>

<span class="cm">/* Board register values. */</span>

<span class="cm">/* DMM32AT_DACSTAT 0x04 */</span>
<span class="cp">#define DMM32AT_DACBUSY 0x80</span>

<span class="cm">/* DMM32AT_FIFOCNTRL 0x07 */</span>
<span class="cp">#define DMM32AT_FIFORESET 0x02</span>
<span class="cp">#define DMM32AT_SCANENABLE 0x04</span>

<span class="cm">/* DMM32AT_CNTRL 0x08 */</span>
<span class="cp">#define DMM32AT_RESET 0x20</span>
<span class="cp">#define DMM32AT_INTRESET 0x08</span>
<span class="cp">#define DMM32AT_CLKACC 0x00</span>
<span class="cp">#define DMM32AT_DIOACC 0x01</span>

<span class="cm">/* DMM32AT_AISTAT 0x08 */</span>
<span class="cp">#define DMM32AT_STATUS 0x80</span>

<span class="cm">/* DMM32AT_INTCLOCK 0x09 */</span>
<span class="cp">#define DMM32AT_ADINT 0x80</span>
<span class="cp">#define DMM32AT_CLKSEL 0x03</span>

<span class="cm">/* DMM32AT_CNTRDIO 0x0a */</span>
<span class="cp">#define DMM32AT_FREQ12 0x80</span>

<span class="cm">/* DMM32AT_AICONF 0x0b */</span>
<span class="cp">#define DMM32AT_RANGE_U10 0x0c</span>
<span class="cp">#define DMM32AT_RANGE_U5 0x0d</span>
<span class="cp">#define DMM32AT_RANGE_B10 0x08</span>
<span class="cp">#define DMM32AT_RANGE_B5 0x00</span>
<span class="cp">#define DMM32AT_SCINT_20 0x00</span>
<span class="cp">#define DMM32AT_SCINT_15 0x10</span>
<span class="cp">#define DMM32AT_SCINT_10 0x20</span>
<span class="cp">#define DMM32AT_SCINT_5 0x30</span>

<span class="cm">/* DMM32AT_CLKCT 0x0f */</span>
<span class="cp">#define DMM32AT_CLKCT1 0x56	</span><span class="cm">/* mode3 counter 1 - write low byte only */</span><span class="cp"></span>
<span class="cp">#define DMM32AT_CLKCT2 0xb6	</span><span class="cm">/*  mode3 counter 2 - write high and low byte */</span><span class="cp"></span>

<span class="cm">/* DMM32AT_DIOCONF 0x0f */</span>
<span class="cp">#define DMM32AT_DIENABLE 0x80</span>
<span class="cp">#define DMM32AT_DIRA 0x10</span>
<span class="cp">#define DMM32AT_DIRB 0x02</span>
<span class="cp">#define DMM32AT_DIRCL 0x01</span>
<span class="cp">#define DMM32AT_DIRCH 0x08</span>

<span class="cm">/* board AI ranges in comedi structure */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">dmm32at_airanges</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">4</span><span class="p">,</span>
	<span class="p">{</span>
	 <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	 <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	 <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	 <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	 <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* register values for above ranges */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dmm32at_rangebits</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">DMM32AT_RANGE_U10</span><span class="p">,</span>
	<span class="n">DMM32AT_RANGE_U5</span><span class="p">,</span>
	<span class="n">DMM32AT_RANGE_B10</span><span class="p">,</span>
	<span class="n">DMM32AT_RANGE_B5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* only one of these ranges is valid, as set by a jumper on the</span>
<span class="cm"> * board. The application should only use the range set by the jumper</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">dmm32at_aoranges</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">4</span><span class="p">,</span>
	<span class="p">{</span>
	 <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	 <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	 <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	 <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	 <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Board descriptions for two imaginary boards.  Describing the</span>
<span class="cm"> * boards in this way is optional, and completely driver-dependent.</span>
<span class="cm"> * Some drivers use arrays such as this, other do not.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dmm32at_board</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ai_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ai_bits</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="o">*</span><span class="n">ai_ranges</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_bits</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="o">*</span><span class="n">ao_ranges</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have_dio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dio_chans</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dmm32at_board</span> <span class="n">dmm32at_boards</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;dmm32at&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_chans</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dmm32at_airanges</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dmm32at_aoranges</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">have_dio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">dio_chans</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
	 <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Useful for shorthand access to the particular board structure</span>
<span class="cm"> */</span>
<span class="cp">#define thisboard ((const struct dmm32at_board *)dev-&gt;board_ptr)</span>

<span class="cm">/* this structure is for data unique to this hardware driver.  If</span>
<span class="cm"> * several hardware drivers keep similar information in this structure,</span>
<span class="cm"> * feel free to suggest moving the variable to the struct comedi_device struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dmm32at_private</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ai_inuse</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ai_scans_left</span><span class="p">;</span>

	<span class="cm">/* Used for AO readback */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_readback</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dio_config</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * most drivers define the following macro to make it easy to</span>
<span class="cm"> * access the private structure.</span>
<span class="cm"> */</span>
<span class="cp">#define devpriv ((struct dmm32at_private *)dev-&gt;private)</span>

<span class="cm">/*</span>
<span class="cm"> * The struct comedi_driver structure tells the Comedi core module</span>
<span class="cm"> * which functions to call to configure/deconfigure (attach/detach)</span>
<span class="cm"> * the board, and also about the kernel module that contains</span>
<span class="cm"> * the device code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dmm32at_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">comedi_driver</span> <span class="n">driver_dmm32at</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;dmm32at&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span> <span class="o">=</span> <span class="n">dmm32at_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach</span> <span class="o">=</span> <span class="n">dmm32at_detach</span><span class="p">,</span>
<span class="cm">/* It is not necessary to implement the following members if you are</span>
<span class="cm"> * writing a driver for a ISA PnP or PCI card */</span>
<span class="cm">/* Most drivers will support multiple types of boards by</span>
<span class="cm"> * having an array of board structures.  These were defined</span>
<span class="cm"> * in dmm32at_boards[] above.  Note that the element &#39;name&#39;</span>
<span class="cm"> * was first in the structure -- Comedi uses this fact to</span>
<span class="cm"> * extract the name of the board without knowing any details</span>
<span class="cm"> * about the structure except for its length.</span>
<span class="cm"> * When a device is attached (by comedi_config), the name</span>
<span class="cm"> * of the device is given to Comedi, and Comedi tries to</span>
<span class="cm"> * match it by going through the list of board names.  If</span>
<span class="cm"> * there is a match, the address of the pointer is put</span>
<span class="cm"> * into dev-&gt;board_ptr and driver-&gt;attach() is called.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that these are not necessary if you can determine</span>
<span class="cm"> * the type of board in software.  ISA PnP, PCI, and PCMCIA</span>
<span class="cm"> * devices are such boards.</span>
<span class="cm"> */</span>
	<span class="p">.</span><span class="n">board_name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dmm32at_boards</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm32at_board</span><span class="p">),</span>
	<span class="p">.</span><span class="n">num_names</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dmm32at_boards</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* prototypes for driver functions below */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_ai_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_dio_insn_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_dio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmm32at_ns_to_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">round</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">dmm32at_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dmm32at_setaitimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nansec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attach is called by the Comedi core to configure the driver</span>
<span class="cm"> * for a particular board.  If you specified a board_name array</span>
<span class="cm"> * in the driver structure, dev-&gt;board_ptr contains that</span>
<span class="cm"> * address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">fifostat</span><span class="p">,</span> <span class="n">aistat</span><span class="p">,</span> <span class="n">intstat</span><span class="p">,</span> <span class="n">airback</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;comedi%d: dmm32at: attaching</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;dmm32at: probing at address 0x%04lx, irq %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">iobase</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* register address space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">DMM32AT_MEMSIZE</span><span class="p">,</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;comedi%d: dmm32at: I/O port conflict</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="cm">/* the following just makes sure the board is there and gets</span>
<span class="cm">	   it to a known state */</span>

	<span class="cm">/* reset the board */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRL</span><span class="p">,</span> <span class="n">DMM32AT_RESET</span><span class="p">);</span>

	<span class="cm">/* allow a millisecond to reset */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/* zero scan and fifo control */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_FIFOCNTRL</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

	<span class="cm">/* zero interrupt and clock control */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_INTCLOCK</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

	<span class="cm">/* write a test channel range, the high 3 bits should drop */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AILOW</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIHIGH</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="cm">/* set the range at 10v unipolar */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AICONF</span><span class="p">,</span> <span class="n">DMM32AT_RANGE_U10</span><span class="p">);</span>

	<span class="cm">/* should take 10 us to settle, here&#39;s a hundred */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* read back the values */</span>
	<span class="n">ailo</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AILOW</span><span class="p">);</span>
	<span class="n">aihi</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIHIGH</span><span class="p">);</span>
	<span class="n">fifostat</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_FIFOSTAT</span><span class="p">);</span>
	<span class="n">aistat</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AISTAT</span><span class="p">);</span>
	<span class="n">intstat</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_INTCLOCK</span><span class="p">);</span>
	<span class="n">airback</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIRBACK</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">fifostat</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
	       <span class="s">&quot;dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">aistat</span><span class="p">,</span> <span class="n">intstat</span><span class="p">,</span> <span class="n">airback</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ailo</span> <span class="o">!=</span> <span class="mh">0x00</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">aihi</span> <span class="o">!=</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fifostat</span> <span class="o">!=</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">aistat</span> <span class="o">!=</span> <span class="mh">0x60</span> <span class="o">||</span> <span class="p">(</span><span class="n">intstat</span> <span class="o">!=</span> <span class="mh">0x00</span><span class="p">)</span> <span class="o">||</span> <span class="n">airback</span> <span class="o">!=</span> <span class="mh">0x0c</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmmat32: board detection failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* board is there, register interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dmm32at_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dmm32at: irq conflict</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If you can probe the device to determine what device in a series</span>
<span class="cm"> * it is, this is the place to do it.  Otherwise, dev-&gt;board_ptr</span>
<span class="cm"> * should already be initialized.</span>
<span class="cm"> */</span>
	<span class="cm">/* dev-&gt;board_ptr = dmm32at_probe(dev); */</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize dev-&gt;board_name.  Note that we can use the &quot;thisboard&quot;</span>
<span class="cm"> * macro now, since we just initialized it in the last line.</span>
<span class="cm"> */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the private structure area.  alloc_private() is a</span>
<span class="cm"> * convenient macro defined in comedidev.h.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_private</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmm32at_private</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the subdevice structures.  alloc_subdevice() is a</span>
<span class="cm"> * convenient macro defined in comedidev.h.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_subdevices</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">read_subdev</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="cm">/* analog input subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AI</span><span class="p">;</span>
	<span class="cm">/* we support single-ended (ground) and differential */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_GROUND</span> <span class="o">|</span> <span class="n">SDF_DIFF</span> <span class="o">|</span> <span class="n">SDF_CMD_READ</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_ranges</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">len_chanlist</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>	<span class="cm">/* This is the maximum chanlist length that</span>
<span class="cm">				   the board can handle */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">dmm32at_ai_rinsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmd</span> <span class="o">=</span> <span class="n">dmm32at_ai_cmd</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmdtest</span> <span class="o">=</span> <span class="n">dmm32at_ai_cmdtest</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cancel</span> <span class="o">=</span> <span class="n">dmm32at_ai_cancel</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* analog output subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_ranges</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="n">dmm32at_ao_winsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">dmm32at_ao_rinsn</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* digital i/o subdevice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">have_dio</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* get access to the DIO regs */</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRL</span><span class="p">,</span> <span class="n">DMM32AT_DIOACC</span><span class="p">);</span>
		<span class="cm">/* set the DIO&#39;s to the defualt input setting */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span> <span class="o">=</span> <span class="n">DMM32AT_DIRA</span> <span class="o">|</span> <span class="n">DMM32AT_DIRB</span> <span class="o">|</span>
		    <span class="n">DMM32AT_DIRCL</span> <span class="o">|</span> <span class="n">DMM32AT_DIRCH</span> <span class="o">|</span> <span class="n">DMM32AT_DIENABLE</span><span class="p">;</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOCONF</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span><span class="p">);</span>

		<span class="cm">/* set up the subdevice */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_DIO</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">dio_chans</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_digital</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_bits</span> <span class="o">=</span> <span class="n">dmm32at_dio_insn_bits</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">dmm32at_dio_insn_config</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_UNUSED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* success */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;comedi%d: dmm32at: attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dmm32at_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">)</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">,</span> <span class="n">DMM32AT_MEMSIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;instructions&quot; read/write data in &quot;one-shot&quot; or &quot;software-triggered&quot;</span>
<span class="cm"> * mode.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_ai_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">msb</span><span class="p">,</span> <span class="n">lsb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">range</span><span class="p">;</span>

	<span class="cm">/* get the channel and range number */</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="cm">/* printk(&quot;channel=0x%02x, range=%d\n&quot;,chan,range); */</span>

	<span class="cm">/* zero scan and fifo control and reset fifo */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_FIFOCNTRL</span><span class="p">,</span> <span class="n">DMM32AT_FIFORESET</span><span class="p">);</span>

	<span class="cm">/* write the ai channel range regs */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AILOW</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIHIGH</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
	<span class="cm">/* set the range bits */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AICONF</span><span class="p">,</span> <span class="n">dmm32at_rangebits</span><span class="p">[</span><span class="n">range</span><span class="p">]);</span>

	<span class="cm">/* wait for circuit to settle */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">40000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIRBACK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DMM32AT_STATUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">40000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;dmm32at: timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* convert n samples */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* trigger conversion */</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CONV</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="cm">/* wait for conversion to end */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">40000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AISTAT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DMM32AT_STATUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">40000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;dmm32at: timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* read data */</span>
		<span class="n">lsb</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AILSB</span><span class="p">);</span>
		<span class="n">msb</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIMSB</span><span class="p">);</span>

		<span class="cm">/* invert sign bit to make range unsigned, this is an</span>
<span class="cm">		   idiosyncrasy of the diamond board, it return</span>
<span class="cm">		   conversions as a signed value, i.e. -32768 to</span>
<span class="cm">		   32767, flipping the bit and interpreting it as</span>
<span class="cm">		   signed gives you a range of 0 to 65535 which is</span>
<span class="cm">		   used by comedi */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="p">((</span><span class="n">msb</span> <span class="o">^</span> <span class="mh">0x0080</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">lsb</span><span class="p">;</span>

		<span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_chan</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* printk(&quot;dmmat32 in command test\n&quot;); */</span>

	<span class="cm">/* cmdtest tests a particular command to see if it is valid.</span>
<span class="cm">	 * Using the cmdtest ioctl, a user can create a valid cmd</span>
<span class="cm">	 * and then have it executes by the cmd ioctl.</span>
<span class="cm">	 *</span>
<span class="cm">	 * cmdtest returns 1,2,3,4 or 0, depending on which tests</span>
<span class="cm">	 * the command passes. */</span>

	<span class="cm">/* step 1: make sure trigger sources are trivially valid */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_NOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="cm">/*| TRIG_EXT */</span> <span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="cm">/*| TRIG_EXT */</span> <span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span> <span class="o">|</span> <span class="n">TRIG_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* step 2: make sure trigger sources are unique and mutually</span>
<span class="cm">	 * compatible */</span>

	<span class="cm">/* note that mutual compatibility is not an issue here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">!=</span> <span class="n">TRIG_COUNT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">!=</span> <span class="n">TRIG_NONE</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* step 3: make sure arguments are trivially compatible */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#define MAX_SCAN_SPEED	1000000	</span><span class="cm">/* in nanoseconds */</span><span class="cp"></span>
<span class="cp">#define MIN_SCAN_SPEED	1000000000	</span><span class="cm">/* in nanoseconds */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span> <span class="n">MAX_SCAN_SPEED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">MAX_SCAN_SPEED</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="n">MIN_SCAN_SPEED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">MIN_SCAN_SPEED</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* external trigger */</span>
		<span class="cm">/* should be level/edge, hi/lo specification here */</span>
		<span class="cm">/* should specify multiple external triggers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;=</span> <span class="mi">17500</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;=</span> <span class="mi">12500</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;=</span> <span class="mi">7500</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* external trigger */</span>
		<span class="cm">/* see above */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">&gt;</span> <span class="mh">0xfffffff0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mh">0xfffffff0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* TRIG_NONE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* step 4: fix up any arguments */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">;</span>
		<span class="n">dmm32at_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">;</span>
		<span class="n">dmm32at_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span>
			    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* step 5 check the channel list, the channel list for this</span>
<span class="cm">	   board must be consecutive and gains must be the same */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gain</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">start_chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span>
			    <span class="p">(</span><span class="n">start_chan</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					     <span class="s">&quot;entries in chanlist must be consecutive channels, counting upwards</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">gain</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					     <span class="s">&quot;entries in chanlist must all have the same gain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">range</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chanlo</span><span class="p">,</span> <span class="n">chanhi</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* get the channel list and range */</span>
	<span class="n">chanlo</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">chanhi</span> <span class="o">=</span> <span class="n">chanlo</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chanhi</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* reset fifo */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_FIFOCNTRL</span><span class="p">,</span> <span class="n">DMM32AT_FIFORESET</span><span class="p">);</span>

	<span class="cm">/* set scan enable */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_FIFOCNTRL</span><span class="p">,</span> <span class="n">DMM32AT_SCANENABLE</span><span class="p">);</span>

	<span class="cm">/* write the ai channel range regs */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AILOW</span><span class="p">,</span> <span class="n">chanlo</span><span class="p">);</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIHIGH</span><span class="p">,</span> <span class="n">chanhi</span><span class="p">);</span>

	<span class="cm">/* set the range bits */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AICONF</span><span class="p">,</span> <span class="n">dmm32at_rangebits</span><span class="p">[</span><span class="n">range</span><span class="p">]);</span>

	<span class="cm">/* reset the interrupt just in case */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRL</span><span class="p">,</span> <span class="n">DMM32AT_INTRESET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_COUNT</span><span class="p">)</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scans_left</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>			<span class="cm">/* TRIG_NONE */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scans_left</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span> <span class="cm">/* indicates TRIG_NONE to</span>
<span class="cm">						      * isr */</span>
	<span class="p">}</span>

	<span class="cm">/* wait for circuit to settle */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">40000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIRBACK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DMM32AT_STATUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">40000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;dmm32at: timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scans_left</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* start the clock and enable the interrupts */</span>
		<span class="n">dmm32at_setaitimer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* start the interrups and initiate a single scan */</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_INTCLOCK</span><span class="p">,</span> <span class="n">DMM32AT_ADINT</span><span class="p">);</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CONV</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cm">/*	printk(&quot;dmmat32 in command\n&quot;); */</span>

<span class="cm">/*	for(i=0;i&lt;cmd-&gt;chanlist_len;i++) */</span>
<span class="cm">/*		comedi_buf_put(s-&gt;async,i*100); */</span>

<span class="cm">/*	s-&gt;async-&gt;events |= COMEDI_CB_EOA; */</span>
<span class="cm">/*	comedi_event(dev, s); */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scans_left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dmm32at_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intstat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">samp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">msb</span><span class="p">,</span> <span class="n">lsb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">attached</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;spurious interrupt&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">intstat</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_INTCLOCK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">DMM32AT_ADINT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">read_subdev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* read data */</span>
			<span class="n">lsb</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AILSB</span><span class="p">);</span>
			<span class="n">msb</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_AIMSB</span><span class="p">);</span>

			<span class="cm">/* invert sign bit to make range unsigned */</span>
			<span class="n">samp</span> <span class="o">=</span> <span class="p">((</span><span class="n">msb</span> <span class="o">^</span> <span class="mh">0x0080</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">lsb</span><span class="p">;</span>
			<span class="n">comedi_buf_put</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">,</span> <span class="n">samp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scans_left</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* TRIG_COUNT */</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scans_left</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scans_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* disable further interrupts and clocks */</span>
				<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_INTCLOCK</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
				<span class="cm">/* set the buffer to be flushed with an EOF */</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>
		<span class="cm">/* flush the buffer */</span>
		<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* reset the interrupt */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRL</span><span class="p">,</span> <span class="n">DMM32AT_INTRESET</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function doesn&#39;t require a particular form, this is just</span>
<span class="cm"> * what happens to be used in some of the drivers.  It should</span>
<span class="cm"> * convert ns nanoseconds to a counter value suitable for programming</span>
<span class="cm"> * the device.  Also, it should adjust ns so that it cooresponds to</span>
<span class="cm"> * the actual time that the device will use. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_ns_to_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">round</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* trivial timer */</span>
	<span class="cm">/* if your timing is done through two cascaded timers, the</span>
<span class="cm">	 * i8253_cascade_ns_to_timer() function in 8253.h can be</span>
<span class="cm">	 * very helpful.  There are also i8254_load() and i8254_mm_load()</span>
<span class="cm">	 * which can be used to load values into the ubiquitous 8254 counters</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Writing a list of values to an AO channel is probably not</span>
<span class="cm">	 * very useful, but that&#39;s how the interface is defined. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* get the low byte */</span>
		<span class="n">lo</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>
		<span class="cm">/* high byte also contains channel number */</span>
		<span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">chan</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="cm">/* printk(&quot;writing 0x%02x  0x%02x\n&quot;,hi,lo); */</span>
		<span class="cm">/* write the low and high values to the board */</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DACLSB</span><span class="p">,</span> <span class="n">lo</span><span class="p">);</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DACMSB</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

		<span class="cm">/* wait for circuit to settle */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">40000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DACSTAT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DMM32AT_DACBUSY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">40000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;dmm32at: timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* dummy read to update trigger the output */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DACMSB</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* AO subdevices should have a read insn as well as a write insn.</span>
<span class="cm"> * Usually this means copying a value stored in devpriv. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DIO devices are slightly special.  Although it is possible to</span>
<span class="cm"> * implement the insn_read/insn_write interface, it is much more</span>
<span class="cm"> * useful to applications if you implement the insn_bits interface.</span>
<span class="cm"> * This allows packed reading/writing of the DIO channels.  The</span>
<span class="cm"> * comedi core can convert between insn_bits and insn_read/write */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_dio_insn_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">diobits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* The insn data is a mask in data[0] and the new data</span>
<span class="cm">	 * in data[1], each channel cooresponding to a bit. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="cm">/* Write out the new digital output lines */</span>
		<span class="cm">/* outw(s-&gt;state,dev-&gt;iobase + DMM32AT_DIO); */</span>
	<span class="p">}</span>

	<span class="cm">/* get access to the DIO regs */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRL</span><span class="p">,</span> <span class="n">DMM32AT_DIOACC</span><span class="p">);</span>

	<span class="cm">/* if either part of dio is set for output */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span> <span class="o">&amp;</span> <span class="n">DMM32AT_DIRCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span> <span class="o">&amp;</span> <span class="n">DMM32AT_DIRCH</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">diobits</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="mh">0x00ff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOC</span><span class="p">,</span> <span class="n">diobits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span> <span class="o">&amp;</span> <span class="n">DMM32AT_DIRB</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diobits</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="mh">0x0000ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOB</span><span class="p">,</span> <span class="n">diobits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span> <span class="o">&amp;</span> <span class="n">DMM32AT_DIRA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diobits</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="mh">0x000000ff</span><span class="p">);</span>
		<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOA</span><span class="p">,</span> <span class="n">diobits</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now read the state back in */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOC</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOB</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">dmm_inb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOA</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="cm">/* on return, data[1] contains the value of the digital</span>
<span class="cm">	 * input and output lines. */</span>
	<span class="cm">/* data[1]=inw(dev-&gt;iobase + DMM32AT_DIO); */</span>
	<span class="cm">/* or we could just return the software copy of the output values if</span>
<span class="cm">	 * it was a purely digital output subdevice */</span>
	<span class="cm">/* data[1]=s-&gt;state; */</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmm32at_dio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chanbit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">chanbit</span> <span class="o">=</span> <span class="n">DMM32AT_DIRA</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">chanbit</span> <span class="o">=</span> <span class="n">DMM32AT_DIRB</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span>
		<span class="n">chanbit</span> <span class="o">=</span> <span class="n">DMM32AT_DIRCL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">chanbit</span> <span class="o">=</span> <span class="n">DMM32AT_DIRCH</span><span class="p">;</span>

	<span class="cm">/* The input or output configuration of each digital line is</span>
<span class="cm">	 * configured by a special insn_config instruction.  chanspec</span>
<span class="cm">	 * contains the channel to be changed, and data[0] contains the</span>
<span class="cm">	 * value COMEDI_INPUT or COMEDI_OUTPUT. */</span>

	<span class="cm">/* if output clear the bit, otherwise set it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">COMEDI_OUTPUT</span><span class="p">)</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">chanbit</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span> <span class="o">|=</span> <span class="n">chanbit</span><span class="p">;</span>
	<span class="cm">/* get access to the DIO regs */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRL</span><span class="p">,</span> <span class="n">DMM32AT_DIOACC</span><span class="p">);</span>
	<span class="cm">/* set the DIO&#39;s to the new configuration setting */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_DIOCONF</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dio_config</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dmm32at_setaitimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nansec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">hi2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">both2</span><span class="p">;</span>

	<span class="cm">/* based on 10mhz clock */</span>
	<span class="n">lo1</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
	<span class="n">both2</span> <span class="o">=</span> <span class="n">nansec</span> <span class="o">/</span> <span class="mi">20000</span><span class="p">;</span>
	<span class="n">hi2</span> <span class="o">=</span> <span class="p">(</span><span class="n">both2</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">lo2</span> <span class="o">=</span> <span class="n">both2</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>

	<span class="cm">/* set the counter frequency to 10mhz */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRDIO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* get access to the clock regs */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CNTRL</span><span class="p">,</span> <span class="n">DMM32AT_CLKACC</span><span class="p">);</span>

	<span class="cm">/* write the counter 1 control word and low byte to counter */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CLKCT</span><span class="p">,</span> <span class="n">DMM32AT_CLKCT1</span><span class="p">);</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CLK1</span><span class="p">,</span> <span class="n">lo1</span><span class="p">);</span>

	<span class="cm">/* write the counter 2 control word and low byte then to counter */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CLKCT</span><span class="p">,</span> <span class="n">DMM32AT_CLKCT2</span><span class="p">);</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CLK2</span><span class="p">,</span> <span class="n">lo2</span><span class="p">);</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_CLK2</span><span class="p">,</span> <span class="n">hi2</span><span class="p">);</span>

	<span class="cm">/* enable the ai conversion interrupt and the clock to start scans */</span>
	<span class="n">dmm_outb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMM32AT_INTCLOCK</span><span class="p">,</span> <span class="n">DMM32AT_ADINT</span> <span class="o">|</span> <span class="n">DMM32AT_CLKSEL</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A convenient macro that defines init_module() and cleanup_module(),</span>
<span class="cm"> * as necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">driver_dmm32at_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">comedi_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_dmm32at</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">driver_dmm32at_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">comedi_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_dmm32at</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">driver_dmm32at_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">driver_dmm32at_cleanup_module</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Comedi http://www.comedi.org&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Comedi low-level driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
