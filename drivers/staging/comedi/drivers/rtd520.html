<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › rtd520.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>rtd520.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    comedi/drivers/rtd520.c</span>
<span class="cm">    Comedi driver for Real Time Devices (RTD) PCI4520/DM7520</span>

<span class="cm">    COMEDI - Linux Control and Measurement Device Interface</span>
<span class="cm">    Copyright (C) 2001 David A. Schleef &lt;ds@schleef.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">Driver: rtd520</span>
<span class="cm">Description: Real Time Devices PCI4520/DM7520</span>
<span class="cm">Author: Dan Christian</span>
<span class="cm">Devices: [Real Time Devices] DM7520HR-1 (rtd520), DM7520HR-8,</span>
<span class="cm">  PCI4520, PCI4520-8</span>
<span class="cm">Status: Works.  Only tested on DM7520-8.  Not SMP safe.</span>

<span class="cm">Configuration options:</span>
<span class="cm">  [0] - PCI bus of device (optional)</span>
<span class="cm">	If bus / slot is not specified, the first available PCI</span>
<span class="cm">	device will be used.</span>
<span class="cm">  [1] - PCI slot of device (optional)</span>
<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">    Created by Dan Christian, NASA Ames Research Center.</span>

<span class="cm">    The PCI4520 is a PCI card.  The DM7520 is a PC/104-plus card.</span>
<span class="cm">    Both have:</span>
<span class="cm">    8/16 12 bit ADC with FIFO and channel gain table</span>
<span class="cm">    8 bits high speed digital out (for external MUX) (or 8 in or 8 out)</span>
<span class="cm">    8 bits high speed digital in with FIFO and interrupt on change (or 8 IO)</span>
<span class="cm">    2 12 bit DACs with FIFOs</span>
<span class="cm">    2 bits output</span>
<span class="cm">    2 bits input</span>
<span class="cm">    bus mastering DMA</span>
<span class="cm">    timers: ADC sample, pacer, burst, about, delay, DA1, DA2</span>
<span class="cm">    sample counter</span>
<span class="cm">    3 user timer/counters (8254)</span>
<span class="cm">    external interrupt</span>

<span class="cm">    The DM7520 has slightly fewer features (fewer gain steps).</span>

<span class="cm">    These boards can support external multiplexors and multi-board</span>
<span class="cm">    synchronization, but this driver doesn&#39;t support that.</span>

<span class="cm">    Board docs: http://www.rtdusa.com/PC104/DM/analog%20IO/dm7520.htm</span>
<span class="cm">    Data sheet: http://www.rtdusa.com/pdf/dm7520.pdf</span>
<span class="cm">    Example source: http://www.rtdusa.com/examples/dm/dm7520.zip</span>
<span class="cm">    Call them and ask for the register level manual.</span>
<span class="cm">    PCI chip: http://www.plxtech.com/products/io/pci9080</span>

<span class="cm">    Notes:</span>
<span class="cm">    This board is memory mapped.  There is some IO stuff, but it isn&#39;t needed.</span>

<span class="cm">    I use a pretty loose naming style within the driver (rtd_blah).</span>
<span class="cm">    All externally visible names should be rtd520_blah.</span>
<span class="cm">    I use camelCase for structures (and inside them).</span>
<span class="cm">    I may also use upper CamelCase for function names (old habit).</span>

<span class="cm">    This board is somewhat related to the RTD PCI4400 board.</span>

<span class="cm">    I borrowed heavily from the ni_mio_common, ni_atmio16d, mite, and</span>
<span class="cm">    das1800, since they have the best documented code.  Driver</span>
<span class="cm">    cb_pcidas64.c uses the same DMA controller.</span>

<span class="cm">    As far as I can tell, the About interrupt doesn&#39;t work if Sample is</span>
<span class="cm">    also enabled.  It turns out that About really isn&#39;t needed, since</span>
<span class="cm">    we always count down samples read.</span>

<span class="cm">    There was some timer/counter code, but it didn&#39;t follow the right API.</span>

<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  driver status:</span>

<span class="cm">  Analog-In supports instruction and command mode.</span>

<span class="cm">  With DMA, you can sample at 1.15Mhz with 70% idle on a 400Mhz K6-2</span>
<span class="cm">  (single channel, 64K read buffer).  I get random system lockups when</span>
<span class="cm">  using DMA with ALI-15xx based systems.  I haven&#39;t been able to test</span>
<span class="cm">  any other chipsets.  The lockups happen soon after the start of an</span>
<span class="cm">  acquistion, not in the middle of a long run.</span>

<span class="cm">  Without DMA, you can do 620Khz sampling with 20% idle on a 400Mhz K6-2</span>
<span class="cm">  (with a 256K read buffer).</span>

<span class="cm">  Digital-IO and Analog-Out only support instruction mode.</span>

<span class="cm">*/</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>

<span class="cp">#include &quot;../comedidev.h&quot;</span>
<span class="cp">#include &quot;comedi_pci.h&quot;</span>

<span class="cp">#define DRV_NAME &quot;rtd520&quot;</span>

<span class="cm">/*======================================================================</span>
<span class="cm">  Driver specific stuff (tunable)</span>
<span class="cm">======================================================================*/</span>
<span class="cm">/* Enable this to test the new DMA support. You may get hard lock ups */</span>
<span class="cm">/*#define USE_DMA*/</span>

<span class="cm">/* We really only need 2 buffers.  More than that means being much</span>
<span class="cm">   smarter about knowing which ones are full. */</span>
<span class="cp">#define DMA_CHAIN_COUNT 2	</span><span class="cm">/* max DMA segments/buffers in a ring (min 2) */</span><span class="cp"></span>

<span class="cm">/* Target period for periodic transfers.  This sets the user read latency. */</span>
<span class="cm">/* Note: There are certain rates where we give this up and transfer 1/2 FIFO */</span>
<span class="cm">/* If this is too low, efficiency is poor */</span>
<span class="cp">#define TRANS_TARGET_PERIOD 10000000	</span><span class="cm">/* 10 ms (in nanoseconds) */</span><span class="cp"></span>

<span class="cm">/* Set a practical limit on how long a list to support (affects memory use) */</span>
<span class="cm">/* The board support a channel list up to the FIFO length (1K or 8K) */</span>
<span class="cp">#define RTD_MAX_CHANLIST	128	</span><span class="cm">/* max channel list that we allow */</span><span class="cp"></span>

<span class="cm">/* tuning for ai/ao instruction done polling */</span>
<span class="cp">#ifdef FAST_SPIN</span>
<span class="cp">#define WAIT_QUIETLY		</span><span class="cm">/* as nothing, spin on done bit */</span><span class="cp"></span>
<span class="cp">#define RTD_ADC_TIMEOUT	66000	</span><span class="cm">/* 2 msec at 33mhz bus rate */</span><span class="cp"></span>
<span class="cp">#define RTD_DAC_TIMEOUT	66000</span>
<span class="cp">#define RTD_DMA_TIMEOUT	33000	</span><span class="cm">/* 1 msec */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cm">/* by delaying, power and electrical noise are reduced somewhat */</span>
<span class="cp">#define WAIT_QUIETLY	udelay(1)</span>
<span class="cp">#define RTD_ADC_TIMEOUT	2000	</span><span class="cm">/* in usec */</span><span class="cp"></span>
<span class="cp">#define RTD_DAC_TIMEOUT	2000	</span><span class="cm">/* in usec */</span><span class="cp"></span>
<span class="cp">#define RTD_DMA_TIMEOUT	1000	</span><span class="cm">/* in usec */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*======================================================================</span>
<span class="cm">  Board specific stuff</span>
<span class="cm">======================================================================*/</span>

<span class="cm">/* registers  */</span>
<span class="cp">#define PCI_VENDOR_ID_RTD	0x1435</span>
<span class="cm">/*</span>
<span class="cm">  The board has three memory windows: las0, las1, and lcfg (the PCI chip)</span>
<span class="cm">  Las1 has the data and can be burst DMAed 32bits at a time.</span>
<span class="cm">*/</span>
<span class="cp">#define LCFG_PCIINDEX	0</span>
<span class="cm">/* PCI region 1 is a 256 byte IO space mapping.  Use??? */</span>
<span class="cp">#define LAS0_PCIINDEX	2	</span><span class="cm">/* PCI memory resources */</span><span class="cp"></span>
<span class="cp">#define LAS1_PCIINDEX	3</span>
<span class="cp">#define LCFG_PCISIZE	0x100</span>
<span class="cp">#define LAS0_PCISIZE	0x200</span>
<span class="cp">#define LAS1_PCISIZE	0x10</span>

<span class="cp">#define RTD_CLOCK_RATE	8000000	</span><span class="cm">/* 8Mhz onboard clock */</span><span class="cp"></span>
<span class="cp">#define RTD_CLOCK_BASE	125	</span><span class="cm">/* clock period in ns */</span><span class="cp"></span>

<span class="cm">/* Note: these speed are slower than the spec, but fit the counter resolution*/</span>
<span class="cp">#define RTD_MAX_SPEED	1625	</span><span class="cm">/* when sampling, in nanoseconds */</span><span class="cp"></span>
<span class="cm">/* max speed if we don&#39;t have to wait for settling */</span>
<span class="cp">#define RTD_MAX_SPEED_1	875	</span><span class="cm">/* if single channel, in nanoseconds */</span><span class="cp"></span>

<span class="cp">#define RTD_MIN_SPEED	2097151875	</span><span class="cm">/* (24bit counter) in nanoseconds */</span><span class="cp"></span>
<span class="cm">/* min speed when only 1 channel (no burst counter) */</span>
<span class="cp">#define RTD_MIN_SPEED_1	5000000	</span><span class="cm">/* 200Hz, in nanoseconds */</span><span class="cp"></span>

<span class="cp">#include &quot;rtd520.h&quot;</span>
<span class="cp">#include &quot;plx9080.h&quot;</span>

<span class="cm">/* Setup continuous ring of 1/2 FIFO transfers.  See RTD manual p91 */</span>
<span class="cp">#define DMA_MODE_BITS (\</span>
<span class="cp">		       PLX_LOCAL_BUS_16_WIDE_BITS \</span>
<span class="cp">		       | PLX_DMA_EN_READYIN_BIT \</span>
<span class="cp">		       | PLX_DMA_LOCAL_BURST_EN_BIT \</span>
<span class="cp">		       | PLX_EN_CHAIN_BIT \</span>
<span class="cp">		       | PLX_DMA_INTR_PCI_BIT \</span>
<span class="cp">		       | PLX_LOCAL_ADDR_CONST_BIT \</span>
<span class="cp">		       | PLX_DEMAND_MODE_BIT)</span>

<span class="cp">#define DMA_TRANSFER_BITS (\</span>
<span class="cm">/* descriptors in PCI memory*/</span><span class="cp">  PLX_DESC_IN_PCI_BIT \</span>
<span class="cm">/* interrupt at end of block */</span><span class="cp"> | PLX_INTR_TERM_COUNT \</span>
<span class="cm">/* from board to PCI */</span><span class="cp">		| PLX_XFER_LOCAL_TO_PCI)</span>

<span class="cm">/*======================================================================</span>
<span class="cm">  Comedi specific stuff</span>
<span class="cm">======================================================================*/</span>

<span class="cm">/*</span>
<span class="cm">  The board has 3 input modes and the gains of 1,2,4,...32 (, 64, 128)</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">rtd_ai_7520_range</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">18</span><span class="p">,</span> <span class="p">{</span>
							     <span class="cm">/* +-5V input range gain steps */</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span>
								       <span class="mi">16</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span>
								       <span class="mi">32</span><span class="p">),</span>
							     <span class="cm">/* +-10V input range gain steps */</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">2</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">4</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">8</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">16</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">32</span><span class="p">),</span>
							     <span class="cm">/* +10V input range gain steps */</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">2</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">4</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">8</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">16</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">32</span><span class="p">),</span>

							     <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* PCI4520 has two more gains (6 more entries) */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">rtd_ai_4520_range</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">24</span><span class="p">,</span> <span class="p">{</span>
							     <span class="cm">/* +-5V input range gain steps */</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span>
								       <span class="mi">16</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span>
								       <span class="mi">32</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span>
								       <span class="mi">64</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span>
								       <span class="mi">128</span><span class="p">),</span>
							     <span class="cm">/* +-10V input range gain steps */</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">2</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">4</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">8</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">16</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">32</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">64</span><span class="p">),</span>
							     <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">128</span><span class="p">),</span>
							     <span class="cm">/* +10V input range gain steps */</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">2</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">4</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">8</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">16</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">32</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">64</span><span class="p">),</span>
							     <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">/</span>
								       <span class="mi">128</span><span class="p">),</span>
							     <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Table order matches range values */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">rtd_ao_range</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="p">{</span>
						       <span class="n">RANGE</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
						       <span class="n">RANGE</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
						       <span class="n">RANGE</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
						       <span class="n">RANGE</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
						       <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">  Board descriptions</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rtdBoard</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>	<span class="cm">/* must be first */</span>
	<span class="kt">int</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">aiChans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">aiBits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">aiMaxGain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">range10Start</span><span class="p">;</span>	<span class="cm">/* start of +-10V range */</span>
	<span class="kt">int</span> <span class="n">rangeUniStart</span><span class="p">;</span>	<span class="cm">/* start of +10V range */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rtdBoard</span> <span class="n">rtd520Boards</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DM7520&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x7520</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">aiChans</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">aiBits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">aiMaxGain</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">range10Start</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">rangeUniStart</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;PCI4520&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x4520</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">aiChans</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">aiBits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">aiMaxGain</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">range10Start</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">rangeUniStart</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Useful for shorthand access to the particular board structure</span>
<span class="cm"> */</span>
<span class="cp">#define thisboard ((const struct rtdBoard *)dev-&gt;board_ptr)</span>

<span class="cm">/*</span>
<span class="cm">   This structure is for data unique to this hardware driver.</span>
<span class="cm">   This is also unique for each board in the system.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">rtdPrivate</span> <span class="p">{</span>
	<span class="cm">/* memory mapped board structures */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">las0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">las1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">lcfg</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intCount</span><span class="p">;</span>	<span class="cm">/* interrupt count */</span>
	<span class="kt">long</span> <span class="n">aiCount</span><span class="p">;</span>		<span class="cm">/* total transfer size (samples) */</span>
	<span class="kt">int</span> <span class="n">transCount</span><span class="p">;</span>		<span class="cm">/* # to transfer data. 0-&gt;1/2FIFO */</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* flag event modes */</span>

	<span class="cm">/* PCI device info */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">got_regions</span><span class="p">;</span>	<span class="cm">/* non-zero if PCI regions owned */</span>

	<span class="cm">/* channel list info */</span>
	<span class="cm">/* chanBipolar tracks whether a channel is bipolar (and needs +2048) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chanBipolar</span><span class="p">[</span><span class="n">RTD_MAX_CHANLIST</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>	<span class="cm">/* bit array */</span>

	<span class="cm">/* read back data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">aoValue</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* Used for AO read back */</span>

	<span class="cm">/* timer gate (when enabled) */</span>
	<span class="n">u8</span> <span class="n">utcGate</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* 1 extra allows simple range check */</span>

	<span class="cm">/* shadow registers affect other registers, but can&#39;t be read back */</span>
	<span class="cm">/* The macros below update these on writes */</span>
	<span class="n">u16</span> <span class="n">intMask</span><span class="p">;</span>		<span class="cm">/* interrupt mask */</span>
	<span class="n">u16</span> <span class="n">intClearMask</span><span class="p">;</span>	<span class="cm">/* interrupt clear mask */</span>
	<span class="n">u8</span> <span class="n">utcCtrl</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* crtl mode for 3 utc + read back */</span>
	<span class="n">u8</span> <span class="n">dioStatus</span><span class="p">;</span>		<span class="cm">/* could be read back (dio0Ctrl) */</span>
<span class="cp">#ifdef USE_DMA</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always DMA 1/2 FIFO.  Buffer (dmaBuff?) is (at least) twice that</span>
<span class="cm">	 * size.  After transferring, interrupt processes 1/2 FIFO and</span>
<span class="cm">	 * passes to comedi</span>
<span class="cm">	 */</span>
	<span class="n">s16</span> <span class="n">dma0Offset</span><span class="p">;</span>		<span class="cm">/* current processing offset (0, 1/2) */</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">DMA_CHAIN_COUNT</span><span class="p">];</span>	<span class="cm">/* DMA buffers (for ADC) */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma0BuffPhysAddr</span><span class="p">[</span><span class="n">DMA_CHAIN_COUNT</span><span class="p">];</span>	<span class="cm">/* physical addresses */</span>
	<span class="k">struct</span> <span class="n">plx_dma_desc</span> <span class="o">*</span><span class="n">dma0Chain</span><span class="p">;</span>	<span class="cm">/* DMA descriptor ring for dmaBuff */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma0ChainPhysAddr</span><span class="p">;</span>	<span class="cm">/* physical addresses */</span>
	<span class="cm">/* shadow registers */</span>
	<span class="n">u8</span> <span class="n">dma0Control</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dma1Control</span><span class="p">;</span>
<span class="cp">#endif				</span><span class="cm">/* USE_DMA */</span><span class="cp"></span>
	<span class="kt">unsigned</span> <span class="n">fifoLen</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* bit defines for &quot;flags&quot; */</span>
<span class="cp">#define SEND_EOS	0x01	</span><span class="cm">/* send End Of Scan events */</span><span class="cp"></span>
<span class="cp">#define DMA0_ACTIVE	0x02	</span><span class="cm">/* DMA0 is active */</span><span class="cp"></span>
<span class="cp">#define DMA1_ACTIVE	0x04	</span><span class="cm">/* DMA1 is active */</span><span class="cp"></span>

<span class="cm">/* Macros for accessing channel list bit array */</span>
<span class="cp">#define CHAN_ARRAY_TEST(array, index) \</span>
<span class="cp">	(((array)[(index)/8] &gt;&gt; ((index) &amp; 0x7)) &amp; 0x1)</span>
<span class="cp">#define CHAN_ARRAY_SET(array, index) \</span>
<span class="cp">	(((array)[(index)/8] |= 1 &lt;&lt; ((index) &amp; 0x7)))</span>
<span class="cp">#define CHAN_ARRAY_CLEAR(array, index) \</span>
<span class="cp">	(((array)[(index)/8] &amp;= ~(1 &lt;&lt; ((index) &amp; 0x7))))</span>

<span class="cm">/*</span>
<span class="cm"> * most drivers define the following macro to make it easy to</span>
<span class="cm"> * access the private structure.</span>
<span class="cm"> */</span>
<span class="cp">#define devpriv ((struct rtdPrivate *)dev-&gt;private)</span>

<span class="cm">/* Macros to access registers */</span>

<span class="cm">/* Reset board */</span>
<span class="cp">#define RtdResetBoard(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_BOARD_RESET)</span>

<span class="cm">/* Reset channel gain table read pointer */</span>
<span class="cp">#define RtdResetCGT(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_CGT_RESET)</span>

<span class="cm">/* Reset channel gain table read and write pointers */</span>
<span class="cp">#define RtdClearCGT(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_CGT_CLEAR)</span>

<span class="cm">/* Reset channel gain table read and write pointers */</span>
<span class="cp">#define RtdEnableCGT(dev, v) \</span>
<span class="cp">	writel((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_CGT_ENABLE)</span>

<span class="cm">/* Write channel gain table entry */</span>
<span class="cp">#define RtdWriteCGTable(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+LAS0_CGT_WRITE)</span>

<span class="cm">/* Write Channel Gain Latch */</span>
<span class="cp">#define RtdWriteCGLatch(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+LAS0_CGL_WRITE)</span>

<span class="cm">/* Reset ADC FIFO */</span>
<span class="cp">#define RtdAdcClearFifo(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_ADC_FIFO_CLEAR)</span>

<span class="cm">/* Set ADC start conversion source select (write only) */</span>
<span class="cp">#define RtdAdcConversionSource(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+LAS0_ADC_CONVERSION)</span>

<span class="cm">/* Set burst start source select (write only) */</span>
<span class="cp">#define RtdBurstStartSource(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+LAS0_BURST_START)</span>

<span class="cm">/* Set Pacer start source select (write only) */</span>
<span class="cp">#define RtdPacerStartSource(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+LAS0_PACER_START)</span>

<span class="cm">/* Set Pacer stop source select (write only) */</span>
<span class="cp">#define RtdPacerStopSource(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+LAS0_PACER_STOP)</span>

<span class="cm">/* Set Pacer clock source select (write only) 0=external 1=internal */</span>
<span class="cp">#define RtdPacerClockSource(dev, v) \</span>
<span class="cp">	writel((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_PACER_SELECT)</span>

<span class="cm">/* Set sample counter source select (write only) */</span>
<span class="cp">#define RtdAdcSampleCounterSource(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+LAS0_ADC_SCNT_SRC)</span>

<span class="cm">/* Set Pacer trigger mode select (write only) 0=single cycle, 1=repeat */</span>
<span class="cp">#define RtdPacerTriggerMode(dev, v) \</span>
<span class="cp">	writel((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_PACER_REPEAT)</span>

<span class="cm">/* Set About counter stop enable (write only) */</span>
<span class="cp">#define RtdAboutStopEnable(dev, v) \</span>
<span class="cp">	writel((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_ACNT_STOP_ENABLE)</span>

<span class="cm">/* Set external trigger polarity (write only) 0=positive edge, 1=negative */</span>
<span class="cp">#define RtdTriggerPolarity(dev, v) \</span>
<span class="cp">	writel((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_ETRG_POLARITY)</span>

<span class="cm">/* Start single ADC conversion */</span>
<span class="cp">#define RtdAdcStart(dev) \</span>
<span class="cp">	writew(0, devpriv-&gt;las0+LAS0_ADC)</span>

<span class="cm">/* Read one ADC data value (12bit (with sign extend) as 16bit) */</span>
<span class="cm">/* Note: matches what DMA would get.  Actual value &gt;&gt; 3 */</span>
<span class="cp">#define RtdAdcFifoGet(dev) \</span>
<span class="cp">	readw(devpriv-&gt;las1+LAS1_ADC_FIFO)</span>

<span class="cm">/* Read two ADC data values (DOESN&#39;T WORK) */</span>
<span class="cp">#define RtdAdcFifoGet2(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las1+LAS1_ADC_FIFO)</span>

<span class="cm">/* FIFO status */</span>
<span class="cp">#define RtdFifoStatus(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_ADC)</span>

<span class="cm">/* pacer start/stop read=start, write=stop*/</span>
<span class="cp">#define RtdPacerStart(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_PACER)</span>
<span class="cp">#define RtdPacerStop(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_PACER)</span>

<span class="cm">/* Interrupt status */</span>
<span class="cp">#define RtdInterruptStatus(dev) \</span>
<span class="cp">	readw(devpriv-&gt;las0+LAS0_IT)</span>

<span class="cm">/* Interrupt mask */</span>
<span class="cp">#define RtdInterruptMask(dev, v) \</span>
<span class="cp">	writew((devpriv-&gt;intMask = (v)), devpriv-&gt;las0+LAS0_IT)</span>

<span class="cm">/* Interrupt status clear (only bits set in mask) */</span>
<span class="cp">#define RtdInterruptClear(dev) \</span>
<span class="cp">	readw(devpriv-&gt;las0+LAS0_CLEAR)</span>

<span class="cm">/* Interrupt clear mask */</span>
<span class="cp">#define RtdInterruptClearMask(dev, v) \</span>
<span class="cp">	writew((devpriv-&gt;intClearMask = (v)), devpriv-&gt;las0+LAS0_CLEAR)</span>

<span class="cm">/* Interrupt overrun status */</span>
<span class="cp">#define RtdInterruptOverrunStatus(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_OVERRUN)</span>

<span class="cm">/* Interrupt overrun clear */</span>
<span class="cp">#define RtdInterruptOverrunClear(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_OVERRUN)</span>

<span class="cm">/* Pacer counter, 24bit */</span>
<span class="cp">#define RtdPacerCount(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_PCLK)</span>
<span class="cp">#define RtdPacerCounter(dev, v) \</span>
<span class="cp">	writel((v) &amp; 0xffffff, devpriv-&gt;las0+LAS0_PCLK)</span>

<span class="cm">/* Burst counter, 10bit */</span>
<span class="cp">#define RtdBurstCount(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_BCLK)</span>
<span class="cp">#define RtdBurstCounter(dev, v) \</span>
<span class="cp">	writel((v) &amp; 0x3ff, devpriv-&gt;las0+LAS0_BCLK)</span>

<span class="cm">/* Delay counter, 16bit */</span>
<span class="cp">#define RtdDelayCount(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_DCLK)</span>
<span class="cp">#define RtdDelayCounter(dev, v) \</span>
<span class="cp">	writel((v) &amp; 0xffff, devpriv-&gt;las0+LAS0_DCLK)</span>

<span class="cm">/* About counter, 16bit */</span>
<span class="cp">#define RtdAboutCount(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_ACNT)</span>
<span class="cp">#define RtdAboutCounter(dev, v) \</span>
<span class="cp">	writel((v) &amp; 0xffff, devpriv-&gt;las0+LAS0_ACNT)</span>

<span class="cm">/* ADC sample counter, 10bit */</span>
<span class="cp">#define RtdAdcSampleCount(dev) \</span>
<span class="cp">	readl(devpriv-&gt;las0+LAS0_ADC_SCNT)</span>
<span class="cp">#define RtdAdcSampleCounter(dev, v) \</span>
<span class="cp">	writel((v) &amp; 0x3ff, devpriv-&gt;las0+LAS0_ADC_SCNT)</span>

<span class="cm">/* User Timer/Counter (8254) */</span>
<span class="cp">#define RtdUtcCounterGet(dev, n) \</span>
<span class="cp">	readb(devpriv-&gt;las0 \</span>
<span class="cp">		+ ((n &lt;= 0) ? LAS0_UTC0 : ((1 == n) ? LAS0_UTC1 : LAS0_UTC2)))</span>

<span class="cp">#define RtdUtcCounterPut(dev, n, v) \</span>
<span class="cp">	writeb((v) &amp; 0xff, devpriv-&gt;las0 \</span>
<span class="cp">		+ ((n &lt;= 0) ? LAS0_UTC0 : ((1 == n) ? LAS0_UTC1 : LAS0_UTC2)))</span>

<span class="cm">/* Set UTC (8254) control byte  */</span>
<span class="cp">#define RtdUtcCtrlPut(dev, n, v) \</span>
<span class="cp">	writeb(devpriv-&gt;utcCtrl[(n) &amp; 3] = (((n) &amp; 3) &lt;&lt; 6) | ((v) &amp; 0x3f), \</span>
<span class="cp">		devpriv-&gt;las0 + LAS0_UTC_CTRL)</span>

<span class="cm">/* Set UTCn clock source (write only) */</span>
<span class="cp">#define RtdUtcClockSource(dev, n, v) \</span>
<span class="cp">	writew(v, devpriv-&gt;las0 \</span>
<span class="cp">		+ ((n &lt;= 0) ? LAS0_UTC0_CLOCK : \</span>
<span class="cp">			((1 == n) ? LAS0_UTC1_CLOCK : LAS0_UTC2_CLOCK)))</span>

<span class="cm">/* Set UTCn gate source (write only) */</span>
<span class="cp">#define RtdUtcGateSource(dev, n, v) \</span>
<span class="cp">	writew(v, devpriv-&gt;las0 \</span>
<span class="cp">		+ ((n &lt;= 0) ? LAS0_UTC0_GATE : \</span>
<span class="cp">			((1 == n) ? LAS0_UTC1_GATE : LAS0_UTC2_GATE)))</span>

<span class="cm">/* User output N source select (write only) */</span>
<span class="cp">#define RtdUsrOutSource(dev, n, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;las0+((n &lt;= 0) ? LAS0_UOUT0_SELECT : \</span>
<span class="cp">				LAS0_UOUT1_SELECT))</span>

<span class="cm">/* Digital IO */</span>
<span class="cp">#define RtdDio0Read(dev) \</span>
<span class="cp">	(readw(devpriv-&gt;las0+LAS0_DIO0) &amp; 0xff)</span>
<span class="cp">#define RtdDio0Write(dev, v) \</span>
<span class="cp">	writew((v) &amp; 0xff, devpriv-&gt;las0+LAS0_DIO0)</span>

<span class="cp">#define RtdDio1Read(dev) \</span>
<span class="cp">	(readw(devpriv-&gt;las0+LAS0_DIO1) &amp; 0xff)</span>
<span class="cp">#define RtdDio1Write(dev, v) \</span>
<span class="cp">	writew((v) &amp; 0xff, devpriv-&gt;las0+LAS0_DIO1)</span>

<span class="cp">#define RtdDioStatusRead(dev) \</span>
<span class="cp">	(readw(devpriv-&gt;las0+LAS0_DIO_STATUS) &amp; 0xff)</span>
<span class="cp">#define RtdDioStatusWrite(dev, v) \</span>
<span class="cp">	writew((devpriv-&gt;dioStatus = (v)), devpriv-&gt;las0+LAS0_DIO_STATUS)</span>

<span class="cp">#define RtdDio0CtrlRead(dev) \</span>
<span class="cp">	(readw(devpriv-&gt;las0+LAS0_DIO0_CTRL) &amp; 0xff)</span>
<span class="cp">#define RtdDio0CtrlWrite(dev, v) \</span>
<span class="cp">	writew((v) &amp; 0xff, devpriv-&gt;las0+LAS0_DIO0_CTRL)</span>

<span class="cm">/* Digital to Analog converter */</span>
<span class="cm">/* Write one data value (sign + 12bit + marker bits) */</span>
<span class="cm">/* Note: matches what DMA would put.  Actual value &lt;&lt; 3 */</span>
<span class="cp">#define RtdDacFifoPut(dev, n, v) \</span>
<span class="cp">	writew((v), devpriv-&gt;las1 + (((n) == 0) ? LAS1_DAC1_FIFO : \</span>
<span class="cp">				LAS1_DAC2_FIFO))</span>

<span class="cm">/* Start single DAC conversion */</span>
<span class="cp">#define RtdDacUpdate(dev, n) \</span>
<span class="cp">	writew(0, devpriv-&gt;las0 + (((n) == 0) ? LAS0_DAC1 : LAS0_DAC2))</span>

<span class="cm">/* Start single DAC conversion on both DACs */</span>
<span class="cp">#define RtdDacBothUpdate(dev) \</span>
<span class="cp">	writew(0, devpriv-&gt;las0+LAS0_DAC)</span>

<span class="cm">/* Set DAC output type and range */</span>
<span class="cp">#define RtdDacRange(dev, n, v) \</span>
<span class="cp">	writew((v) &amp; 7, devpriv-&gt;las0 \</span>
<span class="cp">		+(((n) == 0) ? LAS0_DAC1_CTRL : LAS0_DAC2_CTRL))</span>

<span class="cm">/* Reset DAC FIFO */</span>
<span class="cp">#define RtdDacClearFifo(dev, n) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+(((n) == 0) ? LAS0_DAC1_RESET : \</span>
<span class="cp">				LAS0_DAC2_RESET))</span>

<span class="cm">/* Set source for DMA 0 (write only, shadow?) */</span>
<span class="cp">#define RtdDma0Source(dev, n) \</span>
<span class="cp">	writel((n) &amp; 0xf, devpriv-&gt;las0+LAS0_DMA0_SRC)</span>

<span class="cm">/* Set source for DMA 1 (write only, shadow?) */</span>
<span class="cp">#define RtdDma1Source(dev, n) \</span>
<span class="cp">	writel((n) &amp; 0xf, devpriv-&gt;las0+LAS0_DMA1_SRC)</span>

<span class="cm">/* Reset board state for DMA 0 */</span>
<span class="cp">#define RtdDma0Reset(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_DMA0_RESET)</span>

<span class="cm">/* Reset board state for DMA 1 */</span>
<span class="cp">#define RtdDma1Reset(dev) \</span>
<span class="cp">	writel(0, devpriv-&gt;las0+LAS0_DMA1_SRC)</span>

<span class="cm">/* PLX9080 interrupt mask and status */</span>
<span class="cp">#define RtdPlxInterruptRead(dev) \</span>
<span class="cp">	readl(devpriv-&gt;lcfg+LCFG_ITCSR)</span>
<span class="cp">#define RtdPlxInterruptWrite(dev, v) \</span>
<span class="cp">	writel(v, devpriv-&gt;lcfg+LCFG_ITCSR)</span>

<span class="cm">/* Set  mode for DMA 0 */</span>
<span class="cp">#define RtdDma0Mode(dev, m) \</span>
<span class="cp">	writel((m), devpriv-&gt;lcfg+LCFG_DMAMODE0)</span>

<span class="cm">/* Set PCI address for DMA 0 */</span>
<span class="cp">#define RtdDma0PciAddr(dev, a) \</span>
<span class="cp">	writel((a), devpriv-&gt;lcfg+LCFG_DMAPADR0)</span>

<span class="cm">/* Set local address for DMA 0 */</span>
<span class="cp">#define RtdDma0LocalAddr(dev, a) \</span>
<span class="cp">	writel((a), devpriv-&gt;lcfg+LCFG_DMALADR0)</span>

<span class="cm">/* Set byte count for DMA 0 */</span>
<span class="cp">#define RtdDma0Count(dev, c) \</span>
<span class="cp">	writel((c), devpriv-&gt;lcfg+LCFG_DMASIZ0)</span>

<span class="cm">/* Set next descriptor for DMA 0 */</span>
<span class="cp">#define RtdDma0Next(dev, a) \</span>
<span class="cp">	writel((a), devpriv-&gt;lcfg+LCFG_DMADPR0)</span>

<span class="cm">/* Set  mode for DMA 1 */</span>
<span class="cp">#define RtdDma1Mode(dev, m) \</span>
<span class="cp">	writel((m), devpriv-&gt;lcfg+LCFG_DMAMODE1)</span>

<span class="cm">/* Set PCI address for DMA 1 */</span>
<span class="cp">#define RtdDma1PciAddr(dev, a) \</span>
<span class="cp">	writel((a), devpriv-&gt;lcfg+LCFG_DMAADR1)</span>

<span class="cm">/* Set local address for DMA 1 */</span>
<span class="cp">#define RtdDma1LocalAddr(dev, a) \</span>
<span class="cp">	writel((a), devpriv-&gt;lcfg+LCFG_DMALADR1)</span>

<span class="cm">/* Set byte count for DMA 1 */</span>
<span class="cp">#define RtdDma1Count(dev, c) \</span>
<span class="cp">	writel((c), devpriv-&gt;lcfg+LCFG_DMASIZ1)</span>

<span class="cm">/* Set next descriptor for DMA 1 */</span>
<span class="cp">#define RtdDma1Next(dev, a) \</span>
<span class="cp">	writel((a), devpriv-&gt;lcfg+LCFG_DMADPR1)</span>

<span class="cm">/* Set control for DMA 0 (write only, shadow?) */</span>
<span class="cp">#define RtdDma0Control(dev, n) \</span>
<span class="cp">	writeb(devpriv-&gt;dma0Control = (n), devpriv-&gt;lcfg+LCFG_DMACSR0)</span>

<span class="cm">/* Get status for DMA 0 */</span>
<span class="cp">#define RtdDma0Status(dev) \</span>
<span class="cp">	readb(devpriv-&gt;lcfg+LCFG_DMACSR0)</span>

<span class="cm">/* Set control for DMA 1 (write only, shadow?) */</span>
<span class="cp">#define RtdDma1Control(dev, n) \</span>
<span class="cp">	writeb(devpriv-&gt;dma1Control = (n), devpriv-&gt;lcfg+LCFG_DMACSR1)</span>

<span class="cm">/* Get status for DMA 1 */</span>
<span class="cp">#define RtdDma1Status(dev) \</span>
<span class="cp">	readb(devpriv-&gt;lcfg+LCFG_DMACSR1)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ai_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_dio_insn_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_dio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * static int rtd_ai_poll(struct comedi_device *dev,</span>
<span class="cm"> *			  struct comedi_subdevice *s);</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">roundMode</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">rtd_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd520_probe_fifo_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attach is called by the Comedi core to configure the driver</span>
<span class="cm"> * for a particular board.  If you specified a board_name array</span>
<span class="cm"> * in the driver structure, dev-&gt;board_ptr contains that</span>
<span class="cm"> * address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtd_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* board name and options flags */</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">physLas0</span><span class="p">;</span>	<span class="cm">/* configuration */</span>
	<span class="n">resource_size_t</span> <span class="n">physLas1</span><span class="p">;</span>	<span class="cm">/* data area */</span>
	<span class="n">resource_size_t</span> <span class="n">physLcfg</span><span class="p">;</span>	<span class="cm">/* PLX9080 */</span>
<span class="cp">#ifdef USE_DMA</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;comedi%d: rtd520 attaching.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_COMEDI_DEBUG) &amp;&amp; defined(USE_DMA)</span>
	<span class="cm">/* You can set this a load time: modprobe comedi comedi_debug=1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">comedi_debug</span><span class="p">)</span>	<span class="cm">/* force DMA debug printks */</span>
		<span class="n">comedi_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the private structure area.  alloc_private() is a</span>
<span class="cm">	 * convenient macro defined in comedidev.h.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_private</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtdPrivate</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Probe the device to determine what device in the series it is.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pcidev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RTD</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	     <span class="n">pcidev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	     <span class="n">pcidev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RTD</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">pcidev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">!=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			    <span class="o">||</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rtd520Boards</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">rtd520Boards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">device_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtd520Boards</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_ptr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* found one */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcidev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;No RTD card at bus=%d slot=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;No RTD card found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pcidev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">comedi_pci_enable</span><span class="p">(</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Failed to enable PCI device and request regions.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">got_regions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize base addresses</span>
<span class="cm">	 */</span>
	<span class="cm">/* Get the physical address from PCI config */</span>
	<span class="n">physLas0</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">LAS0_PCIINDEX</span><span class="p">);</span>
	<span class="n">physLas1</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">LAS1_PCIINDEX</span><span class="p">);</span>
	<span class="n">physLcfg</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">LCFG_PCIINDEX</span><span class="p">);</span>
	<span class="cm">/* Now have the kernel map this into memory */</span>
	<span class="cm">/* ASSUME page aligned */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las0</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">physLas0</span><span class="p">,</span> <span class="n">LAS0_PCISIZE</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las1</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">physLas1</span><span class="p">,</span> <span class="n">LAS1_PCISIZE</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">lcfg</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">physLcfg</span><span class="p">,</span> <span class="n">LCFG_PCISIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las0</span> <span class="o">||</span> <span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las1</span> <span class="o">||</span> <span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">lcfg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>


	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: LAS0=%llx, LAS1=%llx, CFG=%llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">physLas0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">physLas1</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">physLcfg</span><span class="p">);</span>
	<span class="p">{</span>			<span class="cm">/* The RTD driver does this */</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pci_latency</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">revision</span><span class="p">;</span>
		<span class="cm">/*uint32_t epld_version; */</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_REVISION_ID</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">revision</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%s: PCI revision %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span><span class="p">,</span> <span class="n">revision</span><span class="p">);</span>

		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				     <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_latency</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_latency</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: PCI latency changed from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span><span class="p">,</span> <span class="n">pci_latency</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					      <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: PCI latency = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_latency</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Undocumented EPLD version (doesn&#39;t match RTD driver results)</span>
<span class="cm">		 */</span>
		<span class="cm">/*DPRINTK (&quot;rtd520: Reading epld from %p\n&quot;,</span>
<span class="cm">		   devpriv-&gt;las0+0);</span>
<span class="cm">		   epld_version = readl (devpriv-&gt;las0+0);</span>
<span class="cm">		   if ((epld_version &amp; 0xF0) &gt;&gt; 4 == 0x0F) {</span>
<span class="cm">		   DPRINTK(&quot;rtd520: pre-v8 EPLD. (%x)\n&quot;, epld_version);</span>
<span class="cm">		   } else {</span>
<span class="cm">		   DPRINTK(&quot;rtd520: EPLD version %x.\n&quot;, epld_version &gt;&gt; 4);</span>
<span class="cm">		   } */</span>
	<span class="p">}</span>

	<span class="cm">/* Show board configuration */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s:&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the subdevice structures.  alloc_subdevice() is a</span>
<span class="cm">	 * convenient macro defined in comedidev.h.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_subdevices</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>


	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">read_subdev</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="cm">/* analog input subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AI</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span>
	    <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_GROUND</span> <span class="o">|</span> <span class="n">SDF_COMMON</span> <span class="o">|</span> <span class="n">SDF_DIFF</span> <span class="o">|</span> <span class="n">SDF_CMD_READ</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">aiChans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">aiBits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">aiMaxGain</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtd_ai_7520_range</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtd_ai_4520_range</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">len_chanlist</span> <span class="o">=</span> <span class="n">RTD_MAX_CHANLIST</span><span class="p">;</span>	<span class="cm">/* devpriv-&gt;fifoLen */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">rtd_ai_rinsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmd</span> <span class="o">=</span> <span class="n">rtd_ai_cmd</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmdtest</span> <span class="o">=</span> <span class="n">rtd_ai_cmdtest</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cancel</span> <span class="o">=</span> <span class="n">rtd_ai_cancel</span><span class="p">;</span>
	<span class="cm">/* s-&gt;poll = rtd_ai_poll; *//* not ready yet */</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* analog output subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">aiBits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtd_ao_range</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="n">rtd_ao_winsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">rtd_ao_rinsn</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* digital i/o subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_DIO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
	<span class="cm">/* we only support port 0 right now.  Ignoring port 1 and user IO */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_digital</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_bits</span> <span class="o">=</span> <span class="n">rtd_dio_insn_bits</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">rtd_dio_insn_config</span><span class="p">;</span>

	<span class="cm">/* timer/counter subdevices (not currently supported) */</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_COUNTER</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="cm">/* initialize board, per RTD spec */</span>
	<span class="cm">/* also, initialize shadow registers */</span>
	<span class="n">RtdResetBoard</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>		<span class="cm">/* needed? */</span>
	<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">RtdInterruptMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* and sets shadow */</span>
	<span class="n">RtdInterruptClearMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* and sets shadow */</span>
	<span class="n">RtdInterruptClear</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* clears bits set by mask */</span>
	<span class="n">RtdInterruptOverrunClear</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">RtdClearCGT</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">RtdAdcClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">RtdDacClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">RtdDacClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* clear digital IO fifo */</span>
	<span class="n">RtdDioStatusWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* safe state, set shadow */</span>
	<span class="n">RtdUtcCtrlPut</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">);</span>	<span class="cm">/* safe state, set shadow */</span>
	<span class="n">RtdUtcCtrlPut</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">);</span>	<span class="cm">/* safe state, set shadow */</span>
	<span class="n">RtdUtcCtrlPut</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">);</span>	<span class="cm">/* safe state, set shadow */</span>
	<span class="n">RtdUtcCtrlPut</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* safe state, set shadow */</span>
	<span class="cm">/* TODO: set user out source ??? */</span>

	<span class="cm">/* check if our interrupt is available and get it */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">rtd_interrupt</span><span class="p">,</span>
			  <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Could not get interrupt! (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;( irq=%u )&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rtd520_probe_fifo_depth</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;( fifoLen=%d )&quot;</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span><span class="p">);</span>

<span class="cp">#ifdef USE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;( DMA buff=%d )</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DMA_CHAIN_COUNT</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The PLX9080 has 2 DMA controllers, but there could be</span>
<span class="cm">		 * 4 sources: ADC, digital, DAC1, and DAC2.  Since only the</span>
<span class="cm">		 * ADC supports cmd mode right now, this isn&#39;t an issue (yet)</span>
<span class="cm">		 */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">DMA_CHAIN_COUNT</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span>
						 <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span>
						 <span class="n">dma0BuffPhysAddr</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">rtd_attach_die_error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*DPRINTK (&quot;buff[%d] @ %p virtual, %x PCI\n&quot;,</span>
<span class="cm">			   index,</span>
<span class="cm">			   devpriv-&gt;dma0Buff[index],</span>
<span class="cm">			   devpriv-&gt;dma0BuffPhysAddr[index]); */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * setup DMA descriptor ring (use cpu_to_le32 for byte</span>
<span class="cm">		 * ordering?)</span>
<span class="cm">		 */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span> <span class="o">=</span>
		    <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">plx_dma_desc</span><span class="p">)</span> <span class="o">*</span>
					 <span class="n">DMA_CHAIN_COUNT</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0ChainPhysAddr</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">DMA_CHAIN_COUNT</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">pci_start_addr</span> <span class="o">=</span>
			    <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0BuffPhysAddr</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">local_start_addr</span> <span class="o">=</span>
			    <span class="n">DMALADDR_ADC</span><span class="p">;</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">transfer_size</span> <span class="o">=</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0ChainPhysAddr</span> <span class="o">+</span> <span class="p">((</span><span class="n">index</span> <span class="o">+</span>
							    <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
							   <span class="p">(</span><span class="n">DMA_CHAIN_COUNT</span><span class="p">))</span>
			     <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
			    <span class="o">|</span> <span class="n">DMA_TRANSFER_BITS</span><span class="p">;</span>
			<span class="cm">/*DPRINTK (&quot;ring[%d] @%lx PCI: %x, local: %x, N: 0x%x, next: %x\n&quot;,</span>
<span class="cm">			   index,</span>
<span class="cm">			   ((long)devpriv-&gt;dma0ChainPhysAddr</span>
<span class="cm">			   + (index * sizeof(devpriv-&gt;dma0Chain[0]))),</span>
<span class="cm">			   devpriv-&gt;dma0Chain[index].pci_start_addr,</span>
<span class="cm">			   devpriv-&gt;dma0Chain[index].local_start_addr,</span>
<span class="cm">			   devpriv-&gt;dma0Chain[index].transfer_size,</span>
<span class="cm">			   devpriv-&gt;dma0Chain[index].next); */</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">rtd_attach_die_error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">RtdDma0Mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_MODE_BITS</span><span class="p">);</span>
		<span class="cm">/* set DMA trigger source */</span>
		<span class="n">RtdDma0Source</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMAS_ADFIFO_HALF_FULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;( no IRQ-&gt;no DMA )&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* enable plx9080 interrupts */</span>
		<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICS_PIE</span> <span class="o">|</span> <span class="n">ICS_PLIE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">comedi%d: rtd520 driver attached.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* hit an error, clean up memory and return ret */</span>
<span class="c">/* rtd_attach_die_error: */</span>
<span class="cp">#ifdef USE_DMA</span>
<span class="c">	for (index = 0; index &lt; DMA_CHAIN_COUNT; index++) {</span>
<span class="c">		if (NULL != devpriv-&gt;dma0Buff[index]) {	/* free buffer memory */</span>
<span class="c">			pci_free_consistent(devpriv-&gt;pci_dev,</span>
<span class="c">					    sizeof(u16) * devpriv-&gt;fifoLen / 2,</span>
<span class="c">					    devpriv-&gt;dma0Buff[index],</span>
<span class="c">					    devpriv-&gt;dma0BuffPhysAddr[index]);</span>
<span class="c">			devpriv-&gt;dma0Buff[index] = NULL;</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="c">	if (NULL != devpriv-&gt;dma0Chain) {</span>
<span class="c">		pci_free_consistent(devpriv-&gt;pci_dev,</span>
<span class="c">				    sizeof(struct plx_dma_desc)</span>
<span class="c">				    * DMA_CHAIN_COUNT,</span>
<span class="c">				    devpriv-&gt;dma0Chain,</span>
<span class="c">				    devpriv-&gt;dma0ChainPhysAddr);</span>
<span class="c">		devpriv-&gt;dma0Chain = NULL;</span>
<span class="c">	}</span>
<span class="cp">#endif /* USE_DMA */</span>
<span class="c">	/* subdevices and priv are freed by the core */</span>
<span class="c">	if (dev-&gt;irq) {</span>
<span class="c">		/* disable interrupt controller */</span>
<span class="c">		RtdPlxInterruptWrite(dev, RtdPlxInterruptRead(dev)</span>
<span class="c">				     &amp; ~(ICS_PLIE | ICS_DMA0_E | ICS_DMA1_E));</span>
<span class="c">		free_irq(dev-&gt;irq, dev);</span>
<span class="c">	}</span>

<span class="c">	/* release all regions that were allocated */</span>
<span class="c">	if (devpriv-&gt;las0)</span>
<span class="c">		iounmap(devpriv-&gt;las0);</span>

<span class="c">	if (devpriv-&gt;las1)</span>
<span class="c">		iounmap(devpriv-&gt;las1);</span>

<span class="c">	if (devpriv-&gt;lcfg)</span>
<span class="c">		iounmap(devpriv-&gt;lcfg);</span>

<span class="c">	if (devpriv-&gt;pci_dev)</span>
<span class="c">		pci_dev_put(devpriv-&gt;pci_dev);</span>

<span class="c">	return ret;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtd_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef USE_DMA</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Shut down any board ops by resetting it */</span>
<span class="cp">#ifdef USE_DMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">lcfg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RtdDma0Control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* disable DMA */</span>
			<span class="n">RtdDma1Control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* disable DMA */</span>
			<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICS_PIE</span> <span class="o">|</span> <span class="n">ICS_PLIE</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RtdResetBoard</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">RtdInterruptMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">RtdInterruptClearMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">RtdInterruptClear</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* clears bits set by mask */</span>
		<span class="p">}</span>
<span class="cp">#ifdef USE_DMA</span>
		<span class="cm">/* release DMA */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">DMA_CHAIN_COUNT</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span>
						    <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
						    <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
						    <span class="n">devpriv</span><span class="o">-&gt;</span>
						    <span class="n">dma0BuffPhysAddr</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">plx_dma_desc</span><span class="p">)</span> <span class="o">*</span>
					    <span class="n">DMA_CHAIN_COUNT</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">,</span>
					    <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0ChainPhysAddr</span><span class="p">);</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
					     <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ICS_PLIE</span> <span class="o">|</span> <span class="n">ICS_DMA0_E</span> <span class="o">|</span>
						 <span class="n">ICS_DMA1_E</span><span class="p">));</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las0</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las1</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">las1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">lcfg</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">lcfg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">got_regions</span><span class="p">)</span>
				<span class="n">comedi_pci_disable</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Convert a single comedi channel-gain entry to a RTD520 table entry</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">rtdConvertChanGain</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comediChan</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chanIndex</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* index in channel list */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">aref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">comediChan</span><span class="p">);</span>
	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">comediChan</span><span class="p">);</span>
	<span class="n">aref</span> <span class="o">=</span> <span class="n">CR_AREF</span><span class="p">(</span><span class="n">comediChan</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">|=</span> <span class="n">chan</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="cm">/* Note: we also setup the channel list bipolar flag array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span> <span class="o">&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">range10Start</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* first batch are +-5 */</span>
		<span class="n">r</span> <span class="o">|=</span> <span class="mh">0x000</span><span class="p">;</span>	<span class="cm">/* +-5 range */</span>
		<span class="n">r</span> <span class="o">|=</span> <span class="p">(</span><span class="n">range</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* gain */</span>
		<span class="n">CHAN_ARRAY_SET</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">chanBipolar</span><span class="p">,</span> <span class="n">chanIndex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">range</span> <span class="o">&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">rangeUniStart</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* second batch are +-10 */</span>
		<span class="n">r</span> <span class="o">|=</span> <span class="mh">0x100</span><span class="p">;</span>	<span class="cm">/* +-10 range */</span>
		<span class="cm">/* gain */</span>
		<span class="n">r</span> <span class="o">|=</span> <span class="p">((</span><span class="n">range</span> <span class="o">-</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">range10Start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">CHAN_ARRAY_SET</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">chanBipolar</span><span class="p">,</span> <span class="n">chanIndex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* last batch is +10 */</span>
		<span class="n">r</span> <span class="o">|=</span> <span class="mh">0x200</span><span class="p">;</span>	<span class="cm">/* +10 range */</span>
		<span class="cm">/* gain */</span>
		<span class="n">r</span> <span class="o">|=</span> <span class="p">((</span><span class="n">range</span> <span class="o">-</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">rangeUniStart</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">CHAN_ARRAY_CLEAR</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">chanBipolar</span><span class="p">,</span> <span class="n">chanIndex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">aref</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AREF_GROUND</span>:	<span class="cm">/* on-board ground */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AREF_COMMON</span>:
		<span class="n">r</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>	<span class="cm">/* ref external analog common */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AREF_DIFF</span>:
		<span class="n">r</span> <span class="o">|=</span> <span class="mh">0x400</span><span class="p">;</span>	<span class="cm">/* differential inputs */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AREF_OTHER</span>:	<span class="cm">/* ??? */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*printk (&quot;chan=%d r=%d a=%d -&gt; 0x%x\n&quot;,</span>
<span class="cm">	   chan, range, aref, r); */</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Setup the channel-gain table from a comedi list</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtd_load_channelgain_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_chan</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_chan</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* setup channel gain table */</span>
		<span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>
		<span class="n">RtdClearCGT</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">RtdEnableCGT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* enable table */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">n_chan</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RtdWriteCGTable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rtdConvertChanGain</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
								<span class="n">ii</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* just use the channel gain latch */</span>
		<span class="n">RtdEnableCGT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* disable table, enable latch */</span>
		<span class="n">RtdWriteCGLatch</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rtdConvertChanGain</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* determine fifo size by doing adc conversions until the fifo half</span>
<span class="cm">empty status flag clears */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtd520_probe_fifo_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chanspec</span> <span class="o">=</span> <span class="n">CR_PACK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AREF_GROUND</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">limit</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">fifo_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">RtdAdcClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rtd_load_channelgain_list</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="n">RtdAdcConversionSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* software */</span>
	<span class="cm">/* convert  samples */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">fifo_status</span><span class="p">;</span>
		<span class="cm">/* trigger conversion */</span>
		<span class="n">RtdAdcStart</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">fifo_status</span> <span class="o">=</span> <span class="n">RtdFifoStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fifo_status</span> <span class="o">&amp;</span> <span class="n">FS_ADC_HEMPTY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fifo_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">comedi: %s: failed to probe fifo size.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">DRV_NAME</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">RtdAdcClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fifo_size</span> <span class="o">!=</span> <span class="mh">0x400</span> <span class="o">&amp;&amp;</span> <span class="n">fifo_size</span> <span class="o">!=</span> <span class="mh">0x2000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span>
		    <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">comedi: %s: unexpected fifo size of %i, expected 1024 or 8192.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">fifo_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fifo_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  &quot;instructions&quot; read/write data in &quot;one-shot&quot; or &quot;software-triggered&quot;</span>
<span class="cm">  mode (simplest case).</span>
<span class="cm">  This doesn&#39;t use interrupts.</span>

<span class="cm">  Note, we don&#39;t do any settling delays.  Use a instruction list to</span>
<span class="cm">  select, delay, then read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtd_ai_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">ii</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>

	<span class="cm">/* clear any old fifo data */</span>
	<span class="n">RtdAdcClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* write channel to multiplexer and clear channel gain table */</span>
	<span class="n">rtd_load_channelgain_list</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="cm">/* set conversion source */</span>
	<span class="n">RtdAdcConversionSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* software */</span>

	<span class="cm">/* convert n samples */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s16</span> <span class="n">d</span><span class="p">;</span>
		<span class="cm">/* trigger conversion */</span>
		<span class="n">RtdAdcStart</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">RTD_ADC_TIMEOUT</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span> <span class="o">=</span> <span class="n">RtdFifoStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">FS_ADC_NOT_EMPTY</span><span class="p">)</span>	<span class="cm">/* 1 -&gt; not empty */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">WAIT_QUIETLY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;=</span> <span class="n">RTD_ADC_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINTK</span>
			    <span class="p">(</span><span class="s">&quot;rtd520: Error: ADC never finished! FifoStatus=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">stat</span> <span class="o">^</span> <span class="mh">0x6666</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* read data */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">RtdAdcFifoGet</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* get 2s comp value */</span>
		<span class="cm">/*printk (&quot;rtd520: Got 0x%x after %d usec\n&quot;, d, ii+1); */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* low 3 bits are marker lines */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CHAN_ARRAY_TEST</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">chanBipolar</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="cm">/* convert to comedi unsigned data */</span>
			<span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Get what we know is there.... Fast!</span>
<span class="cm">  This uses 1/2 the bus cycles of read_dregs (below).</span>

<span class="cm">  The manual claims that we can do a lword read, but it doesn&#39;t work here.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ai_read_n</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">short</span> <span class="n">sample</span><span class="p">;</span>
		<span class="n">s16</span> <span class="n">d</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* done */</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">RtdAdcFifoGet</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Read N and discard */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		if (0 == (RtdFifoStatus(dev) &amp; FS_ADC_NOT_EMPTY)) {	/* DEBUG */</span>
<span class="c">			DPRINTK(&quot;comedi: READ OOPS on %d of %d\n&quot;, ii + 1,</span>
<span class="c">				count);</span>
<span class="c">			break;</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">RtdAdcFifoGet</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* get 2s comp value */</span>

		<span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* low 3 bits are marker lines */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CHAN_ARRAY_TEST</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">chanBipolar</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cur_chan</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* convert to comedi unsigned data */</span>
			<span class="n">sample</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sample</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comedi_buf_put</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">,</span> <span class="n">sample</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* &lt; 0, means read forever */</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  unknown amout of data is waiting in fifo.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ai_read_dregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">RtdFifoStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FS_ADC_NOT_EMPTY</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* 1 -&gt; not empty */</span>
		<span class="kt">short</span> <span class="n">sample</span><span class="p">;</span>
		<span class="n">s16</span> <span class="n">d</span> <span class="o">=</span> <span class="n">RtdAdcFifoGet</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* get 2s comp value */</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* done */</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* read rest */</span>
		<span class="p">}</span>

		<span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* low 3 bits are marker lines */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CHAN_ARRAY_TEST</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">chanBipolar</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cur_chan</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* convert to comedi unsigned data */</span>
			<span class="n">sample</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sample</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comedi_buf_put</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">,</span> <span class="n">sample</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* &lt; 0, means read forever */</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef USE_DMA</span>
<span class="cm">/*</span>
<span class="cm">  Terminate a DMA transfer and wait for everything to quiet down</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">abort_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* DMA channel 0, 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_cs_addr</span><span class="p">;</span>	<span class="cm">/* the control/status register */</span>
	<span class="kt">uint8_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>
	<span class="cm">/* unsigned long flags; */</span>

	<span class="n">dma_cs_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">lcfg</span>
	    <span class="o">+</span> <span class="p">((</span><span class="n">channel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">LCFG_DMACSR0</span> <span class="o">:</span> <span class="n">LCFG_DMACSR1</span><span class="p">);</span>

	<span class="cm">/*  spinlock for plx dma control/status reg */</span>
	<span class="cm">/* spin_lock_irqsave( &amp;dev-&gt;spinlock, flags ); */</span>

	<span class="cm">/*  abort dma transfer if necessary */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">dma_cs_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PLX_DMA_EN_BIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* not enabled (Error?) */</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: AbortDma on non-active channel %d (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">channel</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abortDmaExit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wait to make sure done bit is zero (needed?) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PLX_DMA_DONE_BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">RTD_DMA_TIMEOUT</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WAIT_QUIETLY</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">dma_cs_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PLX_DMA_DONE_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;rtd520: Timeout waiting for dma %i done clear</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">channel</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abortDmaExit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* disable channel (required) */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dma_cs_addr</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>		<span class="cm">/* needed?? */</span>
	<span class="cm">/* set abort bit for channel */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">PLX_DMA_ABORT_BIT</span><span class="p">,</span> <span class="n">dma_cs_addr</span><span class="p">);</span>

	<span class="cm">/*  wait for dma done bit to be set */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">dma_cs_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PLX_DMA_DONE_BIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">RTD_DMA_TIMEOUT</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">dma_cs_addr</span><span class="p">);</span>
		<span class="n">WAIT_QUIETLY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PLX_DMA_DONE_BIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;rtd520: Timeout waiting for dma %i done set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">abortDmaExit:</span>
	<span class="cm">/* spin_unlock_irqrestore( &amp;dev-&gt;spinlock, flags ); */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Process what is in the DMA transfer buffer and pass to comedi</span>
<span class="cm">  Note: this is not re-entrant</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ai_process_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ii</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">s16</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* transfer already complete */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Offset</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;)</span> <span class="p">{</span>	<span class="cm">/* convert samples */</span>
		<span class="kt">short</span> <span class="n">sample</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">CHAN_ARRAY_TEST</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">chanBipolar</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cur_chan</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sample</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dp</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">;</span>	<span class="cm">/* convert to comedi unsigned data */</span>
		<span class="k">else</span>
			<span class="n">sample</span> <span class="o">=</span> <span class="o">*</span><span class="n">dp</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* low 3 bits are marker lines */</span>

		<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="n">sample</span><span class="p">;</span>	<span class="cm">/* put processed value back */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cur_chan</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">chanlist_len</span><span class="p">)</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cur_chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="o">++</span><span class="n">ii</span><span class="p">;</span>		<span class="cm">/* number ready to transfer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* &lt; 0, means read forever */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* done */</span>
				<span class="cm">/*DPRINTK (&quot;rtd520: Final %d samples\n&quot;, ii); */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* now pass the whole array to the comedi buffer */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Buff</span><span class="p">[</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Offset</span><span class="p">];</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">comedi_buf_write_alloc</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">,</span> <span class="n">ii</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s16</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ii</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s16</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/* any residual is an error */</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520:ai_process_dma buffer overflow %d samples!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ii</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s16</span><span class="p">)));</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">comedi_buf_memcpy_to</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">comedi_buf_write_free</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * always at least 1 scan -- 1/2 FIFO is larger than our max scan list</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_BLOCK</span> <span class="o">|</span> <span class="n">COMEDI_CB_EOS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Offset</span> <span class="o">&gt;=</span> <span class="n">DMA_CHAIN_COUNT</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* next buffer */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">  Handle all rtd520 interrupts.</span>
<span class="cm">  Runs atomically and is never re-entered.</span>
<span class="cm">  This is a &quot;slow handler&quot;;  other interrupts may be active.</span>
<span class="cm">  The data conversion may someday happen in a &quot;bottom half&quot;.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">rtd_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>	<span class="cm">/* interrupt number (ignored) */</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* our data *//* cpu context (ignored) */</span>
	<span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>	<span class="cm">/* must be called &quot;dev&quot; for devpriv */</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fifoStatus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* analog in subdevice */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">attached</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intCount</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* DEBUG statistics */</span>

	<span class="n">fifoStatus</span> <span class="o">=</span> <span class="n">RtdFifoStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* check for FIFO full, this automatically halts the ADC! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fifoStatus</span> <span class="o">&amp;</span> <span class="n">FS_ADC_NOT_FULL</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* 0 -&gt; full */</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: FIFO full! fifo_status=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">fifoStatus</span> <span class="o">^</span> <span class="mh">0x6666</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7777</span><span class="p">);</span>	<span class="cm">/* should be all 0s */</span>
		<span class="k">goto</span> <span class="n">abortTransfer</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef USE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA0_ACTIVE</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check DMA */</span>
		<span class="n">u32</span> <span class="n">istatus</span> <span class="o">=</span> <span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">istatus</span> <span class="o">&amp;</span> <span class="n">ICS_DMA0_A</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ai_process_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span>
				    <span class="p">(</span><span class="s">&quot;rtd520: comedi read buffer overflow (DMA) with %ld to go!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">);</span>
				<span class="n">RtdDma0Control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Control</span> <span class="o">&amp;</span>
						<span class="o">~</span><span class="n">PLX_DMA_START_BIT</span><span class="p">)</span>
					       <span class="o">|</span> <span class="n">PLX_CLEAR_DMA_INTR_BIT</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">abortTransfer</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*DPRINTK (&quot;rtd520: DMA transfer: %ld to go, istatus %x\n&quot;,</span>
<span class="cm">			   devpriv-&gt;aiCount, istatus); */</span>
			<span class="n">RtdDma0Control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span>
					<span class="n">dma0Control</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PLX_DMA_START_BIT</span><span class="p">)</span>
				       <span class="o">|</span> <span class="n">PLX_CLEAR_DMA_INTR_BIT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* counted down */</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Samples Done (DMA).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">transferDone</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*DPRINTK (&quot;rtd520: No DMA ready: istatus %x\n&quot;, istatus); */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Fall through and check for other interrupt sources */</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">RtdInterruptStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* if interrupt was not caused by our board, or handled above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQM_ADC_ABOUT_CNT</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* sample count -&gt; read FIFO */</span>
		<span class="cm">/* since the priority interrupt controller may have queued a sample</span>
<span class="cm">		   counter interrupt, even though we have already finished,</span>
<span class="cm">		   we must handle the possibility that there is no data here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fifoStatus</span> <span class="o">&amp;</span> <span class="n">FS_ADC_HEMPTY</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* 0 -&gt; 1/2 full */</span>
			<span class="cm">/*DPRINTK(&quot;rtd520: Sample int, reading 1/2FIFO.  fifo_status 0x%x\n&quot;,</span>
<span class="cm">			   (fifoStatus ^ 0x6666) &amp; 0x7777); */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ai_read_n</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span>
				    <span class="p">(</span><span class="s">&quot;rtd520: comedi read buffer overflow (1/2FIFO) with %ld to go!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">abortTransfer</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* counted down */</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Samples Done (1/2). fifo_status was 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">fifoStatus</span> <span class="o">^</span> <span class="mh">0x6666</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7777</span><span class="p">);</span>	<span class="cm">/* should be all 0s */</span>
				<span class="k">goto</span> <span class="n">transferDone</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* read often */</span>
			<span class="cm">/*DPRINTK(&quot;rtd520: Sample int, reading %d  fifo_status 0x%x\n&quot;,</span>
<span class="cm">			   devpriv-&gt;transCount, (fifoStatus ^ 0x6666) &amp; 0x7777); */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fifoStatus</span> <span class="o">&amp;</span> <span class="n">FS_ADC_NOT_EMPTY</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* 1 -&gt; not empty */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ai_read_n</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">DPRINTK</span>
					    <span class="p">(</span><span class="s">&quot;rtd520: comedi read buffer overflow (N) with %ld to go!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">abortTransfer</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* counted down */</span>
					<span class="n">DPRINTK</span>
					    <span class="p">(</span><span class="s">&quot;rtd520: Samples Done (N). fifo_status was 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">fifoStatus</span> <span class="o">^</span> <span class="mh">0x6666</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7777</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">transferDone</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* wait for 1/2 FIFO (old) */</span>
			<span class="n">DPRINTK</span>
			    <span class="p">(</span><span class="s">&quot;rtd520: Sample int.  Wait for 1/2. fifo_status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">fifoStatus</span> <span class="o">^</span> <span class="mh">0x6666</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7777</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: unknown interrupt source!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="mh">0xffff</span> <span class="o">&amp;</span> <span class="n">RtdInterruptOverrunStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* interrupt overrun */</span>
		<span class="n">DPRINTK</span>
		    <span class="p">(</span><span class="s">&quot;rtd520: Interrupt overrun with %ld to go! over_status=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">,</span> <span class="mh">0xffff</span> <span class="o">&amp;</span> <span class="n">RtdInterruptOverrunStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">abortTransfer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear the interrupt */</span>
	<span class="n">RtdInterruptClearMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">RtdInterruptClear</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

<span class="nl">abortTransfer:</span>
	<span class="n">RtdAdcClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* clears full flag */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_ERROR</span><span class="p">;</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* stop and don&#39;t transfer any more */</span>
	<span class="cm">/* fall into transferDone */</span>

<span class="nl">transferDone:</span>
	<span class="n">RtdPacerStopSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* stop on SOFTWARE stop */</span>
	<span class="n">RtdPacerStop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Stop PACER */</span>
	<span class="n">RtdAdcConversionSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* software trigger only */</span>
	<span class="n">RtdInterruptMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* mask out SAMPLE */</span>
<span class="cp">#ifdef USE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA0_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>	<span class="cm">/* disable any more interrupts */</span>
				     <span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ICS_DMA0_E</span><span class="p">);</span>
		<span class="n">abort_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA0_ACTIVE</span><span class="p">;</span>
		<span class="cm">/* if Using DMA, then we should have read everything by now */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Lost DMA data! %ld remain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* there shouldn&#39;t be anything left */</span>
		<span class="n">fifoStatus</span> <span class="o">=</span> <span class="n">RtdFifoStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Finishing up. %ld remain, fifoStat=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">,</span> <span class="p">(</span><span class="n">fifoStatus</span> <span class="o">^</span> <span class="mh">0x6666</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7777</span><span class="p">);</span>	<span class="cm">/* should read all 0s */</span>
		<span class="n">ai_read_dregs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>	<span class="cm">/* read anything left in FIFO */</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>	<span class="cm">/* signal end to comedi */</span>
	<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="cm">/* clear the interrupt */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">RtdInterruptStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">RtdInterruptClearMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">RtdInterruptClear</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">fifoStatus</span> <span class="o">=</span> <span class="n">RtdFifoStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* DEBUG */</span>
	<span class="n">DPRINTK</span>
	    <span class="p">(</span><span class="s">&quot;rtd520: Acquisition complete. %ld ints, intStat=%x, overStat=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intCount</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
	     <span class="mh">0xffff</span> <span class="o">&amp;</span> <span class="n">RtdInterruptOverrunStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c">  return the number of samples available</span>
<span class="c">*/</span>
<span class="c">static int rtd_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)</span>
<span class="c">{</span>
<span class="c">	/* TODO: This needs to mask interrupts, read_dregs, and then re-enable */</span>
<span class="c">	/* Not sure what to do if DMA is active */</span>
<span class="c">	return s-&gt;async-&gt;buf_write_count - s-&gt;async-&gt;buf_read_count;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">  cmdtest tests a particular command to see if it is valid.</span>
<span class="cm">  Using the cmdtest ioctl, a user can create a valid cmd</span>
<span class="cm">  and then have it executed by the cmd ioctl (asyncronously).</span>

<span class="cm">  cmdtest returns 1,2,3,4 or 0, depending on which tests</span>
<span class="cm">  the command passes.</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* step 1: make sure trigger sources are trivially valid */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_NOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_EXT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>


	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_EXT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>


	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>


	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span> <span class="o">|</span> <span class="n">TRIG_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* step 2: make sure trigger sources are unique</span>
<span class="cm">	   and mutually compatible */</span>
	<span class="cm">/* note that mutual compatibility is not an issue here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">!=</span> <span class="n">TRIG_COUNT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">!=</span> <span class="n">TRIG_NONE</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* step 3: make sure arguments are trivially compatible */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Note: these are time periods, not actual rates */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* no scanning */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span> <span class="n">RTD_MAX_SPEED_1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">RTD_MAX_SPEED_1</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_UP</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="n">RTD_MIN_SPEED_1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">RTD_MIN_SPEED_1</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_DOWN</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span> <span class="n">RTD_MAX_SPEED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">RTD_MAX_SPEED</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_UP</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="n">RTD_MIN_SPEED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">RTD_MIN_SPEED</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_DOWN</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* external trigger */</span>
		<span class="cm">/* should be level/edge, hi/lo specification here */</span>
		<span class="cm">/* should specify multiple external triggers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* no scanning */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&lt;</span> <span class="n">RTD_MAX_SPEED_1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">RTD_MAX_SPEED_1</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_UP</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="n">RTD_MIN_SPEED_1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">RTD_MIN_SPEED_1</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_DOWN</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&lt;</span> <span class="n">RTD_MAX_SPEED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">RTD_MAX_SPEED</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_UP</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="n">RTD_MIN_SPEED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">RTD_MIN_SPEED</span><span class="p">;</span>
				<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_DOWN</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* external trigger */</span>
		<span class="cm">/* see above */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (cmd-&gt;scan_end_arg != cmd-&gt;chanlist_len) {</span>
<span class="c">		cmd-&gt;scan_end_arg = cmd-&gt;chanlist_len;</span>
<span class="c">		err++;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TODO check for rounding error due to counter wrap */</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* TRIG_NONE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>


	<span class="cm">/* step 4: fix up any arguments */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">&gt;</span> <span class="n">RTD_MAX_CHANLIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">=</span> <span class="n">RTD_MAX_CHANLIST</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">;</span>
		<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">;</span>
		<span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span>
			<span class="o">&lt;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span>
			    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Execute a analog in command with many possible triggering options.</span>
<span class="cm">  The data get stored in the async structure of the subdevice.</span>
<span class="cm">  This is usually done by an interrupt handler.</span>
<span class="cm">  Userland gets to the data using read calls.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timer</span><span class="p">;</span>

	<span class="cm">/* stop anything currently running */</span>
	<span class="n">RtdPacerStopSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* stop on SOFTWARE stop */</span>
	<span class="n">RtdPacerStop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* make sure PACER is stopped */</span>
	<span class="n">RtdAdcConversionSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* software trigger only */</span>
	<span class="n">RtdInterruptMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef USE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA0_ACTIVE</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* cancel anything running */</span>
		<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>	<span class="cm">/* disable any more interrupts */</span>
				     <span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ICS_DMA0_E</span><span class="p">);</span>
		<span class="n">abort_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA0_ACTIVE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICS_DMA0_A</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/*clear pending int */</span>
			<span class="n">RtdDma0Control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PLX_CLEAR_DMA_INTR_BIT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">RtdDma0Reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* reset onboard state */</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>
	<span class="n">RtdAdcClearFifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* clear any old data */</span>
	<span class="n">RtdInterruptOverrunClear</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* we need interrupts for this */</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: ERROR! No interrupt available!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* start configuration */</span>
	<span class="cm">/* load channel list and reset CGT */</span>
	<span class="n">rtd_load_channelgain_list</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">);</span>

	<span class="cm">/* setup the common case and override if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*DPRINTK (&quot;rtd520: Multi channel setup\n&quot;); */</span>
		<span class="n">RtdPacerStartSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* software triggers pacer */</span>
		<span class="n">RtdBurstStartSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* PACER triggers burst */</span>
		<span class="n">RtdAdcConversionSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* BURST triggers ADC */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* single channel */</span>
		<span class="cm">/*DPRINTK (&quot;rtd520: single channel setup\n&quot;); */</span>
		<span class="n">RtdPacerStartSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* software triggers pacer */</span>
		<span class="n">RtdAdcConversionSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* PACER triggers ADC */</span>
	<span class="p">}</span>
	<span class="n">RtdAboutCounter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* 1/2 FIFO */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TRIG_TIMER</span> <span class="o">==</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* scan_begin_arg is in nanoseconds */</span>
		<span class="cm">/* find out how many samples to wait before transferring */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_WAKE_EOS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this may generate un-sustainable interrupt rates */</span>
			<span class="cm">/* the application is responsible for doing the right thing */</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SEND_EOS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* arrange to transfer data periodically */</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span>
			    <span class="o">=</span>
			    <span class="p">(</span><span class="n">TRANS_TARGET_PERIOD</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="o">/</span>
			    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* transfer after each scan (and avoid 0) */</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* make a multiple of scan length */</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">+</span>
				     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				    <span class="o">/</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">*=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SEND_EOS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* out of counter range, use 1/2 fifo instead */</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SEND_EOS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* interrupt for each transfer */</span>
			<span class="n">RtdAboutCounter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">DPRINTK</span>
		    <span class="p">(</span><span class="s">&quot;rtd520: scanLen=%d transferCount=%d fifoLen=%d</span><span class="se">\n</span><span class="s">  scanTime(ns)=%d flags=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">fifoLen</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* unknown timing, just use 1/2 FIFO */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SEND_EOS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">RtdPacerClockSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* use INTERNAL 8Mhz clock source */</span>
	<span class="n">RtdAboutStopEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* just interrupt, dont stop */</span>

	<span class="cm">/* BUG??? these look like enumerated values, but they are bit fields */</span>

	<span class="cm">/* First, setup when to stop */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_COUNT</span>:	<span class="cm">/* stop after N scans */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">&gt;</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TRIG_NONE</span>:	<span class="cm">/* stop when cancel is called */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* read forever */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Warning! ignoring stop_src mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Scan timing */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_TIMER</span>:	<span class="cm">/* periodic scanning */</span>
		<span class="n">timer</span> <span class="o">=</span> <span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
					<span class="n">TRIG_ROUND_NEAREST</span><span class="p">);</span>
		<span class="cm">/* set PACER clock */</span>
		<span class="cm">/*DPRINTK (&quot;rtd520: loading %d into pacer\n&quot;, timer); */</span>
		<span class="n">RtdPacerCounter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TRIG_EXT</span>:
		<span class="n">RtdPacerStartSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* EXTERNALy trigger pacer */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Warning! ignoring scan_begin_src mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Sample timing within a scan */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_TIMER</span>:	<span class="cm">/* periodic */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* only needed for multi-channel */</span>
			<span class="n">timer</span> <span class="o">=</span> <span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
						<span class="n">TRIG_ROUND_NEAREST</span><span class="p">);</span>
			<span class="cm">/* setup BURST clock */</span>
			<span class="cm">/*DPRINTK (&quot;rtd520: loading %d into burst\n&quot;, timer); */</span>
			<span class="n">RtdBurstCounter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TRIG_EXT</span>:		<span class="cm">/* external */</span>
		<span class="n">RtdBurstStartSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* EXTERNALy trigger burst */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Warning! ignoring convert_src mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* end configuration */</span>

	<span class="cm">/* This doesn&#39;t seem to work.  There is no way to clear an interrupt</span>
<span class="cm">	   that the priority controller has queued! */</span>
	<span class="n">RtdInterruptClearMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* clear any existing flags */</span>
	<span class="n">RtdInterruptClear</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* TODO: allow multiple interrupt sources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* transfer every N samples */</span>
		<span class="n">RtdInterruptMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IRQM_ADC_ABOUT_CNT</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Transferring every %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">transCount</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* 1/2 FIFO transfers */</span>
<span class="cp">#ifdef USE_DMA</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DMA0_ACTIVE</span><span class="p">;</span>

		<span class="cm">/* point to first transfer in ring */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">RtdDma0Mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_MODE_BITS</span><span class="p">);</span>
		<span class="n">RtdDma0Next</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>	<span class="cm">/* point to first block */</span>
			    <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dma0Chain</span><span class="p">[</span><span class="n">DMA_CHAIN_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">next</span><span class="p">);</span>
		<span class="n">RtdDma0Source</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMAS_ADFIFO_HALF_FULL</span><span class="p">);</span>	<span class="cm">/* set DMA trigger source */</span>

		<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>	<span class="cm">/* enable interrupt */</span>
				     <span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">|</span> <span class="n">ICS_DMA0_E</span><span class="p">);</span>
		<span class="cm">/* Must be 2 steps.  See PLX app note about &quot;Starting a DMA transfer&quot; */</span>
		<span class="n">RtdDma0Control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PLX_DMA_EN_BIT</span><span class="p">);</span>	<span class="cm">/* enable DMA (clear INTR?) */</span>
		<span class="n">RtdDma0Control</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PLX_DMA_EN_BIT</span> <span class="o">|</span> <span class="n">PLX_DMA_START_BIT</span><span class="p">);</span>	<span class="cm">/*start DMA */</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Using DMA0 transfers. plxInt %x RtdInt %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intMask</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>
		<span class="n">RtdInterruptMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IRQM_ADC_ABOUT_CNT</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: Transferring every 1/2 FIFO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>
	<span class="p">}</span>

	<span class="cm">/* BUG: start_src is ASSUMED to be TRIG_NOW */</span>
	<span class="cm">/* BUG? it seems like things are running before the &quot;start&quot; */</span>
	<span class="n">RtdPacerStart</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Start PACER */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Stop a running data acquisition.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">RtdPacerStopSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* stop on SOFTWARE stop */</span>
	<span class="n">RtdPacerStop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Stop PACER */</span>
	<span class="n">RtdAdcConversionSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* software trigger only */</span>
	<span class="n">RtdInterruptMask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aiCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* stop and don&#39;t transfer any more */</span>
<span class="cp">#ifdef USE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA0_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RtdPlxInterruptWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>	<span class="cm">/* disable any more interrupts */</span>
				     <span class="n">RtdPlxInterruptRead</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ICS_DMA0_E</span><span class="p">);</span>
		<span class="n">abort_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA0_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* USE_DMA */</span><span class="cp"></span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">RtdInterruptStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">DPRINTK</span>
	    <span class="p">(</span><span class="s">&quot;rtd520: Acquisition canceled. %ld ints, intStat=%x, overStat=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intCount</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
	     <span class="mh">0xffff</span> <span class="o">&amp;</span> <span class="n">RtdInterruptOverrunStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Given a desired period and the clock period (both in ns),</span>
<span class="cm">  return the proper counter value (divider-1).</span>
<span class="cm">  Sets the original period to be the true value.</span>
<span class="cm">  Note: you have to check if the value is larger than the counter range!</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ns_to_timer_base</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nanosec</span><span class="p">,</span>	<span class="cm">/* desired period (in ns) */</span>
				<span class="kt">int</span> <span class="n">round_mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* clock period (in ns) */</span>
	<span class="kt">int</span> <span class="n">divider</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">round_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_NEAREST</span>:
	<span class="nl">default:</span>
		<span class="n">divider</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">nanosec</span> <span class="o">+</span> <span class="n">base</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_DOWN</span>:
		<span class="n">divider</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">nanosec</span><span class="p">)</span> <span class="o">/</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_UP</span>:
		<span class="n">divider</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">nanosec</span> <span class="o">+</span> <span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">divider</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">divider</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* min is divide by 2 */</span>

	<span class="cm">/* Note: we don&#39;t check for max, because different timers</span>
<span class="cm">	   have different ranges */</span>

	<span class="o">*</span><span class="n">nanosec</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="n">divider</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">divider</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* countdown is divisor+1 */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Given a desired period (in ns),</span>
<span class="cm">  return the proper counter value (divider-1) for the internal clock.</span>
<span class="cm">  Sets the original period to be the true value.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ns_to_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">round_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rtd_ns_to_timer_base</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">round_mode</span><span class="p">,</span> <span class="n">RTD_CLOCK_BASE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Output one (or more) analog values to a single port as fast as possible.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="cm">/* Configure the output range (table index matches the range values) */</span>
	<span class="n">RtdDacRange</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>

	<span class="cm">/* Writing a list of values to an AO channel is probably not</span>
<span class="cm">	 * very useful, but that&#39;s how the interface is defined. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* initialize to avoid bogus warning */</span>
		<span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>

		<span class="cm">/* VERIFY: comedi range and offset conversions */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">range</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>	<span class="cm">/* bipolar */</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* offset and sign extend */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">int</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* unipolor */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DPRINTK</span>
		    <span class="p">(</span><span class="s">&quot;comedi: rtd520 DAC chan=%d range=%d writing %d as 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">chan</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>

		<span class="cm">/* a typical programming sequence */</span>
		<span class="n">RtdDacFifoPut</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>	<span class="cm">/* put the value in */</span>
		<span class="n">RtdDacUpdate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>	<span class="cm">/* trigger the conversion */</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aoValue</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>	<span class="cm">/* save for read back */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">RTD_DAC_TIMEOUT</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span> <span class="o">=</span> <span class="n">RtdFifoStatus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="cm">/* 1 -&gt; not empty */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">0</span> <span class="o">==</span> <span class="n">chan</span><span class="p">)</span> <span class="o">?</span> <span class="n">FS_DAC1_NOT_EMPTY</span> <span class="o">:</span>
				    <span class="n">FS_DAC2_NOT_EMPTY</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">WAIT_QUIETLY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;=</span> <span class="n">RTD_DAC_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINTK</span>
			    <span class="p">(</span><span class="s">&quot;rtd520: Error: DAC never finished! FifoStatus=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">stat</span> <span class="o">^</span> <span class="mh">0x6666</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* AO subdevices should have a read insn as well as a write insn.</span>
<span class="cm"> * Usually this means copying a value stored in devpriv. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">aoValue</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>


	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">   Write a masked set of bits and the read back the port.</span>
<span class="cm">   We track what the bits should be (i.e. we don&#39;t read the port first).</span>

<span class="cm">   DIO devices are slightly special.  Although it is possible to</span>
<span class="cm"> * implement the insn_read/insn_write interface, it is much more</span>
<span class="cm"> * useful to applications if you implement the insn_bits interface.</span>
<span class="cm"> * This allows packed reading/writing of the DIO channels.  The</span>
<span class="cm"> * comedi core can convert between insn_bits and insn_read/write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_dio_insn_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* The insn data is a mask in data[0] and the new data</span>
<span class="cm">	 * in data[1], each channel cooresponding to a bit. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="cm">/* Write out the new digital output lines */</span>
		<span class="n">RtdDio0Write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* on return, data[1] contains the value of the digital</span>
<span class="cm">	 * input lines. */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">RtdDio0Read</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*DPRINTK(&quot;rtd520:port_0 wrote: 0x%x read: 0x%x\n&quot;, s-&gt;state, data[1]); */</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Configure one bit on a IO port as Input or Output (hence the name :-).</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtd_dio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="cm">/* The input or output configuration of each digital line is</span>
<span class="cm">	 * configured by a special insn_config instruction.  chanspec</span>
<span class="cm">	 * contains the channel to be changed, and data[0] contains the</span>
<span class="cm">	 * value COMEDI_INPUT or COMEDI_OUTPUT. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DIO_OUTPUT</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chan</span><span class="p">;</span>	<span class="cm">/* 1 means Out */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DIO_INPUT</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chan</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DIO_QUERY</span>:
		<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chan</span><span class="p">))</span> <span class="o">?</span> <span class="n">COMEDI_OUTPUT</span> <span class="o">:</span> <span class="n">COMEDI_INPUT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;rtd520: port_0_direction=0x%x (1 means out)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span><span class="p">);</span>
	<span class="cm">/* TODO support digital match interrupts and strobes */</span>
	<span class="n">RtdDioStatusWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">);</span>	<span class="cm">/* make Dio0Ctrl point to direction */</span>
	<span class="n">RtdDio0CtrlWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span><span class="p">);</span>	<span class="cm">/* set direction 1 means Out */</span>
	<span class="n">RtdDioStatusWrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* make Dio0Ctrl clear interrupts */</span>

	<span class="cm">/* port1 can only be all input or all output */</span>

	<span class="cm">/* there are also 2 user input lines and 2 user output lines */</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">comedi_driver</span> <span class="n">rtd520_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver_name</span>	<span class="o">=</span> <span class="s">&quot;rtd520&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">rtd_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach</span>		<span class="o">=</span> <span class="n">rtd_detach</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">rtd520_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">comedi_pci_auto_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtd520_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="n">rtd520_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">comedi_pci_auto_unconfig</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">rtd520_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RTD</span><span class="p">,</span> <span class="mh">0x7520</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RTD</span><span class="p">,</span> <span class="mh">0x4520</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">rtd520_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">rtd520_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rtd520&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">rtd520_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">rtd520_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">rtd520_pci_remove</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">module_comedi_pci_driver</span><span class="p">(</span><span class="n">rtd520_driver</span><span class="p">,</span> <span class="n">rtd520_pci_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Comedi http://www.comedi.org&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Comedi low-level driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
