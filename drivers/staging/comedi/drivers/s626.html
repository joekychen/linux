<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › s626.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>s626.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  comedi/drivers/s626.c</span>
<span class="cm">  Sensoray s626 Comedi driver</span>

<span class="cm">  COMEDI - Linux Control and Measurement Device Interface</span>
<span class="cm">  Copyright (C) 2000 David A. Schleef &lt;ds@schleef.org&gt;</span>

<span class="cm">  Based on Sensoray Model 626 Linux driver Version 0.2</span>
<span class="cm">  Copyright (C) 2002-2004 Sensoray Co., Inc.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify</span>
<span class="cm">  it under the terms of the GNU General Public License as published by</span>
<span class="cm">  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">  (at your option) any later version.</span>

<span class="cm">  This program is distributed in the hope that it will be useful,</span>
<span class="cm">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">  GNU General Public License for more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License</span>
<span class="cm">  along with this program; if not, write to the Free Software</span>
<span class="cm">  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Driver: s626</span>
<span class="cm">Description: Sensoray 626 driver</span>
<span class="cm">Devices: [Sensoray] 626 (s626)</span>
<span class="cm">Authors: Gianluca Palli &lt;gpalli@deis.unibo.it&gt;,</span>
<span class="cm">Updated: Fri, 15 Feb 2008 10:28:42 +0000</span>
<span class="cm">Status: experimental</span>

<span class="cm">Configuration options:</span>
<span class="cm">  [0] - PCI bus of device (optional)</span>
<span class="cm">  [1] - PCI slot of device (optional)</span>
<span class="cm">  If bus/slot is not specified, the first supported</span>
<span class="cm">  PCI device found will be used.</span>

<span class="cm">INSN_CONFIG instructions:</span>
<span class="cm">  analog input:</span>
<span class="cm">   none</span>

<span class="cm">  analog output:</span>
<span class="cm">   none</span>

<span class="cm">  digital channel:</span>
<span class="cm">   s626 has 3 dio subdevices (2,3 and 4) each with 16 i/o channels</span>
<span class="cm">   supported configuration options:</span>
<span class="cm">   INSN_CONFIG_DIO_QUERY</span>
<span class="cm">   COMEDI_INPUT</span>
<span class="cm">   COMEDI_OUTPUT</span>

<span class="cm">  encoder:</span>
<span class="cm">   Every channel must be configured before reading.</span>

<span class="cm">   Example code</span>

<span class="cm">   insn.insn=INSN_CONFIG;   //configuration instruction</span>
<span class="cm">   insn.n=1;                //number of operation (must be 1)</span>
<span class="cm">   insn.data=&amp;initialvalue; //initial value loaded into encoder</span>

<span class="cm">//DIVIDER</span>
<span class="cm">   insn.subdev=5;           //encoder subdevice</span>
<span class="cm">   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel</span>

<span class="cm">//DIVIDER</span>

<span class="cm">   comedi_do_insn(cf,&amp;insn); //executing configuration</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &quot;../comedidev.h&quot;</span>

<span class="cp">#include &quot;comedi_pci.h&quot;</span>

<span class="cp">#include &quot;comedi_fc.h&quot;</span>
<span class="cp">#include &quot;s626.h&quot;</span>

<span class="cp">#define PCI_VENDOR_ID_S626 0x1131</span>
<span class="cp">#define PCI_DEVICE_ID_S626 0x7146</span>
<span class="cp">#define PCI_SUBVENDOR_ID_S626 0x6000</span>
<span class="cp">#define PCI_SUBDEVICE_ID_S626 0x0272</span>

<span class="k">struct</span> <span class="n">s626_board</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vendor_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subvendor_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subdevice_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ai_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ai_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dio_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dio_banks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enc_chans</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">s626_board</span> <span class="n">s626_boards</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;s626&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_S626</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_S626</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">subvendor_id</span> <span class="o">=</span> <span class="n">PCI_SUBVENDOR_ID_S626</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">subdevice_id</span> <span class="o">=</span> <span class="n">PCI_SUBDEVICE_ID_S626</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_chans</span> <span class="o">=</span> <span class="n">S626_ADC_CHANNELS</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_bits</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="n">S626_DAC_CHANNELS</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">dio_chans</span> <span class="o">=</span> <span class="n">S626_DIO_CHANNELS</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">dio_banks</span> <span class="o">=</span> <span class="n">S626_DIO_BANKS</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">enc_chans</span> <span class="o">=</span> <span class="n">S626_ENCODER_CHANNELS</span><span class="p">,</span>
	 <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#define thisboard ((const struct s626_board *)dev-&gt;board_ptr)</span>

<span class="k">struct</span> <span class="n">s626_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">got_regions</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">allocatedBuf</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">ai_cmd_running</span><span class="p">;</span>	<span class="cm">/*  ai_cmd is running */</span>
	<span class="kt">uint8_t</span> <span class="n">ai_continous</span><span class="p">;</span>	<span class="cm">/*  continous acquisition */</span>
	<span class="kt">int</span> <span class="n">ai_sample_count</span><span class="p">;</span>	<span class="cm">/*  number of samples to acquire */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ai_sample_timer</span><span class="p">;</span>
	<span class="cm">/*  time between samples in  units of the timer */</span>
	<span class="kt">int</span> <span class="n">ai_convert_count</span><span class="p">;</span>	<span class="cm">/*  conversion counter */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ai_convert_timer</span><span class="p">;</span>
	<span class="cm">/*  time between conversion in  units of the timer */</span>
	<span class="kt">uint16_t</span> <span class="n">CounterIntEnabs</span><span class="p">;</span>
	<span class="cm">/* Counter interrupt enable  mask for MISC2 register. */</span>
	<span class="kt">uint8_t</span> <span class="n">AdcItems</span><span class="p">;</span>	<span class="cm">/* Number of items in ADC poll  list. */</span>
	<span class="k">struct</span> <span class="n">bufferDMA</span> <span class="n">RPSBuf</span><span class="p">;</span>	<span class="cm">/* DMA buffer used to hold ADC (RPS1) program. */</span>
	<span class="k">struct</span> <span class="n">bufferDMA</span> <span class="n">ANABuf</span><span class="p">;</span>
	<span class="cm">/* DMA buffer used to receive ADC data and hold DAC data. */</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pDacWBuf</span><span class="p">;</span>
	<span class="cm">/* Pointer to logical adrs of DMA buffer used to hold DAC  data. */</span>
	<span class="kt">uint16_t</span> <span class="n">Dacpol</span><span class="p">;</span>	<span class="cm">/* Image of DAC polarity register. */</span>
	<span class="kt">uint8_t</span> <span class="n">TrimSetpoint</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>	<span class="cm">/* Images of TrimDAC setpoints */</span>
	<span class="kt">uint16_t</span> <span class="n">ChargeEnabled</span><span class="p">;</span>	<span class="cm">/* Image of MISC2 Battery */</span>
	<span class="cm">/* Charge Enabled (0 or WRMISC2_CHARGE_ENABLE). */</span>
	<span class="kt">uint16_t</span> <span class="n">WDInterval</span><span class="p">;</span>	<span class="cm">/* Image of MISC2 watchdog interval control bits. */</span>
	<span class="kt">uint32_t</span> <span class="n">I2CAdrs</span><span class="p">;</span>
	<span class="cm">/* I2C device address for onboard EEPROM (board rev dependent). */</span>
	<span class="cm">/*   short         I2Cards; */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_readback</span><span class="p">[</span><span class="n">S626_DAC_CHANNELS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dio_private</span> <span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">RDDIn</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">WRDOut</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">RDEdgSel</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">WREdgSel</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">RDCapSel</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">WRCapSel</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">RDCapFlg</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">RDIntSel</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">WRIntSel</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dio_private</span> <span class="n">dio_private_A</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">RDDIn</span> <span class="o">=</span> <span class="n">LP_RDDINA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRDOut</span> <span class="o">=</span> <span class="n">LP_WRDOUTA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDEdgSel</span> <span class="o">=</span> <span class="n">LP_RDEDGSELA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WREdgSel</span> <span class="o">=</span> <span class="n">LP_WREDGSELA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDCapSel</span> <span class="o">=</span> <span class="n">LP_RDCAPSELA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRCapSel</span> <span class="o">=</span> <span class="n">LP_WRCAPSELA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDCapFlg</span> <span class="o">=</span> <span class="n">LP_RDCAPFLGA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDIntSel</span> <span class="o">=</span> <span class="n">LP_RDINTSELA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRIntSel</span> <span class="o">=</span> <span class="n">LP_WRINTSELA</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dio_private</span> <span class="n">dio_private_B</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">RDDIn</span> <span class="o">=</span> <span class="n">LP_RDDINB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRDOut</span> <span class="o">=</span> <span class="n">LP_WRDOUTB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDEdgSel</span> <span class="o">=</span> <span class="n">LP_RDEDGSELB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WREdgSel</span> <span class="o">=</span> <span class="n">LP_WREDGSELB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDCapSel</span> <span class="o">=</span> <span class="n">LP_RDCAPSELB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRCapSel</span> <span class="o">=</span> <span class="n">LP_WRCAPSELB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDCapFlg</span> <span class="o">=</span> <span class="n">LP_RDCAPFLGB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDIntSel</span> <span class="o">=</span> <span class="n">LP_RDINTSELB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRIntSel</span> <span class="o">=</span> <span class="n">LP_WRINTSELB</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dio_private</span> <span class="n">dio_private_C</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">RDDIn</span> <span class="o">=</span> <span class="n">LP_RDDINC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRDOut</span> <span class="o">=</span> <span class="n">LP_WRDOUTC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDEdgSel</span> <span class="o">=</span> <span class="n">LP_RDEDGSELC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WREdgSel</span> <span class="o">=</span> <span class="n">LP_WREDGSELC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDCapSel</span> <span class="o">=</span> <span class="n">LP_RDCAPSELC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRCapSel</span> <span class="o">=</span> <span class="n">LP_WRCAPSELC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDCapFlg</span> <span class="o">=</span> <span class="n">LP_RDCAPFLGC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">RDIntSel</span> <span class="o">=</span> <span class="n">LP_RDINTSELC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">WRIntSel</span> <span class="o">=</span> <span class="n">LP_WRINTSELC</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* to group dio devices (48 bits mask and data are not allowed ???)</span>
<span class="cm">static struct dio_private *dio_private_word[]={</span>
<span class="cm">  &amp;dio_private_A,</span>
<span class="cm">  &amp;dio_private_B,</span>
<span class="cm">  &amp;dio_private_C,</span>
<span class="cm">};</span>
<span class="cm">*/</span>

<span class="cp">#define devpriv ((struct s626_private *)dev-&gt;private)</span>
<span class="cp">#define diopriv ((struct dio_private *)s-&gt;private)</span>

<span class="cm">/* ioctl routines */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ai_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ai_insn_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_dio_insn_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_dio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_dio_reset_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gruop</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_dio_clear_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_enc_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_enc_insn_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_enc_insn_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ns_to_timer</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">nanosec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">round_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ai_load_polllist</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ppl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">s626_ai_inttrig</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trignum</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">s626_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s626_ai_reg_to_uint</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
<span class="cm">/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data); */</span>

<span class="cm">/* end ioctl routines */</span>

<span class="cm">/* internal routines */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">s626_dio_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ResetADC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">ppl</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">LoadTrimDACs</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">WriteTrimDAC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">LogicalChan</span><span class="p">,</span>
			 <span class="kt">uint8_t</span> <span class="n">DacData</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">I2Cread</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">I2Chandshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetDAC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">chan</span><span class="p">,</span> <span class="kt">short</span> <span class="n">dacdata</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SendDAC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">WriteMISC2</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">NewImage</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">DEBItransfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">DEBIread</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">DEBIwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">wdata</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">DEBIreplace</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">mask</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">wdata</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">CloseDMAB</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bufferDMA</span> <span class="o">*</span><span class="n">pdma</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="n">bsize</span><span class="p">);</span>

<span class="cm">/*  COUNTER OBJECT ------------------------------------------------ */</span>
<span class="k">struct</span> <span class="n">enc_private</span> <span class="p">{</span>
	<span class="cm">/*  Pointers to functions that differ for A and B counters: */</span>
	<span class="kt">uint16_t</span><span class="p">(</span><span class="o">*</span><span class="n">GetEnable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Return clock enable. */</span>
	<span class="kt">uint16_t</span><span class="p">(</span><span class="o">*</span><span class="n">GetIntSrc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Return interrupt source. */</span>
	<span class="kt">uint16_t</span><span class="p">(</span><span class="o">*</span><span class="n">GetLoadTrig</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Return preload trigger source. */</span>
	<span class="kt">uint16_t</span><span class="p">(</span><span class="o">*</span><span class="n">GetMode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Return standardized operating mode. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">PulseIndex</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Generate soft index strobe. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">SetEnable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">enab</span><span class="p">);</span>	<span class="cm">/* Program clock enable. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">SetIntSrc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">IntSource</span><span class="p">);</span>	<span class="cm">/* Program interrupt source. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">SetLoadTrig</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">Trig</span><span class="p">);</span>	<span class="cm">/* Program preload trigger source. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">SetMode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">Setup</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">DisableIntSrc</span><span class="p">);</span>	<span class="cm">/* Program standardized operating mode. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ResetCapFlags</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Reset event capture flags. */</span>

	<span class="kt">uint16_t</span> <span class="n">MyCRA</span><span class="p">;</span>		<span class="cm">/*    Address of CRA register. */</span>
	<span class="kt">uint16_t</span> <span class="n">MyCRB</span><span class="p">;</span>		<span class="cm">/*    Address of CRB register. */</span>
	<span class="kt">uint16_t</span> <span class="n">MyLatchLsw</span><span class="p">;</span>	<span class="cm">/*    Address of Latch least-significant-word */</span>
	<span class="cm">/*    register. */</span>
	<span class="kt">uint16_t</span> <span class="n">MyEventBits</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/*    Bit translations for IntSrc --&gt;RDMISC2. */</span>
<span class="p">};</span>

<span class="cp">#define encpriv ((struct enc_private *)(dev-&gt;subdevices+5)-&gt;private)</span>

<span class="cm">/* counters routines */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">s626_timer_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">tick</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">ReadLatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ResetCapFlags_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ResetCapFlags_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetMode_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetMode_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetMode_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
		      <span class="kt">uint16_t</span> <span class="n">Setup</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">DisableIntSrc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetMode_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
		      <span class="kt">uint16_t</span> <span class="n">Setup</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">DisableIntSrc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetEnable_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">enab</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetEnable_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">enab</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetEnable_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetEnable_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetLatchSource</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			   <span class="kt">uint16_t</span> <span class="n">value</span><span class="p">);</span>
<span class="cm">/* static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k ); */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetLoadTrig_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			  <span class="kt">uint16_t</span> <span class="n">Trig</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetLoadTrig_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			  <span class="kt">uint16_t</span> <span class="n">Trig</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetLoadTrig_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetLoadTrig_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetIntSrc_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">IntSource</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">SetIntSrc_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">IntSource</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetIntSrc_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">GetIntSrc_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="cm">/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value ) ; */</span>
<span class="cm">/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k ) ; */</span>
<span class="cm">/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value ); */</span>
<span class="cm">/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k ) ; */</span>
<span class="cm">/* static void SetIndexSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value );  */</span>
<span class="cm">/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k );  */</span>
<span class="cm">/* static void SetIndexSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value );  */</span>
<span class="cm">/* static uint16_t GetIndexSrc( struct comedi_device *dev,struct enc_private *k );  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">PulseIndex_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">PulseIndex_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">Preload</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
		    <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">CountersInit</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cm">/* end internal routines */</span>

<span class="cm">/*  Counter objects constructor. */</span>

<span class="cm">/*  Counter overflow/index event flag masks for RDMISC2. */</span>
<span class="cp">#define INDXMASK(C)		(1 &lt;&lt; (((C) &gt; 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))</span>
<span class="cp">#define OVERMASK(C)		(1 &lt;&lt; (((C) &gt; 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))</span>
<span class="cp">#define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }</span>

<span class="cm">/*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */</span>
<span class="cm">/* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */</span>

<span class="cm">/* struct enc_private; */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="n">enc_private_data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">GetEnable</span> <span class="o">=</span> <span class="n">GetEnable_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetIntSrc</span> <span class="o">=</span> <span class="n">GetIntSrc_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetLoadTrig</span> <span class="o">=</span> <span class="n">GetLoadTrig_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetMode</span> <span class="o">=</span> <span class="n">GetMode_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">PulseIndex</span> <span class="o">=</span> <span class="n">PulseIndex_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetEnable</span> <span class="o">=</span> <span class="n">SetEnable_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetIntSrc</span> <span class="o">=</span> <span class="n">SetIntSrc_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetLoadTrig</span> <span class="o">=</span> <span class="n">SetLoadTrig_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetMode</span> <span class="o">=</span> <span class="n">SetMode_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ResetCapFlags</span> <span class="o">=</span> <span class="n">ResetCapFlags_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRA</span> <span class="o">=</span> <span class="n">LP_CR0A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRB</span> <span class="o">=</span> <span class="n">LP_CR0B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyLatchLsw</span> <span class="o">=</span> <span class="n">LP_CNTR0ALSW</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyEventBits</span> <span class="o">=</span> <span class="n">EVBITS</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">GetEnable</span> <span class="o">=</span> <span class="n">GetEnable_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetIntSrc</span> <span class="o">=</span> <span class="n">GetIntSrc_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetLoadTrig</span> <span class="o">=</span> <span class="n">GetLoadTrig_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetMode</span> <span class="o">=</span> <span class="n">GetMode_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">PulseIndex</span> <span class="o">=</span> <span class="n">PulseIndex_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetEnable</span> <span class="o">=</span> <span class="n">SetEnable_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetIntSrc</span> <span class="o">=</span> <span class="n">SetIntSrc_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetLoadTrig</span> <span class="o">=</span> <span class="n">SetLoadTrig_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetMode</span> <span class="o">=</span> <span class="n">SetMode_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ResetCapFlags</span> <span class="o">=</span> <span class="n">ResetCapFlags_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRA</span> <span class="o">=</span> <span class="n">LP_CR1A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRB</span> <span class="o">=</span> <span class="n">LP_CR1B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyLatchLsw</span> <span class="o">=</span> <span class="n">LP_CNTR1ALSW</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyEventBits</span> <span class="o">=</span> <span class="n">EVBITS</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">GetEnable</span> <span class="o">=</span> <span class="n">GetEnable_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetIntSrc</span> <span class="o">=</span> <span class="n">GetIntSrc_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetLoadTrig</span> <span class="o">=</span> <span class="n">GetLoadTrig_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetMode</span> <span class="o">=</span> <span class="n">GetMode_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">PulseIndex</span> <span class="o">=</span> <span class="n">PulseIndex_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetEnable</span> <span class="o">=</span> <span class="n">SetEnable_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetIntSrc</span> <span class="o">=</span> <span class="n">SetIntSrc_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetLoadTrig</span> <span class="o">=</span> <span class="n">SetLoadTrig_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetMode</span> <span class="o">=</span> <span class="n">SetMode_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ResetCapFlags</span> <span class="o">=</span> <span class="n">ResetCapFlags_A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRA</span> <span class="o">=</span> <span class="n">LP_CR2A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRB</span> <span class="o">=</span> <span class="n">LP_CR2B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyLatchLsw</span> <span class="o">=</span> <span class="n">LP_CNTR2ALSW</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyEventBits</span> <span class="o">=</span> <span class="n">EVBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">GetEnable</span> <span class="o">=</span> <span class="n">GetEnable_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetIntSrc</span> <span class="o">=</span> <span class="n">GetIntSrc_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetLoadTrig</span> <span class="o">=</span> <span class="n">GetLoadTrig_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetMode</span> <span class="o">=</span> <span class="n">GetMode_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">PulseIndex</span> <span class="o">=</span> <span class="n">PulseIndex_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetEnable</span> <span class="o">=</span> <span class="n">SetEnable_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetIntSrc</span> <span class="o">=</span> <span class="n">SetIntSrc_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetLoadTrig</span> <span class="o">=</span> <span class="n">SetLoadTrig_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetMode</span> <span class="o">=</span> <span class="n">SetMode_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ResetCapFlags</span> <span class="o">=</span> <span class="n">ResetCapFlags_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRA</span> <span class="o">=</span> <span class="n">LP_CR0A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRB</span> <span class="o">=</span> <span class="n">LP_CR0B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyLatchLsw</span> <span class="o">=</span> <span class="n">LP_CNTR0BLSW</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyEventBits</span> <span class="o">=</span> <span class="n">EVBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">GetEnable</span> <span class="o">=</span> <span class="n">GetEnable_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetIntSrc</span> <span class="o">=</span> <span class="n">GetIntSrc_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetLoadTrig</span> <span class="o">=</span> <span class="n">GetLoadTrig_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetMode</span> <span class="o">=</span> <span class="n">GetMode_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">PulseIndex</span> <span class="o">=</span> <span class="n">PulseIndex_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetEnable</span> <span class="o">=</span> <span class="n">SetEnable_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetIntSrc</span> <span class="o">=</span> <span class="n">SetIntSrc_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetLoadTrig</span> <span class="o">=</span> <span class="n">SetLoadTrig_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetMode</span> <span class="o">=</span> <span class="n">SetMode_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ResetCapFlags</span> <span class="o">=</span> <span class="n">ResetCapFlags_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRA</span> <span class="o">=</span> <span class="n">LP_CR1A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRB</span> <span class="o">=</span> <span class="n">LP_CR1B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyLatchLsw</span> <span class="o">=</span> <span class="n">LP_CNTR1BLSW</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyEventBits</span> <span class="o">=</span> <span class="n">EVBITS</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">GetEnable</span> <span class="o">=</span> <span class="n">GetEnable_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetIntSrc</span> <span class="o">=</span> <span class="n">GetIntSrc_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetLoadTrig</span> <span class="o">=</span> <span class="n">GetLoadTrig_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">GetMode</span> <span class="o">=</span> <span class="n">GetMode_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">PulseIndex</span> <span class="o">=</span> <span class="n">PulseIndex_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetEnable</span> <span class="o">=</span> <span class="n">SetEnable_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetIntSrc</span> <span class="o">=</span> <span class="n">SetIntSrc_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetLoadTrig</span> <span class="o">=</span> <span class="n">SetLoadTrig_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">SetMode</span> <span class="o">=</span> <span class="n">SetMode_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ResetCapFlags</span> <span class="o">=</span> <span class="n">ResetCapFlags_B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRA</span> <span class="o">=</span> <span class="n">LP_CR2A</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyCRB</span> <span class="o">=</span> <span class="n">LP_CR2B</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyLatchLsw</span> <span class="o">=</span> <span class="n">LP_CNTR2BLSW</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">MyEventBits</span> <span class="o">=</span> <span class="n">EVBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	 <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*  enab/disable a function or test status bit(s) that are accessed */</span>
<span class="cm">/*  through Main Control Registers 1 or 2. */</span>
<span class="cp">#define MC_ENABLE(REGADRS, CTRLWORD)	writel(((uint32_t)(CTRLWORD) &lt;&lt; 16) | (uint32_t)(CTRLWORD), devpriv-&gt;base_addr+(REGADRS))</span>

<span class="cp">#define MC_DISABLE(REGADRS, CTRLWORD)	writel((uint32_t)(CTRLWORD) &lt;&lt; 16 , devpriv-&gt;base_addr+(REGADRS))</span>

<span class="cp">#define MC_TEST(REGADRS, CTRLWORD)	((readl(devpriv-&gt;base_addr+(REGADRS)) &amp; CTRLWORD) != 0)</span>

<span class="cm">/* #define WR7146(REGARDS,CTRLWORD)</span>
<span class="cm">    writel(CTRLWORD,(uint32_t)(devpriv-&gt;base_addr+(REGARDS))) */</span>
<span class="cp">#define WR7146(REGARDS, CTRLWORD) writel(CTRLWORD, devpriv-&gt;base_addr+(REGARDS))</span>

<span class="cm">/* #define RR7146(REGARDS)</span>
<span class="cm">    readl((uint32_t)(devpriv-&gt;base_addr+(REGARDS))) */</span>
<span class="cp">#define RR7146(REGARDS)		readl(devpriv-&gt;base_addr+(REGARDS))</span>

<span class="cp">#define BUGFIX_STREG(REGADRS)   (REGADRS - 4)</span>

<span class="cm">/*  Write a time slot control record to TSL2. */</span>
<span class="cp">#define VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) &lt;&lt; 2))</span>
<span class="cp">#define SETVECT(VECTNUM, VECTVAL)	WR7146(VECTPORT(VECTNUM), (VECTVAL))</span>

<span class="cm">/*  Code macros used for constructing I2C command bytes. */</span>
<span class="cp">#define I2C_B2(ATTR, VAL)	(((ATTR) &lt;&lt; 6) | ((VAL) &lt;&lt; 24))</span>
<span class="cp">#define I2C_B1(ATTR, VAL)	(((ATTR) &lt;&lt; 4) | ((VAL) &lt;&lt; 16))</span>
<span class="cp">#define I2C_B0(ATTR, VAL)	(((ATTR) &lt;&lt; 2) | ((VAL) &lt;&lt;  8))</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">s626_range_table</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span>
							   <span class="n">RANGE</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
							   <span class="n">RANGE</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
							   <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*   uint8_t	PollList; */</span>
<span class="cm">/*   uint16_t	AdcData; */</span>
<span class="cm">/*   uint16_t	StartVal; */</span>
<span class="cm">/*   uint16_t	index; */</span>
<span class="cm">/*   unsigned int data[16]; */</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">resourceStart</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">appdma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_private</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">s626_private</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">s626_boards</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pdev</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_subsys</span><span class="p">(</span><span class="n">s626_boards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendor_id</span><span class="p">,</span>
					      <span class="n">s626_boards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">device_id</span><span class="p">,</span>
					      <span class="n">s626_boards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subvendor_id</span><span class="p">,</span>
					      <span class="n">s626_boards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subdevice_id</span><span class="p">,</span>
					      <span class="n">pdev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* matches requested bus/slot */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
				    <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s626_attach: Board not present!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">comedi_pci_enable</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;s626&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s626_attach: comedi_pci_enable fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">got_regions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">resourceStart</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">resourceStart</span><span class="p">,</span> <span class="n">SIZEOF_ADDRESS_SPACE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s626_attach: IOREMAP failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* disable master interrupt */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_IER</span><span class="p">);</span>

		<span class="cm">/* soft reset */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">MC1_SOFT_RESET</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_MC1</span><span class="p">);</span>

		<span class="cm">/* DMA FIXME DMA// */</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_attach: DMA ALLOCATION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* adc buffer allocation */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">allocatedBuf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">LogicalBase</span> <span class="o">=</span>
		    <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMABUF_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">appdma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">LogicalBase</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s626_attach: DMA Memory mapping error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">PhysicalBase</span> <span class="o">=</span> <span class="n">appdma</span><span class="p">;</span>

		<span class="n">DEBUG</span>
		    <span class="p">(</span><span class="s">&quot;s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">LogicalBase</span><span class="p">,</span> <span class="n">DMABUF_SIZE</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">PhysicalBase</span><span class="p">);</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">allocatedBuf</span><span class="o">++</span><span class="p">;</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">LogicalBase</span> <span class="o">=</span>
		    <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMABUF_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">appdma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">LogicalBase</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s626_attach: DMA Memory mapping error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">PhysicalBase</span> <span class="o">=</span> <span class="n">appdma</span><span class="p">;</span>

		<span class="n">DEBUG</span>
		    <span class="p">(</span><span class="s">&quot;s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">LogicalBase</span><span class="p">,</span> <span class="n">DMABUF_SIZE</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">PhysicalBase</span><span class="p">);</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">allocatedBuf</span><span class="o">++</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_ptr</span> <span class="o">=</span> <span class="n">s626_boards</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_subdevices</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* set up interrupt handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot; unknown irq (bad)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">s626_irq_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				  <span class="s">&quot;s626&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot; irq not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_attach: -- it opts  %d,%d --</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* analog input subdevice */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">read_subdev</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="cm">/* we support single-ended (ground) and differential */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AI</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_DIFF</span> <span class="o">|</span> <span class="n">SDF_CMD_READ</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xffff</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s626_range_table</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">len_chanlist</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_chans</span><span class="p">;</span>	<span class="cm">/* This is the maximum chanlist</span>
<span class="cm">						   length that the board can</span>
<span class="cm">						   handle */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s626_ai_insn_config</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">s626_ai_insn_read</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmd</span> <span class="o">=</span> <span class="n">s626_ai_cmd</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmdtest</span> <span class="o">=</span> <span class="n">s626_ai_cmdtest</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cancel</span> <span class="o">=</span> <span class="n">s626_ai_cancel</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* analog output subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span> <span class="o">|</span> <span class="n">SDF_READABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x3fff</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_bipolar10</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="n">s626_ao_winsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">s626_ao_rinsn</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* digital I/O subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_DIO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span> <span class="o">|</span> <span class="n">SDF_READABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">S626_DIO_CHANNELS</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dio_private_A</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_digital</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s626_dio_insn_config</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_bits</span> <span class="o">=</span> <span class="n">s626_dio_insn_bits</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* digital I/O subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_DIO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span> <span class="o">|</span> <span class="n">SDF_READABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dio_private_B</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_digital</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s626_dio_insn_config</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_bits</span> <span class="o">=</span> <span class="n">s626_dio_insn_bits</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="cm">/* digital I/O subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_DIO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span> <span class="o">|</span> <span class="n">SDF_READABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dio_private_C</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_digital</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s626_dio_insn_config</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_bits</span> <span class="o">=</span> <span class="n">s626_dio_insn_bits</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
	<span class="cm">/* encoder (counter) subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_COUNTER</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span> <span class="o">|</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_LSAMPL</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">enc_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">enc_private_data</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_config</span> <span class="o">=</span> <span class="n">s626_enc_insn_config</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="n">s626_enc_insn_read</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="n">s626_enc_insn_write</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">range_unknown</span><span class="p">;</span>

	<span class="cm">/* stop ai_command */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">allocatedBuf</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">pPhysBuf</span><span class="p">;</span>
		<span class="kt">uint16_t</span> <span class="n">chan</span><span class="p">;</span>

		<span class="cm">/*  enab DEBI and audio pins, enable I2C interface. */</span>
		<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_DEBI</span> <span class="o">|</span> <span class="n">MC1_AUDIO</span> <span class="o">|</span> <span class="n">MC1_I2C</span><span class="p">);</span>
		<span class="cm">/*  Configure DEBI operating mode. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBICFG</span><span class="p">,</span> <span class="n">DEBI_CFG_SLAVE16</span>	<span class="cm">/*  Local bus is 16 */</span>
		       <span class="cm">/*  bits wide. */</span>
		       <span class="o">|</span> <span class="p">(</span><span class="n">DEBI_TOUT</span> <span class="o">&lt;&lt;</span> <span class="n">DEBI_CFG_TOUT_BIT</span><span class="p">)</span>

		       <span class="cm">/*  Declare DEBI */</span>
		       <span class="cm">/*  transfer timeout */</span>
		       <span class="cm">/*  interval. */</span>
		       <span class="o">|</span><span class="n">DEBI_SWAP</span>	<span class="cm">/*  Set up byte lane */</span>
		       <span class="cm">/*  steering. */</span>
		       <span class="o">|</span> <span class="n">DEBI_CFG_INTEL</span><span class="p">);</span>	<span class="cm">/*  Intel-compatible */</span>
		<span class="cm">/*  local bus (DEBI */</span>
		<span class="cm">/*  never times out). */</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_attach: %d debi init -- %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">DEBI_CFG_SLAVE16</span> <span class="o">|</span> <span class="p">(</span><span class="n">DEBI_TOUT</span> <span class="o">&lt;&lt;</span> <span class="n">DEBI_CFG_TOUT_BIT</span><span class="p">)</span> <span class="o">|</span>
		      <span class="n">DEBI_SWAP</span> <span class="o">|</span> <span class="n">DEBI_CFG_INTEL</span><span class="p">,</span>
		      <span class="n">DEBI_CFG_INTEL</span> <span class="o">|</span> <span class="n">DEBI_CFG_TOQ</span> <span class="o">|</span> <span class="n">DEBI_CFG_INCQ</span> <span class="o">|</span>
		      <span class="n">DEBI_CFG_16Q</span><span class="p">);</span>

		<span class="cm">/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */</span>
		<span class="cm">/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */</span>

		<span class="cm">/*  Paging is disabled. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBIPAGE</span><span class="p">,</span> <span class="n">DEBI_PAGE_DISABLE</span><span class="p">);</span>	<span class="cm">/*  Disable MMU paging. */</span>

		<span class="cm">/*  Init GPIO so that ADC Start* is negated. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GPIO_BASE</span> <span class="o">|</span> <span class="n">GPIO1_HI</span><span class="p">);</span>

		<span class="cm">/* IsBoardRevA is a boolean that indicates whether the board is RevA.</span>
<span class="cm">		 *</span>
<span class="cm">		 * VERSION 2.01 CHANGE: REV A &amp; B BOARDS NOW SUPPORTED BY DYNAMIC</span>
<span class="cm">		 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which</span>
<span class="cm">		 * is used to access the onboard serial EEPROM.  The EEPROM&#39;s I2C</span>
<span class="cm">		 * DeviceAddress is hardwired to a value that is dependent on the</span>
<span class="cm">		 * 626 board revision.  On all board revisions, the EEPROM stores</span>
<span class="cm">		 * TrimDAC calibration constants for analog I/O.  On RevB and</span>
<span class="cm">		 * higher boards, the DeviceAddress is hardwired to 0 to enable</span>
<span class="cm">		 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;</span>
<span class="cm">		 * this is the address at which the SAA7146 expects a</span>
<span class="cm">		 * configuration EEPROM to reside.  On RevA boards, the EEPROM</span>
<span class="cm">		 * device address, which is hardwired to 4, prevents the SAA7146</span>
<span class="cm">		 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in</span>
<span class="cm">		 * default values, instead.</span>
<span class="cm">		 */</span>

		<span class="cm">/*     devpriv-&gt;I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */</span>
		<span class="cm">/*  DeviceType (0xA0) */</span>
		<span class="cm">/*  and DeviceAddress&lt;&lt;1. */</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">I2CAdrs</span> <span class="o">=</span> <span class="mh">0xA0</span><span class="p">;</span>	<span class="cm">/*  I2C device address for onboard */</span>
		<span class="cm">/*  eeprom(revb) */</span>

		<span class="cm">/*  Issue an I2C ABORT command to halt any I2C operation in */</span>
		<span class="cm">/* progress and reset BUSY flag. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_I2CSTAT</span><span class="p">,</span> <span class="n">I2C_CLKSEL</span> <span class="o">|</span> <span class="n">I2C_ABORT</span><span class="p">);</span>
		<span class="cm">/*  Write I2C control: abort any I2C activity. */</span>
		<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_UPLD_IIC</span><span class="p">);</span>
		<span class="cm">/*  Invoke command  upload */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MC2_UPLD_IIC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="cm">/*  and wait for upload to complete. */</span>

		<span class="cm">/* Per SAA7146 data sheet, write to STATUS reg twice to</span>
<span class="cm">		 * reset all  I2C error flags. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WR7146</span><span class="p">(</span><span class="n">P_I2CSTAT</span><span class="p">,</span> <span class="n">I2C_CLKSEL</span><span class="p">);</span>
			<span class="cm">/*  Write I2C control: reset  error flags. */</span>
			<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_UPLD_IIC</span><span class="p">);</span>	<span class="cm">/*  Invoke command upload */</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MC_TEST</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_UPLD_IIC</span><span class="p">))</span>
				<span class="p">;</span>
			<span class="cm">/* and wait for upload to complete. */</span>
		<span class="p">}</span>

		<span class="cm">/* Init audio interface functional attributes: set DAC/ADC</span>
<span class="cm">		 * serial clock rates, invert DAC serial clock so that</span>
<span class="cm">		 * DAC data setup times are satisfied, enable DAC serial</span>
<span class="cm">		 * clock out.</span>
<span class="cm">		 */</span>

		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_ACON2</span><span class="p">,</span> <span class="n">ACON2_INIT</span><span class="p">);</span>

		<span class="cm">/* Set up TSL1 slot list, which is used to control the</span>
<span class="cm">		 * accumulation of ADC data: RSD1 = shift data in on SD1.</span>
<span class="cm">		 * SIB_A1  = store data uint8_t at next available location in</span>
<span class="cm">		 * FB BUFFER1  register. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_TSL1</span><span class="p">,</span> <span class="n">RSD1</span> <span class="o">|</span> <span class="n">SIB_A1</span><span class="p">);</span>
		<span class="cm">/*  Fetch ADC high data uint8_t. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_TSL1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">RSD1</span> <span class="o">|</span> <span class="n">SIB_A1</span> <span class="o">|</span> <span class="n">EOS</span><span class="p">);</span>
		<span class="cm">/*  Fetch ADC low data uint8_t; end of TSL1. */</span>

		<span class="cm">/*  enab TSL1 slot list so that it executes all the time. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_ACON1</span><span class="p">,</span> <span class="n">ACON1_ADCSTART</span><span class="p">);</span>

		<span class="cm">/*  Initialize RPS registers used for ADC. */</span>

		<span class="cm">/* Physical start of RPS program. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_RPSADDR1</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">PhysicalBase</span><span class="p">);</span>

		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_RPSPAGE1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*  RPS program performs no explicit mem writes. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_RPS1_TOUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/*  Disable RPS timeouts. */</span>

		<span class="cm">/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface</span>
<span class="cm">		 * to a known state by invoking ADCs until FB BUFFER 1</span>
<span class="cm">		 * register shows that it is correctly receiving ADC data.</span>
<span class="cm">		 * This is necessary because the SAA7146 ADC interface does</span>
<span class="cm">		 * not start up in a defined state after a PCI reset.</span>
<span class="cm">		 */</span>

<span class="cm">/*     PollList = EOPL;		// Create a simple polling */</span>
<span class="cm">/*				// list for analog input */</span>
<span class="cm">/*				// channel 0. */</span>
<span class="cm">/*     ResetADC( dev, &amp;PollList ); */</span>

<span class="cm">/*     s626_ai_rinsn(dev,dev-&gt;subdevices,NULL,data); //( &amp;AdcData ); // */</span>
<span class="cm">/*							//Get initial ADC */</span>
<span class="cm">/*							//value. */</span>

<span class="cm">/*     StartVal = data[0]; */</span>

<span class="cm">/*     // VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED EXECUTION. */</span>
<span class="cm">/*     // Invoke ADCs until the new ADC value differs from the initial */</span>
<span class="cm">/*     // value or a timeout occurs.  The timeout protects against the */</span>
<span class="cm">/*     // possibility that the driver is restarting and the ADC data is a */</span>
<span class="cm">/*     // fixed value resulting from the applied ADC analog input being */</span>
<span class="cm">/*     // unusually quiet or at the rail. */</span>

<span class="cm">/*     for ( index = 0; index &lt; 500; index++ ) */</span>
<span class="cm">/*       { */</span>
<span class="cm">/*	s626_ai_rinsn(dev,dev-&gt;subdevices,NULL,data); */</span>
<span class="cm">/*	AdcData = data[0];	//ReadADC(  &amp;AdcData ); */</span>
<span class="cm">/*	if ( AdcData != StartVal ) */</span>
<span class="cm">/*		break; */</span>
<span class="cm">/*       } */</span>

		<span class="cm">/*  end initADC */</span>

		<span class="cm">/*  init the DAC interface */</span>

		<span class="cm">/* Init Audio2&#39;s output DMAC attributes: burst length = 1</span>
<span class="cm">		 * DWORD,  threshold = 1 DWORD.</span>
<span class="cm">		 */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_PCI_BT_A</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Init Audio2&#39;s output DMA physical addresses.  The protection</span>
<span class="cm">		 * address is set to 1 DWORD past the base address so that a</span>
<span class="cm">		 * single DWORD will be transferred each time a DMA transfer is</span>
<span class="cm">		 * enabled. */</span>

		<span class="n">pPhysBuf</span> <span class="o">=</span>
		    <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">PhysicalBase</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">DAC_WDMABUF_OS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>

		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_BASEA2_OUT</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">pPhysBuf</span><span class="p">);</span>	<span class="cm">/*  Buffer base adrs. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_PROTA2_OUT</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">(</span><span class="n">pPhysBuf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)));</span>	<span class="cm">/*  Protection address. */</span>

		<span class="cm">/* Cache Audio2&#39;s output DMA buffer logical address.  This is</span>
<span class="cm">		 * where DAC data is buffered for A2 output DMA transfers. */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pDacWBuf</span> <span class="o">=</span>
		    <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">LogicalBase</span> <span class="o">+</span> <span class="n">DAC_WDMABUF_OS</span><span class="p">;</span>

		<span class="cm">/* Audio2&#39;s output channels does not use paging.  The protection</span>
<span class="cm">		 * violation handling bit is set so that the DMAC will</span>
<span class="cm">		 * automatically halt and its PCI address pointer will be reset</span>
<span class="cm">		 * when the protection address is reached. */</span>

		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_PAGEA2_OUT</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="cm">/* Initialize time slot list 2 (TSL2), which is used to control</span>
<span class="cm">		 * the clock generation for and serialization of data to be sent</span>
<span class="cm">		 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL</span>
<span class="cm">		 * execution; this permits other slots to be safely modified</span>
<span class="cm">		 * without first turning off the TSL sequencer (which is</span>
<span class="cm">		 * apparently impossible to do).  Also, SD3 (which is driven by a</span>
<span class="cm">		 * pull-up resistor) is shifted in and stored to the MSB of</span>
<span class="cm">		 * FB_BUFFER2 to be used as evidence that the slot sequence has</span>
<span class="cm">		 * not yet finished executing.</span>
<span class="cm">		 */</span>

		<span class="n">SETVECT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">RSD3</span> <span class="o">|</span> <span class="n">SIB_A2</span> <span class="o">|</span> <span class="n">EOS</span><span class="p">);</span>
		<span class="cm">/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */</span>

		<span class="cm">/* Initialize slot 1, which is constant.  Slot 1 causes a</span>
<span class="cm">		 * DWORD to be transferred from audio channel 2&#39;s output FIFO</span>
<span class="cm">		 * to the FIFO&#39;s output buffer so that it can be serialized</span>
<span class="cm">		 * and sent to the DAC during subsequent slots.  All remaining</span>
<span class="cm">		 * slots are dynamically populated as required by the target</span>
<span class="cm">		 * DAC device.</span>
<span class="cm">		 */</span>
		<span class="n">SETVECT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">LF_A2</span><span class="p">);</span>
		<span class="cm">/*  Slot 1: Fetch DWORD from Audio2&#39;s output FIFO. */</span>

		<span class="cm">/*  Start DAC&#39;s audio interface (TSL2) running. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_ACON1</span><span class="p">,</span> <span class="n">ACON1_DACSTART</span><span class="p">);</span>

		<span class="cm">/* end init DAC interface */</span>

		<span class="cm">/* Init Trim DACs to calibrated values.  Do it twice because the</span>
<span class="cm">		 * SAA7146 audio channel does not always reset properly and</span>
<span class="cm">		 * sometimes causes the first few TrimDAC writes to malfunction.</span>
<span class="cm">		 */</span>

		<span class="n">LoadTrimDACs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">LoadTrimDACs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/*  Insurance. */</span>

		<span class="cm">/* Manually init all gate array hardware in case this is a soft</span>
<span class="cm">		 * reset (we have no way of determining whether this is a warm</span>
<span class="cm">		 * or cold start).  This is necessary because the gate array will</span>
<span class="cm">		 * reset only in response to a PCI hard reset; there is no soft</span>
<span class="cm">		 * reset function. */</span>

		<span class="cm">/* Init all DAC outputs to 0V and init all DAC setpoint and</span>
<span class="cm">		 * polarity images.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">S626_DAC_CHANNELS</span><span class="p">;</span> <span class="n">chan</span><span class="o">++</span><span class="p">)</span>
			<span class="n">SetDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Init image of WRMISC2 Battery Charger Enabled control bit.</span>
<span class="cm">		 * This image is used when the state of the charger control bit,</span>
<span class="cm">		 * which has no direct hardware readback mechanism, is queried.</span>
<span class="cm">		 */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ChargeEnabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Init image of watchdog timer interval in WRMISC2.  This image</span>
<span class="cm">		 * maintains the value of the control bits of MISC2 are</span>
<span class="cm">		 * continuously reset to zero as long as the WD timer is disabled.</span>
<span class="cm">		 */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">WDInterval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Init Counter Interrupt enab mask for RDMISC2.  This mask is</span>
<span class="cm">		 * applied against MISC2 when testing to determine which timer</span>
<span class="cm">		 * events are requesting interrupt service.</span>
<span class="cm">		 */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">CounterIntEnabs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*  Init counters. */</span>
		<span class="n">CountersInit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* Without modifying the state of the Battery Backup enab, disable</span>
<span class="cm">		 * the watchdog timer, set DIO channels 0-5 to operate in the</span>
<span class="cm">		 * standard DIO (vs. counter overflow) mode, disable the battery</span>
<span class="cm">		 * charger, and reset the watchdog interval selector to zero.</span>
<span class="cm">		 */</span>
		<span class="n">WriteMISC2</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						     <span class="n">LP_RDMISC2</span><span class="p">)</span> <span class="o">&amp;</span>
					    <span class="n">MISC2_BATT_ENABLE</span><span class="p">));</span>

		<span class="cm">/*  Initialize the digital I/O subsystem. */</span>
		<span class="n">s626_dio_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* enable interrupt test */</span>
		<span class="cm">/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv-&gt;base_addr+P_IER); */</span>
	<span class="p">}</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_attach: comedi%d s626 attached %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span>
	      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">s626_ai_reg_to_uint</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tempdata</span><span class="p">;</span>

	<span class="n">tempdata</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tempdata</span> <span class="o">&amp;</span> <span class="mh">0x2000</span><span class="p">)</span>
		<span class="n">tempdata</span> <span class="o">&amp;=</span> <span class="mh">0x1fff</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tempdata</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tempdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data){ */</span>
<span class="cm">/*   return 0; */</span>
<span class="cm">/* } */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">s626_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="o">*</span><span class="n">readaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">irqtype</span><span class="p">,</span> <span class="n">irqstatus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">tempdata</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">group</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">irqbit</span><span class="p">;</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt request received!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">attached</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="cm">/*  lock to avoid race with comedi_poll */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* save interrupt enable register state */</span>
	<span class="n">irqstatus</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_IER</span><span class="p">);</span>

	<span class="cm">/* read interrupt type */</span>
	<span class="n">irqtype</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_ISR</span><span class="p">);</span>

	<span class="cm">/* disable master interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_IER</span><span class="p">);</span>

	<span class="cm">/* clear interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">irqtype</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_ISR</span><span class="p">);</span>

	<span class="cm">/* do somethings */</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irqtype</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">irqtype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRQ_RPS1</span>:		<span class="cm">/*  end_of_scan occurs */</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: RPS1 irq detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/*  manage ai subdevice */</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span><span class="p">;</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>

		<span class="cm">/* Init ptr to DMA buffer that holds new ADC data.  We skip the</span>
<span class="cm">		 * first uint16_t in the buffer because it contains junk data from</span>
<span class="cm">		 * the final ADC of the previous poll list scan.</span>
<span class="cm">		 */</span>
		<span class="n">readaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">LogicalBase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*  get the data and hand it over to comedi */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">chanlist_len</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*  Convert ADC data to 16-bit integer values and copy to application */</span>
			<span class="cm">/*  buffer. */</span>
			<span class="n">tempdata</span> <span class="o">=</span> <span class="n">s626_ai_reg_to_uint</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">readaddr</span><span class="p">);</span>
			<span class="n">readaddr</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* put data into read buffer */</span>
			<span class="cm">/*  comedi_buf_put(s-&gt;async, tempdata); */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cfc_write_to_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tempdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span>
				    <span class="p">(</span><span class="s">&quot;s626_irq_handler: cfc_write_to_buffer error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: ai channel %d acquired: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">i</span><span class="p">,</span> <span class="n">tempdata</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* end of scan occurs */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOS</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continous</span><span class="p">))</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_sample_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_sample_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*  Stop RPS program. */</span>
			<span class="n">MC_DISABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_ERPS1</span><span class="p">);</span>

			<span class="cm">/* send end of acquisition */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>

			<span class="cm">/* disable master interrupt */</span>
			<span class="n">irqstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span>
			    <span class="p">(</span><span class="s">&quot;s626_irq_handler: enable interrupt on dio channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">);</span>

			<span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">);</span>

			<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: External trigger is set!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*  tell comedi that data is there */</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: events %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
		<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRQ_GPIO3</span>:	<span class="cm">/* check dio and conter interrupt */</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: GPIO3 irq detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/*  manage ai subdevice */</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span><span class="p">;</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>

		<span class="cm">/* s626_dio_clear_irq(dev); */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">S626_DIO_BANKS</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irqbit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* read interrupt type */</span>
			<span class="n">irqbit</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span>
								  <span class="n">subdevices</span> <span class="o">+</span>
								  <span class="mi">2</span> <span class="o">+</span>
								  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span>
					   <span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RDCapFlg</span><span class="p">);</span>

			<span class="cm">/* check if interrupt is generated from dio channels */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irqbit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">s626_dio_reset_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">irqbit</span><span class="p">);</span>
				<span class="n">DEBUG</span>
				    <span class="p">(</span><span class="s">&quot;s626_irq_handler: check interrupt on dio group %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">group</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* check if interrupt is an ai acquisition start trigger */</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">irqbit</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">-</span>
							<span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">group</span><span class="p">)))</span>
					    <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">DEBUG</span>
						    <span class="p">(</span><span class="s">&quot;s626_irq_handler: Edge capture interrupt received from channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span><span class="p">);</span>

						<span class="cm">/*  Start executing the RPS program. */</span>
						<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_ERPS1</span><span class="p">);</span>

						<span class="n">DEBUG</span>
						    <span class="p">(</span><span class="s">&quot;s626_irq_handler: acquisition start triggered!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span>
						    <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">DEBUG</span>
							    <span class="p">(</span><span class="s">&quot;s626_ai_cmd: enable interrupt on dio channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							     <span class="n">cmd</span><span class="o">-&gt;</span>
							     <span class="n">scan_begin_arg</span><span class="p">);</span>

							<span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
									 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">);</span>

							<span class="n">DEBUG</span>
							    <span class="p">(</span><span class="s">&quot;s626_irq_handler: External scan trigger is set!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">irqbit</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">-</span>
							<span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">group</span><span class="p">)))</span>
					    <span class="o">==</span> <span class="mi">1</span>
					    <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span>
					    <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">DEBUG</span>
						    <span class="p">(</span><span class="s">&quot;s626_irq_handler: Edge capture interrupt received from channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">);</span>

						<span class="cm">/*  Trigger ADC scan loop start by setting RPS Signal 0. */</span>
						<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_ADC_RPS</span><span class="p">);</span>

						<span class="n">DEBUG</span>
						    <span class="p">(</span><span class="s">&quot;s626_irq_handler: scan triggered!!! %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_sample_count</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span>
						    <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>

							<span class="n">DEBUG</span>
							    <span class="p">(</span><span class="s">&quot;s626_ai_cmd: enable interrupt on dio channel %d group %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">-</span>
							     <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">group</span><span class="p">),</span>
							     <span class="n">group</span><span class="p">);</span>

							<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span>
							    <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>

							<span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
									 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">);</span>

							<span class="n">DEBUG</span>
							    <span class="p">(</span><span class="s">&quot;s626_irq_handler: External convert trigger is set!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
						<span class="p">}</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span>
						    <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
							<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span>
							    <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
							<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
								     <span class="n">CLKENAB_ALWAYS</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">irqbit</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">-</span>
							<span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">group</span><span class="p">)))</span>
					    <span class="o">==</span> <span class="mi">1</span>
					    <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">DEBUG</span>
						    <span class="p">(</span><span class="s">&quot;s626_irq_handler: Edge capture interrupt received from channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">);</span>

						<span class="cm">/*  Trigger ADC scan loop start by setting RPS Signal 0. */</span>
						<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_ADC_RPS</span><span class="p">);</span>

						<span class="n">DEBUG</span>
						    <span class="p">(</span><span class="s">&quot;s626_irq_handler: adc convert triggered!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

						<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span><span class="o">--</span><span class="p">;</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span> <span class="o">&gt;</span>
						    <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

							<span class="n">DEBUG</span>
							    <span class="p">(</span><span class="s">&quot;s626_ai_cmd: enable interrupt on dio channel %d group %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">-</span>
							     <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">group</span><span class="p">),</span>
							     <span class="n">group</span><span class="p">);</span>

							<span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
									 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">);</span>

							<span class="n">DEBUG</span>
							    <span class="p">(</span><span class="s">&quot;s626_irq_handler: External trigger is set!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* read interrupt type */</span>
		<span class="n">irqbit</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_RDMISC2</span><span class="p">);</span>

		<span class="cm">/* check interrupt on counters */</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: check counters interrupt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">irqbit</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irqbit</span> <span class="o">&amp;</span> <span class="n">IRQ_COINT1A</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span>
			    <span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt on counter 1A overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

			<span class="cm">/* clear interrupt capture flag */</span>
			<span class="n">k</span><span class="o">-&gt;</span><span class="n">ResetCapFlags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqbit</span> <span class="o">&amp;</span> <span class="n">IRQ_COINT2A</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span>
			    <span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt on counter 2A overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

			<span class="cm">/* clear interrupt capture flag */</span>
			<span class="n">k</span><span class="o">-&gt;</span><span class="n">ResetCapFlags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqbit</span> <span class="o">&amp;</span> <span class="n">IRQ_COINT3A</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span>
			    <span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt on counter 3A overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

			<span class="cm">/* clear interrupt capture flag */</span>
			<span class="n">k</span><span class="o">-&gt;</span><span class="n">ResetCapFlags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqbit</span> <span class="o">&amp;</span> <span class="n">IRQ_COINT1B</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span>
			    <span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt on counter 1B overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

			<span class="cm">/* clear interrupt capture flag */</span>
			<span class="n">k</span><span class="o">-&gt;</span><span class="n">ResetCapFlags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqbit</span> <span class="o">&amp;</span> <span class="n">IRQ_COINT2B</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span>
			    <span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt on counter 2B overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

			<span class="cm">/* clear interrupt capture flag */</span>
			<span class="n">k</span><span class="o">-&gt;</span><span class="n">ResetCapFlags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">CLKENAB_INDEX</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">DEBUG</span>
					    <span class="p">(</span><span class="s">&quot;s626_irq_handler: conver timer trigger!!! %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span><span class="p">);</span>

					<span class="cm">/*  Trigger ADC scan loop start by setting RPS Signal 0. */</span>
					<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_ADC_RPS</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqbit</span> <span class="o">&amp;</span> <span class="n">IRQ_COINT3B</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span>
			    <span class="p">(</span><span class="s">&quot;s626_irq_handler: interrupt on counter 3B overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

			<span class="cm">/* clear interrupt capture flag */</span>
			<span class="n">k</span><span class="o">-&gt;</span><span class="n">ResetCapFlags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DEBUG</span>
				    <span class="p">(</span><span class="s">&quot;s626_irq_handler: scan timer trigger!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="cm">/*  Trigger ADC scan loop start by setting RPS Signal 0. */</span>
				<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_ADC_RPS</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DEBUG</span>
				    <span class="p">(</span><span class="s">&quot;s626_irq_handler: convert timer trigger is set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
				<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">CLKENAB_ALWAYS</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* enable interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">irqstatus</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_IER</span><span class="p">);</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_irq_handler: exit interrupt service routine.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s626_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* stop ai_command */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* interrupt mask */</span>
			<span class="n">WR7146</span><span class="p">(</span><span class="n">P_IER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/*  Disable master interrupt. */</span>
			<span class="n">WR7146</span><span class="p">(</span><span class="n">P_ISR</span><span class="p">,</span> <span class="n">IRQ_GPIO3</span> <span class="o">|</span> <span class="n">IRQ_RPS1</span><span class="p">);</span>	<span class="cm">/*  Clear board&#39;s IRQ status flag. */</span>

			<span class="cm">/*  Disable the watchdog timer and battery charger. */</span>
			<span class="n">WriteMISC2</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/*  Close all interfaces on 7146 device. */</span>
			<span class="n">WR7146</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_SHUTDOWN</span><span class="p">);</span>
			<span class="n">WR7146</span><span class="p">(</span><span class="n">P_ACON1</span><span class="p">,</span> <span class="n">ACON1_BASE</span><span class="p">);</span>

			<span class="n">CloseDMAB</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">,</span> <span class="n">DMABUF_SIZE</span><span class="p">);</span>
			<span class="n">CloseDMAB</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">,</span> <span class="n">DMABUF_SIZE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">)</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">got_regions</span><span class="p">)</span>
				<span class="n">comedi_pci_disable</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this functions build the RPS program for hardware driven acquistion</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ResetADC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">ppl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pRPS</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">JmpAdrs</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">LocalPPL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/*  Stop RPS program in case it is currently running. */</span>
	<span class="n">MC_DISABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_ERPS1</span><span class="p">);</span>

	<span class="cm">/*  Set starting logical address to write RPS commands. */</span>
	<span class="n">pRPS</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">LogicalBase</span><span class="p">;</span>

	<span class="cm">/*  Initialize RPS instruction pointer. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_RPSADDR1</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">PhysicalBase</span><span class="p">);</span>

	<span class="cm">/*  Construct RPS program in RPSBuf DMA buffer */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;ResetADC: scan_begin pause inserted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*  Wait for Start trigger. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_PAUSE</span> <span class="o">|</span> <span class="n">RPS_SIGADC</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_CLRSIGNAL</span> <span class="o">|</span> <span class="n">RPS_SIGADC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary</span>
<span class="cm">	 * because the first RPS DEBI Write following a non-RPS DEBI write</span>
<span class="cm">	 * seems to always fail.  If we don&#39;t do this dummy write, the ADC</span>
<span class="cm">	 * gain might not be set to the value required for the first slot in</span>
<span class="cm">	 * the poll list; the ADC gain would instead remain unchanged from</span>
<span class="cm">	 * the previously programmed value.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_DEBICMD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="cm">/* Write DEBI Write command and address to shadow RAM. */</span>

	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">DEBI_CMD_WRWORD</span> <span class="o">|</span> <span class="n">LP_GSEL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_DEBIAD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="cm">/*  Write DEBI immediate data  to shadow RAM: */</span>

	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">GSEL_BIPOLAR5V</span><span class="p">;</span>
	<span class="cm">/*  arbitrary immediate data  value. */</span>

	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_CLRSIGNAL</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>
	<span class="cm">/*  Reset &quot;shadow RAM  uploaded&quot; flag. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_UPLOAD</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>	<span class="cm">/*  Invoke shadow RAM upload. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_PAUSE</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>	<span class="cm">/*  Wait for shadow upload to finish. */</span>

	<span class="cm">/* Digitize all slots in the poll list. This is implemented as a</span>
<span class="cm">	 * for loop to limit the slot count to 16 in case the application</span>
<span class="cm">	 * forgot to set the EOPL flag in the final slot.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">AdcItems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">AdcItems</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">AdcItems</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Convert application&#39;s poll list item to private board class</span>
<span class="cm">		 * format.  Each app poll list item is an uint8_t with form</span>
<span class="cm">		 * (EOPL,x,x,RANGE,CHAN&lt;3:0&gt;), where RANGE code indicates 0 =</span>
<span class="cm">		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.</span>
<span class="cm">		 */</span>
		<span class="n">LocalPPL</span> <span class="o">=</span>
		    <span class="p">(</span><span class="o">*</span><span class="n">ppl</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">ppl</span> <span class="o">&amp;</span> <span class="mh">0x10</span> <span class="o">?</span> <span class="n">GSEL_BIPOLAR5V</span> <span class="o">:</span>
				   <span class="n">GSEL_BIPOLAR10V</span><span class="p">);</span>

		<span class="cm">/*  Switch ADC analog gain. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_DEBICMD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/*  Write DEBI command */</span>
		<span class="cm">/*  and address to */</span>
		<span class="cm">/*  shadow RAM. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">DEBI_CMD_WRWORD</span> <span class="o">|</span> <span class="n">LP_GSEL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_DEBIAD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/*  Write DEBI */</span>
		<span class="cm">/*  immediate data to */</span>
		<span class="cm">/*  shadow RAM. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">LocalPPL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_CLRSIGNAL</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>	<span class="cm">/*  Reset &quot;shadow RAM uploaded&quot; */</span>
		<span class="cm">/*  flag. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_UPLOAD</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>	<span class="cm">/*  Invoke shadow RAM upload. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_PAUSE</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>	<span class="cm">/*  Wait for shadow upload to */</span>
		<span class="cm">/*  finish. */</span>

		<span class="cm">/*  Select ADC analog input channel. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_DEBICMD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="cm">/*  Write DEBI command and address to  shadow RAM. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">DEBI_CMD_WRWORD</span> <span class="o">|</span> <span class="n">LP_ISEL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_DEBIAD</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="cm">/*  Write DEBI immediate data to shadow RAM. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">LocalPPL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_CLRSIGNAL</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>
		<span class="cm">/*  Reset &quot;shadow RAM uploaded&quot;  flag. */</span>

		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_UPLOAD</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>
		<span class="cm">/*  Invoke shadow RAM upload. */</span>

		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_PAUSE</span> <span class="o">|</span> <span class="n">RPS_DEBI</span><span class="p">;</span>
		<span class="cm">/*  Wait for shadow upload to finish. */</span>

		<span class="cm">/* Delay at least 10 microseconds for analog input settling.</span>
<span class="cm">		 * Instead of padding with NOPs, we use RPS_JUMP instructions</span>
<span class="cm">		 * here; this allows us to produce a longer delay than is</span>
<span class="cm">		 * possible with NOPs because each RPS_JUMP flushes the RPS&#39;</span>
<span class="cm">		 * instruction prefetch pipeline.</span>
<span class="cm">		 */</span>
		<span class="n">JmpAdrs</span> <span class="o">=</span>
		    <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">PhysicalBase</span> <span class="o">+</span>
		    <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pRPS</span> <span class="o">-</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">LogicalBase</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">RPSCLK_PER_US</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JmpAdrs</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/*  Repeat to implement time delay: */</span>
			<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_JUMP</span><span class="p">;</span>	<span class="cm">/*  Jump to next RPS instruction. */</span>
			<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">JmpAdrs</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_NOW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;ResetADC: convert pause inserted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/*  Wait for Start trigger. */</span>
			<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_PAUSE</span> <span class="o">|</span> <span class="n">RPS_SIGADC</span><span class="p">;</span>
			<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_CLRSIGNAL</span> <span class="o">|</span> <span class="n">RPS_SIGADC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*  Start ADC by pulsing GPIO1. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_GPIO</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/*  Begin ADC Start pulse. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">GPIO_BASE</span> <span class="o">|</span> <span class="n">GPIO1_LO</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_NOP</span><span class="p">;</span>
		<span class="cm">/*  VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_GPIO</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/*  End ADC Start pulse. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">GPIO_BASE</span> <span class="o">|</span> <span class="n">GPIO1_HI</span><span class="p">;</span>

		<span class="cm">/* Wait for ADC to complete (GPIO2 is asserted high when ADC not</span>
<span class="cm">		 * busy) and for data from previous conversion to shift into FB</span>
<span class="cm">		 * BUFFER 1 register.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_PAUSE</span> <span class="o">|</span> <span class="n">RPS_GPIO2</span><span class="p">;</span>	<span class="cm">/*  Wait for ADC done. */</span>

		<span class="cm">/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_STREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">BUGFIX_STREG</span><span class="p">(</span><span class="n">P_FB_BUFFER1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span>
		    <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">PhysicalBase</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">AdcItems</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

		<span class="cm">/*  If this slot&#39;s EndOfPollList flag is set, all channels have */</span>
		<span class="cm">/*  now been processed. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppl</span><span class="o">++</span> <span class="o">&amp;</span> <span class="n">EOPL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">AdcItems</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/*  Adjust poll list item count. */</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/*  Exit poll list processing loop. */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;ResetADC: ADC items %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">AdcItems</span><span class="p">);</span>

	<span class="cm">/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the</span>
<span class="cm">	 * ADC to stabilize for 2 microseconds before starting the final</span>
<span class="cm">	 * (dummy) conversion.  This delay is necessary to allow sufficient</span>
<span class="cm">	 * time between last conversion finished and the start of the dummy</span>
<span class="cm">	 * conversion.  Without this delay, the last conversion&#39;s data value</span>
<span class="cm">	 * is sometimes set to the previous conversion&#39;s data value.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">RPSCLK_PER_US</span><span class="p">);</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_NOP</span><span class="p">;</span>

	<span class="cm">/* Start a dummy conversion to cause the data from the last</span>
<span class="cm">	 * conversion of interest to be shifted in.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_GPIO</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/*  Begin ADC Start pulse. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">GPIO_BASE</span> <span class="o">|</span> <span class="n">GPIO1_LO</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_NOP</span><span class="p">;</span>
	<span class="cm">/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_LDREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">P_GPIO</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/*  End ADC Start pulse. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">GPIO_BASE</span> <span class="o">|</span> <span class="n">GPIO1_HI</span><span class="p">;</span>

	<span class="cm">/* Wait for the data from the last conversion of interest to arrive</span>
<span class="cm">	 * in FB BUFFER 1 register.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_PAUSE</span> <span class="o">|</span> <span class="n">RPS_GPIO2</span><span class="p">;</span>	<span class="cm">/*  Wait for ADC done. */</span>

	<span class="cm">/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_STREG</span> <span class="o">|</span> <span class="p">(</span><span class="n">BUGFIX_STREG</span><span class="p">(</span><span class="n">P_FB_BUFFER1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/*  */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span>
	    <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ANABuf</span><span class="p">.</span><span class="n">PhysicalBase</span> <span class="o">+</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">AdcItems</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*  Indicate ADC scan loop is finished. */</span>
	<span class="cm">/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */</span>

	<span class="cm">/* invoke interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;ResetADC: insert irq in ADC RPS task</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_IRQ</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*  Restart RPS program at its beginning. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="n">RPS_JUMP</span><span class="p">;</span>	<span class="cm">/*  Branch to start of RPS program. */</span>
	<span class="o">*</span><span class="n">pRPS</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">RPSBuf</span><span class="p">.</span><span class="n">PhysicalBase</span><span class="p">;</span>

	<span class="cm">/*  End of RPS program build */</span>
<span class="p">}</span>

<span class="cm">/* TO COMPLETE, IF NECESSARY */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ai_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data) */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   register uint8_t	i; */</span>
<span class="cm">/*   register int32_t	*readaddr; */</span>

<span class="cm">/*   DEBUG(&quot;as626_ai_rinsn: ai_rinsn enter\n&quot;);  */</span>

<span class="cm">/*   Trigger ADC scan loop start by setting RPS Signal 0. */</span>
<span class="cm">/*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */</span>

<span class="cm">/*   Wait until ADC scan loop is finished (RPS Signal 0 reset). */</span>
<span class="cm">/*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */</span>

<span class="cm">/* Init ptr to DMA buffer that holds new ADC data.  We skip the</span>
<span class="cm"> * first uint16_t in the buffer because it contains junk data from</span>
<span class="cm"> * the final ADC of the previous poll list scan.</span>
<span class="cm"> */</span>
<span class="cm">/*   readaddr = (uint32_t *)devpriv-&gt;ANABuf.LogicalBase + 1; */</span>

<span class="cm">/*  Convert ADC data to 16-bit integer values and copy to application buffer. */</span>
<span class="cm">/*   for ( i = 0; i &lt; devpriv-&gt;AdcItems; i++ ) { */</span>
<span class="cm">/*     *data = s626_ai_reg_to_uint( *readaddr++ ); */</span>
<span class="cm">/*     DEBUG(&quot;s626_ai_rinsn: data %d\n&quot;,*data); */</span>
<span class="cm">/*     data++; */</span>
<span class="cm">/*   } */</span>

<span class="cm">/*   DEBUG(&quot;s626_ai_rinsn: ai_rinsn escape\n&quot;); */</span>
<span class="cm">/*   return i; */</span>
<span class="cm">/* } */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ai_insn_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">AdcSpec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">GpioImage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* interrupt call test  */</span>
<span class="cm">/*   writel(IRQ_GPIO3,devpriv-&gt;base_addr+P_PSR); */</span>
	<span class="cm">/* Writing a logical 1 into any of the RPS_PSR bits causes the</span>
<span class="cm">	 * corresponding interrupt to be generated if enabled</span>
<span class="cm">	 */</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_insn_read: entering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Convert application&#39;s ADC specification into form</span>
<span class="cm">	 *  appropriate for register programming.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">AdcSpec</span> <span class="o">=</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">GSEL_BIPOLAR5V</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">AdcSpec</span> <span class="o">=</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">GSEL_BIPOLAR10V</span><span class="p">);</span>

	<span class="cm">/*  Switch ADC analog gain. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_GSEL</span><span class="p">,</span> <span class="n">AdcSpec</span><span class="p">);</span>	<span class="cm">/*  Set gain. */</span>

	<span class="cm">/*  Select ADC analog input channel. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_ISEL</span><span class="p">,</span> <span class="n">AdcSpec</span><span class="p">);</span>	<span class="cm">/*  Select channel. */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*  Delay 10 microseconds for analog input settling. */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="cm">/*  Start ADC by pulsing GPIO1 low. */</span>
		<span class="n">GpioImage</span> <span class="o">=</span> <span class="n">RR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">);</span>
		<span class="cm">/*  Assert ADC Start command */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GPIO1_HI</span><span class="p">);</span>
		<span class="cm">/*    and stretch it out. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GPIO1_HI</span><span class="p">);</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GPIO1_HI</span><span class="p">);</span>
		<span class="cm">/*  Negate ADC Start command. */</span>
		<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">|</span> <span class="n">GPIO1_HI</span><span class="p">);</span>

		<span class="cm">/*  Wait for ADC to complete (GPIO2 is asserted high when */</span>
		<span class="cm">/*  ADC not busy) and for data from previous conversion to */</span>
		<span class="cm">/*  shift into FB BUFFER 1 register. */</span>

		<span class="cm">/*  Wait for ADC done. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_PSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_GPIO2</span><span class="p">))</span>
			<span class="p">;</span>

		<span class="cm">/*  Fetch ADC data. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s626_ai_reg_to_uint</span><span class="p">(</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_FB_BUFFER1</span><span class="p">));</span>

		<span class="cm">/* Allow the ADC to stabilize for 4 microseconds before</span>
<span class="cm">		 * starting the next (final) conversion.  This delay is</span>
<span class="cm">		 * necessary to allow sufficient time between last</span>
<span class="cm">		 * conversion finished and the start of the next</span>
<span class="cm">		 * conversion.  Without this delay, the last conversion&#39;s</span>
<span class="cm">		 * data value is sometimes set to the previous</span>
<span class="cm">		 * conversion&#39;s data value.</span>
<span class="cm">		 */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Start a dummy conversion to cause the data from the</span>
<span class="cm">	 * previous conversion to be shifted in. */</span>
	<span class="n">GpioImage</span> <span class="o">=</span> <span class="n">RR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">);</span>

	<span class="cm">/* Assert ADC Start command */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GPIO1_HI</span><span class="p">);</span>
	<span class="cm">/*    and stretch it out. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GPIO1_HI</span><span class="p">);</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">GPIO1_HI</span><span class="p">);</span>
	<span class="cm">/*  Negate ADC Start command. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_GPIO</span><span class="p">,</span> <span class="n">GpioImage</span> <span class="o">|</span> <span class="n">GPIO1_HI</span><span class="p">);</span>

	<span class="cm">/*  Wait for the data to arrive in FB BUFFER 1 register. */</span>

	<span class="cm">/*  Wait for ADC done. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_PSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_GPIO2</span><span class="p">))</span>
		<span class="p">;</span>

	<span class="cm">/*  Fetch ADC data from audio interface&#39;s input shift register. */</span>

	<span class="cm">/*  Fetch ADC data. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s626_ai_reg_to_uint</span><span class="p">(</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_FB_BUFFER1</span><span class="p">));</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_insn_read: samples %d, data %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ai_load_polllist</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ppl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CR_RANGE</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">)[</span><span class="n">n</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ppl</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">CR_CHAN</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">)[</span><span class="n">n</span><span class="p">]))</span> <span class="o">|</span> <span class="p">(</span><span class="n">RANGE_5V</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ppl</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">CR_CHAN</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">)[</span><span class="n">n</span><span class="p">]))</span> <span class="o">|</span> <span class="p">(</span><span class="n">RANGE_10V</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ppl</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">EOPL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ai_inttrig</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trignum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trignum</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_inttrig: trigger adc start...&quot;</span><span class="p">);</span>

	<span class="cm">/*  Start executing the RPS program. */</span>
	<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_ERPS1</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot; done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  TO COMPLETE  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">uint8_t</span> <span class="n">ppl</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tick</span><span class="p">;</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: entering command function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;s626_ai_cmd: Another ai_cmd is running %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* disable interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_IER</span><span class="p">);</span>

	<span class="cm">/* clear interrupt request */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">IRQ_RPS1</span> <span class="o">|</span> <span class="n">IRQ_GPIO3</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_ISR</span><span class="p">);</span>

	<span class="cm">/* clear any pending interrupt */</span>
	<span class="n">s626_dio_clear_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/*   s626_enc_clear_irq(dev); */</span>

	<span class="cm">/* reset ai_cmd_running flag */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*  test if cmd is valid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: NULL command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: command received!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;s626_ai_cmd: cannot run command without an irq&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s626_ai_load_polllist</span><span class="p">(</span><span class="n">ppl</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_convert_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_FOLLOW</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
		<span class="cm">/*  set a conter to generate adc trigger at scan_begin_arg interval */</span>
		<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
		<span class="n">tick</span> <span class="o">=</span> <span class="n">s626_ns_to_timer</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>

		<span class="cm">/* load timer value and enable interrupt */</span>
		<span class="n">s626_timer_load</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tick</span><span class="p">);</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">CLKENAB_ALWAYS</span><span class="p">);</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: scan trigger timer is set with value %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">tick</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_EXT</span>:
		<span class="cm">/*  set the digital line and interrupt for scan trigger */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span><span class="p">)</span>
			<span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">);</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: External scan trigger is set!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_NOW</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
		<span class="cm">/*  set a conter to generate adc trigger at convert_arg interval */</span>
		<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">tick</span> <span class="o">=</span> <span class="n">s626_ns_to_timer</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>

		<span class="cm">/* load timer value and enable interrupt */</span>
		<span class="n">s626_timer_load</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tick</span><span class="p">);</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">CLKENAB_INDEX</span><span class="p">);</span>

		<span class="n">DEBUG</span>
		    <span class="p">(</span><span class="s">&quot;s626_ai_cmd: convert trigger timer is set with value %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">tick</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_EXT</span>:
		<span class="cm">/*  set the digital line and interrupt for convert trigger */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span>
		    <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span><span class="p">)</span>
			<span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">);</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: External convert trigger is set!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_COUNT</span>:
		<span class="cm">/*  data arrives as one packet */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_sample_count</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_NONE</span>:
		<span class="cm">/*  continous acquisition */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continous</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_sample_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ResetADC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ppl</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_NOW</span>:
		<span class="cm">/*  Trigger ADC scan loop start by setting RPS Signal 0. */</span>
		<span class="cm">/*  MC_ENABLE( P_MC2, MC2_ADC_RPS ); */</span>

		<span class="cm">/*  Start executing the RPS program. */</span>
		<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_ERPS1</span><span class="p">);</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: ADC triggered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_EXT</span>:
		<span class="cm">/* configure DIO channel for acquisition trigger */</span>
		<span class="n">s626_dio_set_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span><span class="p">);</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: External start trigger is set!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_INT</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="n">s626_ai_inttrig</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enable interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">IRQ_GPIO3</span> <span class="o">|</span> <span class="n">IRQ_RPS1</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_IER</span><span class="p">);</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_ai_cmd: command function terminated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* cmdtest tests a particular command to see if it is valid.  Using</span>
<span class="cm">	 * the cmdtest ioctl, a user can create a valid cmd and then have it</span>
<span class="cm">	 * executes by the cmd ioctl.</span>
<span class="cm">	 *</span>
<span class="cm">	 * cmdtest returns 1,2,3,4 or 0, depending on which tests the</span>
<span class="cm">	 * command passes. */</span>

	<span class="cm">/* step 1: make sure trigger sources are trivially valid */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_NOW</span> <span class="o">|</span> <span class="n">TRIG_INT</span> <span class="o">|</span> <span class="n">TRIG_EXT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_EXT</span> <span class="o">|</span> <span class="n">TRIG_FOLLOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_EXT</span> <span class="o">|</span> <span class="n">TRIG_NOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span> <span class="o">|</span> <span class="n">TRIG_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* step 2: make sure trigger sources are unique and mutually</span>
<span class="cm">	   compatible */</span>

	<span class="cm">/* note that mutual compatibility is not an issue here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span>
	    <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_NOW</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">!=</span> <span class="n">TRIG_COUNT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">!=</span> <span class="n">TRIG_NONE</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* step 3: make sure arguments are trivially compatible */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">!=</span> <span class="n">TRIG_EXT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">&gt;</span> <span class="mi">39</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="mi">39</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="mi">39</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#define MAX_SPEED	200000	</span><span class="cm">/* in nanoseconds */</span><span class="cp"></span>
<span class="cp">#define MIN_SPEED	2000000000	</span><span class="cm">/* in nanoseconds */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span> <span class="n">MAX_SPEED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">MAX_SPEED</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="n">MIN_SPEED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">MIN_SPEED</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* external trigger */</span>
		<span class="cm">/* should be level/edge, hi/lo specification here */</span>
		<span class="cm">/* should specify multiple external triggers */</span>
<span class="cm">/*     if(cmd-&gt;scan_begin_arg&gt;9){ */</span>
<span class="cm">/*       cmd-&gt;scan_begin_arg=9; */</span>
<span class="cm">/*       err++; */</span>
<span class="cm">/*     } */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&lt;</span> <span class="n">MAX_SPEED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">MAX_SPEED</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="n">MIN_SPEED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">MIN_SPEED</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* external trigger */</span>
		<span class="cm">/* see above */</span>
<span class="cm">/*     if(cmd-&gt;convert_arg&gt;9){ */</span>
<span class="cm">/*       cmd-&gt;convert_arg=9; */</span>
<span class="cm">/*       err++; */</span>
<span class="cm">/*     } */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">&gt;</span> <span class="mh">0x00ffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mh">0x00ffffff</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* TRIG_NONE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* step 4: fix up any arguments */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">;</span>
		<span class="n">s626_ns_to_timer</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
				 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">;</span>
		<span class="n">s626_ns_to_timer</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
				 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span>
			    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  Stop RPS program in case it is currently running. */</span>
	<span class="n">MC_DISABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_ERPS1</span><span class="p">);</span>

	<span class="cm">/* disable master interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">P_IER</span><span class="p">);</span>

	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_cmd_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function doesn&#39;t require a particular form, this is just what</span>
<span class="cm"> * happens to be used in some of the drivers.  It should convert ns</span>
<span class="cm"> * nanoseconds to a counter value suitable for programming the device.</span>
<span class="cm"> * Also, it should adjust ns so that it cooresponds to the actual time</span>
<span class="cm"> * that the device will use. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ns_to_timer</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">nanosec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">round_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">divider</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>		<span class="cm">/* 2MHz internal clock */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">round_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_NEAREST</span>:
	<span class="nl">default:</span>
		<span class="n">divider</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">nanosec</span> <span class="o">+</span> <span class="n">base</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_DOWN</span>:
		<span class="n">divider</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">nanosec</span><span class="p">)</span> <span class="o">/</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_UP</span>:
		<span class="n">divider</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">nanosec</span> <span class="o">+</span> <span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">nanosec</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="n">divider</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">divider</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="kt">int16_t</span> <span class="n">dacdata</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dacdata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int16_t</span><span class="p">)</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dacdata</span> <span class="o">-=</span> <span class="p">(</span><span class="mh">0x1fff</span><span class="p">);</span>

		<span class="n">SetDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">dacdata</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">)];</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* *************** DIGITAL I/O FUNCTIONS ***************</span>
<span class="cm"> * All DIO functions address a group of DIO channels by means of</span>
<span class="cm"> * &quot;group&quot; argument.  group may be 0, 1 or 2, which correspond to DIO</span>
<span class="cm"> * ports A, B and C, respectively.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s626_dio_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="cm">/*  Prepare to treat writes to WRCapSel as capture disables. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_MISC1</span><span class="p">,</span> <span class="n">MISC1_NOEDCAP</span><span class="p">);</span>

	<span class="cm">/*  For each group of sixteen channels ... */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">S626_DIO_BANKS</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">group</span><span class="p">;</span>
		<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">diopriv</span><span class="o">-&gt;</span><span class="n">WRIntSel</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/*  Disable all interrupts. */</span>
		<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">diopriv</span><span class="o">-&gt;</span><span class="n">WRCapSel</span><span class="p">,</span> <span class="mh">0xFFFF</span><span class="p">);</span>	<span class="cm">/*  Disable all event */</span>
		<span class="cm">/*  captures. */</span>
		<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">diopriv</span><span class="o">-&gt;</span><span class="n">WREdgSel</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/*  Init all DIOs to */</span>
		<span class="cm">/*  default edge */</span>
		<span class="cm">/*  polarity. */</span>
		<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">diopriv</span><span class="o">-&gt;</span><span class="n">WRDOut</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/*  Program all outputs */</span>
		<span class="cm">/*  to inactive state. */</span>
	<span class="p">}</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_dio_init: DIO initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DIO devices are slightly special.  Although it is possible to</span>
<span class="cm"> * implement the insn_read/insn_write interface, it is much more</span>
<span class="cm"> * useful to applications if you implement the insn_bits interface.</span>
<span class="cm"> * This allows packed reading/writing of the DIO channels.  The comedi</span>
<span class="cm"> * core can convert between insn_bits and insn_read/write */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_dio_insn_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* Length of data must be 2 (mask and new data, see below) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span>
		    <span class="p">(</span><span class="s">&quot;comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The insn data consists of a mask in data[0] and the new data in</span>
<span class="cm">	 * data[1]. The mask defines which bits we are concerning about.</span>
<span class="cm">	 * The new data must be anded with the mask.  Each channel</span>
<span class="cm">	 * corresponds to a bit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/* Check if requested ports are configured for output */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="cm">/* Write out the new digital output lines */</span>

		<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">diopriv</span><span class="o">-&gt;</span><span class="n">WRDOut</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">diopriv</span><span class="o">-&gt;</span><span class="n">RDDIn</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_dio_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INSN_CONFIG_DIO_QUERY</span>:
		<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span>
		     <span class="n">io_bits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">)))</span> <span class="o">?</span> <span class="n">COMEDI_OUTPUT</span> <span class="o">:</span>
		    <span class="n">COMEDI_INPUT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMEDI_INPUT</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMEDI_OUTPUT</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">diopriv</span><span class="o">-&gt;</span><span class="n">WRDOut</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">io_bits</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_dio_set_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitmask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* select dio bank */</span>
	<span class="n">group</span> <span class="o">=</span> <span class="n">chan</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">bitmask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">chan</span> <span class="o">-</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">group</span><span class="p">));</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_dio_set_irq: enable interrupt on dio channel %d group %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">chan</span> <span class="o">-</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">group</span><span class="p">),</span> <span class="n">group</span><span class="p">);</span>

	<span class="cm">/* set channel to capture positive edge */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
						  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RDEdgSel</span><span class="p">);</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
					  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">WREdgSel</span><span class="p">,</span>
		  <span class="n">bitmask</span> <span class="o">|</span> <span class="n">status</span><span class="p">);</span>

	<span class="cm">/* enable interrupt on selected channel */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
						  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RDIntSel</span><span class="p">);</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
					  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">WRIntSel</span><span class="p">,</span>
		  <span class="n">bitmask</span> <span class="o">|</span> <span class="n">status</span><span class="p">);</span>

	<span class="cm">/* enable edge capture write command */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_MISC1</span><span class="p">,</span> <span class="n">MISC1_EDCAP</span><span class="p">);</span>

	<span class="cm">/* enable edge capture on selected channel */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
						  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RDCapSel</span><span class="p">);</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
					  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">WRCapSel</span><span class="p">,</span>
		  <span class="n">bitmask</span> <span class="o">|</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_dio_reset_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBUG</span>
	    <span class="p">(</span><span class="s">&quot;s626_dio_reset_irq: disable  interrupt on dio channel %d group %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">mask</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>

	<span class="cm">/* disable edge capture write command */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_MISC1</span><span class="p">,</span> <span class="n">MISC1_NOEDCAP</span><span class="p">);</span>

	<span class="cm">/* enable edge capture on selected channel */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
					  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">WRCapSel</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_dio_clear_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">;</span>

	<span class="cm">/* disable edge capture write command */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_MISC1</span><span class="p">,</span> <span class="n">MISC1_NOEDCAP</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">S626_DIO_BANKS</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* clear pending events and interrupt */</span>
		<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			  <span class="p">((</span><span class="k">struct</span> <span class="n">dio_private</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
						  <span class="n">group</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">WRCapSel</span><span class="p">,</span>
			  <span class="mh">0xffff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Now this function initializes the value of the counter (data[0])</span>
<span class="cm">   and set the subdevice. To complete with trigger and interrupt</span>
<span class="cm">   configuration */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_enc_insn_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">Setup</span> <span class="o">=</span> <span class="p">(</span><span class="n">LOADSRC_INDX</span> <span class="o">&lt;&lt;</span> <span class="n">BF_LOADSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Preload upon */</span>
	    <span class="cm">/*  index. */</span>
	    <span class="p">(</span><span class="n">INDXSRC_SOFT</span> <span class="o">&lt;&lt;</span> <span class="n">BF_INDXSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Disable hardware index. */</span>
	    <span class="p">(</span><span class="n">CLKSRC_COUNTER</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Operating mode is Counter. */</span>
	    <span class="p">(</span><span class="n">CLKPOL_POS</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKPOL</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Active high clock. */</span>
	    <span class="cm">/* ( CNTDIR_UP &lt;&lt; BF_CLKPOL ) |      // Count direction is Down. */</span>
	    <span class="p">(</span><span class="n">CLKMULT_1X</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKMULT</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Clock multiplier is 1x. */</span>
	    <span class="p">(</span><span class="n">CLKENAB_INDEX</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKENAB</span><span class="p">);</span>
	<span class="cm">/*   uint16_t DisableIntSrc=TRUE; */</span>
	<span class="cm">/*  uint32_t Preloadvalue;              //Counter initial value */</span>
	<span class="kt">uint16_t</span> <span class="n">valueSrclatch</span> <span class="o">=</span> <span class="n">LATCHSRC_AB_READ</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">enab</span> <span class="o">=</span> <span class="n">CLKENAB_ALWAYS</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">)];</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_enc_insn_config: encoder config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */</span>

	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetMode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">Setup</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
	<span class="n">Preload</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">PulseIndex</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
	<span class="n">SetLatchSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">valueSrclatch</span><span class="p">);</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">enab</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_enc_insn_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">)];</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_enc_insn_read: encoder read channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadLatch</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_enc_insn_read: encoder sample %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s626_enc_insn_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">)];</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_enc_insn_write: encoder write channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">));</span>

	<span class="cm">/*  Set the preload register */</span>
	<span class="n">Preload</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/*  Software index pulse forces the preload register to load */</span>
	<span class="cm">/*  into the counter */</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetLoadTrig</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">PulseIndex</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetLoadTrig</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;s626_enc_insn_write: End encoder write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s626_timer_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">tick</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">Setup</span> <span class="o">=</span> <span class="p">(</span><span class="n">LOADSRC_INDX</span> <span class="o">&lt;&lt;</span> <span class="n">BF_LOADSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Preload upon */</span>
	    <span class="cm">/*  index. */</span>
	    <span class="p">(</span><span class="n">INDXSRC_SOFT</span> <span class="o">&lt;&lt;</span> <span class="n">BF_INDXSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Disable hardware index. */</span>
	    <span class="p">(</span><span class="n">CLKSRC_TIMER</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Operating mode is Timer. */</span>
	    <span class="p">(</span><span class="n">CLKPOL_POS</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKPOL</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Active high clock. */</span>
	    <span class="p">(</span><span class="n">CNTDIR_DOWN</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKPOL</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Count direction is Down. */</span>
	    <span class="p">(</span><span class="n">CLKMULT_1X</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKMULT</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Clock multiplier is 1x. */</span>
	    <span class="p">(</span><span class="n">CLKENAB_INDEX</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKENAB</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">valueSrclatch</span> <span class="o">=</span> <span class="n">LATCHSRC_A_INDXA</span><span class="p">;</span>
	<span class="cm">/*   uint16_t enab=CLKENAB_ALWAYS; */</span>

	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetMode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">Setup</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

	<span class="cm">/*  Set the preload register */</span>
	<span class="n">Preload</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tick</span><span class="p">);</span>

	<span class="cm">/*  Software index pulse forces the preload register to load */</span>
	<span class="cm">/*  into the counter */</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetLoadTrig</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">PulseIndex</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

	<span class="cm">/* set reload on counter overflow */</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetLoadTrig</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* set interrupt on overflow */</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetIntSrc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">INTSRC_OVER</span><span class="p">);</span>

	<span class="n">SetLatchSource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">valueSrclatch</span><span class="p">);</span>
	<span class="cm">/*   k-&gt;SetEnable(dev,k,(uint16_t)(enab != 0)); */</span>
<span class="p">}</span>

<span class="cm">/* ***********  DAC FUNCTIONS *********** */</span>

<span class="cm">/*  Slot 0 base settings. */</span>
<span class="cp">#define VECT0	(XSD2 | RSD3 | SIB_A2)</span>
<span class="cm">/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */</span>

<span class="cm">/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">trimchan</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>

<span class="cm">/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">trimadrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="mh">0x52</span><span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">,</span> <span class="mh">0x62</span><span class="p">,</span> <span class="mh">0x63</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">LoadTrimDACs</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">trimchan</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">WriteTrimDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">I2Cread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">trimadrs</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">WriteTrimDAC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">LogicalChan</span><span class="p">,</span>
			 <span class="kt">uint8_t</span> <span class="n">DacData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">chan</span><span class="p">;</span>

	<span class="cm">/*  Save the new setpoint in case the application needs to read it back later. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">TrimSetpoint</span><span class="p">[</span><span class="n">LogicalChan</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">DacData</span><span class="p">;</span>

	<span class="cm">/*  Map logical channel number to physical channel number. */</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">trimchan</span><span class="p">[</span><span class="n">LogicalChan</span><span class="p">];</span>

	<span class="cm">/* Set up TSL2 records for TrimDac write operation.  All slots shift</span>
<span class="cm">	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence</span>
<span class="cm">	 * can be detected.</span>
<span class="cm">	 */</span>

	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_1</span> <span class="o">|</span> <span class="n">WS3</span><span class="p">);</span>
	<span class="cm">/* Slot 2: Send high uint8_t to target TrimDac. */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_0</span> <span class="o">|</span> <span class="n">WS3</span><span class="p">);</span>
	<span class="cm">/* Slot 3: Send low uint8_t to target TrimDac. */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_3</span> <span class="o">|</span> <span class="n">WS1</span><span class="p">);</span>
	<span class="cm">/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_2</span> <span class="o">|</span> <span class="n">WS1</span> <span class="o">|</span> <span class="n">EOS</span><span class="p">);</span>
	<span class="cm">/* Slot 5: Send NOP low  uint8_t to DAC0. */</span>

	<span class="cm">/* Construct and transmit target DAC&#39;s serial packet:</span>
<span class="cm">	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A&lt;3:0&gt; is the</span>
<span class="cm">	 * DAC channel&#39;s address, and D&lt;7:0&gt; is the DAC setpoint.  Append a</span>
<span class="cm">	 * WORD value (that writes a channel 0 NOP command to a non-existent</span>
<span class="cm">	 * main DAC channel) that serves to keep the clock running after the</span>
<span class="cm">	 * packet has been sent to the target DAC.</span>
<span class="cm">	 */</span>

	<span class="cm">/*  Address the DAC channel within the trimdac device. */</span>
	<span class="n">SendDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">chan</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">DacData</span><span class="p">);</span>	<span class="cm">/*  Include DAC setpoint data. */</span>
<span class="p">}</span>

<span class="cm">/* **************  EEPROM ACCESS FUNCTIONS  ************** */</span>
<span class="cm">/*  Read uint8_t from EEPROM. */</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">I2Cread</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">rtnval</span><span class="p">;</span>

	<span class="cm">/*  Send EEPROM target address. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">I2Chandshake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">I2C_B2</span><span class="p">(</span><span class="n">I2C_ATTRSTART</span><span class="p">,</span> <span class="n">I2CW</span><span class="p">)</span>
			 <span class="cm">/* Byte2 = I2C command: write to I2C EEPROM  device. */</span>
			 <span class="o">|</span> <span class="n">I2C_B1</span><span class="p">(</span><span class="n">I2C_ATTRSTOP</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
			 <span class="cm">/* Byte1 = EEPROM internal target address. */</span>
			 <span class="o">|</span> <span class="n">I2C_B0</span><span class="p">(</span><span class="n">I2C_ATTRNOP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/*  Byte0 = Not sent. */</span>
		<span class="cm">/*  Abort function and declare error if handshake failed. */</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;I2Cread: error handshake I2Cread  a</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*  Execute EEPROM read. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">I2Chandshake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">I2C_B2</span><span class="p">(</span><span class="n">I2C_ATTRSTART</span><span class="p">,</span> <span class="n">I2CR</span><span class="p">)</span>

			 <span class="cm">/*  Byte2 = I2C */</span>
			 <span class="cm">/*  command: read */</span>
			 <span class="cm">/*  from I2C EEPROM */</span>
			 <span class="cm">/*  device. */</span>
			 <span class="o">|</span><span class="n">I2C_B1</span><span class="p">(</span><span class="n">I2C_ATTRSTOP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

			 <span class="cm">/*  Byte1 receives */</span>
			 <span class="cm">/*  uint8_t from */</span>
			 <span class="cm">/*  EEPROM. */</span>
			 <span class="o">|</span><span class="n">I2C_B0</span><span class="p">(</span><span class="n">I2C_ATTRNOP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/*  Byte0 = Not  sent. */</span>

		<span class="cm">/*  Abort function and declare error if handshake failed. */</span>
		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;I2Cread: error handshake I2Cread b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*  Return copy of EEPROM value. */</span>
	<span class="n">rtnval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_I2CCTRL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rtnval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">I2Chandshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  Write I2C command to I2C Transfer Control shadow register. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_I2CCTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/*  Upload I2C shadow registers into working registers and wait for */</span>
	<span class="cm">/*  upload confirmation. */</span>

	<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_UPLD_IIC</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MC_TEST</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_UPLD_IIC</span><span class="p">))</span>
		<span class="p">;</span>

	<span class="cm">/*  Wait until I2C bus transfer is finished or an error occurs. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_I2CCTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I2C_BUSY</span> <span class="o">|</span> <span class="n">I2C_ERR</span><span class="p">))</span> <span class="o">==</span> <span class="n">I2C_BUSY</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="cm">/*  Return non-zero if I2C error occurred. */</span>
	<span class="k">return</span> <span class="n">RR7146</span><span class="p">(</span><span class="n">P_I2CCTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2C_ERR</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*  Private helper function: Write setpoint to an application DAC channel. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetDAC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">chan</span><span class="p">,</span> <span class="kt">short</span> <span class="n">dacdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">signmask</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint32_t</span> <span class="n">WSImage</span><span class="p">;</span>

	<span class="cm">/*  Adjust DAC data polarity and set up Polarity Control Register */</span>
	<span class="cm">/*  image. */</span>
	<span class="n">signmask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chan</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dacdata</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dacdata</span> <span class="o">=</span> <span class="o">-</span><span class="n">dacdata</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">Dacpol</span> <span class="o">|=</span> <span class="n">signmask</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">Dacpol</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">signmask</span><span class="p">;</span>

	<span class="cm">/*  Limit DAC setpoint value to valid range. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="n">dacdata</span> <span class="o">&gt;</span> <span class="mh">0x1FFF</span><span class="p">)</span>
		<span class="n">dacdata</span> <span class="o">=</span> <span class="mh">0x1FFF</span><span class="p">;</span>

	<span class="cm">/* Set up TSL2 records (aka &quot;vectors&quot;) for DAC update.  Vectors V2</span>
<span class="cm">	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send</span>
<span class="cm">	 * data to a non-existent TrimDac channel just to keep the clock</span>
<span class="cm">	 * running after sending data to the target DAC.  This is necessary</span>
<span class="cm">	 * to eliminate the clock glitch that would otherwise occur at the</span>
<span class="cm">	 * end of the target DAC&#39;s serial data stream.  When the sequence</span>
<span class="cm">	 * restarts at V0 (after executing V5), the gate array automatically</span>
<span class="cm">	 * disables gating for the DAC clock and all DAC chip selects.</span>
<span class="cm">	 */</span>

	<span class="n">WSImage</span> <span class="o">=</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">WS1</span> <span class="o">:</span> <span class="n">WS2</span><span class="p">;</span>
	<span class="cm">/* Choose DAC chip select to be asserted. */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_1</span> <span class="o">|</span> <span class="n">WSImage</span><span class="p">);</span>
	<span class="cm">/* Slot 2: Transmit high data byte to target DAC. */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_0</span> <span class="o">|</span> <span class="n">WSImage</span><span class="p">);</span>
	<span class="cm">/* Slot 3: Transmit low data byte to target DAC. */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_3</span> <span class="o">|</span> <span class="n">WS3</span><span class="p">);</span>
	<span class="cm">/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_2</span> <span class="o">|</span> <span class="n">WS3</span> <span class="o">|</span> <span class="n">EOS</span><span class="p">);</span>
	<span class="cm">/* Slot 5: running after writing target DAC&#39;s low data byte. */</span>

	<span class="cm">/*  Construct and transmit target DAC&#39;s serial packet:</span>
<span class="cm">	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan&lt;0&gt;,</span>
<span class="cm">	 * and D&lt;12:0&gt; is the DAC setpoint.  Append a WORD value (that writes</span>
<span class="cm">	 * to a  non-existent TrimDac channel) that serves to keep the clock</span>
<span class="cm">	 * running after the packet has been sent to the target DAC.</span>
<span class="cm">	 */</span>
	<span class="n">SendDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0F000000</span>
		<span class="cm">/* Continue clock after target DAC data (write to non-existent trimdac). */</span>
		<span class="o">|</span> <span class="mh">0x00004000</span>
		<span class="cm">/* Address the two main dual-DAC devices (TSL&#39;s chip select enables</span>
<span class="cm">		 * target device). */</span>
		<span class="o">|</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span>
		<span class="cm">/*  Address the DAC channel within the  device. */</span>
		<span class="o">|</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">dacdata</span><span class="p">);</span>	<span class="cm">/*  Include DAC setpoint data. */</span>

<span class="p">}</span>

<span class="cm">/* Private helper function: Transmit serial data to DAC via Audio</span>
<span class="cm"> * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)</span>
<span class="cm"> * Dacpol contains valid target image.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SendDAC</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* START THE SERIAL CLOCK RUNNING ------------- */</span>

	<span class="cm">/* Assert DAC polarity control and enable gating of DAC serial clock</span>
<span class="cm">	 * and audio bit stream signals.  At this point in time we must be</span>
<span class="cm">	 * assured of being in time slot 0.  If we are not in slot 0, the</span>
<span class="cm">	 * serial clock and audio stream signals will be disabled; this is</span>
<span class="cm">	 * because the following DEBIwrite statement (which enables signals</span>
<span class="cm">	 * to be passed through the gate array) would execute before the</span>
<span class="cm">	 * trailing edge of WS1/WS3 (which turns off the signals), thus</span>
<span class="cm">	 * causing the signals to be inactive during the DAC write.</span>
<span class="cm">	 */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_DACPOL</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">Dacpol</span><span class="p">);</span>

	<span class="cm">/* TRANSFER OUTPUT DWORD VALUE INTO A2&#39;S OUTPUT FIFO ---------------- */</span>

	<span class="cm">/* Copy DAC setpoint value to DAC&#39;s output DMA buffer. */</span>

	<span class="cm">/* WR7146( (uint32_t)devpriv-&gt;pDacWBuf, val ); */</span>
	<span class="o">*</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pDacWBuf</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/* enab the output DMA transfer.  This will cause the DMAC to copy</span>
<span class="cm">	 * the DAC&#39;s data value to A2&#39;s output FIFO.  The DMA transfer will</span>
<span class="cm">	 * then immediately terminate because the protection address is</span>
<span class="cm">	 * reached upon transfer of the first DWORD value.</span>
<span class="cm">	 */</span>
	<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">,</span> <span class="n">MC1_A2OUT</span><span class="p">);</span>

	<span class="cm">/*  While the DMA transfer is executing ... */</span>

	<span class="cm">/* Reset Audio2 output FIFO&#39;s underflow flag (along with any other</span>
<span class="cm">	 * FIFO underflow/overflow flags).  When set, this flag will</span>
<span class="cm">	 * indicate that we have emerged from slot 0.</span>
<span class="cm">	 */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_ISR</span><span class="p">,</span> <span class="n">ISR_AFOU</span><span class="p">);</span>

	<span class="cm">/* Wait for the DMA transfer to finish so that there will be data</span>
<span class="cm">	 * available in the FIFO when time slot 1 tries to transfer a DWORD</span>
<span class="cm">	 * from the FIFO to the output buffer register.  We test for DMA</span>
<span class="cm">	 * Done by polling the DMAC enable flag; this flag is automatically</span>
<span class="cm">	 * cleared when the transfer has finished.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_MC1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MC1_A2OUT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="cm">/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */</span>

	<span class="cm">/* FIFO data is now available, so we enable execution of time slots</span>
<span class="cm">	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3</span>
<span class="cm">	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list</span>
<span class="cm">	 * detection.</span>
<span class="cm">	 */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">RSD3</span> <span class="o">|</span> <span class="n">SIB_A2</span><span class="p">);</span>

	<span class="cm">/* Wait for slot 1 to execute to ensure that the Packet will be</span>
<span class="cm">	 * transmitted.  This is detected by polling the Audio2 output FIFO</span>
<span class="cm">	 * underflow flag, which will be set when slot 1 execution has</span>
<span class="cm">	 * finished transferring the DAC&#39;s data DWORD from the output FIFO</span>
<span class="cm">	 * to the output buffer register.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_SSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSR_AF2_OUT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="cm">/* Set up to trap execution at slot 0 when the TSL sequencer cycles</span>
<span class="cm">	 * back to slot 0 after executing the EOS in slot 5.  Also,</span>
<span class="cm">	 * simultaneously shift out and in the 0x00 that is ALWAYS the value</span>
<span class="cm">	 * stored in the last byte to be shifted out of the FIFO&#39;s DWORD</span>
<span class="cm">	 * buffer register.</span>
<span class="cm">	 */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">XSD2</span> <span class="o">|</span> <span class="n">XFIFO_2</span> <span class="o">|</span> <span class="n">RSD2</span> <span class="o">|</span> <span class="n">SIB_A2</span> <span class="o">|</span> <span class="n">EOS</span><span class="p">);</span>

	<span class="cm">/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */</span>

	<span class="cm">/* Wait for the TSL to finish executing all time slots before</span>
<span class="cm">	 * exiting this function.  We must do this so that the next DAC</span>
<span class="cm">	 * write doesn&#39;t start, thereby enabling clock/chip select signals:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1. Before the TSL sequence cycles back to slot 0, which disables</span>
<span class="cm">	 *    the clock/cs signal gating and traps slot // list execution.</span>
<span class="cm">	 *    we have not yet finished slot 5 then the clock/cs signals are</span>
<span class="cm">	 *    still gated and we have not finished transmitting the stream.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In</span>
<span class="cm">	 *    this case, the slot sequence is currently repeating, but with</span>
<span class="cm">	 *    clock/cs signals disabled.  We must wait for slot 0 to trap</span>
<span class="cm">	 *    execution before setting up the next DAC setpoint DMA transfer</span>
<span class="cm">	 *    and enabling the clock/cs signals.  To detect the end of slot 5,</span>
<span class="cm">	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If</span>
<span class="cm">	 *    the TSL has not yet finished executing slot 5 ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_FB_BUFFER2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The trap was set on time and we are still executing somewhere</span>
<span class="cm">		 * in slots 2-5, so we now wait for slot 0 to execute and trap</span>
<span class="cm">		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes</span>
<span class="cm">		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting</span>
<span class="cm">		 * out/in on SD2 the 0x00 that is always referenced by slot 5.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_FB_BUFFER2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Either (1) we were too late setting the slot 0 trap; the TSL</span>
<span class="cm">	 * sequencer restarted slot 0 before we could set the EOS trap flag,</span>
<span class="cm">	 * or (2) we were not late and execution is now trapped at slot 0.</span>
<span class="cm">	 * In either case, we must now change slot 0 so that it will store</span>
<span class="cm">	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.</span>
<span class="cm">	 * In order to do this, we reprogram slot 0 so that it will shift in</span>
<span class="cm">	 * SD3, which is driven only by a pull-up resistor.</span>
<span class="cm">	 */</span>
	<span class="n">SETVECT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RSD3</span> <span class="o">|</span> <span class="n">SIB_A2</span> <span class="o">|</span> <span class="n">EOS</span><span class="p">);</span>

	<span class="cm">/* Wait for slot 0 to execute, at which time the TSL is setup for</span>
<span class="cm">	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes</span>
<span class="cm">	 * from 0x00 to 0xFF.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_FB_BUFFER2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">WriteMISC2</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">NewImage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_MISC1</span><span class="p">,</span> <span class="n">MISC1_WENABLE</span><span class="p">);</span>	<span class="cm">/*  enab writes to */</span>
	<span class="cm">/*  MISC2 register. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_WRMISC2</span><span class="p">,</span> <span class="n">NewImage</span><span class="p">);</span>	<span class="cm">/*  Write new image to MISC2. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LP_MISC1</span><span class="p">,</span> <span class="n">MISC1_WDISABLE</span><span class="p">);</span>	<span class="cm">/*  Disable writes to MISC2. */</span>
<span class="p">}</span>

<span class="cm">/*  Initialize the DEBI interface for all transfers. */</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">DEBIread</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*  Set up DEBI control register value in shadow RAM. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBICMD</span><span class="p">,</span> <span class="n">DEBI_CMD_RDWORD</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>

	<span class="cm">/*  Execute the DEBI transfer. */</span>
	<span class="n">DEBItransfer</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*  Fetch target register value. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="n">RR7146</span><span class="p">(</span><span class="n">P_DEBIAD</span><span class="p">);</span>

	<span class="cm">/*  Return register value. */</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Execute a DEBI transfer.  This must be called from within a */</span>
<span class="cm">/*  critical section. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DEBItransfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  Initiate upload of shadow RAM to DEBI control register. */</span>
	<span class="n">MC_ENABLE</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_UPLD_DEBI</span><span class="p">);</span>

	<span class="cm">/*  Wait for completion of upload from shadow RAM to DEBI control */</span>
	<span class="cm">/*  register. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MC_TEST</span><span class="p">(</span><span class="n">P_MC2</span><span class="p">,</span> <span class="n">MC2_UPLD_DEBI</span><span class="p">))</span>
		<span class="p">;</span>

	<span class="cm">/*  Wait until DEBI transfer is done. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">RR7146</span><span class="p">(</span><span class="n">P_PSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_DEBI_S</span><span class="p">)</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Write a value to a gate array register. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DEBIwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">wdata</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*  Set up DEBI control register value in shadow RAM. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBICMD</span><span class="p">,</span> <span class="n">DEBI_CMD_WRWORD</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBIAD</span><span class="p">,</span> <span class="n">wdata</span><span class="p">);</span>

	<span class="cm">/*  Execute the DEBI transfer. */</span>
	<span class="n">DEBItransfer</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Replace the specified bits in a gate array register.  Imports: mask</span>
<span class="cm"> * specifies bits that are to be preserved, wdata is new value to be</span>
<span class="cm"> * or&#39;d with the masked original.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DEBIreplace</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">mask</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">wdata</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*  Copy target gate array register into P_DEBIAD register. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBICMD</span><span class="p">,</span> <span class="n">DEBI_CMD_RDWORD</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* Set up DEBI control reg value in shadow RAM. */</span>
	<span class="n">DEBItransfer</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/*  Execute the DEBI Read transfer. */</span>

	<span class="cm">/*  Write back the modified image. */</span>
	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBICMD</span><span class="p">,</span> <span class="n">DEBI_CMD_WRWORD</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* Set up DEBI control reg value in shadow  RAM. */</span>

	<span class="n">WR7146</span><span class="p">(</span><span class="n">P_DEBIAD</span><span class="p">,</span> <span class="n">wdata</span> <span class="o">|</span> <span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="n">RR7146</span><span class="p">(</span><span class="n">P_DEBIAD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">));</span>
	<span class="cm">/* Modify the register image. */</span>
	<span class="n">DEBItransfer</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/*  Execute the DEBI Write transfer. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">CloseDMAB</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bufferDMA</span> <span class="o">*</span><span class="n">pdma</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="n">bsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vbptr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">vpptr</span><span class="p">;</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;CloseDMAB: Entering S626DRV_CloseDMAB():</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdma</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* find the matching allocation from the board struct */</span>

	<span class="n">vbptr</span> <span class="o">=</span> <span class="n">pdma</span><span class="o">-&gt;</span><span class="n">LogicalBase</span><span class="p">;</span>
	<span class="n">vpptr</span> <span class="o">=</span> <span class="n">pdma</span><span class="o">-&gt;</span><span class="n">PhysicalBase</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vbptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">vbptr</span><span class="p">,</span> <span class="n">vpptr</span><span class="p">);</span>
		<span class="n">pdma</span><span class="o">-&gt;</span><span class="n">LogicalBase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pdma</span><span class="o">-&gt;</span><span class="n">PhysicalBase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">vbptr</span><span class="p">,</span> <span class="n">bsize</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">vpptr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ******  COUNTER FUNCTIONS  ******* */</span>
<span class="cm">/* All counter functions address a specific counter by means of the</span>
<span class="cm"> * &quot;Counter&quot; argument, which is a logical counter number.  The Counter</span>
<span class="cm"> * argument may have any of the following legal values: 0=0A, 1=1A,</span>
<span class="cm"> * 2=2A, 3=0B, 4=1B, 5=2B.</span>
<span class="cm"> */</span>

<span class="cm">/* Forward declarations for functions that are common to both A and B counters: */</span>

<span class="cm">/* ******  PRIVATE COUNTER FUNCTIONS ****** */</span>

<span class="cm">/*  Read a counter&#39;s output latch. */</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">ReadLatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">;</span>
	<span class="cm">/* DEBUG FIXME DEBUG(&quot;ReadLatch: Read Latch enter\n&quot;); */</span>

	<span class="cm">/*  Latch counts and fetch LSW of latched counts value. */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyLatchLsw</span><span class="p">);</span>

	<span class="cm">/*  Fetch MSW of latched counts and combine with LSW. */</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyLatchLsw</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/*  DEBUG FIXME DEBUG(&quot;ReadLatch: Read Latch exit\n&quot;); */</span>

	<span class="cm">/*  Return latched counts. */</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Reset a counter&#39;s index and overflow event capture flags. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ResetCapFlags_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="n">CRBMSK_INTCTRL</span><span class="p">),</span>
		    <span class="n">CRBMSK_INTRESETCMD</span> <span class="o">|</span> <span class="n">CRBMSK_INTRESET_A</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ResetCapFlags_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="n">CRBMSK_INTCTRL</span><span class="p">),</span>
		    <span class="n">CRBMSK_INTRESETCMD</span> <span class="o">|</span> <span class="n">CRBMSK_INTRESET_B</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Return counter setup in a format (COUNTER_SETUP) that is consistent */</span>
<span class="cm">/*  for both A and B counters. */</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetMode_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">cra</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">crb</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">setup</span><span class="p">;</span>

	<span class="cm">/*  Fetch CRA and CRB register images. */</span>
	<span class="n">cra</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">);</span>
	<span class="n">crb</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">);</span>

	<span class="cm">/*  Populate the standardized counter setup bit fields.  Note: */</span>
	<span class="cm">/*  IndexSrc is restricted to ENC_X or IndxPol. */</span>
	<span class="n">setup</span> <span class="o">=</span> <span class="p">((</span><span class="n">cra</span> <span class="o">&amp;</span> <span class="n">STDMSK_LOADSRC</span><span class="p">)</span>	<span class="cm">/*  LoadSrc  = LoadSrcA. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_LATCHSRC</span> <span class="o">-</span> <span class="n">CRBBIT_LATCHSRC</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_LATCHSRC</span><span class="p">)</span>	<span class="cm">/*  LatchSrc = LatchSrcA. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_INTSRC</span> <span class="o">-</span> <span class="n">CRABIT_INTSRC_A</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_INTSRC</span><span class="p">)</span>	<span class="cm">/*  IntSrc   = IntSrcA. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_INDXSRC</span> <span class="o">-</span> <span class="p">(</span><span class="n">CRABIT_INDXSRC_A</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXSRC</span><span class="p">)</span>	<span class="cm">/*  IndxSrc  = IndxSrcA&lt;1&gt;. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRABIT_INDXPOL_A</span> <span class="o">-</span> <span class="n">STDBIT_INDXPOL</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXPOL</span><span class="p">)</span>	<span class="cm">/*  IndxPol  = IndxPolA. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRBBIT_CLKENAB_A</span> <span class="o">-</span> <span class="n">STDBIT_CLKENAB</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKENAB</span><span class="p">));</span>	<span class="cm">/*  ClkEnab  = ClkEnabA. */</span>

	<span class="cm">/*  Adjust mode-dependent parameters. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cra</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKSRC_A</span><span class="p">))</span>	<span class="cm">/*  If Timer mode (ClkSrcA&lt;1&gt; == 1): */</span>
		<span class="n">setup</span> <span class="o">|=</span> <span class="p">((</span><span class="n">CLKSRC_TIMER</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKSRC</span><span class="p">)</span>	<span class="cm">/*    Indicate Timer mode. */</span>
			  <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_CLKPOL</span> <span class="o">-</span> <span class="n">CRABIT_CLKSRC_A</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">)</span>	<span class="cm">/*    Set ClkPol to indicate count direction (ClkSrcA&lt;0&gt;). */</span>
			  <span class="o">|</span><span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKMULT</span><span class="p">));</span>	<span class="cm">/*    ClkMult must be 1x in Timer mode. */</span>

	<span class="k">else</span>			<span class="cm">/*  If Counter mode (ClkSrcA&lt;1&gt; == 0): */</span>
		<span class="n">setup</span> <span class="o">|=</span> <span class="p">((</span><span class="n">CLKSRC_COUNTER</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKSRC</span><span class="p">)</span>	<span class="cm">/*    Indicate Counter mode. */</span>
			  <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRABIT_CLKPOL_A</span> <span class="o">-</span> <span class="n">STDBIT_CLKPOL</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">)</span>	<span class="cm">/*    Pass through ClkPol. */</span>
			  <span class="o">|</span><span class="p">(((</span><span class="n">cra</span> <span class="o">&amp;</span> <span class="n">CRAMSK_CLKMULT_A</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">MULT_X0</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKMULT_A</span><span class="p">))</span> <span class="o">?</span>	<span class="cm">/*    Force ClkMult to 1x if not legal, else pass through. */</span>
			    <span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKMULT</span><span class="p">)</span> <span class="o">:</span>
			    <span class="p">((</span><span class="n">cra</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRABIT_CLKMULT_A</span> <span class="o">-</span>
				      <span class="n">STDBIT_CLKMULT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKMULT</span><span class="p">)));</span>

	<span class="cm">/*  Return adjusted counter setup. */</span>
	<span class="k">return</span> <span class="n">setup</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetMode_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">cra</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">crb</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">setup</span><span class="p">;</span>

	<span class="cm">/*  Fetch CRA and CRB register images. */</span>
	<span class="n">cra</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">);</span>
	<span class="n">crb</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">);</span>

	<span class="cm">/*  Populate the standardized counter setup bit fields.  Note: */</span>
	<span class="cm">/*  IndexSrc is restricted to ENC_X or IndxPol. */</span>
	<span class="n">setup</span> <span class="o">=</span> <span class="p">(((</span><span class="n">crb</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_INTSRC</span> <span class="o">-</span> <span class="n">CRBBIT_INTSRC_B</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_INTSRC</span><span class="p">)</span>	<span class="cm">/*  IntSrc   = IntSrcB. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_LATCHSRC</span> <span class="o">-</span> <span class="n">CRBBIT_LATCHSRC</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_LATCHSRC</span><span class="p">)</span>	<span class="cm">/*  LatchSrc = LatchSrcB. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_LOADSRC</span> <span class="o">-</span> <span class="n">CRBBIT_LOADSRC_B</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_LOADSRC</span><span class="p">)</span>	<span class="cm">/*  LoadSrc  = LoadSrcB. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_INDXPOL</span> <span class="o">-</span> <span class="n">CRBBIT_INDXPOL_B</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXPOL</span><span class="p">)</span>	<span class="cm">/*  IndxPol  = IndxPolB. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRBBIT_CLKENAB_B</span> <span class="o">-</span> <span class="n">STDBIT_CLKENAB</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKENAB</span><span class="p">)</span>	<span class="cm">/*  ClkEnab  = ClkEnabB. */</span>
		 <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">CRABIT_INDXSRC_B</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">STDBIT_INDXSRC</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXSRC</span><span class="p">));</span>	<span class="cm">/*  IndxSrc  = IndxSrcB&lt;1&gt;. */</span>

	<span class="cm">/*  Adjust mode-dependent parameters. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">crb</span> <span class="o">&amp;</span> <span class="n">CRBMSK_CLKMULT_B</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">MULT_X0</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKMULT_B</span><span class="p">))</span>	<span class="cm">/*  If Extender mode (ClkMultB == MULT_X0): */</span>
		<span class="n">setup</span> <span class="o">|=</span> <span class="p">((</span><span class="n">CLKSRC_EXTENDER</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKSRC</span><span class="p">)</span>	<span class="cm">/*    Indicate Extender mode. */</span>
			  <span class="o">|</span><span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKMULT</span><span class="p">)</span>	<span class="cm">/*    Indicate multiplier is 1x. */</span>
			  <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRABIT_CLKSRC_B</span> <span class="o">-</span> <span class="n">STDBIT_CLKPOL</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">));</span>	<span class="cm">/*    Set ClkPol equal to Timer count direction (ClkSrcB&lt;0&gt;). */</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cra</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKSRC_B</span><span class="p">))</span>	<span class="cm">/*  If Timer mode (ClkSrcB&lt;1&gt; == 1): */</span>
		<span class="n">setup</span> <span class="o">|=</span> <span class="p">((</span><span class="n">CLKSRC_TIMER</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKSRC</span><span class="p">)</span>	<span class="cm">/*    Indicate Timer mode. */</span>
			  <span class="o">|</span><span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKMULT</span><span class="p">)</span>	<span class="cm">/*    Indicate multiplier is 1x. */</span>
			  <span class="o">|</span><span class="p">((</span><span class="n">cra</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRABIT_CLKSRC_B</span> <span class="o">-</span> <span class="n">STDBIT_CLKPOL</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">));</span>	<span class="cm">/*    Set ClkPol equal to Timer count direction (ClkSrcB&lt;0&gt;). */</span>

	<span class="k">else</span>			<span class="cm">/*  If Counter mode (ClkSrcB&lt;1&gt; == 0): */</span>
		<span class="n">setup</span> <span class="o">|=</span> <span class="p">((</span><span class="n">CLKSRC_COUNTER</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKSRC</span><span class="p">)</span>	<span class="cm">/*    Indicate Timer mode. */</span>
			  <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">CRBBIT_CLKMULT_B</span> <span class="o">-</span> <span class="n">STDBIT_CLKMULT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKMULT</span><span class="p">)</span>	<span class="cm">/*    Clock multiplier is passed through. */</span>
			  <span class="o">|</span><span class="p">((</span><span class="n">crb</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">STDBIT_CLKPOL</span> <span class="o">-</span> <span class="n">CRBBIT_CLKPOL_B</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">));</span>	<span class="cm">/*    Clock polarity is passed through. */</span>

	<span class="cm">/*  Return adjusted counter setup. */</span>
	<span class="k">return</span> <span class="n">setup</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the operating mode for the specified counter.  The setup</span>
<span class="cm"> * parameter is treated as a COUNTER_SETUP data type.  The following</span>
<span class="cm"> * parameters are programmable (all other parms are ignored): ClkMult,</span>
<span class="cm"> * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetMode_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
		      <span class="kt">uint16_t</span> <span class="n">Setup</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">DisableIntSrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">cra</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">crb</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">setup</span> <span class="o">=</span> <span class="n">Setup</span><span class="p">;</span>	<span class="cm">/*  Cache the Standard Setup. */</span>

	<span class="cm">/*  Initialize CRA and CRB images. */</span>
	<span class="n">cra</span> <span class="o">=</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">CRAMSK_LOADSRC_A</span><span class="p">)</span>	<span class="cm">/*  Preload trigger is passed through. */</span>
	       <span class="o">|</span><span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXSRC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">STDBIT_INDXSRC</span> <span class="o">-</span> <span class="p">(</span><span class="n">CRABIT_INDXSRC_A</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))));</span>	<span class="cm">/*  IndexSrc is restricted to ENC_X or IndxPol. */</span>

	<span class="n">crb</span> <span class="o">=</span> <span class="p">(</span><span class="n">CRBMSK_INTRESETCMD</span> <span class="o">|</span> <span class="n">CRBMSK_INTRESET_A</span>	<span class="cm">/*  Reset any pending CounterA event captures. */</span>
	       <span class="o">|</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKENAB</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRBBIT_CLKENAB_A</span> <span class="o">-</span> <span class="n">STDBIT_CLKENAB</span><span class="p">)));</span>	<span class="cm">/*  Clock enable is passed through. */</span>

	<span class="cm">/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DisableIntSrc</span><span class="p">)</span>
		<span class="n">cra</span> <span class="o">|=</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INTSRC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">STDBIT_INTSRC</span> <span class="o">-</span>
						    <span class="n">CRABIT_INTSRC_A</span><span class="p">));</span>

	<span class="cm">/*  Populate all mode-dependent attributes of CRA &amp; CRB images. */</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKSRC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">STDBIT_CLKSRC</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLKSRC_EXTENDER</span>:	<span class="cm">/*  Extender Mode: Force to Timer mode */</span>
		<span class="cm">/*  (Extender valid only for B counters). */</span>

	<span class="k">case</span> <span class="n">CLKSRC_TIMER</span>:	<span class="cm">/*  Timer Mode: */</span>
		<span class="n">cra</span> <span class="o">|=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKSRC_A</span><span class="p">)</span>	<span class="cm">/*    ClkSrcA&lt;1&gt; selects system clock */</span>
			<span class="o">|</span><span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">STDBIT_CLKPOL</span> <span class="o">-</span> <span class="n">CRABIT_CLKSRC_A</span><span class="p">))</span>	<span class="cm">/*      with count direction (ClkSrcA&lt;0&gt;) obtained from ClkPol. */</span>
			<span class="o">|</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKPOL_A</span><span class="p">)</span>	<span class="cm">/*    ClkPolA behaves as always-on clock enable. */</span>
			<span class="o">|</span><span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKMULT_A</span><span class="p">));</span>	<span class="cm">/*    ClkMult must be 1x. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>		<span class="cm">/*  Counter Mode: */</span>
		<span class="n">cra</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CLKSRC_COUNTER</span>	<span class="cm">/*    Select ENC_C and ENC_D as clock/direction inputs. */</span>
			<span class="o">|</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRABIT_CLKPOL_A</span> <span class="o">-</span> <span class="n">STDBIT_CLKPOL</span><span class="p">))</span>	<span class="cm">/*    Clock polarity is passed through. */</span>
			<span class="o">|</span><span class="p">(((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKMULT</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">MULT_X0</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKMULT</span><span class="p">))</span> <span class="o">?</span>	<span class="cm">/*    Force multiplier to x1 if not legal, otherwise pass through. */</span>
			  <span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKMULT_A</span><span class="p">)</span> <span class="o">:</span>
			  <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKMULT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRABIT_CLKMULT_A</span> <span class="o">-</span>
							<span class="n">STDBIT_CLKMULT</span><span class="p">))));</span>
	<span class="p">}</span>

	<span class="cm">/*  Force positive index polarity if IndxSrc is software-driven only, */</span>
	<span class="cm">/*  otherwise pass it through. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXSRC</span><span class="p">)</span>
		<span class="n">cra</span> <span class="o">|=</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXPOL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRABIT_INDXPOL_A</span> <span class="o">-</span>
						     <span class="n">STDBIT_INDXPOL</span><span class="p">));</span>

	<span class="cm">/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */</span>
	<span class="cm">/*  enable mask to indicate the counter interrupt is disabled. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DisableIntSrc</span><span class="p">)</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">CounterIntEnabs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">MyEventBits</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/*  While retaining CounterB and LatchSrc configurations, program the */</span>
	<span class="cm">/*  new counter operating mode. */</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">,</span> <span class="n">CRAMSK_INDXSRC_B</span> <span class="o">|</span> <span class="n">CRAMSK_CLKSRC_B</span><span class="p">,</span> <span class="n">cra</span><span class="p">);</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CRBMSK_INTCTRL</span> <span class="o">|</span> <span class="n">CRBMSK_CLKENAB_A</span><span class="p">)),</span> <span class="n">crb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetMode_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
		      <span class="kt">uint16_t</span> <span class="n">Setup</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">DisableIntSrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">cra</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">crb</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">setup</span> <span class="o">=</span> <span class="n">Setup</span><span class="p">;</span>	<span class="cm">/*  Cache the Standard Setup. */</span>

	<span class="cm">/*  Initialize CRA and CRB images. */</span>
	<span class="n">cra</span> <span class="o">=</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXSRC</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">CRABIT_INDXSRC_B</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">STDBIT_INDXSRC</span><span class="p">));</span>	<span class="cm">/*  IndexSrc field is restricted to ENC_X or IndxPol. */</span>

	<span class="n">crb</span> <span class="o">=</span> <span class="p">(</span><span class="n">CRBMSK_INTRESETCMD</span> <span class="o">|</span> <span class="n">CRBMSK_INTRESET_B</span>	<span class="cm">/*  Reset event captures and disable interrupts. */</span>
	       <span class="o">|</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKENAB</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRBBIT_CLKENAB_B</span> <span class="o">-</span> <span class="n">STDBIT_CLKENAB</span><span class="p">))</span>	<span class="cm">/*  Clock enable is passed through. */</span>
	       <span class="o">|</span><span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_LOADSRC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">STDBIT_LOADSRC</span> <span class="o">-</span> <span class="n">CRBBIT_LOADSRC_B</span><span class="p">)));</span>	<span class="cm">/*  Preload trigger source is passed through. */</span>

	<span class="cm">/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DisableIntSrc</span><span class="p">)</span>
		<span class="n">crb</span> <span class="o">|=</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INTSRC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">STDBIT_INTSRC</span> <span class="o">-</span>
						    <span class="n">CRBBIT_INTSRC_B</span><span class="p">));</span>

	<span class="cm">/*  Populate all mode-dependent attributes of CRA &amp; CRB images. */</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKSRC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">STDBIT_CLKSRC</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLKSRC_TIMER</span>:	<span class="cm">/*  Timer Mode: */</span>
		<span class="n">cra</span> <span class="o">|=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKSRC_B</span><span class="p">)</span>	<span class="cm">/*    ClkSrcB&lt;1&gt; selects system clock */</span>
			<span class="o">|</span><span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRABIT_CLKSRC_B</span> <span class="o">-</span> <span class="n">STDBIT_CLKPOL</span><span class="p">)));</span>	<span class="cm">/*      with direction (ClkSrcB&lt;0&gt;) obtained from ClkPol. */</span>
		<span class="n">crb</span> <span class="o">|=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKPOL_B</span><span class="p">)</span>	<span class="cm">/*    ClkPolB behaves as always-on clock enable. */</span>
			<span class="o">|</span><span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKMULT_B</span><span class="p">));</span>	<span class="cm">/*    ClkMultB must be 1x. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CLKSRC_EXTENDER</span>:	<span class="cm">/*  Extender Mode: */</span>
		<span class="n">cra</span> <span class="o">|=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKSRC_B</span><span class="p">)</span>	<span class="cm">/*    ClkSrcB source is OverflowA (same as &quot;timer&quot;) */</span>
			<span class="o">|</span><span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRABIT_CLKSRC_B</span> <span class="o">-</span> <span class="n">STDBIT_CLKPOL</span><span class="p">)));</span>	<span class="cm">/*      with direction obtained from ClkPol. */</span>
		<span class="n">crb</span> <span class="o">|=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKPOL_B</span><span class="p">)</span>	<span class="cm">/*    ClkPolB controls IndexB -- always set to active. */</span>
			<span class="o">|</span><span class="p">(</span><span class="n">MULT_X0</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKMULT_B</span><span class="p">));</span>	<span class="cm">/*    ClkMultB selects OverflowA as the clock source. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>		<span class="cm">/*  Counter Mode: */</span>
		<span class="n">cra</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CLKSRC_COUNTER</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_CLKSRC_B</span><span class="p">);</span>	<span class="cm">/*    Select ENC_C and ENC_D as clock/direction inputs. */</span>
		<span class="n">crb</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKPOL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">STDBIT_CLKPOL</span> <span class="o">-</span> <span class="n">CRBBIT_CLKPOL_B</span><span class="p">))</span>	<span class="cm">/*    ClkPol is passed through. */</span>
			<span class="o">|</span><span class="p">(((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKMULT</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">MULT_X0</span> <span class="o">&lt;&lt;</span> <span class="n">STDBIT_CLKMULT</span><span class="p">))</span> <span class="o">?</span>	<span class="cm">/*    Force ClkMult to x1 if not legal, otherwise pass through. */</span>
			  <span class="p">(</span><span class="n">MULT_X1</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKMULT_B</span><span class="p">)</span> <span class="o">:</span>
			  <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_CLKMULT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CRBBIT_CLKMULT_B</span> <span class="o">-</span>
							<span class="n">STDBIT_CLKMULT</span><span class="p">))));</span>
	<span class="p">}</span>

	<span class="cm">/*  Force positive index polarity if IndxSrc is software-driven only, */</span>
	<span class="cm">/*  otherwise pass it through. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXSRC</span><span class="p">)</span>
		<span class="n">crb</span> <span class="o">|=</span> <span class="p">((</span><span class="n">setup</span> <span class="o">&amp;</span> <span class="n">STDMSK_INDXPOL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">STDBIT_INDXPOL</span> <span class="o">-</span>
						     <span class="n">CRBBIT_INDXPOL_B</span><span class="p">));</span>

	<span class="cm">/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */</span>
	<span class="cm">/*  enable mask to indicate the counter interrupt is disabled. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DisableIntSrc</span><span class="p">)</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">CounterIntEnabs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">MyEventBits</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/*  While retaining CounterA and LatchSrc configurations, program the */</span>
	<span class="cm">/*  new counter operating mode. */</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CRAMSK_INDXSRC_B</span> <span class="o">|</span> <span class="n">CRAMSK_CLKSRC_B</span><span class="p">)),</span> <span class="n">cra</span><span class="p">);</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span> <span class="n">CRBMSK_CLKENAB_A</span> <span class="o">|</span> <span class="n">CRBMSK_LATCHSRC</span><span class="p">,</span> <span class="n">crb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Return/set a counter&#39;s enable.  enab: 0=always enabled, 1=enabled by index. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetEnable_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">enab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;SetEnable_A: SetEnable_A enter 3541</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CRBMSK_INTCTRL</span> <span class="o">|</span> <span class="n">CRBMSK_CLKENAB_A</span><span class="p">)),</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">enab</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKENAB_A</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetEnable_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">enab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CRBMSK_INTCTRL</span> <span class="o">|</span> <span class="n">CRBMSK_CLKENAB_B</span><span class="p">)),</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">enab</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_CLKENAB_B</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetEnable_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CRBBIT_CLKENAB_A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetEnable_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CRBBIT_CLKENAB_B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return/set a counter pair&#39;s latch trigger source.  0: On read</span>
<span class="cm"> * access, 1: A index latches A, 2: B index latches B, 3: A overflow</span>
<span class="cm"> * latches B.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetLatchSource</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			   <span class="kt">uint16_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;SetLatchSource: SetLatchSource enter 3550</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CRBMSK_INTCTRL</span> <span class="o">|</span> <span class="n">CRBMSK_LATCHSRC</span><span class="p">)),</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_LATCHSRC</span><span class="p">));</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;SetLatchSource: SetLatchSource exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k )</span>
<span class="cm"> * {</span>
<span class="cm"> *	return ( DEBIread( dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_LATCHSRC ) &amp; 3;</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Return/set the event that will trigger transfer of the preload</span>
<span class="cm"> * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,</span>
<span class="cm"> * 2=OverflowA (B counters only), 3=disabled.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetLoadTrig_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			  <span class="kt">uint16_t</span> <span class="n">Trig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="n">CRAMSK_LOADSRC_A</span><span class="p">),</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">Trig</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_LOADSRC_A</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetLoadTrig_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			  <span class="kt">uint16_t</span> <span class="n">Trig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CRBMSK_LOADSRC_B</span> <span class="o">|</span> <span class="n">CRBMSK_INTCTRL</span><span class="p">)),</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">Trig</span> <span class="o">&lt;&lt;</span> <span class="n">CRBBIT_LOADSRC_B</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetLoadTrig_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CRABIT_LOADSRC_A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetLoadTrig_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CRBBIT_LOADSRC_B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return/set counter interrupt source and clear any captured</span>
<span class="cm"> * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,</span>
<span class="cm"> * 2=IndexOnly, 3=IndexAndOverflow.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetIntSrc_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">IntSource</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  Reset any pending counter overflow or index captures. */</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="n">CRBMSK_INTCTRL</span><span class="p">),</span>
		    <span class="n">CRBMSK_INTRESETCMD</span> <span class="o">|</span> <span class="n">CRBMSK_INTRESET_A</span><span class="p">);</span>

	<span class="cm">/*  Program counter interrupt source. */</span>
	<span class="n">DEBIreplace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">,</span> <span class="o">~</span><span class="n">CRAMSK_INTSRC_A</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">IntSource</span> <span class="o">&lt;&lt;</span> <span class="n">CRABIT_INTSRC_A</span><span class="p">));</span>

	<span class="cm">/*  Update MISC2 interrupt enable mask. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">CounterIntEnabs</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">CounterIntEnabs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">k</span><span class="o">-&gt;</span>
	     <span class="n">MyEventBits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">|</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyEventBits</span><span class="p">[</span><span class="n">IntSource</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SetIntSrc_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
			<span class="kt">uint16_t</span> <span class="n">IntSource</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">crb</span><span class="p">;</span>

	<span class="cm">/*  Cache writeable CRB register image. */</span>
	<span class="n">crb</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CRBMSK_INTCTRL</span><span class="p">;</span>

	<span class="cm">/*  Reset any pending counter overflow or index captures. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">crb</span> <span class="o">|</span> <span class="n">CRBMSK_INTRESETCMD</span> <span class="o">|</span> <span class="n">CRBMSK_INTRESET_B</span><span class="p">));</span>

	<span class="cm">/*  Program counter interrupt source. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">((</span><span class="n">crb</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CRBMSK_INTSRC_B</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">IntSource</span> <span class="o">&lt;&lt;</span>
							  <span class="n">CRBBIT_INTSRC_B</span><span class="p">)));</span>

	<span class="cm">/*  Update MISC2 interrupt enable mask. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">CounterIntEnabs</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">CounterIntEnabs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">k</span><span class="o">-&gt;</span>
	     <span class="n">MyEventBits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">|</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyEventBits</span><span class="p">[</span><span class="n">IntSource</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetIntSrc_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CRABIT_INTSRC_A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">GetIntSrc_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CRBBIT_INTSRC_B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Return/set the clock multiplier. */</span>

<span class="cm">/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   k-&gt;SetMode(dev, k, (uint16_t)( ( k-&gt;GetMode(dev, k ) &amp; ~STDMSK_CLKMULT ) | ( value &lt;&lt; STDBIT_CLKMULT ) ), FALSE ); */</span>
<span class="cm">/* } */</span>

<span class="cm">/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_CLKMULT ) &amp; 3; */</span>
<span class="cm">/* } */</span>

<span class="cm">/* Return/set the clock polarity. */</span>

<span class="cm">/* static void SetClkPol( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   k-&gt;SetMode(dev, k, (uint16_t)( ( k-&gt;GetMode(dev, k ) &amp; ~STDMSK_CLKPOL ) | ( value &lt;&lt; STDBIT_CLKPOL ) ), FALSE ); */</span>
<span class="cm">/* } */</span>

<span class="cm">/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_CLKPOL ) &amp; 1; */</span>
<span class="cm">/* } */</span>

<span class="cm">/* Return/set the clock source.  */</span>

<span class="cm">/* static void SetClkSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   k-&gt;SetMode(dev, k, (uint16_t)( ( k-&gt;GetMode(dev, k ) &amp; ~STDMSK_CLKSRC ) | ( value &lt;&lt; STDBIT_CLKSRC ) ), FALSE ); */</span>
<span class="cm">/* } */</span>

<span class="cm">/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_CLKSRC ) &amp; 3; */</span>
<span class="cm">/* } */</span>

<span class="cm">/* Return/set the index polarity. */</span>

<span class="cm">/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   k-&gt;SetMode(dev, k, (uint16_t)( ( k-&gt;GetMode(dev, k ) &amp; ~STDMSK_INDXPOL ) | ( (value != 0) &lt;&lt; STDBIT_INDXPOL ) ), FALSE ); */</span>
<span class="cm">/* } */</span>

<span class="cm">/* static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_INDXPOL ) &amp; 1; */</span>
<span class="cm">/* } */</span>

<span class="cm">/*  Return/set the index source. */</span>

<span class="cm">/* static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   DEBUG(&quot;SetIndexSrc: set index src enter 3700\n&quot;); */</span>
<span class="cm">/*   k-&gt;SetMode(dev, k, (uint16_t)( ( k-&gt;GetMode(dev, k ) &amp; ~STDMSK_INDXSRC ) | ( (value != 0) &lt;&lt; STDBIT_INDXSRC ) ), FALSE ); */</span>
<span class="cm">/* } */</span>

<span class="cm">/* static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k )  */</span>
<span class="cm">/* { */</span>
<span class="cm">/*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_INDXSRC ) &amp; 1; */</span>
<span class="cm">/* } */</span>

<span class="cm">/*  Generate an index pulse. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">PulseIndex_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">cra</span><span class="p">;</span>

	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;PulseIndex_A: pulse index enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">cra</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">);</span>	<span class="cm">/*  Pulse index. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">cra</span> <span class="o">^</span> <span class="n">CRAMSK_INDXPOL_A</span><span class="p">));</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;PulseIndex_A: pulse index step1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRA</span><span class="p">,</span> <span class="n">cra</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">PulseIndex_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uint16_t</span> <span class="n">crb</span><span class="p">;</span>

	<span class="n">crb</span> <span class="o">=</span> <span class="n">DEBIread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CRBMSK_INTCTRL</span><span class="p">;</span>	<span class="cm">/*  Pulse index. */</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">crb</span> <span class="o">^</span> <span class="n">CRBMSK_INDXPOL_B</span><span class="p">));</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">MyCRB</span><span class="p">,</span> <span class="n">crb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Write value into counter preload register. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">Preload</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span>
		    <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;Preload: preload enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">MyLatchLsw</span><span class="p">),</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="n">value</span><span class="p">);</span>	<span class="cm">/*  Write value to preload register. */</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;Preload: preload step 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DEBIwrite</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">MyLatchLsw</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
		  <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">CountersInit</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">enc_private</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">Setup</span> <span class="o">=</span> <span class="p">(</span><span class="n">LOADSRC_INDX</span> <span class="o">&lt;&lt;</span> <span class="n">BF_LOADSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Preload upon */</span>
	    <span class="cm">/*  index. */</span>
	    <span class="p">(</span><span class="n">INDXSRC_SOFT</span> <span class="o">&lt;&lt;</span> <span class="n">BF_INDXSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Disable hardware index. */</span>
	    <span class="p">(</span><span class="n">CLKSRC_COUNTER</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKSRC</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Operating mode is counter. */</span>
	    <span class="p">(</span><span class="n">CLKPOL_POS</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKPOL</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Active high clock. */</span>
	    <span class="p">(</span><span class="n">CNTDIR_UP</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKPOL</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Count direction is up. */</span>
	    <span class="p">(</span><span class="n">CLKMULT_1X</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKMULT</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/*  Clock multiplier is 1x. */</span>
	    <span class="p">(</span><span class="n">CLKENAB_INDEX</span> <span class="o">&lt;&lt;</span> <span class="n">BF_CLKENAB</span><span class="p">);</span>	<span class="cm">/*  Enabled by index */</span>

	<span class="cm">/*  Disable all counter interrupts and clear any captured counter events. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">S626_ENCODER_CHANNELS</span><span class="p">;</span> <span class="n">chan</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">encpriv</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetMode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">Setup</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetIntSrc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">ResetCapFlags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">SetEnable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">CLKENAB_ALWAYS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DEBUG</span><span class="p">(</span><span class="s">&quot;CountersInit: counters initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">comedi_driver</span> <span class="n">s626_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver_name</span>	<span class="o">=</span> <span class="s">&quot;s626&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">s626_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach</span>		<span class="o">=</span> <span class="n">s626_detach</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">s626_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">comedi_pci_auto_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s626_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">s626_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">comedi_pci_auto_unconfig</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For devices with vendor:device id == 0x1131:0x7146 you must specify</span>
<span class="cm"> * also subvendor:subdevice ids, because otherwise it will conflict with</span>
<span class="cm"> * Philips SAA7146 media/dvb based cards.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">s626_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_S626</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_S626</span><span class="p">,</span>
		<span class="n">PCI_SUBVENDOR_ID_S626</span><span class="p">,</span> <span class="n">PCI_SUBDEVICE_ID_S626</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">s626_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">s626_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;s626&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">s626_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">s626_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">s626_pci_remove</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">module_comedi_pci_driver</span><span class="p">(</span><span class="n">s626_driver</span><span class="p">,</span> <span class="n">s626_pci_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Gianluca Palli &lt;gpalli@deis.unibo.it&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Sensoray 626 Comedi driver module&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>during configuration</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>to configure</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
