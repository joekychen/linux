<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › amplc_pci230.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>amplc_pci230.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre> <span class="cm">/*</span>
<span class="cm">    comedi/drivers/amplc_pci230.c</span>
<span class="cm">    Driver for Amplicon PCI230 and PCI260 Multifunction I/O boards.</span>

<span class="cm">    Copyright (C) 2001 Allan Willcox &lt;allanwillcox@ozemail.com.au&gt;</span>

<span class="cm">    COMEDI - Linux Control and Measurement Device Interface</span>
<span class="cm">    Copyright (C) 2000 David A. Schleef &lt;ds@schleef.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm">  */</span>
<span class="cm">/*</span>
<span class="cm">Driver: amplc_pci230</span>
<span class="cm">Description: Amplicon PCI230, PCI260 Multifunction I/O boards</span>
<span class="cm">Author: Allan Willcox &lt;allanwillcox@ozemail.com.au&gt;,</span>
<span class="cm">  Steve D Sharples &lt;steve.sharples@nottingham.ac.uk&gt;,</span>
<span class="cm">  Ian Abbott &lt;abbotti@mev.co.uk&gt;</span>
<span class="cm">Updated: Wed, 22 Oct 2008 12:34:49 +0100</span>
<span class="cm">Devices: [Amplicon] PCI230 (pci230 or amplc_pci230),</span>
<span class="cm">  PCI230+ (pci230+ or amplc_pci230),</span>
<span class="cm">  PCI260 (pci260 or amplc_pci230), PCI260+ (pci260+ or amplc_pci230)</span>
<span class="cm">Status: works</span>

<span class="cm">Configuration options:</span>
<span class="cm">  [0] - PCI bus of device (optional).</span>
<span class="cm">  [1] - PCI slot of device (optional).</span>
<span class="cm">          If bus/slot is not specified, the first available PCI device</span>
<span class="cm">          will be used.</span>

<span class="cm">Configuring a &quot;amplc_pci230&quot; will match any supported card and it will</span>
<span class="cm">choose the best match, picking the &quot;+&quot; models if possible.  Configuring</span>
<span class="cm">a &quot;pci230&quot; will match a PCI230 or PCI230+ card and it will be treated as</span>
<span class="cm">a PCI230.  Configuring a &quot;pci260&quot; will match a PCI260 or PCI260+ card</span>
<span class="cm">and it will be treated as a PCI260.  Configuring a &quot;pci230+&quot; will match</span>
<span class="cm">a PCI230+ card.  Configuring a &quot;pci260+&quot; will match a PCI260+ card.</span>

<span class="cm">Subdevices:</span>

<span class="cm">                PCI230(+)    PCI260(+)</span>
<span class="cm">                ---------    ---------</span>
<span class="cm">  Subdevices       3            1</span>
<span class="cm">        0          AI           AI</span>
<span class="cm">	1          AO</span>
<span class="cm">	2          DIO</span>

<span class="cm">AI Subdevice:</span>

<span class="cm">  The AI subdevice has 16 single-ended channels or 8 differential</span>
<span class="cm">  channels.</span>

<span class="cm">  The PCI230 and PCI260 cards have 12-bit resolution.  The PCI230+ and</span>
<span class="cm">  PCI260+ cards have 16-bit resolution.</span>

<span class="cm">  For differential mode, use inputs 2N and 2N+1 for channel N (e.g. use</span>
<span class="cm">  inputs 14 and 15 for channel 7).  If the card is physically a PCI230</span>
<span class="cm">  or PCI260 then it actually uses a &quot;pseudo-differential&quot; mode where the</span>
<span class="cm">  inputs are sampled a few microseconds apart.  The PCI230+ and PCI260+</span>
<span class="cm">  use true differential sampling.  Another difference is that if the</span>
<span class="cm">  card is physically a PCI230 or PCI260, the inverting input is 2N,</span>
<span class="cm">  whereas for a PCI230+ or PCI260+ the inverting input is 2N+1.  So if a</span>
<span class="cm">  PCI230 is physically replaced by a PCI230+ (or a PCI260 with a</span>
<span class="cm">  PCI260+) and differential mode is used, the differential inputs need</span>
<span class="cm">  to be physically swapped on the connector.</span>

<span class="cm">  The following input ranges are supported:</span>

<span class="cm">    0 =&gt; [-10, +10] V</span>
<span class="cm">    1 =&gt; [-5, +5] V</span>
<span class="cm">    2 =&gt; [-2.5, +2.5] V</span>
<span class="cm">    3 =&gt; [-1.25, +1.25] V</span>
<span class="cm">    4 =&gt; [0, 10] V</span>
<span class="cm">    5 =&gt; [0, 5] V</span>
<span class="cm">    6 =&gt; [0, 2.5] V</span>

<span class="cm">AI Commands:</span>

<span class="cm">  +=========+==============+===========+============+==========+</span>
<span class="cm">  |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |</span>
<span class="cm">  +=========+==============+===========+============+==========+</span>
<span class="cm">  |TRIG_NOW | TRIG_FOLLOW  |TRIG_TIMER | TRIG_COUNT |TRIG_NONE |</span>
<span class="cm">  |TRIG_INT |              |TRIG_EXT(3)|            |TRIG_COUNT|</span>
<span class="cm">  |         |              |TRIG_INT   |            |          |</span>
<span class="cm">  |         |--------------|-----------|            |          |</span>
<span class="cm">  |         | TRIG_TIMER(1)|TRIG_TIMER |            |          |</span>
<span class="cm">  |         | TRIG_EXT(2)  |           |            |          |</span>
<span class="cm">  |         | TRIG_INT     |           |            |          |</span>
<span class="cm">  +---------+--------------+-----------+------------+----------+</span>

<span class="cm">  Note 1: If AI command and AO command are used simultaneously, only</span>
<span class="cm">          one may have scan_begin_src == TRIG_TIMER.</span>

<span class="cm">  Note 2: For PCI230 and PCI230+, scan_begin_src == TRIG_EXT uses</span>
<span class="cm">          DIO channel 16 (pin 49) which will need to be configured as</span>
<span class="cm">          a digital input.  For PCI260+, the EXTTRIG/EXTCONVCLK input</span>
<span class="cm">          (pin 17) is used instead.  For PCI230, scan_begin_src ==</span>
<span class="cm">          TRIG_EXT is not supported.  The trigger is a rising edge</span>
<span class="cm">          on the input.</span>

<span class="cm">  Note 3: For convert_src == TRIG_EXT, the EXTTRIG/EXTCONVCLK input</span>
<span class="cm">          (pin 25 on PCI230(+), pin 17 on PCI260(+)) is used.  The</span>
<span class="cm">          convert_arg value is interpreted as follows:</span>

<span class="cm">            convert_arg == (CR_EDGE | 0) =&gt; rising edge</span>
<span class="cm">            convert_arg == (CR_EDGE | CR_INVERT | 0) =&gt; falling edge</span>
<span class="cm">            convert_arg == 0 =&gt; falling edge (backwards compatibility)</span>
<span class="cm">            convert_arg == 1 =&gt; rising edge (backwards compatibility)</span>

<span class="cm">  All entries in the channel list must use the same analogue reference.</span>
<span class="cm">  If the analogue reference is not AREF_DIFF (not differential) each</span>
<span class="cm">  pair of channel numbers (0 and 1, 2 and 3, etc.) must use the same</span>
<span class="cm">  input range.  The input ranges used in the sequence must be all</span>
<span class="cm">  bipolar (ranges 0 to 3) or all unipolar (ranges 4 to 6).  The channel</span>
<span class="cm">  sequence must consist of 1 or more identical subsequences.  Within the</span>
<span class="cm">  subsequence, channels must be in ascending order with no repeated</span>
<span class="cm">  channels.  For example, the following sequences are valid: 0 1 2 3</span>
<span class="cm">  (single valid subsequence), 0 2 3 5 0 2 3 5 (repeated valid</span>
<span class="cm">  subsequence), 1 1 1 1 (repeated valid subsequence).  The following</span>
<span class="cm">  sequences are invalid: 0 3 2 1 (invalid subsequence), 0 2 3 5 0 2 3</span>
<span class="cm">  (incompletely repeated subsequence).  Some versions of the PCI230+ and</span>
<span class="cm">  PCI260+ have a bug that requires a subsequence longer than one entry</span>
<span class="cm">  long to include channel 0.</span>

<span class="cm">AO Subdevice:</span>

<span class="cm">  The AO subdevice has 2 channels with 12-bit resolution.</span>

<span class="cm">  The following output ranges are supported:</span>

<span class="cm">    0 =&gt; [0, 10] V</span>
<span class="cm">    1 =&gt; [-10, +10] V</span>

<span class="cm">AO Commands:</span>

<span class="cm">  +=========+==============+===========+============+==========+</span>
<span class="cm">  |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |</span>
<span class="cm">  +=========+==============+===========+============+==========+</span>
<span class="cm">  |TRIG_INT | TRIG_TIMER(1)| TRIG_NOW  | TRIG_COUNT |TRIG_NONE |</span>
<span class="cm">  |         | TRIG_EXT(2)  |           |            |TRIG_COUNT|</span>
<span class="cm">  |         | TRIG_INT     |           |            |          |</span>
<span class="cm">  +---------+--------------+-----------+------------+----------+</span>

<span class="cm">  Note 1: If AI command and AO command are used simultaneously, only</span>
<span class="cm">          one may have scan_begin_src == TRIG_TIMER.</span>

<span class="cm">  Note 2: scan_begin_src == TRIG_EXT is only supported if the card is</span>
<span class="cm">          configured as a PCI230+ and is only supported on later</span>
<span class="cm">          versions of the card.  As a card configured as a PCI230+ is</span>
<span class="cm">          not guaranteed to support external triggering, please consider</span>
<span class="cm">          this support to be a bonus.  It uses the EXTTRIG/ EXTCONVCLK</span>
<span class="cm">          input (PCI230+ pin 25).  Triggering will be on the rising edge</span>
<span class="cm">          unless the CR_INVERT flag is set in scan_begin_arg.</span>

<span class="cm">  The channels in the channel sequence must be in ascending order with</span>
<span class="cm">  no repeats.  All entries in the channel sequence must use the same</span>
<span class="cm">  output range.</span>

<span class="cm">DIO Subdevice:</span>

<span class="cm">  The DIO subdevice is a 8255 chip providing 24 DIO channels.  The DIO</span>
<span class="cm">  channels are configurable as inputs or outputs in four groups:</span>

<span class="cm">    Port A  - channels  0 to  7</span>
<span class="cm">    Port B  - channels  8 to 15</span>
<span class="cm">    Port CL - channels 16 to 19</span>
<span class="cm">    Port CH - channels 20 to 23</span>

<span class="cm">  Only mode 0 of the 8255 chip is supported.</span>

<span class="cm">  Bit 0 of port C (DIO channel 16) is also used as an external scan</span>
<span class="cm">  trigger input for AI commands on PCI230 and PCI230+, so would need to</span>
<span class="cm">  be configured as an input to use it for that purpose.</span>
<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">Extra triggered scan functionality, interrupt bug-fix added by Steve Sharples.</span>
<span class="cm">Support for PCI230+/260+, more triggered scan functionality, and workarounds</span>
<span class="cm">for (or detection of) various hardware problems added by Ian Abbott.</span>
<span class="cm">*/</span>

<span class="cp">#include &quot;../comedidev.h&quot;</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include &quot;comedi_pci.h&quot;</span>
<span class="cp">#include &quot;8253.h&quot;</span>
<span class="cp">#include &quot;8255.h&quot;</span>

<span class="cm">/* PCI230 PCI configuration register information */</span>
<span class="cp">#define PCI_VENDOR_ID_AMPLICON 0x14dc</span>
<span class="cp">#define PCI_DEVICE_ID_PCI230 0x0000</span>
<span class="cp">#define PCI_DEVICE_ID_PCI260 0x0006</span>
<span class="cp">#define PCI_DEVICE_ID_INVALID 0xffff</span>

<span class="cp">#define PCI230_IO1_SIZE 32	</span><span class="cm">/* Size of I/O space 1 */</span><span class="cp"></span>
<span class="cp">#define PCI230_IO2_SIZE 16	</span><span class="cm">/* Size of I/O space 2 */</span><span class="cp"></span>

<span class="cm">/* PCI230 i/o space 1 registers. */</span>
<span class="cp">#define PCI230_PPI_X_BASE	0x00	</span><span class="cm">/* User PPI (82C55) base */</span><span class="cp"></span>
<span class="cp">#define PCI230_PPI_X_A		0x00	</span><span class="cm">/* User PPI (82C55) port A */</span><span class="cp"></span>
<span class="cp">#define PCI230_PPI_X_B		0x01	</span><span class="cm">/* User PPI (82C55) port B */</span><span class="cp"></span>
<span class="cp">#define PCI230_PPI_X_C		0x02	</span><span class="cm">/* User PPI (82C55) port C */</span><span class="cp"></span>
<span class="cp">#define PCI230_PPI_X_CMD	0x03	</span><span class="cm">/* User PPI (82C55) control word */</span><span class="cp"></span>
<span class="cp">#define PCI230_Z2_CT_BASE	0x14	</span><span class="cm">/* 82C54 counter/timer base */</span><span class="cp"></span>
<span class="cp">#define PCI230_Z2_CT0		0x14	</span><span class="cm">/* 82C54 counter/timer 0 */</span><span class="cp"></span>
<span class="cp">#define PCI230_Z2_CT1		0x15	</span><span class="cm">/* 82C54 counter/timer 1 */</span><span class="cp"></span>
<span class="cp">#define PCI230_Z2_CT2		0x16	</span><span class="cm">/* 82C54 counter/timer 2 */</span><span class="cp"></span>
<span class="cp">#define PCI230_Z2_CTC		0x17	</span><span class="cm">/* 82C54 counter/timer control word */</span><span class="cp"></span>
<span class="cp">#define PCI230_ZCLK_SCE		0x1A	</span><span class="cm">/* Group Z Clock Configuration */</span><span class="cp"></span>
<span class="cp">#define PCI230_ZGAT_SCE		0x1D	</span><span class="cm">/* Group Z Gate Configuration */</span><span class="cp"></span>
<span class="cp">#define PCI230_INT_SCE		0x1E	</span><span class="cm">/* Interrupt source mask (w) */</span><span class="cp"></span>
<span class="cp">#define PCI230_INT_STAT		0x1E	</span><span class="cm">/* Interrupt status (r) */</span><span class="cp"></span>

<span class="cm">/* PCI230 i/o space 2 registers. */</span>
<span class="cp">#define PCI230_DACCON		0x00	</span><span class="cm">/* DAC control */</span><span class="cp"></span>
<span class="cp">#define PCI230_DACOUT1		0x02	</span><span class="cm">/* DAC channel 0 (w) */</span><span class="cp"></span>
<span class="cp">#define PCI230_DACOUT2		0x04	</span><span class="cm">/* DAC channel 1 (w) (not FIFO mode) */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADCDATA		0x08	</span><span class="cm">/* ADC data (r) */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADCSWTRIG	0x08	</span><span class="cm">/* ADC software trigger (w) */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADCCON		0x0A	</span><span class="cm">/* ADC control */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADCEN		0x0C	</span><span class="cm">/* ADC channel enable bits */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADCG		0x0E	</span><span class="cm">/* ADC gain control bits */</span><span class="cp"></span>
<span class="cm">/* PCI230+ i/o space 2 additional registers. */</span>
<span class="cp">#define PCI230P_ADCTRIG		0x10	</span><span class="cm">/* ADC start acquisition trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P_ADCTH		0x12	</span><span class="cm">/* ADC analog trigger threshold */</span><span class="cp"></span>
<span class="cp">#define PCI230P_ADCFFTH		0x14	</span><span class="cm">/* ADC FIFO interrupt threshold */</span><span class="cp"></span>
<span class="cp">#define PCI230P_ADCFFLEV	0x16	</span><span class="cm">/* ADC FIFO level (r) */</span><span class="cp"></span>
<span class="cp">#define PCI230P_ADCPTSC		0x18	</span><span class="cm">/* ADC pre-trigger sample count (r) */</span><span class="cp"></span>
<span class="cp">#define PCI230P_ADCHYST		0x1A	</span><span class="cm">/* ADC analog trigger hysteresys */</span><span class="cp"></span>
<span class="cp">#define PCI230P_EXTFUNC		0x1C	</span><span class="cm">/* Extended functions */</span><span class="cp"></span>
<span class="cp">#define PCI230P_HWVER		0x1E	</span><span class="cm">/* Hardware version (r) */</span><span class="cp"></span>
<span class="cm">/* PCI230+ hardware version 2 onwards. */</span>
<span class="cp">#define PCI230P2_DACDATA	0x02	</span><span class="cm">/* DAC data (FIFO mode) (w) */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DACSWTRIG	0x02	</span><span class="cm">/* DAC soft trigger (FIFO mode) (r) */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DACEN		0x06	</span><span class="cm">/* DAC channel enable (FIFO mode) */</span><span class="cp"></span>

<span class="cm">/* Convertor related constants. */</span>
<span class="cp">#define PCI230_DAC_SETTLE 5	</span><span class="cm">/* Analogue output settling time in µs */</span><span class="cp"></span>
				<span class="cm">/* (DAC itself is 1µs nominally). */</span>
<span class="cp">#define PCI230_ADC_SETTLE 1	</span><span class="cm">/* Analogue input settling time in µs */</span><span class="cp"></span>
				<span class="cm">/* (ADC itself is 1.6µs nominally but we poll</span>
<span class="cm">				 * anyway). */</span>
<span class="cp">#define PCI230_MUX_SETTLE 10	</span><span class="cm">/* ADC MUX settling time in µS */</span><span class="cp"></span>
				<span class="cm">/* - 10µs for se, 20µs de. */</span>

<span class="cm">/* DACCON read-write values. */</span>
<span class="cp">#define PCI230_DAC_OR_UNI		(0&lt;&lt;0)	</span><span class="cm">/* Output range unipolar */</span><span class="cp"></span>
<span class="cp">#define PCI230_DAC_OR_BIP		(1&lt;&lt;0)	</span><span class="cm">/* Output range bipolar */</span><span class="cp"></span>
<span class="cp">#define PCI230_DAC_OR_MASK		(1&lt;&lt;0)</span>
<span class="cm">/* The following applies only if DAC FIFO support is enabled in the EXTFUNC</span>
<span class="cm"> * register (and only for PCI230+ hardware version 2 onwards). */</span>
<span class="cp">#define PCI230P2_DAC_FIFO_EN		(1&lt;&lt;8)	</span><span class="cm">/* FIFO enable */</span><span class="cp"></span>
<span class="cm">/* The following apply only if the DAC FIFO is enabled (and only for PCI230+</span>
<span class="cm"> * hardware version 2 onwards). */</span>
<span class="cp">#define PCI230P2_DAC_TRIG_NONE		(0&lt;&lt;2)	</span><span class="cm">/* No trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_TRIG_SW		(1&lt;&lt;2)	</span><span class="cm">/* Software trigger trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_TRIG_EXTP		(2&lt;&lt;2)	</span><span class="cm">/* EXTTRIG +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_TRIG_EXTN		(3&lt;&lt;2)	</span><span class="cm">/* EXTTRIG -ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_TRIG_Z2CT0		(4&lt;&lt;2)	</span><span class="cm">/* CT0-OUT +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_TRIG_Z2CT1		(5&lt;&lt;2)	</span><span class="cm">/* CT1-OUT +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_TRIG_Z2CT2		(6&lt;&lt;2)	</span><span class="cm">/* CT2-OUT +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_TRIG_MASK		(7&lt;&lt;2)</span>
<span class="cp">#define PCI230P2_DAC_FIFO_WRAP		(1&lt;&lt;7)	</span><span class="cm">/* FIFO wraparound mode */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_INT_FIFO_EMPTY	(0&lt;&lt;9)	</span><span class="cm">/* FIFO interrupt empty */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_INT_FIFO_NEMPTY	(1&lt;&lt;9)</span>
<span class="cp">#define PCI230P2_DAC_INT_FIFO_NHALF	(2&lt;&lt;9)	</span><span class="cm">/* FIFO intr not half full */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_INT_FIFO_HALF	(3&lt;&lt;9)</span>
<span class="cp">#define PCI230P2_DAC_INT_FIFO_NFULL	(4&lt;&lt;9)	</span><span class="cm">/* FIFO interrupt not full */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_INT_FIFO_FULL	(5&lt;&lt;9)</span>
<span class="cp">#define PCI230P2_DAC_INT_FIFO_MASK	(7&lt;&lt;9)</span>

<span class="cm">/* DACCON read-only values. */</span>
<span class="cp">#define PCI230_DAC_BUSY			(1&lt;&lt;1)	</span><span class="cm">/* DAC busy. */</span><span class="cp"></span>
<span class="cm">/* The following apply only if the DAC FIFO is enabled (and only for PCI230+</span>
<span class="cm"> * hardware version 2 onwards). */</span>
<span class="cp">#define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED	(1&lt;&lt;5)	</span><span class="cm">/* Underrun error */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_FIFO_EMPTY		(1&lt;&lt;13)	</span><span class="cm">/* FIFO empty */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_FIFO_FULL		(1&lt;&lt;14)	</span><span class="cm">/* FIFO full */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_FIFO_HALF		(1&lt;&lt;15)	</span><span class="cm">/* FIFO half full */</span><span class="cp"></span>

<span class="cm">/* DACCON write-only, transient values. */</span>
<span class="cm">/* The following apply only if the DAC FIFO is enabled (and only for PCI230+</span>
<span class="cm"> * hardware version 2 onwards). */</span>
<span class="cp">#define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR	(1&lt;&lt;5)	</span><span class="cm">/* Clear underrun */</span><span class="cp"></span>
<span class="cp">#define PCI230P2_DAC_FIFO_RESET		(1&lt;&lt;12)	</span><span class="cm">/* FIFO reset */</span><span class="cp"></span>

<span class="cm">/* PCI230+ hardware version 2 DAC FIFO levels. */</span>
<span class="cp">#define PCI230P2_DAC_FIFOLEVEL_HALF	512</span>
<span class="cp">#define PCI230P2_DAC_FIFOLEVEL_FULL	1024</span>
<span class="cm">/* Free space in DAC FIFO. */</span>
<span class="cp">#define PCI230P2_DAC_FIFOROOM_EMPTY		PCI230P2_DAC_FIFOLEVEL_FULL</span>
<span class="cp">#define PCI230P2_DAC_FIFOROOM_ONETOHALF		\</span>
<span class="cp">	(PCI230P2_DAC_FIFOLEVEL_FULL - PCI230P2_DAC_FIFOLEVEL_HALF)</span>
<span class="cp">#define PCI230P2_DAC_FIFOROOM_HALFTOFULL	1</span>
<span class="cp">#define PCI230P2_DAC_FIFOROOM_FULL		0</span>

<span class="cm">/* ADCCON read/write values. */</span>
<span class="cp">#define PCI230_ADC_TRIG_NONE		(0&lt;&lt;0)	</span><span class="cm">/* No trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_TRIG_SW		(1&lt;&lt;0)	</span><span class="cm">/* Software trigger trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_TRIG_EXTP		(2&lt;&lt;0)	</span><span class="cm">/* EXTTRIG +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_TRIG_EXTN		(3&lt;&lt;0)	</span><span class="cm">/* EXTTRIG -ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_TRIG_Z2CT0		(4&lt;&lt;0)	</span><span class="cm">/* CT0-OUT +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_TRIG_Z2CT1		(5&lt;&lt;0)	</span><span class="cm">/* CT1-OUT +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_TRIG_Z2CT2		(6&lt;&lt;0)	</span><span class="cm">/* CT2-OUT +ve edge trigger */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_TRIG_MASK		(7&lt;&lt;0)</span>
<span class="cp">#define PCI230_ADC_IR_UNI		(0&lt;&lt;3)	</span><span class="cm">/* Input range unipolar */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_IR_BIP		(1&lt;&lt;3)	</span><span class="cm">/* Input range bipolar */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_IR_MASK		(1&lt;&lt;3)</span>
<span class="cp">#define PCI230_ADC_IM_SE		(0&lt;&lt;4)	</span><span class="cm">/* Input mode single ended */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_IM_DIF		(1&lt;&lt;4)	</span><span class="cm">/* Input mode differential */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_IM_MASK		(1&lt;&lt;4)</span>
<span class="cp">#define PCI230_ADC_FIFO_EN		(1&lt;&lt;8)	</span><span class="cm">/* FIFO enable */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_INT_FIFO_EMPTY	(0&lt;&lt;9)</span>
<span class="cp">#define PCI230_ADC_INT_FIFO_NEMPTY	(1&lt;&lt;9)	</span><span class="cm">/* FIFO interrupt not empty */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_INT_FIFO_NHALF	(2&lt;&lt;9)</span>
<span class="cp">#define PCI230_ADC_INT_FIFO_HALF	(3&lt;&lt;9)	</span><span class="cm">/* FIFO interrupt half full */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_INT_FIFO_NFULL	(4&lt;&lt;9)</span>
<span class="cp">#define PCI230_ADC_INT_FIFO_FULL	(5&lt;&lt;9)	</span><span class="cm">/* FIFO interrupt full */</span><span class="cp"></span>
<span class="cp">#define PCI230P_ADC_INT_FIFO_THRESH	(7&lt;&lt;9)	</span><span class="cm">/* FIFO interrupt threshold */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_INT_FIFO_MASK	(7&lt;&lt;9)</span>

<span class="cm">/* ADCCON write-only, transient values. */</span>
<span class="cp">#define PCI230_ADC_FIFO_RESET		(1&lt;&lt;12)	</span><span class="cm">/* FIFO reset */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_GLOB_RESET		(1&lt;&lt;13)	</span><span class="cm">/* Global reset */</span><span class="cp"></span>

<span class="cm">/* ADCCON read-only values. */</span>
<span class="cp">#define PCI230_ADC_BUSY			(1&lt;&lt;15)	</span><span class="cm">/* ADC busy */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_FIFO_EMPTY		(1&lt;&lt;12)	</span><span class="cm">/* FIFO empty */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_FIFO_FULL		(1&lt;&lt;13)	</span><span class="cm">/* FIFO full */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_FIFO_HALF		(1&lt;&lt;14)	</span><span class="cm">/* FIFO half full */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_FIFO_FULL_LATCHED	(1&lt;&lt;5)	</span><span class="cm">/* Indicates overrun occurred */</span><span class="cp"></span>

<span class="cm">/* PCI230 ADC FIFO levels. */</span>
<span class="cp">#define PCI230_ADC_FIFOLEVEL_HALFFULL	2049	</span><span class="cm">/* Value for FIFO half full */</span><span class="cp"></span>
<span class="cp">#define PCI230_ADC_FIFOLEVEL_FULL	4096	</span><span class="cm">/* FIFO size */</span><span class="cp"></span>

<span class="cm">/* Value to write to ADCSWTRIG to trigger ADC conversion in software trigger</span>
<span class="cm"> * mode.  Can be anything.  */</span>
<span class="cp">#define PCI230_ADC_CONV			0xffff</span>

<span class="cm">/* PCI230+ EXTFUNC values. */</span>
<span class="cp">#define PCI230P_EXTFUNC_GAT_EXTTRIG	(1&lt;&lt;0)</span>
			<span class="cm">/* Route EXTTRIG pin to external gate inputs. */</span>
<span class="cm">/* PCI230+ hardware version 2 values. */</span>
<span class="cp">#define PCI230P2_EXTFUNC_DACFIFO	(1&lt;&lt;1)</span>
			<span class="cm">/* Allow DAC FIFO to be enabled. */</span>

<span class="cm">/*</span>
<span class="cm"> * Counter/timer clock input configuration sources.</span>
<span class="cm"> */</span>
<span class="cp">#define CLK_CLK		0	</span><span class="cm">/* reserved (channel-specific clock) */</span><span class="cp"></span>
<span class="cp">#define CLK_10MHZ	1	</span><span class="cm">/* internal 10 MHz clock */</span><span class="cp"></span>
<span class="cp">#define CLK_1MHZ	2	</span><span class="cm">/* internal 1 MHz clock */</span><span class="cp"></span>
<span class="cp">#define CLK_100KHZ	3	</span><span class="cm">/* internal 100 kHz clock */</span><span class="cp"></span>
<span class="cp">#define CLK_10KHZ	4	</span><span class="cm">/* internal 10 kHz clock */</span><span class="cp"></span>
<span class="cp">#define CLK_1KHZ	5	</span><span class="cm">/* internal 1 kHz clock */</span><span class="cp"></span>
<span class="cp">#define CLK_OUTNM1	6	</span><span class="cm">/* output of channel-1 modulo total */</span><span class="cp"></span>
<span class="cp">#define CLK_EXT		7	</span><span class="cm">/* external clock */</span><span class="cp"></span>
<span class="cm">/* Macro to construct clock input configuration register value. */</span>
<span class="cp">#define CLK_CONFIG(chan, src)	((((chan) &amp; 3) &lt;&lt; 3) | ((src) &amp; 7))</span>
<span class="cm">/* Timebases in ns. */</span>
<span class="cp">#define TIMEBASE_10MHZ		100</span>
<span class="cp">#define TIMEBASE_1MHZ		1000</span>
<span class="cp">#define TIMEBASE_100KHZ		10000</span>
<span class="cp">#define TIMEBASE_10KHZ		100000</span>
<span class="cp">#define TIMEBASE_1KHZ		1000000</span>

<span class="cm">/*</span>
<span class="cm"> * Counter/timer gate input configuration sources.</span>
<span class="cm"> */</span>
<span class="cp">#define GAT_VCC		0	</span><span class="cm">/* VCC (i.e. enabled) */</span><span class="cp"></span>
<span class="cp">#define GAT_GND		1	</span><span class="cm">/* GND (i.e. disabled) */</span><span class="cp"></span>
<span class="cp">#define GAT_EXT		2	</span><span class="cm">/* external gate input (PPCn on PCI230) */</span><span class="cp"></span>
<span class="cp">#define GAT_NOUTNM2	3	</span><span class="cm">/* inverted output of channel-2 modulo total */</span><span class="cp"></span>
<span class="cm">/* Macro to construct gate input configuration register value. */</span>
<span class="cp">#define GAT_CONFIG(chan, src)	((((chan) &amp; 3) &lt;&lt; 3) | ((src) &amp; 7))</span>

<span class="cm">/*</span>
<span class="cm"> * Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI230 and PCI260:</span>
<span class="cm"> *</span>
<span class="cm"> *              Channel&#39;s       Channel&#39;s</span>
<span class="cm"> *              clock input     gate input</span>
<span class="cm"> * Channel      CLK_OUTNM1      GAT_NOUTNM2</span>
<span class="cm"> * -------      ----------      -----------</span>
<span class="cm"> * Z2-CT0       Z2-CT2-OUT      /Z2-CT1-OUT</span>
<span class="cm"> * Z2-CT1       Z2-CT0-OUT      /Z2-CT2-OUT</span>
<span class="cm"> * Z2-CT2       Z2-CT1-OUT      /Z2-CT0-OUT</span>
<span class="cm"> */</span>

<span class="cm">/* Interrupt enables/status register values. */</span>
<span class="cp">#define PCI230_INT_DISABLE		0</span>
<span class="cp">#define PCI230_INT_PPI_C0		(1&lt;&lt;0)</span>
<span class="cp">#define PCI230_INT_PPI_C3		(1&lt;&lt;1)</span>
<span class="cp">#define PCI230_INT_ADC			(1&lt;&lt;2)</span>
<span class="cp">#define PCI230_INT_ZCLK_CT1		(1&lt;&lt;5)</span>
<span class="cm">/* For PCI230+ hardware version 2 when DAC FIFO enabled. */</span>
<span class="cp">#define PCI230P2_INT_DAC		(1&lt;&lt;4)</span>

<span class="cp">#define PCI230_TEST_BIT(val, n)	((val&gt;&gt;n)&amp;1)</span>
			<span class="cm">/* Assumes bits numbered with zero offset, ie. 0-15 */</span>

<span class="cm">/* (Potentially) shared resources and their owners */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RES_Z2CT0</span><span class="p">,</span>		<span class="cm">/* Z2-CT0 */</span>
	<span class="n">RES_Z2CT1</span><span class="p">,</span>		<span class="cm">/* Z2-CT1 */</span>
	<span class="n">RES_Z2CT2</span><span class="p">,</span>		<span class="cm">/* Z2-CT2 */</span>
	<span class="n">NUM_RESOURCES</span>		<span class="cm">/* Number of (potentially) shared resources. */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">OWNER_NONE</span><span class="p">,</span>		<span class="cm">/* Not owned */</span>
	<span class="n">OWNER_AICMD</span><span class="p">,</span>		<span class="cm">/* Owned by AI command */</span>
	<span class="n">OWNER_AOCMD</span>		<span class="cm">/* Owned by AO command */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Handy macros.</span>
<span class="cm"> */</span>

<span class="cm">/* Combine old and new bits. */</span>
<span class="cp">#define COMBINE(old, new, mask)	(((old) &amp; ~(mask)) | ((new) &amp; (mask)))</span>

<span class="cm">/* A generic null function pointer value.  */</span>
<span class="cp">#define NULLFUNC	0</span>

<span class="cm">/* Current CPU.  XXX should this be hard_smp_processor_id()? */</span>
<span class="cp">#define THISCPU		smp_processor_id()</span>

<span class="cm">/* State flags for atomic bit operations */</span>
<span class="cp">#define AI_CMD_STARTED	0</span>
<span class="cp">#define AO_CMD_STARTED	1</span>

<span class="cm">/*</span>
<span class="cm"> * Board descriptions for the two boards supported.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pci230_board</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ai_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ai_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have_dio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_hwver</span><span class="p">;</span>	<span class="cm">/* Minimum hardware version supported. */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci230_board</span> <span class="n">pci230_boards</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci230+&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_PCI230</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_chans</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">have_dio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">min_hwver</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci260+&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_PCI260</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_chans</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">have_dio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">min_hwver</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci230&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_PCI230</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_chans</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">have_dio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci260&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_PCI260</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_chans</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ai_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">have_dio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;amplc_pci230&quot;</span><span class="p">,</span>	<span class="cm">/* Wildcard matches any above */</span>
	 <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">PCI_DEVICE_ID_INVALID</span><span class="p">,</span>
	 <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Useful for shorthand access to the particular board structure</span>
<span class="cm"> */</span>
<span class="cp">#define n_pci230_boards ARRAY_SIZE(pci230_boards)</span>
<span class="cp">#define thisboard ((const struct pci230_board *)dev-&gt;board_ptr)</span>

<span class="cm">/* this structure is for data unique to this hardware driver.  If</span>
<span class="cm">   several hardware drivers keep similar information in this structure,</span>
<span class="cm">   feel free to suggest moving the variable to the struct comedi_device struct.  */</span>
<span class="k">struct</span> <span class="n">pci230_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">isr_spinlock</span><span class="p">;</span>	<span class="cm">/* Interrupt spin lock */</span>
	<span class="n">spinlock_t</span> <span class="n">res_spinlock</span><span class="p">;</span>	<span class="cm">/* Shared resources spin lock */</span>
	<span class="n">spinlock_t</span> <span class="n">ai_stop_spinlock</span><span class="p">;</span>	<span class="cm">/* Spin lock for stopping AI command */</span>
	<span class="n">spinlock_t</span> <span class="n">ao_stop_spinlock</span><span class="p">;</span>	<span class="cm">/* Spin lock for stopping AO command */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>	<span class="cm">/* State flags */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iobase1</span><span class="p">;</span>	<span class="cm">/* PCI230&#39;s I/O space 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_readback</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* Used for AO readback */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ai_scan_count</span><span class="p">;</span>	<span class="cm">/* Number of analogue input scans</span>
<span class="cm">					 * remaining.  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ai_scan_pos</span><span class="p">;</span>	<span class="cm">/* Current position within analogue</span>
<span class="cm">					 * input scan */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_scan_count</span><span class="p">;</span>	<span class="cm">/* Number of analogue output scans</span>
<span class="cm">					 * remaining.  */</span>
	<span class="kt">int</span> <span class="n">intr_cpuid</span><span class="p">;</span>		<span class="cm">/* ID of CPU running interrupt routine. */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">hwver</span><span class="p">;</span>	<span class="cm">/* Hardware version (for &#39;+&#39; models). */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">adccon</span><span class="p">;</span>	<span class="cm">/* ADCCON register value. */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">daccon</span><span class="p">;</span>	<span class="cm">/* DACCON register value. */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">adcfifothresh</span><span class="p">;</span>	<span class="cm">/* ADC FIFO programmable interrupt</span>
<span class="cm">					 * level threshold (PCI230+/260+). */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">adcg</span><span class="p">;</span>	<span class="cm">/* ADCG register value. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">int_en</span><span class="p">;</span>	<span class="cm">/* Interrupt enables bits. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ai_continuous</span><span class="p">;</span>	<span class="cm">/* Flag set when cmd-&gt;stop_src ==</span>
<span class="cm">					 * TRIG_NONE - user chooses to stop</span>
<span class="cm">					 * continuous conversion by</span>
<span class="cm">					 * cancelation. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ao_continuous</span><span class="p">;</span>	<span class="cm">/* Flag set when cmd-&gt;stop_src ==</span>
<span class="cm">					 * TRIG_NONE - user chooses to stop</span>
<span class="cm">					 * continuous conversion by</span>
<span class="cm">					 * cancelation. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ai_bipolar</span><span class="p">;</span>	<span class="cm">/* Set if bipolar input range so we</span>
<span class="cm">					 * know to mangle it. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ao_bipolar</span><span class="p">;</span>	<span class="cm">/* Set if bipolar output range so we</span>
<span class="cm">					 * know to mangle it. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ier</span><span class="p">;</span>	<span class="cm">/* Copy of interrupt enables/status register. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intr_running</span><span class="p">;</span>	<span class="cm">/* Flag set in interrupt routine. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">res_owner</span><span class="p">[</span><span class="n">NUM_RESOURCES</span><span class="p">];</span>	<span class="cm">/* Shared resource owners. */</span>
<span class="p">};</span>

<span class="cp">#define devpriv ((struct pci230_private *)dev-&gt;private)</span>

<span class="cm">/* PCI230 clock source periods in ns */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci230_timebase</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">CLK_10MHZ</span><span class="p">]</span> <span class="o">=</span> <span class="n">TIMEBASE_10MHZ</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CLK_1MHZ</span><span class="p">]</span> <span class="o">=</span> <span class="n">TIMEBASE_1MHZ</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CLK_100KHZ</span><span class="p">]</span> <span class="o">=</span> <span class="n">TIMEBASE_100KHZ</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CLK_10KHZ</span><span class="p">]</span> <span class="o">=</span> <span class="n">TIMEBASE_10KHZ</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CLK_1KHZ</span><span class="p">]</span> <span class="o">=</span> <span class="n">TIMEBASE_1KHZ</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* PCI230 analogue input range table */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">pci230_ai_range</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="p">{</span>
							  <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
							  <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
							  <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">2.5</span><span class="p">),</span>
							  <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">1.25</span><span class="p">),</span>
							  <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
							  <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
							  <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
							  <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* PCI230 analogue gain bits for each input range. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pci230_ai_gain</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

<span class="cm">/* PCI230 adccon bipolar flag for each analogue input range. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pci230_ai_bipolar</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cm">/* PCI230 analogue output range table */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">pci230_ao_range</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span>
							  <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
							  <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
							  <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* PCI230 daccon bipolar flag for each analogue output range. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pci230_ao_bipolar</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ai_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pci230_ct_setup_ns_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ct</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">ns</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">round</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pci230_ns_to_single_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">round</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pci230_cancel_ct</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ct</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">pci230_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ao_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ao_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ao_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pci230_ao_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pci230_handle_ao_nofifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_handle_ao_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci230_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pci230_ai_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pci230_handle_ai</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">short</span> <span class="nf">pci230_ai_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Read sample. */</span>
	<span class="kt">short</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCDATA</span><span class="p">);</span>

	<span class="cm">/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower</span>
<span class="cm">	 * four bits reserved for expansion). */</span>
	<span class="cm">/* PCI230+ is 16 bit AI. */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">-</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_bits</span><span class="p">);</span>

	<span class="cm">/* If a bipolar range was specified, mangle it (twos</span>
<span class="cm">	 * complement-&gt;straight binary). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_bipolar</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">pci230_ao_mangle_datum</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						    <span class="kt">short</span> <span class="n">datum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If a bipolar range was specified, mangle it (straight binary-&gt;twos</span>
<span class="cm">	 * complement). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_bipolar</span><span class="p">)</span>
		<span class="n">datum</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>


	<span class="cm">/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower</span>
<span class="cm">	 * four bits reserved for expansion). */</span>
	<span class="cm">/* PCI230+ is also 12 bit AO. */</span>
	<span class="n">datum</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">-</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_bits</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">datum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci230_ao_write_nofifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">short</span> <span class="n">datum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Store unmangled datum to be read back later. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">datum</span><span class="p">;</span>

	<span class="cm">/* Write mangled datum to appropriate DACOUT register. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">pci230_ao_mangle_datum</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">datum</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="p">(((</span><span class="n">chan</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
								<span class="o">?</span> <span class="n">PCI230_DACOUT1</span>
								<span class="o">:</span>
								<span class="n">PCI230_DACOUT2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci230_ao_write_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">datum</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Store unmangled datum to be read back later. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">datum</span><span class="p">;</span>

	<span class="cm">/* Write mangled datum to appropriate DACDATA register. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">pci230_ao_mangle_datum</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">datum</span><span class="p">),</span>
	     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230P2_DACDATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attach is called by the Comedi core to configure the driver</span>
<span class="cm"> * for a particular board.  If you specified a board_name array</span>
<span class="cm"> * in the driver structure, dev-&gt;board_ptr contains that</span>
<span class="cm"> * address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iobase1</span><span class="p">,</span> <span class="n">iobase2</span><span class="p">;</span>
	<span class="cm">/* PCI230&#39;s I/O spaces 1 and 2 respectively. */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq_hdl</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: attach %s %d,%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span>
	       <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="cm">/* Allocate the private structure area using alloc_private().</span>
<span class="cm">	 * Macro defined in comedidev.h - memsets struct fields to 0. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">alloc_private</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci230_private</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_spinlock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_stop_spinlock</span><span class="p">);</span>
	<span class="cm">/* Find card */</span>
	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* Match against bus/slot options. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">||</span>
			    <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">!=</span> <span class="n">PCI_VENDOR_ID_AMPLICON</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The name was specified as &quot;amplc_pci230&quot; which is</span>
<span class="cm">			 * used to match any supported device.  Replace the</span>
<span class="cm">			 * current dev-&gt;board_ptr with one that matches the</span>
<span class="cm">			 * PCI device ID. */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_pci230_boards</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">pci230_boards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pci230_boards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min_hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Check for a &#39;+&#39; model.</span>
<span class="cm">						 * First check length of</span>
<span class="cm">						 * registers. */</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
						    <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
							<span class="cm">/* Not a &#39;+&#39; model. */</span>
							<span class="k">continue</span><span class="p">;</span>
						<span class="p">}</span>
						<span class="cm">/* TODO: temporarily enable the</span>
<span class="cm">						 * PCI device and read the</span>
<span class="cm">						 * hardware version register.</span>
<span class="cm">						 * For now assume it&#39;s okay. */</span>
					<span class="p">}</span>
					<span class="cm">/* Change board_ptr to matched board */</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_boards</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_pci230_boards</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* The name was specified as a specific device name.</span>
<span class="cm">			 * The current dev-&gt;board_ptr is correct.  Check</span>
<span class="cm">			 * whether it matches the PCI device ID. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Check minimum hardware version. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">min_hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Looking for a &#39;+&#39; model.  First</span>
<span class="cm">					 * check length of registers. */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Not a &#39;+&#39; model. */</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/* TODO: temporarily enable the PCI</span>
<span class="cm">					 * device and read the hardware version</span>
<span class="cm">					 * register.  For now, assume it&#39;s</span>
<span class="cm">					 * okay. */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: No %s card found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span>
		       <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize dev-&gt;board_name.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* Enable PCI device and reserve I/O spaces. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">comedi_pci_enable</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;amplc_pci230&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: failed to enable PCI device &quot;</span>
		       <span class="s">&quot;and request regions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read base addresses of the PCI230&#39;s two I/O regions from PCI</span>
<span class="cm">	 * configuration register. */</span>
	<span class="n">iobase1</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">iobase2</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: %s I/O region 1 0x%04lx I/O region 2 0x%04lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span><span class="p">,</span> <span class="n">iobase1</span><span class="p">,</span> <span class="n">iobase2</span><span class="p">);</span>

	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">=</span> <span class="n">iobase1</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">iobase2</span><span class="p">;</span>

	<span class="cm">/* Read bits of DACCON register - only the output range. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCI230_DAC_OR_MASK</span><span class="p">;</span>

	<span class="cm">/* Read hardware version register and set extended function register</span>
<span class="cm">	 * if they exist. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">extfunc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230P_HWVER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">min_hwver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: %s - bad hardware version &quot;</span>
			       <span class="s">&quot;- got %u, need %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span><span class="p">,</span>
			       <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">min_hwver</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">have_dio</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* No DIO ports.  Route counters&#39; external gates</span>
<span class="cm">				 * to the EXTTRIG signal (PCI260+ pin 17).</span>
<span class="cm">				 * (Otherwise, they would be routed to DIO</span>
<span class="cm">				 * inputs PC0, PC1 and PC2 which don&#39;t exist</span>
<span class="cm">				 * on PCI260[+].) */</span>
				<span class="n">extfunc</span> <span class="o">|=</span> <span class="n">PCI230P_EXTFUNC_GAT_EXTTRIG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Enable DAC FIFO functionality. */</span>
				<span class="n">extfunc</span> <span class="o">|=</span> <span class="n">PCI230P2_EXTFUNC_DACFIFO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">extfunc</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230P_EXTFUNC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">extfunc</span> <span class="o">&amp;</span> <span class="n">PCI230P2_EXTFUNC_DACFIFO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Temporarily enable DAC FIFO, reset it and disable</span>
<span class="cm">			 * FIFO wraparound. */</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span> <span class="o">|</span> <span class="n">PCI230P2_DAC_FIFO_EN</span>
			     <span class="o">|</span> <span class="n">PCI230P2_DAC_FIFO_RESET</span><span class="p">,</span>
			     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>
			<span class="cm">/* Clear DAC FIFO channel enable register. */</span>
			<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230P2_DACEN</span><span class="p">);</span>
			<span class="cm">/* Disable DAC FIFO. */</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Disable board&#39;s interrupts. */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>

	<span class="cm">/* Set ADC to a reasonable state. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_NONE</span> <span class="o">|</span> <span class="n">PCI230_ADC_IM_SE</span>
	    <span class="o">|</span> <span class="n">PCI230_ADC_IR_BIP</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCEN</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCG</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">|</span> <span class="n">PCI230_ADC_FIFO_RESET</span><span class="p">,</span>
	     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>

	<span class="cm">/* Register the interrupt handler. */</span>
	<span class="n">irq_hdl</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pci230_interrupt</span><span class="p">,</span>
			      <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;amplc_pci230&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_hdl</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: unable to register irq, &quot;</span>
		       <span class="s">&quot;commands will not be available %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span>
		       <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: registered irq %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span>
		       <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the subdevice structures.  alloc_subdevice() is a</span>
<span class="cm">	 * convenient macro defined in comedidev.h.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_subdevices</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* analog input subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AI</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_READABLE</span> <span class="o">|</span> <span class="n">SDF_DIFF</span> <span class="o">|</span> <span class="n">SDF_GROUND</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ai_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ai_range</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ai_rinsn</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">len_chanlist</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>	<span class="cm">/* but there are restrictions. */</span>
	<span class="cm">/* Only register commands if the interrupt handler is installed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_hdl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">read_subdev</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">|=</span> <span class="n">SDF_CMD_READ</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ai_cmd</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmdtest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ai_cmdtest</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cancel</span> <span class="o">=</span> <span class="n">pci230_ai_cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* analog output subdevice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AO</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span> <span class="o">|</span> <span class="n">SDF_GROUND</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ao_range</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ao_winsn</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_read</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ao_rinsn</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">len_chanlist</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span><span class="p">;</span>
		<span class="cm">/* Only register commands if the interrupt handler is</span>
<span class="cm">		 * installed. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_hdl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">write_subdev</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">|=</span> <span class="n">SDF_CMD_WRITE</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ao_cmd</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">do_cmdtest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_ao_cmdtest</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">cancel</span> <span class="o">=</span> <span class="n">pci230_ao_cancel</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_UNUSED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* digital i/o subdevice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">have_dio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">subdev_8255_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				      <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_PPI_X_BASE</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_UNUSED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi%d: attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">&amp;&amp;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">have_dio</span><span class="p">)</span>
		<span class="n">subdev_8255_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">)</span>
				<span class="n">comedi_pci_disable</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res_mask</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ok</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">claimed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">claimed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RESOURCES</span><span class="p">)</span>
	     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">res_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="n">b</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">res_mask</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">b</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_owner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">OWNER_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_owner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
				<span class="n">claimed</span> <span class="o">|=</span> <span class="n">b</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_owner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">claimed</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">claimed</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_owner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
						    <span class="o">=</span> <span class="n">OWNER_NONE</span><span class="p">;</span>
						<span class="n">claimed</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">b</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_one_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">resource</span><span class="p">),</span> <span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res_mask</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RESOURCES</span><span class="p">)</span>
	     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">res_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="n">b</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">res_mask</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">b</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_owner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_owner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OWNER_NONE</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">res_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_one_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">resource</span><span class="p">),</span> <span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_all_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">NUM_RESOURCES</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  COMEDI_SUBD_AI instruction;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">aref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gainshift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">adccon</span><span class="p">,</span> <span class="n">adcen</span><span class="p">;</span>

	<span class="cm">/* Unpack channel and range. */</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="n">aref</span> <span class="o">=</span> <span class="n">CR_AREF</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aref</span> <span class="o">==</span> <span class="n">AREF_DIFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Differential. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ai_rinsn: &quot;</span>
				<span class="s">&quot;differential channel number out of range &quot;</span>
				<span class="s">&quot;0 to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Use Z2-CT2 as a conversion trigger instead of the built-in</span>
<span class="cm">	 * software trigger, as otherwise triggering of differential channels</span>
<span class="cm">	 * doesn&#39;t work properly for some versions of PCI230/260.  Also set</span>
<span class="cm">	 * FIFO mode because the ADC busy bit only works for software triggers.</span>
<span class="cm">	 */</span>
	<span class="n">adccon</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_Z2CT2</span> <span class="o">|</span> <span class="n">PCI230_ADC_FIFO_EN</span><span class="p">;</span>
	<span class="cm">/* Set Z2-CT2 output low to avoid any false triggers. */</span>
	<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">I8254_MODE0</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_bipolar</span> <span class="o">=</span> <span class="n">pci230_ai_bipolar</span><span class="p">[</span><span class="n">range</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aref</span> <span class="o">==</span> <span class="n">AREF_DIFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Differential. */</span>
		<span class="n">gainshift</span> <span class="o">=</span> <span class="n">chan</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Original PCI230/260 expects both inputs of the</span>
<span class="cm">			 * differential channel to be enabled. */</span>
			<span class="n">adcen</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* PCI230+/260+ expects only one input of the</span>
<span class="cm">			 * differential channel to be enabled. */</span>
			<span class="n">adcen</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IM_DIF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Single ended. */</span>
		<span class="n">adcen</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chan</span><span class="p">;</span>
		<span class="n">gainshift</span> <span class="o">=</span> <span class="n">chan</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IM_SE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">))</span>
	    <span class="o">|</span> <span class="p">(</span><span class="n">pci230_ai_gain</span><span class="p">[</span><span class="n">range</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_bipolar</span><span class="p">)</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IR_BIP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IR_UNI</span><span class="p">;</span>


	<span class="cm">/* Enable only this channel in the scan list - otherwise by default</span>
<span class="cm">	 * we&#39;ll get one sample from each channel. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">adcen</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCEN</span><span class="p">);</span>

	<span class="cm">/* Set gain for channel. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCG</span><span class="p">);</span>

	<span class="cm">/* Specify uni/bip, se/diff, conversion source, and reset FIFO. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">=</span> <span class="n">adccon</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">adccon</span> <span class="o">|</span> <span class="n">PCI230_ADC_FIFO_RESET</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>

	<span class="cm">/* Convert n samples */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Trigger conversion by toggling Z2-CT2 output (finish with</span>
<span class="cm">		 * output high). */</span>
		<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			       <span class="n">I8254_MODE0</span><span class="p">);</span>
		<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			       <span class="n">I8254_MODE1</span><span class="p">);</span>

<span class="cp">#define TIMEOUT 100</span>
		<span class="cm">/* wait for conversion to end */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCI230_ADC_FIFO_EMPTY</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* printk() should be used instead of printk()</span>
<span class="cm">			 * whenever the code can be called from real-time. */</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* read data */</span>
		<span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pci230_ai_read</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  COMEDI_SUBD_AO instructions;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span><span class="p">,</span> <span class="n">range</span><span class="p">;</span>

	<span class="cm">/* Unpack channel and range. */</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="cm">/* Set range - see analogue output range table; 0 =&gt; unipolar 10V,</span>
<span class="cm">	 * 1 =&gt; bipolar +/-10V range scale */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_bipolar</span> <span class="o">=</span> <span class="n">pci230_ao_bipolar</span><span class="p">[</span><span class="n">range</span><span class="p">];</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>

	<span class="cm">/* Writing a list of values to an AO channel is probably not</span>
<span class="cm">	 * very useful, but that&#39;s how the interface is defined. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Write value to DAC and store it. */</span>
		<span class="n">pci230_ao_write_nofifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">chan</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* AO subdevices should have a read insn as well as a write insn.</span>
<span class="cm"> * Usually this means copying a value stored in devpriv. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ao_rinsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_readback</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ao_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* cmdtest tests a particular command to see if it is valid.</span>
<span class="cm">	 * Using the cmdtest ioctl, a user can create a valid cmd</span>
<span class="cm">	 * and then have it executes by the cmd ioctl.</span>
<span class="cm">	 *</span>
<span class="cm">	 * cmdtest returns 1,2,3,4 or 0, depending on which tests</span>
<span class="cm">	 * the command passes. */</span>

	<span class="cm">/* Step 1: make sure trigger sources are trivially valid.</span>
<span class="cm">	 * &quot;invalid source&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_INT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">min_hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For PCI230+ hardware version 2 onwards, allow external</span>
<span class="cm">		 * trigger from EXTTRIG/EXTCONVCLK input (PCI230+ pin 25).</span>
<span class="cm">		 *</span>
<span class="cm">		 * FIXME: The permitted scan_begin_src values shouldn&#39;t depend</span>
<span class="cm">		 * on devpriv-&gt;hwver (the detected card&#39;s actual hardware</span>
<span class="cm">		 * version).  They should only depend on thisboard-&gt;min_hwver</span>
<span class="cm">		 * (the static capabilities of the configured card).  To fix</span>
<span class="cm">		 * it, a new card model, e.g. &quot;pci230+2&quot; would have to be</span>
<span class="cm">		 * defined with min_hwver set to 2.  It doesn&#39;t seem worth it</span>
<span class="cm">		 * for this alone.  At the moment, please consider</span>
<span class="cm">		 * scan_begin_src==TRIG_EXT support to be a bonus rather than a</span>
<span class="cm">		 * guarantee!</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_INT</span> <span class="o">|</span> <span class="n">TRIG_EXT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_INT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_NOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span> <span class="o">|</span> <span class="n">TRIG_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Step 2: make sure trigger sources are unique and mutually compatible</span>
<span class="cm">	 * &quot;source conflict&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="cm">/* these tests are true if more than one _src bit is set */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Step 3: make sure arguments are trivially compatible.</span>
<span class="cm">	 * &quot;invalid argument&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#define MAX_SPEED_AO	8000	</span><span class="cm">/* 8000 ns =&gt; 125 kHz */</span><span class="cp"></span>
<span class="cp">#define MIN_SPEED_AO	4294967295u	</span><span class="cm">/* 4294967295ns = 4.29s */</span><span class="cp"></span>
			<span class="cm">/*- Comedi limit due to unsigned int cmd.  Driver limit</span>
<span class="cm">			 * = 2^16 (16bit * counter) * 1000000ns (1kHz onboard</span>
<span class="cm">			 * clock) = 65.536s */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span> <span class="n">MAX_SPEED_AO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">MAX_SPEED_AO</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&gt;</span> <span class="n">MIN_SPEED_AO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">MIN_SPEED_AO</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_EXT</span>:
		<span class="cm">/* External trigger - for PCI230+ hardware version 2 onwards. */</span>
		<span class="cm">/* Trigger number must be 0. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CR_FLAGS_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">COMBINE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						      <span class="o">~</span><span class="n">CR_FLAGS_MASK</span><span class="p">);</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* The only flags allowed are CR_EDGE and CR_INVERT.  The</span>
<span class="cm">		 * CR_EDGE flag is ignored. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span>
		     <span class="o">&amp;</span> <span class="p">(</span><span class="n">CR_FLAGS_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">CR_EDGE</span> <span class="o">|</span> <span class="n">CR_INVERT</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span>
			    <span class="n">COMBINE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">CR_FLAGS_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">CR_EDGE</span> <span class="o">|</span> <span class="n">CR_INVERT</span><span class="p">));</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TRIG_NONE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* Step 4: fix up any arguments.</span>
<span class="cm">	 * &quot;argument conflict&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">;</span>
		<span class="n">pci230_ns_to_single_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
					  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Step 5: check channel list if it exists. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="p">{</span>
			<span class="n">seq_err</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">range_err</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">};</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">errors</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">,</span> <span class="n">prev_chan</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">,</span> <span class="n">first_range</span><span class="p">;</span>

		<span class="n">prev_chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">first_range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
			<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
			<span class="cm">/* Channel numbers must strictly increase. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&lt;</span> <span class="n">prev_chan</span><span class="p">)</span>
				<span class="n">errors</span> <span class="o">|=</span> <span class="n">seq_err</span><span class="p">;</span>

			<span class="cm">/* Ranges must be the same. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">range</span> <span class="o">!=</span> <span class="n">first_range</span><span class="p">)</span>
				<span class="n">errors</span> <span class="o">|=</span> <span class="n">range_err</span><span class="p">;</span>

			<span class="n">prev_chan</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">seq_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ao_cmdtest: &quot;</span>
					<span class="s">&quot;channel numbers must increase</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">range_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ao_cmdtest: &quot;</span>
					<span class="s">&quot;channels must have the same range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ao_inttrig_scan_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trig_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trig_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AO_CMD_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Perform scan. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Not using DAC FIFO. */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_stop_spinlock</span><span class="p">,</span>
					       <span class="n">irqflags</span><span class="p">);</span>
			<span class="n">pci230_handle_ao_nofifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Using DAC FIFO. */</span>
			<span class="cm">/* Read DACSWTRIG register to trigger conversion. */</span>
			<span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230P2_DACSWTRIG</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_stop_spinlock</span><span class="p">,</span>
					       <span class="n">irqflags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Delay.  Should driver be responsible for this? */</span>
		<span class="cm">/* XXX TODO: See if DAC busy bit can be used. */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_ao_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_async</span> <span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">AO_CMD_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_continuous</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* An empty acquisition! */</span>
		<span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>
		<span class="n">pci230_ao_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Using DAC FIFO. */</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">scantrig</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">run</span><span class="p">;</span>

			<span class="cm">/* Preload FIFO data. */</span>
			<span class="n">run</span> <span class="o">=</span> <span class="n">pci230_handle_ao_fifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">run</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Stopped. */</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Set scan trigger source. */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
				<span class="n">scantrig</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_TRIG_Z2CT1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TRIG_EXT</span>:
				<span class="cm">/* Trigger on EXTTRIG/EXTCONVCLK pin. */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&amp;</span> <span class="n">CR_INVERT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* +ve edge */</span>
					<span class="n">scantrig</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_TRIG_EXTP</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* -ve edge */</span>
					<span class="n">scantrig</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_TRIG_EXTN</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TRIG_INT</span>:
				<span class="n">scantrig</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_TRIG_SW</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="cm">/* Shouldn&#39;t get here. */</span>
				<span class="n">scantrig</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_TRIG_NONE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span>
					   <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI230P2_DAC_TRIG_MASK</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">scantrig</span><span class="p">;</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Not using DAC FIFO. */</span>
				<span class="cm">/* Enable CT1 timer interrupt. */</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span>
						  <span class="n">irqflags</span><span class="p">);</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span> <span class="o">|=</span> <span class="n">PCI230_INT_ZCLK_CT1</span><span class="p">;</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">|=</span> <span class="n">PCI230_INT_ZCLK_CT1</span><span class="p">;</span>
				<span class="n">outb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span>
				     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span>
						       <span class="n">irqflags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Set CT1 gate high to start counting. */</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GAT_VCC</span><span class="p">),</span>
			     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRIG_INT</span>:
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="n">pci230_ao_inttrig_scan_begin</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Using DAC FIFO.  Enable DAC FIFO interrupt. */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span> <span class="o">|=</span> <span class="n">PCI230P2_INT_DAC</span><span class="p">;</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">|=</span> <span class="n">PCI230P2_INT_DAC</span><span class="p">;</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span>
					       <span class="n">irqflags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ao_inttrig_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trig_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trig_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="n">NULLFUNC</span><span class="p">;</span>
	<span class="n">pci230_ao_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ao_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">daccon</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">;</span>

	<span class="cm">/* Get the command. */</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Claim Z2-CT1. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_one_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RES_Z2CT1</span><span class="p">,</span> <span class="n">OWNER_AOCMD</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/* Get number of scans required. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_continuous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* TRIG_NONE, user calls cancel. */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_continuous</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set range - see analogue output range table; 0 =&gt; unipolar 10V,</span>
<span class="cm">	 * 1 =&gt; bipolar +/-10V range scale */</span>
	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_bipolar</span> <span class="o">=</span> <span class="n">pci230_ao_bipolar</span><span class="p">[</span><span class="n">range</span><span class="p">];</span>
	<span class="n">daccon</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_bipolar</span> <span class="o">?</span> <span class="n">PCI230_DAC_OR_BIP</span> <span class="o">:</span> <span class="n">PCI230_DAC_OR_UNI</span><span class="p">;</span>
	<span class="cm">/* Use DAC FIFO for hardware version 2 onwards. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dacen</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">dacen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">dacen</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/* Set channel scan list. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">dacen</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230P2_DACEN</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Enable DAC FIFO.</span>
<span class="cm">		 * Set DAC scan source to &#39;none&#39;.</span>
<span class="cm">		 * Set DAC FIFO interrupt trigger level to &#39;not half full&#39;.</span>
<span class="cm">		 * Reset DAC FIFO and clear underrun.</span>
<span class="cm">		 *</span>
<span class="cm">		 * N.B. DAC FIFO interrupts are currently disabled.</span>
<span class="cm">		 */</span>
		<span class="n">daccon</span> <span class="o">|=</span> <span class="n">PCI230P2_DAC_FIFO_EN</span> <span class="o">|</span> <span class="n">PCI230P2_DAC_FIFO_RESET</span>
		    <span class="o">|</span> <span class="n">PCI230P2_DAC_FIFO_UNDERRUN_CLEAR</span>
		    <span class="o">|</span> <span class="n">PCI230P2_DAC_TRIG_NONE</span> <span class="o">|</span> <span class="n">PCI230P2_DAC_INT_FIFO_NHALF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set DACCON. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">daccon</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>
	<span class="cm">/* Preserve most of DACCON apart from write-only, transient bits. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span> <span class="o">=</span> <span class="n">daccon</span>
	    <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PCI230P2_DAC_FIFO_RESET</span> <span class="o">|</span> <span class="n">PCI230P2_DAC_FIFO_UNDERRUN_CLEAR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the counter timer 1 to the specified scan frequency. */</span>
		<span class="cm">/* cmd-&gt;scan_begin_arg is sampling period in ns */</span>
		<span class="cm">/* gate it off for now. */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GAT_GND</span><span class="p">),</span>
		     <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
		<span class="n">pci230_ct_setup_ns_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">I8254_MODE3</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* N.B. cmd-&gt;start_src == TRIG_INT */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="n">pci230_ao_inttrig_start</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_check_scan_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_scan_period</span><span class="p">,</span> <span class="n">chanlist_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">chanlist_len</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">chanlist_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">min_scan_period</span> <span class="o">=</span> <span class="n">chanlist_len</span> <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">min_scan_period</span> <span class="o">&lt;</span> <span class="n">chanlist_len</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">min_scan_period</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Arithmetic overflow. */</span>
		<span class="n">min_scan_period</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&lt;</span> <span class="n">min_scan_period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">min_scan_period</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_cmdtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* cmdtest tests a particular command to see if it is valid.</span>
<span class="cm">	 * Using the cmdtest ioctl, a user can create a valid cmd</span>
<span class="cm">	 * and then have it executes by the cmd ioctl.</span>
<span class="cm">	 *</span>
<span class="cm">	 * cmdtest returns 1,2,3,4,5 or 0, depending on which tests</span>
<span class="cm">	 * the command passes. */</span>

	<span class="cm">/* Step 1: make sure trigger sources are trivially valid.</span>
<span class="cm">	 * &quot;invalid source&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_NOW</span> <span class="o">|</span> <span class="n">TRIG_INT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">;</span>
	<span class="cm">/* Unfortunately, we cannot trigger a scan off an external source</span>
<span class="cm">	 * on the PCI260 board, since it uses the PPIC0 (DIO) input, which</span>
<span class="cm">	 * isn&#39;t present on the PCI260.  For PCI260+ we can use the</span>
<span class="cm">	 * EXTTRIG/EXTCONVCLK input on pin 17 instead. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">have_dio</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">min_hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_FOLLOW</span> <span class="o">|</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_INT</span>
		    <span class="o">|</span> <span class="n">TRIG_EXT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_FOLLOW</span> <span class="o">|</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_INT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_TIMER</span> <span class="o">|</span> <span class="n">TRIG_INT</span> <span class="o">|</span> <span class="n">TRIG_EXT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">&amp;=</span> <span class="n">TRIG_COUNT</span> <span class="o">|</span> <span class="n">TRIG_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Step 2: make sure trigger sources are unique and mutually compatible</span>
<span class="cm">	 * &quot;source conflict&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="cm">/* these tests are true if more than one _src bit is set */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If scan_begin_src is not TRIG_FOLLOW, then a monostable will be</span>
<span class="cm">	 * set up to generate a fixed number of timed conversion pulses. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_TIMER</span><span class="p">))</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Step 3: make sure arguments are trivially compatible.</span>
<span class="cm">	 * &quot;invalid argument&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#define MAX_SPEED_AI_SE		3200	</span><span class="cm">/* PCI230 SE:   3200 ns =&gt; 312.5 kHz */</span><span class="cp"></span>
<span class="cp">#define MAX_SPEED_AI_DIFF	8000	</span><span class="cm">/* PCI230 DIFF: 8000 ns =&gt; 125 kHz */</span><span class="cp"></span>
<span class="cp">#define MAX_SPEED_AI_PLUS	4000	</span><span class="cm">/* PCI230+:     4000 ns =&gt; 250 kHz */</span><span class="cp"></span>
<span class="cp">#define MIN_SPEED_AI	4294967295u	</span><span class="cm">/* 4294967295ns = 4.29s */</span><span class="cp"></span>
			<span class="cm">/*- Comedi limit due to unsigned int cmd.  Driver limit</span>
<span class="cm">			 * = 2^16 (16bit * counter) * 1000000ns (1kHz onboard</span>
<span class="cm">			 * clock) = 65.536s */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_speed_ai</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* PCI230 or PCI260.  Max speed depends whether</span>
<span class="cm">			 * single-ended or pseudo-differential. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Peek analogue reference of first channel. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">CR_AREF</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">AREF_DIFF</span><span class="p">)</span>
					<span class="n">max_speed_ai</span> <span class="o">=</span> <span class="n">MAX_SPEED_AI_DIFF</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">max_speed_ai</span> <span class="o">=</span> <span class="n">MAX_SPEED_AI_SE</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* No channel list.  Assume single-ended. */</span>
				<span class="n">max_speed_ai</span> <span class="o">=</span> <span class="n">MAX_SPEED_AI_SE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* PCI230+ or PCI260+. */</span>
			<span class="n">max_speed_ai</span> <span class="o">=</span> <span class="n">MAX_SPEED_AI_PLUS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&lt;</span> <span class="n">max_speed_ai</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">max_speed_ai</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="n">MIN_SPEED_AI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">MIN_SPEED_AI</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * external trigger</span>
<span class="cm">		 *</span>
<span class="cm">		 * convert_arg == (CR_EDGE | 0)</span>
<span class="cm">		 *                =&gt; trigger on +ve edge.</span>
<span class="cm">		 * convert_arg == (CR_EDGE | CR_INVERT | 0)</span>
<span class="cm">		 *                =&gt; trigger on -ve edge.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&amp;</span> <span class="n">CR_FLAGS_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Trigger number must be 0. */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CR_FLAGS_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="n">COMBINE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							   <span class="o">~</span><span class="n">CR_FLAGS_MASK</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* The only flags allowed are CR_INVERT and CR_EDGE.</span>
<span class="cm">			 * CR_EDGE is required. */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CR_FLAGS_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CR_INVERT</span><span class="p">))</span>
			    <span class="o">!=</span> <span class="n">CR_EDGE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Set CR_EDGE, preserve CR_INVERT. */</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span>
				    <span class="n">COMBINE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_arg</span><span class="p">,</span> <span class="p">(</span><span class="n">CR_EDGE</span> <span class="o">|</span> <span class="mi">0</span><span class="p">),</span>
					    <span class="n">CR_FLAGS_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CR_INVERT</span><span class="p">);</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Backwards compatibility with previous versions. */</span>
			<span class="cm">/* convert_arg == 0 =&gt; trigger on -ve edge. */</span>
			<span class="cm">/* convert_arg == 1 =&gt; trigger on +ve edge. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Default to trigger on +ve edge. */</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
		<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_EXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* external &quot;trigger&quot; to begin each scan</span>
<span class="cm">		 * scan_begin_arg==0 =&gt; use PPC0 input -&gt; gate of CT0 -&gt; gate</span>
<span class="cm">		 * of CT2 (sample convert trigger is CT2) */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CR_FLAGS_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">COMBINE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						      <span class="o">~</span><span class="n">CR_FLAGS_MASK</span><span class="p">);</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* The only flag allowed is CR_EDGE, which is ignored. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">&amp;</span> <span class="n">CR_FLAGS_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CR_EDGE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="n">COMBINE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						      <span class="n">CR_FLAGS_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CR_EDGE</span><span class="p">);</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. cmd-&gt;convert_arg is also TRIG_TIMER */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci230_ai_check_scan_period</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* Step 4: fix up any arguments.</span>
<span class="cm">	 * &quot;argument conflict&quot; returned by comedilib to user mode process</span>
<span class="cm">	 * if this fails. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">;</span>
		<span class="n">pci230_ns_to_single_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
					  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. cmd-&gt;convert_arg is also TRIG_TIMER */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">;</span>
		<span class="n">pci230_ns_to_single_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
					  <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci230_ai_check_scan_period</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Was below minimum required.  Round up. */</span>
			<span class="n">pci230_ns_to_single_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
						  <span class="n">TRIG_ROUND_UP</span><span class="p">);</span>
			<span class="n">pci230_ai_check_scan_period</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">)</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Step 5: check channel list if it exists. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="p">{</span>
			<span class="n">seq_err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">rangepair_err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">polarity_err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
			<span class="n">aref_err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
			<span class="n">diffchan_err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
			<span class="n">buggy_chan0_err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
		<span class="p">};</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">errors</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="p">,</span> <span class="n">prev_chan</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">,</span> <span class="n">prev_range</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">polarity</span><span class="p">,</span> <span class="n">prev_polarity</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">aref</span><span class="p">,</span> <span class="n">prev_aref</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subseq_len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">subseq_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">prev_chan</span> <span class="o">=</span> <span class="n">prev_aref</span> <span class="o">=</span> <span class="n">prev_range</span> <span class="o">=</span> <span class="n">prev_polarity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
			<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
			<span class="n">aref</span> <span class="o">=</span> <span class="n">CR_AREF</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
			<span class="n">polarity</span> <span class="o">=</span> <span class="n">pci230_ai_bipolar</span><span class="p">[</span><span class="n">range</span><span class="p">];</span>
			<span class="cm">/* Only the first half of the channels are available if</span>
<span class="cm">			 * differential.  (These are remapped in software.  In</span>
<span class="cm">			 * hardware, only the even channels are available.) */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">aref</span> <span class="o">==</span> <span class="n">AREF_DIFF</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">errors</span> <span class="o">|=</span> <span class="n">diffchan_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Channel numbers must strictly increase or</span>
<span class="cm">				 * subsequence must repeat exactly. */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">chan</span> <span class="o">&lt;=</span> <span class="n">prev_chan</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">subseq_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">subseq_len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">subseq_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">n</span> <span class="o">%</span> <span class="n">subseq_len</span><span class="p">]))</span> <span class="p">{</span>
					<span class="n">errors</span> <span class="o">|=</span> <span class="n">seq_err</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* Channels must have same AREF. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">aref</span> <span class="o">!=</span> <span class="n">prev_aref</span><span class="p">)</span>
					<span class="n">errors</span> <span class="o">|=</span> <span class="n">aref_err</span><span class="p">;</span>

				<span class="cm">/* Channel ranges must have same polarity. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">polarity</span> <span class="o">!=</span> <span class="n">prev_polarity</span><span class="p">)</span>
					<span class="n">errors</span> <span class="o">|=</span> <span class="n">polarity_err</span><span class="p">;</span>

				<span class="cm">/* Single-ended channel pairs must have same</span>
<span class="cm">				 * range.  */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">aref</span> <span class="o">!=</span> <span class="n">AREF_DIFF</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(((</span><span class="n">chan</span> <span class="o">^</span> <span class="n">prev_chan</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">range</span> <span class="o">!=</span> <span class="n">prev_range</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">errors</span> <span class="o">|=</span> <span class="n">rangepair_err</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">prev_chan</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
			<span class="n">prev_range</span> <span class="o">=</span> <span class="n">range</span><span class="p">;</span>
			<span class="n">prev_aref</span> <span class="o">=</span> <span class="n">aref</span><span class="p">;</span>
			<span class="n">prev_polarity</span> <span class="o">=</span> <span class="n">polarity</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subseq_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Subsequence is whole sequence. */</span>
			<span class="n">subseq_len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If channel list is a repeating subsequence, need a whole</span>
<span class="cm">		 * number of repeats. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">%</span> <span class="n">subseq_len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">errors</span> <span class="o">|=</span> <span class="n">seq_err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Buggy PCI230+ or PCI260+ requires channel 0 to be</span>
<span class="cm">			 * (first) in the sequence if the sequence contains</span>
<span class="cm">			 * more than one channel.  Hardware versions 1 and 2</span>
<span class="cm">			 * have the bug.  There is no hardware version 3.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Actually, there are two firmwares that report</span>
<span class="cm">			 * themselves as hardware version 1 (the boards</span>
<span class="cm">			 * have different ADC chips with slightly different</span>
<span class="cm">			 * timing requirements, which was supposed to be</span>
<span class="cm">			 * invisible to software).  The first one doesn&#39;t</span>
<span class="cm">			 * seem to have the bug, but the second one</span>
<span class="cm">			 * does, and we can&#39;t tell them apart!</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">subseq_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">errors</span> <span class="o">|=</span> <span class="n">buggy_chan0_err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">seq_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ai_cmdtest: &quot;</span>
					<span class="s">&quot;channel numbers must increase or &quot;</span>
					<span class="s">&quot;sequence must repeat exactly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">rangepair_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ai_cmdtest: &quot;</span>
					<span class="s">&quot;single-ended channel pairs must &quot;</span>
					<span class="s">&quot;have the same range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">polarity_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ai_cmdtest: &quot;</span>
					<span class="s">&quot;channel sequence ranges must be all &quot;</span>
					<span class="s">&quot;bipolar or all unipolar</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">aref_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ai_cmdtest: &quot;</span>
					<span class="s">&quot;channel sequence analogue references &quot;</span>
					<span class="s">&quot;must be all the same (single-ended &quot;</span>
					<span class="s">&quot;or differential)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">diffchan_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;comedi%d: amplc_pci230: ai_cmdtest: &quot;</span>
					<span class="s">&quot;differential channel number out of &quot;</span>
					<span class="s">&quot;range 0 to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span>
					<span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">buggy_chan0_err</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Use printk instead of DPRINTK here. */</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;comedi: comedi%d: amplc_pci230: &quot;</span>
				       <span class="s">&quot;ai_cmdtest: Buggy PCI230+/260+ &quot;</span>
				       <span class="s">&quot;h/w version %u requires first channel &quot;</span>
				       <span class="s">&quot;of multi-channel sequence to be 0 &quot;</span>
				       <span class="s">&quot;(corrected in h/w version 4)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_ai_update_fifo_trigger_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scanlen</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wake</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">triglev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">adccon</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_WAKE_EOS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wake at end of scan. */</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="n">scanlen</span> <span class="o">-</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_pos</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continuous</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">&gt;=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">scanlen</span> <span class="o">&gt;=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wake</span> <span class="o">=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wake</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">*</span> <span class="n">scanlen</span><span class="p">)</span>
			    <span class="o">-</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_pos</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span> <span class="o">&gt;=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">triglev</span> <span class="o">=</span> <span class="n">PCI230_ADC_INT_FIFO_HALF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wake</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* PCI230+/260+ programmable FIFO interrupt level. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcfifothresh</span> <span class="o">!=</span> <span class="n">wake</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcfifothresh</span> <span class="o">=</span> <span class="n">wake</span><span class="p">;</span>
				<span class="n">outw</span><span class="p">(</span><span class="n">wake</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230P_ADCFFTH</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">triglev</span> <span class="o">=</span> <span class="n">PCI230P_ADC_INT_FIFO_THRESH</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">triglev</span> <span class="o">=</span> <span class="n">PCI230_ADC_INT_FIFO_NEMPTY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">adccon</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI230_ADC_INT_FIFO_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">triglev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adccon</span> <span class="o">!=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">=</span> <span class="n">adccon</span><span class="p">;</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">adccon</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_inttrig_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trig_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trig_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AI_CMD_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delayus</span><span class="p">;</span>

		<span class="cm">/* Trigger conversion by toggling Z2-CT2 output.  Finish</span>
<span class="cm">		 * with output high. */</span>
		<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			       <span class="n">I8254_MODE0</span><span class="p">);</span>
		<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			       <span class="n">I8254_MODE1</span><span class="p">);</span>
		<span class="cm">/* Delay.  Should driver be responsible for this?  An</span>
<span class="cm">		 * alternative would be to wait until conversion is complete,</span>
<span class="cm">		 * but we can&#39;t tell when it&#39;s complete because the ADC busy</span>
<span class="cm">		 * bit has a different meaning when FIFO enabled (and when</span>
<span class="cm">		 * FIFO not enabled, it only works for software triggers). */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">&amp;</span> <span class="n">PCI230_ADC_IM_MASK</span><span class="p">)</span>
		     <span class="o">==</span> <span class="n">PCI230_ADC_IM_DIF</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* PCI230/260 in differential mode */</span>
			<span class="n">delayus</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* single-ended or PCI230+/260+ */</span>
			<span class="n">delayus</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">delayus</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_inttrig_scan_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trig_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">zgat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trig_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AI_CMD_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Trigger scan by waggling CT0 gate source. */</span>
		<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GAT_GND</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
		<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GAT_VCC</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_ai_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">conv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_async</span> <span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">AI_CMD_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continuous</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* An empty acquisition! */</span>
		<span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>
		<span class="n">pci230_ai_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Enable ADC FIFO trigger level interrupt. */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span> <span class="o">|=</span> <span class="n">PCI230_INT_ADC</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">|=</span> <span class="n">PCI230_INT_ADC</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

		<span class="cm">/* Update conversion trigger source which is currently set</span>
<span class="cm">		 * to CT2 output, which is currently stuck high. */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="n">conv</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_NONE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
			<span class="cm">/* Using CT2 output. */</span>
			<span class="n">conv</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_Z2CT2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRIG_EXT</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&amp;</span> <span class="n">CR_EDGE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">&amp;</span> <span class="n">CR_INVERT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Trigger on +ve edge. */</span>
					<span class="n">conv</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_EXTP</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Trigger on -ve edge. */</span>
					<span class="n">conv</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_EXTN</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Backwards compatibility. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Trigger on +ve edge. */</span>
					<span class="n">conv</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_EXTP</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Trigger on -ve edge. */</span>
					<span class="n">conv</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_EXTN</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TRIG_INT</span>:
			<span class="cm">/* Use CT2 output for software trigger due to problems</span>
<span class="cm">			 * in differential mode on PCI230/260. */</span>
			<span class="n">conv</span> <span class="o">=</span> <span class="n">PCI230_ADC_TRIG_Z2CT2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI230_ADC_TRIG_MASK</span><span class="p">)</span>
		    <span class="o">|</span> <span class="n">conv</span><span class="p">;</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_INT</span><span class="p">)</span>
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="n">pci230_ai_inttrig_convert</span><span class="p">;</span>

		<span class="cm">/* Update FIFO interrupt trigger level, which is currently</span>
<span class="cm">		 * set to &quot;full&quot;.  */</span>
		<span class="n">pci230_ai_update_fifo_trigger_level</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Update timer gates. */</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">zgat</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Conversion timer CT2 needs to be gated by</span>
<span class="cm">				 * inverted output of monostable CT2. */</span>
				<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">GAT_NOUTNM2</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Conversion timer CT2 needs to be gated on</span>
<span class="cm">				 * continuously. */</span>
				<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">GAT_VCC</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Set monostable CT0 trigger source. */</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
				<span class="nl">default:</span>
					<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GAT_VCC</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">TRIG_EXT</span>:
					<span class="cm">/*</span>
<span class="cm">					 * For CT0 on PCI230, the external</span>
<span class="cm">					 * trigger (gate) signal comes from</span>
<span class="cm">					 * PPC0, which is channel 16 of the DIO</span>
<span class="cm">					 * subdevice.  The application needs to</span>
<span class="cm">					 * configure this as an input in order</span>
<span class="cm">					 * to use it as an external scan</span>
<span class="cm">					 * trigger.</span>
<span class="cm">					 */</span>
					<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GAT_EXT</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
					<span class="cm">/*</span>
<span class="cm">					 * Monostable CT0 triggered by rising</span>
<span class="cm">					 * edge on inverted output of CT1</span>
<span class="cm">					 * (falling edge on CT1).</span>
<span class="cm">					 */</span>
					<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GAT_NOUTNM2</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">TRIG_INT</span>:
					<span class="cm">/*</span>
<span class="cm">					 * Monostable CT0 is triggered by</span>
<span class="cm">					 * inttrig function waggling the CT0</span>
<span class="cm">					 * gate source.</span>
<span class="cm">					 */</span>
					<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GAT_VCC</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">TRIG_TIMER</span>:
					<span class="cm">/* Scan period timer CT1 needs to be</span>
<span class="cm">					 * gated on to start counting. */</span>
					<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GAT_VCC</span><span class="p">);</span>
					<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span>
					     <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">TRIG_INT</span>:
					<span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span>
					    <span class="n">pci230_ai_inttrig_scan_begin</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">!=</span> <span class="n">TRIG_INT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No longer need Z2-CT2. */</span>
			<span class="n">put_one_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RES_Z2CT2</span><span class="p">,</span> <span class="n">OWNER_AICMD</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_inttrig_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trig_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trig_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="n">NULLFUNC</span><span class="p">;</span>
	<span class="n">pci230_ai_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">diff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">adccon</span><span class="p">,</span> <span class="n">adcen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">zgat</span><span class="p">;</span>

	<span class="cm">/* Get the command. */</span>
	<span class="k">struct</span> <span class="n">comedi_async</span> <span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine which shared resources are needed.</span>
<span class="cm">	 */</span>
	<span class="n">res_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Need Z2-CT2 to supply a conversion trigger source at a high</span>
<span class="cm">	 * logic level, even if not doing timed conversions. */</span>
	<span class="n">res_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">RES_Z2CT2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Using Z2-CT0 monostable to gate Z2-CT2 conversion timer */</span>
		<span class="n">res_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">RES_Z2CT0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Using Z2-CT1 for scan frequency */</span>
			<span class="n">res_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">RES_Z2CT1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Claim resources. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">res_mask</span><span class="p">,</span> <span class="n">OWNER_AICMD</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>


	<span class="cm">/* Get number of scans required. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_src</span> <span class="o">==</span> <span class="n">TRIG_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stop_arg</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continuous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* TRIG_NONE, user calls cancel. */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continuous</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Position within scan. */</span>

	<span class="cm">/* Steps;</span>
<span class="cm">	 * - Set channel scan list.</span>
<span class="cm">	 * - Set channel gains.</span>
<span class="cm">	 * - Enable and reset FIFO, specify uni/bip, se/diff, and set</span>
<span class="cm">	 *   start conversion source to point to something at a high logic</span>
<span class="cm">	 *   level (we use the output of counter/timer 2 for this purpose.</span>
<span class="cm">	 * - PAUSE to allow things to settle down.</span>
<span class="cm">	 * - Reset the FIFO again because it needs resetting twice and there</span>
<span class="cm">	 *   may have been a false conversion trigger on some versions of</span>
<span class="cm">	 *   PCI230/260 due to the start conversion source being set to a</span>
<span class="cm">	 *   high logic level.</span>
<span class="cm">	 * - Enable ADC FIFO level interrupt.</span>
<span class="cm">	 * - Set actual conversion trigger source and FIFO interrupt trigger</span>
<span class="cm">	 *   level.</span>
<span class="cm">	 * - If convert_src is TRIG_TIMER, set up the timers.</span>
<span class="cm">	 */</span>

	<span class="n">adccon</span> <span class="o">=</span> <span class="n">PCI230_ADC_FIFO_EN</span><span class="p">;</span>
	<span class="n">adcen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CR_AREF</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">AREF_DIFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Differential - all channels must be differential. */</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IM_DIF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Single ended - all channels must be single-ended. */</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IM_SE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_bipolar</span> <span class="o">=</span> <span class="n">pci230_ai_bipolar</span><span class="p">[</span><span class="n">range</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_bipolar</span><span class="p">)</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IR_BIP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_IR_UNI</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gainshift</span><span class="p">;</span>

		<span class="n">chan</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gainshift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">chan</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Original PCI230/260 expects both inputs of</span>
<span class="cm">				 * the differential channel to be enabled. */</span>
				<span class="n">adcen</span> <span class="o">|=</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* PCI230+/260+ expects only one input of the</span>
<span class="cm">				 * differential channel to be enabled. */</span>
				<span class="n">adcen</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">gainshift</span> <span class="o">=</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">adcen</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chan</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">))</span>
		    <span class="o">|</span> <span class="p">(</span><span class="n">pci230_ai_gain</span><span class="p">[</span><span class="n">range</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">gainshift</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set channel scan list. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">adcen</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCEN</span><span class="p">);</span>

	<span class="cm">/* Set channel gains. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adcg</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCG</span><span class="p">);</span>

	<span class="cm">/* Set counter/timer 2 output high for use as the initial start</span>
<span class="cm">	 * conversion source. */</span>
	<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">I8254_MODE1</span><span class="p">);</span>

	<span class="cm">/* Temporarily use CT2 output as conversion trigger source and</span>
<span class="cm">	 * temporarily set FIFO interrupt trigger level to &#39;full&#39;. */</span>
	<span class="n">adccon</span> <span class="o">|=</span> <span class="n">PCI230_ADC_INT_FIFO_FULL</span> <span class="o">|</span> <span class="n">PCI230_ADC_TRIG_Z2CT2</span><span class="p">;</span>

	<span class="cm">/* Enable and reset FIFO, specify FIFO trigger level full, specify</span>
<span class="cm">	 * uni/bip, se/diff, and temporarily set the start conversion source</span>
<span class="cm">	 * to CT2 output.  Note that CT2 output is currently high, and this</span>
<span class="cm">	 * will produce a false conversion trigger on some versions of the</span>
<span class="cm">	 * PCI230/260, but that will be dealt with later. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">=</span> <span class="n">adccon</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">adccon</span> <span class="o">|</span> <span class="n">PCI230_ADC_FIFO_RESET</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>

	<span class="cm">/* Delay */</span>
	<span class="cm">/* Failure to include this will result in the first few channels&#39;-worth</span>
<span class="cm">	 * of data being corrupt, normally manifesting itself by large negative</span>
<span class="cm">	 * voltages. It seems the board needs time to settle between the first</span>
<span class="cm">	 * FIFO reset (above) and the second FIFO reset (below). Setting the</span>
<span class="cm">	 * channel gains and scan list _before_ the first FIFO reset also</span>
<span class="cm">	 * helps, though only slightly. */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

	<span class="cm">/* Reset FIFO again. */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">adccon</span> <span class="o">|</span> <span class="n">PCI230_ADC_FIFO_RESET</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up CT2 as conversion timer, but gate it off for now.</span>
<span class="cm">		 * Note, counter/timer output 2 can be monitored on the</span>
<span class="cm">		 * connector: PCI230 pin 21, PCI260 pin 18. */</span>
		<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">GAT_GND</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
		<span class="cm">/* Set counter/timer 2 to the specified conversion period. */</span>
		<span class="n">pci230_ct_setup_ns_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">I8254_MODE3</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set up monostable on CT0 output for scan timing.  A</span>
<span class="cm">			 * rising edge on the trigger (gate) input of CT0 will</span>
<span class="cm">			 * trigger the monostable, causing its output to go low</span>
<span class="cm">			 * for the configured period.  The period depends on</span>
<span class="cm">			 * the conversion period and the number of conversions</span>
<span class="cm">			 * in the scan.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Set the trigger high before setting up the</span>
<span class="cm">			 * monostable to stop it triggering.  The trigger</span>
<span class="cm">			 * source will be changed later.</span>
<span class="cm">			 */</span>
			<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GAT_VCC</span><span class="p">);</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
			<span class="n">pci230_ct_setup_ns_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">I8254_MODE1</span><span class="p">,</span>
						<span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_arg</span>
						 <span class="o">*</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_end_arg</span><span class="p">),</span>
						<span class="n">TRIG_ROUND_UP</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Monostable on CT0 will be triggered by</span>
<span class="cm">				 * output of CT1 at configured scan frequency.</span>
<span class="cm">				 *</span>
<span class="cm">				 * Set up CT1 but gate it off for now.</span>
<span class="cm">				 */</span>
				<span class="n">zgat</span> <span class="o">=</span> <span class="n">GAT_CONFIG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GAT_GND</span><span class="p">);</span>
				<span class="n">outb</span><span class="p">(</span><span class="n">zgat</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZGAT_SCE</span><span class="p">);</span>
				<span class="n">pci230_ct_setup_ns_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">I8254_MODE3</span><span class="p">,</span>
							<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_arg</span><span class="p">,</span>
							<span class="n">cmd</span><span class="o">-&gt;</span>
							<span class="n">flags</span> <span class="o">&amp;</span>
							<span class="n">TRIG_ROUND_MASK</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">start_src</span> <span class="o">==</span> <span class="n">TRIG_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">inttrig</span> <span class="o">=</span> <span class="n">pci230_ai_inttrig_start</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* TRIG_NOW */</span>
		<span class="n">pci230_ai_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">divide_ns</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timebase</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">round_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">div</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rem</span><span class="p">;</span>

	<span class="n">div</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">div</span><span class="p">,</span> <span class="n">timebase</span><span class="p">);</span>
	<span class="n">round_mode</span> <span class="o">&amp;=</span> <span class="n">TRIG_ROUND_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">round_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_NEAREST</span>:
		<span class="n">div</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rem</span> <span class="o">+</span> <span class="p">(</span><span class="n">timebase</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">timebase</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_DOWN</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRIG_ROUND_UP</span>:
		<span class="n">div</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rem</span> <span class="o">+</span> <span class="n">timebase</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">timebase</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">div</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span> <span class="o">?</span> <span class="n">UINT_MAX</span> <span class="o">:</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">div</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Given desired period in ns, returns the required internal clock source</span>
<span class="cm"> * and gets the initial count. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">pci230_choose_clk_count</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">round_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clk_src</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">clk_src</span> <span class="o">=</span> <span class="n">CLK_10MHZ</span><span class="p">;;</span> <span class="n">clk_src</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">divide_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">pci230_timebase</span><span class="p">[</span><span class="n">clk_src</span><span class="p">],</span> <span class="n">round_mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">65536</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">clk_src</span> <span class="o">==</span> <span class="n">CLK_1KHZ</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">clk_src</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_ns_to_single_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">round</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clk_src</span><span class="p">;</span>

	<span class="n">clk_src</span> <span class="o">=</span> <span class="n">pci230_choose_clk_count</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">round</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">pci230_timebase</span><span class="p">[</span><span class="n">clk_src</span><span class="p">];</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_ct_setup_ns_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ct</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">ns</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">round</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clk_src</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* Set mode. */</span>
	<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="cm">/* Determine clock source and count. */</span>
	<span class="n">clk_src</span> <span class="o">=</span> <span class="n">pci230_choose_clk_count</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">round</span><span class="p">);</span>
	<span class="cm">/* Program clock source. */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CLK_CONFIG</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">clk_src</span><span class="p">),</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_ZCLK_SCE</span><span class="p">);</span>
	<span class="cm">/* Set initial count. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">65536</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i8254_write</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_cancel_ct</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i8254_set_mode</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_Z2_CT_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span>
		       <span class="n">I8254_MODE1</span><span class="p">);</span>
	<span class="cm">/* Counter ct, 8254 mode 1, initial count not written. */</span>
<span class="p">}</span>

<span class="cm">/* Interrupt handler */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pci230_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status_int</span><span class="p">,</span> <span class="n">valid_status_int</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="cm">/* Read interrupt status/enable register. */</span>
	<span class="n">status_int</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_STAT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status_int</span> <span class="o">==</span> <span class="n">PCI230_INT_DISABLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>


	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="n">valid_status_int</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span> <span class="o">&amp;</span> <span class="n">status_int</span><span class="p">;</span>
	<span class="cm">/* Disable triggered interrupts.</span>
<span class="cm">	 * (Only those interrupts that need re-enabling, are, later in the</span>
<span class="cm">	 * handler).  */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">status_int</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intr_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intr_cpuid</span> <span class="o">=</span> <span class="n">THISCPU</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the source of interrupt and handle it.</span>
<span class="cm">	 * The PCI230 can cope with concurrent ADC, DAC, PPI C0 and C3</span>
<span class="cm">	 * interrupts.  However, at present (Comedi-0.7.60) does not allow</span>
<span class="cm">	 * concurrent execution of commands, instructions or a mixture of the</span>
<span class="cm">	 * two.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">valid_status_int</span> <span class="o">&amp;</span> <span class="n">PCI230_INT_ZCLK_CT1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">write_subdev</span><span class="p">;</span>
		<span class="n">pci230_handle_ao_nofifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">valid_status_int</span> <span class="o">&amp;</span> <span class="n">PCI230P2_INT_DAC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">write_subdev</span><span class="p">;</span>
		<span class="n">pci230_handle_ao_fifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">valid_status_int</span> <span class="o">&amp;</span> <span class="n">PCI230_INT_ADC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">read_subdev</span><span class="p">;</span>
		<span class="n">pci230_handle_ai</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">comedi_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reenable interrupts. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">!=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intr_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_handle_ao_nofifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_async</span> <span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_continuous</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>


	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read sample from Comedi&#39;s circular buffer. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">comedi_buf_get</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_OVERFLOW</span><span class="p">;</span>
			<span class="n">pci230_ao_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;AO buffer underrun&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Write value to DAC. */</span>
		<span class="n">pci230_ao_write_nofifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_BLOCK</span> <span class="o">|</span> <span class="n">COMEDI_CB_EOS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_continuous</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* End of acquisition. */</span>
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>
			<span class="n">pci230_ao_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Loads DAC FIFO (if using it) from buffer. */</span>
<span class="cm">/* Returns 0 if AO finished due to completion or error, 1 if still going. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_handle_ao_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_async</span> <span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_scans</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">room</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dacstat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_per_scan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">running</span><span class="p">;</span>

	<span class="cm">/* Get DAC FIFO status. */</span>
	<span class="n">dacstat</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>

	<span class="cm">/* Determine number of scans available in buffer. */</span>
	<span class="n">bytes_per_scan</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="n">num_scans</span> <span class="o">=</span> <span class="n">comedi_buf_read_n_available</span><span class="p">(</span><span class="n">async</span><span class="p">)</span> <span class="o">/</span> <span class="n">bytes_per_scan</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_continuous</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fixed number of scans. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_scans</span> <span class="o">&gt;</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span><span class="p">)</span>
			<span class="n">num_scans</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* End of acquisition. */</span>
			<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for FIFO underrun. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dacstat</span> <span class="o">&amp;</span> <span class="n">PCI230P2_DAC_FIFO_UNDERRUN_LATCHED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;AO FIFO underrun&quot;</span><span class="p">);</span>
			<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_OVERFLOW</span> <span class="o">|</span> <span class="n">COMEDI_CB_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check for buffer underrun if FIFO less than half full</span>
<span class="cm">		 * (otherwise there will be loads of &quot;DAC FIFO not half full&quot;</span>
<span class="cm">		 * interrupts). */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">num_scans</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">dacstat</span> <span class="o">&amp;</span> <span class="n">PCI230P2_DAC_FIFO_HALF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;AO buffer underrun&quot;</span><span class="p">);</span>
			<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_OVERFLOW</span> <span class="o">|</span> <span class="n">COMEDI_CB_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Determine how much room is in the FIFO (in samples). */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dacstat</span> <span class="o">&amp;</span> <span class="n">PCI230P2_DAC_FIFO_FULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">room</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_FIFOROOM_FULL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">dacstat</span> <span class="o">&amp;</span> <span class="n">PCI230P2_DAC_FIFO_HALF</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">room</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_FIFOROOM_HALFTOFULL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">dacstat</span> <span class="o">&amp;</span> <span class="n">PCI230P2_DAC_FIFO_EMPTY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">room</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_FIFOROOM_EMPTY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">room</span> <span class="o">=</span> <span class="n">PCI230P2_DAC_FIFOROOM_ONETOHALF</span><span class="p">;</span>

		<span class="cm">/* Convert room to number of scans that can be added. */</span>
		<span class="n">room</span> <span class="o">/=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span>
		<span class="cm">/* Determine number of scans to process. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_scans</span> <span class="o">&gt;</span> <span class="n">room</span><span class="p">)</span>
			<span class="n">num_scans</span> <span class="o">=</span> <span class="n">room</span><span class="p">;</span>

		<span class="cm">/* Process scans. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">num_scans</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">short</span> <span class="n">datum</span><span class="p">;</span>

				<span class="n">comedi_buf_get</span><span class="p">(</span><span class="n">async</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">datum</span><span class="p">);</span>
				<span class="n">pci230_ao_write_fifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span>
						     <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">chanlist</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOS</span> <span class="o">|</span> <span class="n">COMEDI_CB_BLOCK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_continuous</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">-=</span> <span class="n">num_scans</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* All data for the command has been written</span>
<span class="cm">				 * to FIFO.  Set FIFO interrupt trigger level</span>
<span class="cm">				 * to &#39;empty&#39;. */</span>
				<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span>
						   <span class="o">&amp;</span>
						   <span class="o">~</span><span class="n">PCI230P2_DAC_INT_FIFO_MASK</span><span class="p">)</span>
				    <span class="o">|</span> <span class="n">PCI230P2_DAC_INT_FIFO_EMPTY</span><span class="p">;</span>
				<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span><span class="p">,</span>
				     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Check if FIFO underrun occurred while writing to FIFO. */</span>
		<span class="n">dacstat</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dacstat</span> <span class="o">&amp;</span> <span class="n">PCI230P2_DAC_FIFO_UNDERRUN_LATCHED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;AO FIFO underrun&quot;</span><span class="p">);</span>
			<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_OVERFLOW</span> <span class="o">|</span> <span class="n">COMEDI_CB_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">COMEDI_CB_EOA</span> <span class="o">|</span> <span class="n">COMEDI_CB_ERROR</span> <span class="o">|</span> <span class="n">COMEDI_CB_OVERFLOW</span><span class="p">))</span>
	    <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stopping AO due to completion or error. */</span>
		<span class="n">pci230_ao_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">events</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">running</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_handle_ai</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status_fifo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">todo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fifoamount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_async</span> <span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scanlen</span> <span class="o">=</span> <span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">scan_end_arg</span><span class="p">;</span>

	<span class="cm">/* Determine number of samples to read. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continuous</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">todo</span> <span class="o">=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">todo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">&gt;</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">)</span>
		   <span class="o">||</span> <span class="p">(</span><span class="n">scanlen</span> <span class="o">&gt;</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">todo</span> <span class="o">=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">todo</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">*</span> <span class="n">scanlen</span><span class="p">)</span>
		    <span class="o">-</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_pos</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">todo</span> <span class="o">&gt;</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">)</span>
			<span class="n">todo</span> <span class="o">=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">todo</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>


	<span class="n">fifoamount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">todo</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fifoamount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Read FIFO state. */</span>
			<span class="n">status_fifo</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">status_fifo</span> <span class="o">&amp;</span> <span class="n">PCI230_ADC_FIFO_FULL_LATCHED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Report error otherwise FIFO overruns will go</span>
<span class="cm">				 * unnoticed by the caller. */</span>
				<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;AI FIFO overrun&quot;</span><span class="p">);</span>
				<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_OVERFLOW</span> <span class="o">|</span> <span class="n">COMEDI_CB_ERROR</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status_fifo</span> <span class="o">&amp;</span> <span class="n">PCI230_ADC_FIFO_EMPTY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* FIFO empty. */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status_fifo</span> <span class="o">&amp;</span> <span class="n">PCI230_ADC_FIFO_HALF</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* FIFO half full. */</span>
				<span class="n">fifoamount</span> <span class="o">=</span> <span class="n">PCI230_ADC_FIFOLEVEL_HALFFULL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* FIFO not empty. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Read PCI230+/260+ ADC FIFO level. */</span>
					<span class="n">fifoamount</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span>
							 <span class="o">+</span> <span class="n">PCI230P_ADCFFLEV</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">fifoamount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Shouldn&#39;t happen. */</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">fifoamount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Read sample and store in Comedi&#39;s circular buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">comedi_buf_put</span><span class="p">(</span><span class="n">async</span><span class="p">,</span> <span class="n">pci230_ai_read</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_ERROR</span> <span class="o">|</span> <span class="n">COMEDI_CB_OVERFLOW</span><span class="p">;</span>
			<span class="n">comedi_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;AI buffer overflow&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fifoamount</span><span class="o">--</span><span class="p">;</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_pos</span> <span class="o">==</span> <span class="n">scanlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* End of scan. */</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_continuous</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_scan_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* End of acquisition. */</span>
		<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_EOA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* More samples required, tell Comedi to block. */</span>
		<span class="n">events</span> <span class="o">|=</span> <span class="n">COMEDI_CB_BLOCK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">events</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">COMEDI_CB_EOA</span> <span class="o">|</span> <span class="n">COMEDI_CB_ERROR</span> <span class="o">|</span>
			      <span class="n">COMEDI_CB_OVERFLOW</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* disable hardware conversions */</span>
		<span class="n">pci230_ai_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* update FIFO interrupt trigger level */</span>
		<span class="n">pci230_ai_update_fifo_trigger_level</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_ao_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">intsrc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">started</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="n">started</span> <span class="o">=</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">AO_CMD_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">started</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>


	<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stop scan rate generator. */</span>
		<span class="n">pci230_cancel_ct</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Determine interrupt source. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not using DAC FIFO.  Using CT1 interrupt. */</span>
		<span class="n">intsrc</span> <span class="o">=</span> <span class="n">PCI230_INT_ZCLK_CT1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Using DAC FIFO interrupt. */</span>
		<span class="n">intsrc</span> <span class="o">=</span> <span class="n">PCI230P2_INT_DAC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Disable interrupt and wait for interrupt routine to finish running</span>
<span class="cm">	 * unless we are called from the interrupt routine. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">intsrc</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intr_running</span> <span class="o">&amp;&amp;</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intr_cpuid</span> <span class="o">!=</span> <span class="n">THISCPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">!=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">hwver</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Using DAC FIFO.  Reset FIFO, clear underrun error,</span>
<span class="cm">		 * disable FIFO. */</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span> <span class="o">&amp;=</span> <span class="n">PCI230_DAC_OR_MASK</span><span class="p">;</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">daccon</span> <span class="o">|</span> <span class="n">PCI230P2_DAC_FIFO_RESET</span>
		     <span class="o">|</span> <span class="n">PCI230P2_DAC_FIFO_UNDERRUN_CLEAR</span><span class="p">,</span>
		     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_DACCON</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Release resources. */</span>
	<span class="n">put_all_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">OWNER_AOCMD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ao_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci230_ao_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci230_ai_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">started</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="n">started</span> <span class="o">=</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">AI_CMD_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ai_stop_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">started</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>


	<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">convert_src</span> <span class="o">==</span> <span class="n">TRIG_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stop conversion rate generator. */</span>
		<span class="n">pci230_cancel_ct</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scan_begin_src</span> <span class="o">!=</span> <span class="n">TRIG_FOLLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stop scan period monostable. */</span>
		<span class="n">pci230_cancel_ct</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="cm">/* Disable ADC interrupt and wait for interrupt routine to finish</span>
<span class="cm">	 * running unless we are called from the interrupt routine. */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI230_INT_ADC</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intr_running</span> <span class="o">&amp;&amp;</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">intr_cpuid</span> <span class="o">!=</span> <span class="n">THISCPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">!=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">int_en</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">iobase1</span> <span class="o">+</span> <span class="n">PCI230_INT_SCE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">isr_spinlock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Reset FIFO, disable FIFO and set start conversion source to none.</span>
<span class="cm">	 * Keep se/diff and bip/uni settings */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">=</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI230_ADC_IR_MASK</span>
					      <span class="o">|</span> <span class="n">PCI230_ADC_IM_MASK</span><span class="p">))</span> <span class="o">|</span>
	    <span class="n">PCI230_ADC_TRIG_NONE</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">adccon</span> <span class="o">|</span> <span class="n">PCI230_ADC_FIFO_RESET</span><span class="p">,</span>
	     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">PCI230_ADCCON</span><span class="p">);</span>

	<span class="cm">/* Release resources. */</span>
	<span class="n">put_all_resources</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">OWNER_AICMD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci230_ai_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci230_ai_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">comedi_driver</span> <span class="n">amplc_pci230_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver_name</span>	<span class="o">=</span> <span class="s">&quot;amplc_pci230&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">pci230_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach</span>		<span class="o">=</span> <span class="n">pci230_detach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">board_name</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pci230_boards</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offset</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pci230_boards</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
	<span class="p">.</span><span class="n">num_names</span>	<span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pci230_boards</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">amplc_pci230_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">comedi_pci_auto_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amplc_pci230_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">amplc_pci230_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">comedi_pci_auto_unconfig</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">amplc_pci230_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMPLICON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PCI230</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMPLICON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PCI260</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">amplc_pci230_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">amplc_pci230_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;amplc_pci230&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">amplc_pci230_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">amplc_pci230_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">amplc_pci230_pci_remove</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">module_comedi_pci_driver</span><span class="p">(</span><span class="n">amplc_pci230_driver</span><span class="p">,</span> <span class="n">amplc_pci230_pci_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Comedi http://www.comedi.org&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Comedi low-level driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
