<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › cb_pcidda.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cb_pcidda.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    comedi/drivers/cb_pcidda.c</span>
<span class="cm">    This intends to be a driver for the ComputerBoards / MeasurementComputing</span>
<span class="cm">    PCI-DDA series.</span>

<span class="cm">	 Copyright (C) 2001 Ivan Martinez &lt;ivanmr@altavista.com&gt;</span>
<span class="cm">    Copyright (C) 2001 Frank Mori Hess &lt;fmhess@users.sourceforge.net&gt;</span>

<span class="cm">    COMEDI - Linux Control and Measurement Device Interface</span>
<span class="cm">    Copyright (C) 1997-8 David A. Schleef &lt;ds@schleef.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">Driver: cb_pcidda</span>
<span class="cm">Description: MeasurementComputing PCI-DDA series</span>
<span class="cm">Author: Ivan Martinez &lt;ivanmr@altavista.com&gt;, Frank Mori Hess &lt;fmhess@users.sourceforge.net&gt;</span>
<span class="cm">Status: Supports 08/16, 04/16, 02/16, 08/12, 04/12, and 02/12</span>
<span class="cm">Devices: [Measurement Computing] PCI-DDA08/12 (cb_pcidda), PCI-DDA04/12,</span>
<span class="cm">  PCI-DDA02/12, PCI-DDA08/16, PCI-DDA04/16, PCI-DDA02/16</span>

<span class="cm">Configuration options:</span>
<span class="cm">  [0] - PCI bus of device (optional)</span>
<span class="cm">  [1] - PCI slot of device (optional)</span>
<span class="cm">  If bus/slot is not specified, the first available PCI</span>
<span class="cm">  device will be used.</span>

<span class="cm">Only simple analog output writing is supported.</span>

<span class="cm">So far it has only been tested with:</span>
<span class="cm">  - PCI-DDA08/12</span>
<span class="cm">Please report success/failure with other different cards to</span>
<span class="cm">&lt;comedi@comedi.org&gt;.</span>
<span class="cm">*/</span>

<span class="cp">#include &quot;../comedidev.h&quot;</span>

<span class="cp">#include &quot;comedi_pci.h&quot;</span>
<span class="cp">#include &quot;8255.h&quot;</span>


<span class="cm">/* PCI vendor number of ComputerBoards */</span>
<span class="cp">#define PCI_VENDOR_ID_CB        0x1307</span>
<span class="cp">#define EEPROM_SIZE	128	</span><span class="cm">/*  number of entries in eeprom */</span><span class="cp"></span>
<span class="cm">/* maximum number of ao channels for supported boards */</span>
<span class="cp">#define MAX_AO_CHANNELS 8</span>

<span class="cm">/* PCI-DDA base addresses */</span>
<span class="cp">#define DIGITALIO_BADRINDEX	2</span>
	<span class="cm">/*  DIGITAL I/O is pci_dev-&gt;resource[2] */</span>
<span class="cp">#define DIGITALIO_SIZE 8</span>
	<span class="cm">/*  DIGITAL I/O uses 8 I/O port addresses */</span>
<span class="cp">#define DAC_BADRINDEX	3</span>
	<span class="cm">/*  DAC is pci_dev-&gt;resource[3] */</span>

<span class="cm">/* Digital I/O registers */</span>
<span class="cp">#define PORT1A 0		</span><span class="cm">/*  PORT 1A DATA */</span><span class="cp"></span>

<span class="cp">#define PORT1B 1		</span><span class="cm">/*  PORT 1B DATA */</span><span class="cp"></span>

<span class="cp">#define PORT1C 2		</span><span class="cm">/*  PORT 1C DATA */</span><span class="cp"></span>

<span class="cp">#define CONTROL1 3		</span><span class="cm">/*  CONTROL REGISTER 1 */</span><span class="cp"></span>

<span class="cp">#define PORT2A 4		</span><span class="cm">/*  PORT 2A DATA */</span><span class="cp"></span>

<span class="cp">#define PORT2B 5		</span><span class="cm">/*  PORT 2B DATA */</span><span class="cp"></span>

<span class="cp">#define PORT2C 6		</span><span class="cm">/*  PORT 2C DATA */</span><span class="cp"></span>

<span class="cp">#define CONTROL2 7		</span><span class="cm">/*  CONTROL REGISTER 2 */</span><span class="cp"></span>

<span class="cm">/* DAC registers */</span>
<span class="cp">#define DACONTROL	0	</span><span class="cm">/*  D/A CONTROL REGISTER */</span><span class="cp"></span>
<span class="cp">#define	SU	0000001		</span><span class="cm">/*  Simultaneous update enabled */</span><span class="cp"></span>
<span class="cp">#define NOSU	0000000		</span><span class="cm">/*  Simultaneous update disabled */</span><span class="cp"></span>
<span class="cp">#define	ENABLEDAC	0000002	</span><span class="cm">/*  Enable specified DAC */</span><span class="cp"></span>
<span class="cp">#define	DISABLEDAC	0000000	</span><span class="cm">/*  Disable specified DAC */</span><span class="cp"></span>
<span class="cp">#define RANGE2V5	0000000	</span><span class="cm">/*  2.5V */</span><span class="cp"></span>
<span class="cp">#define RANGE5V	0000200		</span><span class="cm">/*  5V */</span><span class="cp"></span>
<span class="cp">#define RANGE10V	0000300	</span><span class="cm">/*  10V */</span><span class="cp"></span>
<span class="cp">#define UNIP	0000400		</span><span class="cm">/*  Unipolar outputs */</span><span class="cp"></span>
<span class="cp">#define BIP	0000000		</span><span class="cm">/*  Bipolar outputs */</span><span class="cp"></span>

<span class="cp">#define DACALIBRATION1	4	</span><span class="cm">/*  D/A CALIBRATION REGISTER 1 */</span><span class="cp"></span>
<span class="cm">/* write bits */</span>
<span class="cm">/* serial data input for eeprom, caldacs, reference dac */</span>
<span class="cp">#define SERIAL_IN_BIT   0x1</span>
<span class="cp">#define	CAL_CHANNEL_MASK	(0x7 &lt;&lt; 1)</span>
<span class="cp">#define	CAL_CHANNEL_BITS(channel)	(((channel) &lt;&lt; 1) &amp; CAL_CHANNEL_MASK)</span>
<span class="cm">/* read bits */</span>
<span class="cp">#define	CAL_COUNTER_MASK	0x1f</span>
<span class="cm">/* calibration counter overflow status bit */</span>
<span class="cp">#define CAL_COUNTER_OVERFLOW_BIT        0x20</span>
<span class="cm">/* analog output is less than reference dac voltage */</span>
<span class="cp">#define AO_BELOW_REF_BIT        0x40</span>
<span class="cp">#define	SERIAL_OUT_BIT	0x80	</span><span class="cm">/*  serial data out, for reading from eeprom */</span><span class="cp"></span>

<span class="cp">#define DACALIBRATION2	6	</span><span class="cm">/*  D/A CALIBRATION REGISTER 2 */</span><span class="cp"></span>
<span class="cp">#define	SELECT_EEPROM_BIT	0x1	</span><span class="cm">/*  send serial data in to eeprom */</span><span class="cp"></span>
<span class="cm">/* don&#39;t send serial data to MAX542 reference dac */</span>
<span class="cp">#define DESELECT_REF_DAC_BIT    0x2</span>
<span class="cm">/* don&#39;t send serial data to caldac n */</span>
<span class="cp">#define DESELECT_CALDAC_BIT(n)  (0x4 &lt;&lt; (n))</span>
<span class="cm">/* manual says to set this bit with no explanation */</span>
<span class="cp">#define DUMMY_BIT       0x40</span>

<span class="cp">#define DADATA	8		</span><span class="cm">/*  FIRST D/A DATA REGISTER (0) */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="n">cb_pcidda_ranges</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">6</span><span class="p">,</span>
	<span class="p">{</span>
	 <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	 <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	 <span class="n">BIP_RANGE</span><span class="p">(</span><span class="mf">2.5</span><span class="p">),</span>
	 <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	 <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	 <span class="n">UNI_RANGE</span><span class="p">(</span><span class="mf">2.5</span><span class="p">),</span>
	 <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Board descriptions for two imaginary boards.  Describing the</span>
<span class="cm"> * boards in this way is optional, and completely driver-dependent.</span>
<span class="cm"> * Some drivers use arrays such as this, other do not.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cb_pcidda_board</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/*  Driver status: */</span>

	<span class="cm">/*</span>
<span class="cm">	 * 0 - tested</span>
<span class="cm">	 * 1 - manual read, not tested</span>
<span class="cm">	 * 2 - manual not read</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_chans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ao_bits</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">comedi_lrange</span> <span class="o">*</span><span class="n">ranges</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cb_pcidda_board</span> <span class="n">cb_pcidda_boards</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci-dda02/12&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_pcidda_ranges</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci-dda04/12&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x21</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_pcidda_ranges</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci-dda08/12&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x22</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_pcidda_ranges</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci-dda02/16&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x23</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_pcidda_ranges</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci-dda04/16&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_pcidda_ranges</span><span class="p">,</span>
	 <span class="p">},</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pci-dda08/16&quot;</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mh">0x25</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_chans</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ao_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_pcidda_ranges</span><span class="p">,</span>
	 <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Useful for shorthand access to the particular board structure</span>
<span class="cm"> */</span>
<span class="cp">#define thisboard ((const struct cb_pcidda_board *)dev-&gt;board_ptr)</span>

<span class="cm">/*</span>
<span class="cm"> * this structure is for data unique to this hardware driver.  If</span>
<span class="cm"> * several hardware drivers keep similar information in this structure,</span>
<span class="cm"> * feel free to suggest moving the variable to the struct comedi_device</span>
<span class="cm"> * struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cb_pcidda_private</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* would be useful for a PCI device */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">digitalio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dac</span><span class="p">;</span>

	<span class="cm">/* unsigned long control_status; */</span>
	<span class="cm">/* unsigned long adc_fifo; */</span>

	<span class="cm">/* bits last written to da calibration register 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dac_cal1_bits</span><span class="p">;</span>
	<span class="cm">/* current range settings for output channels */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_range</span><span class="p">[</span><span class="n">MAX_AO_CHANNELS</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span><span class="p">[</span><span class="n">EEPROM_SIZE</span><span class="p">];</span>	<span class="cm">/*  software copy of board&#39;s eeprom */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * most drivers define the following macro to make it easy to</span>
<span class="cm"> * access the private structure.</span>
<span class="cm"> */</span>
<span class="cp">#define devpriv ((struct cb_pcidda_private *)dev-&gt;private)</span>

<span class="cm">/* static int cb_pcidda_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cb_pcidda_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* static int cb_pcidda_ai_cmd(struct comedi_device *dev, struct *comedi_subdevice *s);*/</span>
<span class="cm">/* static int cb_pcidda_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd); */</span>
<span class="cm">/* static int cb_pcidda_ns_to_timer(unsigned int *ns,int *round); */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cb_pcidda_serial_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cb_pcidda_serial_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_bits</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cb_pcidda_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cb_pcidda_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attach is called by the Comedi core to configure the driver</span>
<span class="cm"> * for a particular board.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cb_pcidda_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pcidev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Allocate the private structure area.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_private</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cb_pcidda_private</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Probe the device to determine what device in the series it is.</span>
<span class="cm"> */</span>

	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">pcidev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_CB</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">!=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span>
				    <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cb_pcidda_boards</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cb_pcidda_boards</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">device_id</span> <span class="o">==</span>
				    <span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcidev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_dev</span><span class="p">,</span> <span class="s">&quot;Not a ComputerBoards/MeasurementComputing card on requested position</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">found:</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pcidev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_ptr</span> <span class="o">=</span> <span class="n">cb_pcidda_boards</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
	<span class="cm">/*  &quot;thisboard&quot; macro can be used from here. */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_dev</span><span class="p">,</span> <span class="s">&quot;Found %s at requested position</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable PCI device and request regions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">comedi_pci_enable</span><span class="p">(</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_dev</span><span class="p">,</span> <span class="s">&quot;cb_pcidda: failed to enable PCI device and request regions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the I/O ports.</span>
<span class="cm"> */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">digitalio</span> <span class="o">=</span>
	    <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">DIGITALIO_BADRINDEX</span><span class="p">);</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">DAC_BADRINDEX</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Warn about the status of the driver.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printk</span>
		    <span class="p">(</span><span class="s">&quot;WARNING: DRIVER FOR THIS BOARD NOT CHECKED WITH MANUAL. &quot;</span>
		     <span class="s">&quot;WORKS ASSUMING FULL COMPATIBILITY WITH PCI-DDA08/12. &quot;</span>
		     <span class="s">&quot;PLEASE REPORT USAGE TO &lt;ivanmr@altavista.com&gt;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize dev-&gt;board_name.</span>
<span class="cm"> */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">board_name</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the subdevice structures.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_subdevices</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* analog output subdevice */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMEDI_SUBD_AO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">subdev_flags</span> <span class="o">=</span> <span class="n">SDF_WRITABLE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">n_chan</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">range_table</span> <span class="o">=</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">insn_write</span> <span class="o">=</span> <span class="n">cb_pcidda_ao_winsn</span><span class="p">;</span>

	<span class="cm">/* s-&gt;subdev_flags |= SDF_CMD_READ; */</span>
	<span class="cm">/* s-&gt;do_cmd = cb_pcidda_ai_cmd; */</span>
	<span class="cm">/* s-&gt;do_cmdtest = cb_pcidda_ai_cmdtest; */</span>

	<span class="cm">/*  two 8255 digital io subdevices */</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">subdev_8255_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">digitalio</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">subdev_8255_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">digitalio</span> <span class="o">+</span> <span class="n">PORT2A</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_dev</span><span class="p">,</span> <span class="s">&quot;eeprom:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">EEPROM_SIZE</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cb_pcidda_read_eeprom</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_dev</span><span class="p">,</span> <span class="s">&quot;%i:0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*  set calibrations dacs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">thisboard</span><span class="o">-&gt;</span><span class="n">ao_chans</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cb_pcidda_calibrate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_range</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cb_pcidda_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span><span class="p">)</span>
				<span class="n">comedi_pci_disable</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">subdev_8255_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">subdev_8255_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subdevices</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * I will program this later... ;-)</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int cb_pcidda_ai_cmd(struct comedi_device *dev,</span>
<span class="c">			    struct comedi_subdevice *s)</span>
<span class="c">{</span>
<span class="c">	printk(&quot;cb_pcidda_ai_cmd\n&quot;);</span>
<span class="c">	printk(&quot;subdev: %d\n&quot;, cmd-&gt;subdev);</span>
<span class="c">	printk(&quot;flags: %d\n&quot;, cmd-&gt;flags);</span>
<span class="c">	printk(&quot;start_src: %d\n&quot;, cmd-&gt;start_src);</span>
<span class="c">	printk(&quot;start_arg: %d\n&quot;, cmd-&gt;start_arg);</span>
<span class="c">	printk(&quot;scan_begin_src: %d\n&quot;, cmd-&gt;scan_begin_src);</span>
<span class="c">	printk(&quot;convert_src: %d\n&quot;, cmd-&gt;convert_src);</span>
<span class="c">	printk(&quot;convert_arg: %d\n&quot;, cmd-&gt;convert_arg);</span>
<span class="c">	printk(&quot;scan_end_src: %d\n&quot;, cmd-&gt;scan_end_src);</span>
<span class="c">	printk(&quot;scan_end_arg: %d\n&quot;, cmd-&gt;scan_end_arg);</span>
<span class="c">	printk(&quot;stop_src: %d\n&quot;, cmd-&gt;stop_src);</span>
<span class="c">	printk(&quot;stop_arg: %d\n&quot;, cmd-&gt;stop_arg);</span>
<span class="c">	printk(&quot;chanlist_len: %d\n&quot;, cmd-&gt;chanlist_len);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int cb_pcidda_ai_cmdtest(struct comedi_device *dev,</span>
<span class="c">				struct comedi_subdevice *s,</span>
<span class="c">				struct comedi_cmd *cmd)</span>
<span class="c">{</span>
<span class="c">	int err = 0;</span>
<span class="c">	int tmp;</span>

<span class="c">	/* cmdtest tests a particular command to see if it is valid.</span>
<span class="c">	 * Using the cmdtest ioctl, a user can create a valid cmd</span>
<span class="c">	 * and then have it executes by the cmd ioctl.</span>
<span class="c">	 *</span>
<span class="c">	 * cmdtest returns 1,2,3,4 or 0, depending on which tests</span>
<span class="c">	 * the command passes. */</span>

<span class="c">	/* step 1: make sure trigger sources are trivially valid */</span>

<span class="c">	tmp = cmd-&gt;start_src;</span>
<span class="c">	cmd-&gt;start_src &amp;= TRIG_NOW;</span>
<span class="c">	if (!cmd-&gt;start_src || tmp != cmd-&gt;start_src)</span>
<span class="c">		err++;</span>

<span class="c">	tmp = cmd-&gt;scan_begin_src;</span>
<span class="c">	cmd-&gt;scan_begin_src &amp;= TRIG_TIMER | TRIG_EXT;</span>
<span class="c">	if (!cmd-&gt;scan_begin_src || tmp != cmd-&gt;scan_begin_src)</span>
<span class="c">		err++;</span>

<span class="c">	tmp = cmd-&gt;convert_src;</span>
<span class="c">	cmd-&gt;convert_src &amp;= TRIG_TIMER | TRIG_EXT;</span>
<span class="c">	if (!cmd-&gt;convert_src || tmp != cmd-&gt;convert_src)</span>
<span class="c">		err++;</span>

<span class="c">	tmp = cmd-&gt;scan_end_src;</span>
<span class="c">	cmd-&gt;scan_end_src &amp;= TRIG_COUNT;</span>
<span class="c">	if (!cmd-&gt;scan_end_src || tmp != cmd-&gt;scan_end_src)</span>
<span class="c">		err++;</span>

<span class="c">	tmp = cmd-&gt;stop_src;</span>
<span class="c">	cmd-&gt;stop_src &amp;= TRIG_COUNT | TRIG_NONE;</span>
<span class="c">	if (!cmd-&gt;stop_src || tmp != cmd-&gt;stop_src)</span>
<span class="c">		err++;</span>

<span class="c">	if (err)</span>
<span class="c">		return 1;</span>

<span class="c">	/*</span>
<span class="c">	 * step 2: make sure trigger sources are unique and mutually</span>
<span class="c">	 * compatible</span>
<span class="c">	 */</span>

<span class="c">	/* note that mutual compatibility is not an issue here */</span>
<span class="c">	if (cmd-&gt;scan_begin_src != TRIG_TIMER</span>
<span class="c">	    &amp;&amp; cmd-&gt;scan_begin_src != TRIG_EXT)</span>
<span class="c">		err++;</span>
<span class="c">	if (cmd-&gt;convert_src != TRIG_TIMER &amp;&amp; cmd-&gt;convert_src != TRIG_EXT)</span>
<span class="c">		err++;</span>
<span class="c">	if (cmd-&gt;stop_src != TRIG_TIMER &amp;&amp; cmd-&gt;stop_src != TRIG_EXT)</span>
<span class="c">		err++;</span>

<span class="c">	if (err)</span>
<span class="c">		return 2;</span>

<span class="c">	/* step 3: make sure arguments are trivially compatible */</span>

<span class="c">	if (cmd-&gt;start_arg != 0) {</span>
<span class="c">		cmd-&gt;start_arg = 0;</span>
<span class="c">		err++;</span>
<span class="c">	}</span>
<span class="c">#define MAX_SPEED	10000	/* in nanoseconds */</span>
<span class="c">#define MIN_SPEED	1000000000	/* in nanoseconds */</span>

<span class="c">	if (cmd-&gt;scan_begin_src == TRIG_TIMER) {</span>
<span class="c">		if (cmd-&gt;scan_begin_arg &lt; MAX_SPEED) {</span>
<span class="c">			cmd-&gt;scan_begin_arg = MAX_SPEED;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">		if (cmd-&gt;scan_begin_arg &gt; MIN_SPEED) {</span>
<span class="c">			cmd-&gt;scan_begin_arg = MIN_SPEED;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">	} else {</span>
<span class="c">		/* external trigger */</span>
<span class="c">		/* should be level/edge, hi/lo specification here */</span>
<span class="c">		/* should specify multiple external triggers */</span>
<span class="c">		if (cmd-&gt;scan_begin_arg &gt; 9) {</span>
<span class="c">			cmd-&gt;scan_begin_arg = 9;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="c">	if (cmd-&gt;convert_src == TRIG_TIMER) {</span>
<span class="c">		if (cmd-&gt;convert_arg &lt; MAX_SPEED) {</span>
<span class="c">			cmd-&gt;convert_arg = MAX_SPEED;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">		if (cmd-&gt;convert_arg &gt; MIN_SPEED) {</span>
<span class="c">			cmd-&gt;convert_arg = MIN_SPEED;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">	} else {</span>
<span class="c">		/* external trigger */</span>
<span class="c">		/* see above */</span>
<span class="c">		if (cmd-&gt;convert_arg &gt; 9) {</span>
<span class="c">			cmd-&gt;convert_arg = 9;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">	}</span>

<span class="c">	if (cmd-&gt;scan_end_arg != cmd-&gt;chanlist_len) {</span>
<span class="c">		cmd-&gt;scan_end_arg = cmd-&gt;chanlist_len;</span>
<span class="c">		err++;</span>
<span class="c">	}</span>
<span class="c">	if (cmd-&gt;stop_src == TRIG_COUNT) {</span>
<span class="c">		if (cmd-&gt;stop_arg &gt; 0x00ffffff) {</span>
<span class="c">			cmd-&gt;stop_arg = 0x00ffffff;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">	} else {</span>
<span class="c">		/* TRIG_NONE */</span>
<span class="c">		if (cmd-&gt;stop_arg != 0) {</span>
<span class="c">			cmd-&gt;stop_arg = 0;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">	}</span>

<span class="c">	if (err)</span>
<span class="c">		return 3;</span>

<span class="c">	/* step 4: fix up any arguments */</span>

<span class="c">	if (cmd-&gt;scan_begin_src == TRIG_TIMER) {</span>
<span class="c">		tmp = cmd-&gt;scan_begin_arg;</span>
<span class="c">		cb_pcidda_ns_to_timer(&amp;cmd-&gt;scan_begin_arg,</span>
<span class="c">				      cmd-&gt;flags &amp; TRIG_ROUND_MASK);</span>
<span class="c">		if (tmp != cmd-&gt;scan_begin_arg)</span>
<span class="c">			err++;</span>
<span class="c">	}</span>
<span class="c">	if (cmd-&gt;convert_src == TRIG_TIMER) {</span>
<span class="c">		tmp = cmd-&gt;convert_arg;</span>
<span class="c">		cb_pcidda_ns_to_timer(&amp;cmd-&gt;convert_arg,</span>
<span class="c">				      cmd-&gt;flags &amp; TRIG_ROUND_MASK);</span>
<span class="c">		if (tmp != cmd-&gt;convert_arg)</span>
<span class="c">			err++;</span>
<span class="c">		if (cmd-&gt;scan_begin_src == TRIG_TIMER &amp;&amp;</span>
<span class="c">		    cmd-&gt;scan_begin_arg &lt;</span>
<span class="c">		    cmd-&gt;convert_arg * cmd-&gt;scan_end_arg) {</span>
<span class="c">			cmd-&gt;scan_begin_arg =</span>
<span class="c">			    cmd-&gt;convert_arg * cmd-&gt;scan_end_arg;</span>
<span class="c">			err++;</span>
<span class="c">		}</span>
<span class="c">	}</span>

<span class="c">	if (err)</span>
<span class="c">		return 4;</span>

<span class="c">	return 0;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/* This function doesn&#39;t require a particular form, this is just</span>
<span class="cm"> * what happens to be used in some of the drivers.  It should</span>
<span class="cm"> * convert ns nanoseconds to a counter value suitable for programming</span>
<span class="cm"> * the device.  Also, it should adjust ns so that it cooresponds to</span>
<span class="cm"> * the actual time that the device will use. */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int cb_pcidda_ns_to_timer(unsigned int *ns, int round)</span>
<span class="c">{</span>
<span class="c">	/* trivial timer */</span>
<span class="c">	return *ns;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cb_pcidda_ao_winsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_subdevice</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">comedi_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="n">range</span><span class="p">;</span>

	<span class="n">channel</span> <span class="o">=</span> <span class="n">CR_CHAN</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>
	<span class="n">range</span> <span class="o">=</span> <span class="n">CR_RANGE</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">chanspec</span><span class="p">);</span>

	<span class="cm">/*  adjust calibration dacs if range has changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span> <span class="o">!=</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_range</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>
		<span class="n">cb_pcidda_calibrate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>

	<span class="cm">/* output channel configuration */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="n">NOSU</span> <span class="o">|</span> <span class="n">ENABLEDAC</span><span class="p">;</span>

	<span class="cm">/* output channel range */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">range</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">command</span> <span class="o">|=</span> <span class="n">BIP</span> <span class="o">|</span> <span class="n">RANGE10V</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">command</span> <span class="o">|=</span> <span class="n">BIP</span> <span class="o">|</span> <span class="n">RANGE5V</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">command</span> <span class="o">|=</span> <span class="n">BIP</span> <span class="o">|</span> <span class="n">RANGE2V5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">command</span> <span class="o">|=</span> <span class="n">UNIP</span> <span class="o">|</span> <span class="n">RANGE10V</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">command</span> <span class="o">|=</span> <span class="n">UNIP</span> <span class="o">|</span> <span class="n">RANGE5V</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">command</span> <span class="o">|=</span> <span class="n">UNIP</span> <span class="o">|</span> <span class="n">RANGE2V5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* output channel specification */</span>
	<span class="n">command</span> <span class="o">|=</span> <span class="n">channel</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DACONTROL</span><span class="p">);</span>

	<span class="cm">/* write data */</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DADATA</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* return the number of samples read/written */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lowlevel read from eeprom */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cb_pcidda_serial_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">value_width</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/*  number of bits wide values are */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">value_width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  read bits most significant bit first */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inw_p</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DACALIBRATION1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SERIAL_OUT_BIT</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">value_width</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lowlevel write to eeprom/dac */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cb_pcidda_serial_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num_bits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  send bits most significant bit first */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">num_bits</span> <span class="o">-</span> <span class="n">i</span><span class="p">)))</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac_cal1_bits</span> <span class="o">|=</span> <span class="n">SERIAL_IN_BIT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac_cal1_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SERIAL_IN_BIT</span><span class="p">;</span>
		<span class="n">outw_p</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac_cal1_bits</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DACALIBRATION1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* reads a 16 bit value from board&#39;s eeprom */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cb_pcidda_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cal2_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
	<span class="cm">/* one caldac for every two dac channels */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">max_num_caldacs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="cm">/* bits to send to tell eeprom we want to read */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">read_instruction</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">instruction_length</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">address_length</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/*  send serial output stream to eeprom */</span>
	<span class="n">cal2_bits</span> <span class="o">=</span> <span class="n">SELECT_EEPROM_BIT</span> <span class="o">|</span> <span class="n">DESELECT_REF_DAC_BIT</span> <span class="o">|</span> <span class="n">DUMMY_BIT</span><span class="p">;</span>
	<span class="cm">/*  deactivate caldacs (one caldac for every two channels) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_num_caldacs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cal2_bits</span> <span class="o">|=</span> <span class="n">DESELECT_CALDAC_BIT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">outw_p</span><span class="p">(</span><span class="n">cal2_bits</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DACALIBRATION2</span><span class="p">);</span>

	<span class="cm">/*  tell eeprom we want to read */</span>
	<span class="n">cb_pcidda_serial_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">read_instruction</span><span class="p">,</span> <span class="n">instruction_length</span><span class="p">);</span>
	<span class="cm">/*  send address we want to read from */</span>
	<span class="n">cb_pcidda_serial_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">address_length</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">cb_pcidda_serial_in</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*  deactivate eeprom */</span>
	<span class="n">cal2_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SELECT_EEPROM_BIT</span><span class="p">;</span>
	<span class="n">outw_p</span><span class="p">(</span><span class="n">cal2_bits</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DACALIBRATION2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* writes to 8 bit calibration dacs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cb_pcidda_write_caldac</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">caldac</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cal2_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* caldacs use 3 bit channel specification */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">num_channel_bits</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">num_caldac_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/*  8 bit calibration dacs */</span>
	<span class="cm">/* one caldac for every two dac channels */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">max_num_caldacs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* write 3 bit channel */</span>
	<span class="n">cb_pcidda_serial_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">num_channel_bits</span><span class="p">);</span>
	<span class="cm">/*  write 8 bit caldac value */</span>
	<span class="n">cb_pcidda_serial_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">num_caldac_bits</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">* latch stream into appropriate caldac deselect reference dac</span>
<span class="cm">*/</span>
	<span class="n">cal2_bits</span> <span class="o">=</span> <span class="n">DESELECT_REF_DAC_BIT</span> <span class="o">|</span> <span class="n">DUMMY_BIT</span><span class="p">;</span>
	<span class="cm">/*  deactivate caldacs (one caldac for every two channels) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_num_caldacs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cal2_bits</span> <span class="o">|=</span> <span class="n">DESELECT_CALDAC_BIT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="cm">/*  activate the caldac we want */</span>
	<span class="n">cal2_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DESELECT_CALDAC_BIT</span><span class="p">(</span><span class="n">caldac</span><span class="p">);</span>
	<span class="n">outw_p</span><span class="p">(</span><span class="n">cal2_bits</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DACALIBRATION2</span><span class="p">);</span>
	<span class="cm">/*  deactivate caldac */</span>
	<span class="n">cal2_bits</span> <span class="o">|=</span> <span class="n">DESELECT_CALDAC_BIT</span><span class="p">(</span><span class="n">caldac</span><span class="p">);</span>
	<span class="n">outw_p</span><span class="p">(</span><span class="n">cal2_bits</span><span class="p">,</span> <span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">dac</span> <span class="o">+</span> <span class="n">DACALIBRATION2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns caldac that calibrates given analog out channel */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">caldac_number</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">channel</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns caldac channel that provides fine gain for given ao channel */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fine_gain_channel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">ao_channel</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns caldac channel that provides coarse gain for given ao channel */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">coarse_gain_channel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">ao_channel</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns caldac channel that provides coarse offset for given ao channel */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">coarse_offset_channel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">ao_channel</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns caldac channel that provides fine offset for given ao channel */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fine_offset_channel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">ao_channel</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns eeprom address that provides offset for given ao channel and range */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">offset_eeprom_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_channel</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mh">0x7</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">range</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">ao_channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns eeprom address that provides gain calibration for given ao</span>
<span class="cm"> * channel and range</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gain_eeprom_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ao_channel</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mh">0x8</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">range</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">ao_channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns upper byte of eeprom entry, which gives the coarse adjustment</span>
<span class="cm"> * values</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">eeprom_coarse_byte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">word</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns lower byte of eeprom entry, which gives the fine adjustment values */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">eeprom_fine_byte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set caldacs to eeprom values for given channel and range */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cb_pcidda_calibrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">comedi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">coarse_offset</span><span class="p">,</span> <span class="n">fine_offset</span><span class="p">,</span> <span class="n">coarse_gain</span><span class="p">,</span> <span class="n">fine_gain</span><span class="p">;</span>

	<span class="cm">/* remember range so we can tell when we need to readjust calibration */</span>
	<span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">ao_range</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">range</span><span class="p">;</span>

	<span class="cm">/*  get values from eeprom data */</span>
	<span class="n">coarse_offset</span> <span class="o">=</span>
	    <span class="n">eeprom_coarse_byte</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">eeprom_data</span>
			       <span class="p">[</span><span class="n">offset_eeprom_address</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">range</span><span class="p">)]);</span>
	<span class="n">fine_offset</span> <span class="o">=</span>
	    <span class="n">eeprom_fine_byte</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">eeprom_data</span>
			     <span class="p">[</span><span class="n">offset_eeprom_address</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">range</span><span class="p">)]);</span>
	<span class="n">coarse_gain</span> <span class="o">=</span>
	    <span class="n">eeprom_coarse_byte</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">eeprom_data</span>
			       <span class="p">[</span><span class="n">gain_eeprom_address</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">range</span><span class="p">)]);</span>
	<span class="n">fine_gain</span> <span class="o">=</span>
	    <span class="n">eeprom_fine_byte</span><span class="p">(</span><span class="n">devpriv</span><span class="o">-&gt;</span><span class="n">eeprom_data</span>
			     <span class="p">[</span><span class="n">gain_eeprom_address</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">range</span><span class="p">)]);</span>

	<span class="cm">/*  set caldacs */</span>
	<span class="n">cb_pcidda_write_caldac</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">caldac_number</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span>
			       <span class="n">coarse_offset_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">coarse_offset</span><span class="p">);</span>
	<span class="n">cb_pcidda_write_caldac</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">caldac_number</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span>
			       <span class="n">fine_offset_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">fine_offset</span><span class="p">);</span>
	<span class="n">cb_pcidda_write_caldac</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">caldac_number</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span>
			       <span class="n">coarse_gain_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">coarse_gain</span><span class="p">);</span>
	<span class="n">cb_pcidda_write_caldac</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">caldac_number</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span>
			       <span class="n">fine_gain_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">fine_gain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">comedi_driver</span> <span class="n">cb_pcidda_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver_name</span>	<span class="o">=</span> <span class="s">&quot;cb_pcidda&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">cb_pcidda_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach</span>		<span class="o">=</span> <span class="n">cb_pcidda_detach</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">cb_pcidda_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">comedi_pci_auto_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb_pcidda_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">cb_pcidda_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">comedi_pci_auto_unconfig</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">cb_pcidda_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CB</span><span class="p">,</span> <span class="mh">0x0020</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CB</span><span class="p">,</span> <span class="mh">0x0021</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CB</span><span class="p">,</span> <span class="mh">0x0022</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CB</span><span class="p">,</span> <span class="mh">0x0023</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CB</span><span class="p">,</span> <span class="mh">0x0024</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CB</span><span class="p">,</span> <span class="mh">0x0025</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">cb_pcidda_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">cb_pcidda_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;cb_pcidda&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">cb_pcidda_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">cb_pcidda_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">cb_pcidda_pci_remove</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">module_comedi_pci_driver</span><span class="p">(</span><span class="n">cb_pcidda_driver</span><span class="p">,</span> <span class="n">cb_pcidda_pci_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Comedi http://www.comedi.org&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Comedi low-level driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
