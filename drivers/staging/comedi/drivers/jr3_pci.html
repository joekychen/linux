<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › drivers › jr3_pci.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>jr3_pci.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Helper types to take care of the fact that the DSP card memory</span>
<span class="cm"> * is 16 bits, but aligned on a 32 bit PCI boundary</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">get_u16</span><span class="p">(</span><span class="k">volatile</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">readl</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_u16</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s16</span> <span class="nf">get_s16</span><span class="p">(</span><span class="k">volatile</span> <span class="k">const</span> <span class="n">s32</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s16</span><span class="p">)</span> <span class="n">readl</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_s16</span><span class="p">(</span><span class="k">volatile</span> <span class="n">s32</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">s16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The raw data is stored in a format which facilitates rapid</span>
<span class="cm"> * processing by the JR3 DSP chip. The raw_channel structure shows the</span>
<span class="cm"> * format for a single channel of data. Each channel takes four,</span>
<span class="cm"> * two-byte words.</span>
<span class="cm"> *</span>
<span class="cm"> * Raw_time is an unsigned integer which shows the value of the JR3</span>
<span class="cm"> * DSP&#39;s internal clock at the time the sample was received. The clock</span>
<span class="cm"> * runs at 1/10 the JR3 DSP cycle time. JR3&#39;s slowest DSP runs at 10</span>
<span class="cm"> * Mhz. At 10 Mhz raw_time would therefore clock at 1 Mhz.</span>
<span class="cm"> *</span>
<span class="cm"> * Raw_data is the raw data received directly from the sensor. The</span>
<span class="cm"> * sensor data stream is capable of representing 16 different</span>
<span class="cm"> * channels. Channel 0 shows the excitation voltage at the sensor. It</span>
<span class="cm"> * is used to regulate the voltage over various cable lengths.</span>
<span class="cm"> * Channels 1-6 contain the coupled force data Fx through Mz. Channel</span>
<span class="cm"> * 7 contains the sensor&#39;s calibration data. The use of channels 8-15</span>
<span class="cm"> * varies with different sensors.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">raw_channel</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">raw_time</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">raw_data</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* The force_array structure shows the layout for the decoupled and</span>
<span class="cm"> * filtered force data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">force_array</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">fx</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">fy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">fz</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">mx</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">my</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">mz</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">v1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The six_axis_array structure shows the layout for the offsets and</span>
<span class="cm"> * the full scales.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">six_axis_array</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">fx</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">fy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">fz</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">mx</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">my</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">mz</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* VECT_BITS */</span>
<span class="cm">/* The vect_bits structure shows the layout for indicating</span>
<span class="cm"> * which axes to use in computing the vectors. Each bit signifies</span>
<span class="cm"> * selection of a single axis. The V1x axis bit corresponds to a hex</span>
<span class="cm"> * value of 0x0001 and the V2z bit corresponds to a hex value of</span>
<span class="cm"> * 0x0020. Example: to specify the axes V1x, V1y, V2x, and V2z the</span>
<span class="cm"> * pattern would be 0x002b. Vector 1 defaults to a force vector and</span>
<span class="cm"> * vector 2 defaults to a moment vector. It is possible to change one</span>
<span class="cm"> * or the other so that two force vectors or two moment vectors are</span>
<span class="cm"> * calculated. Setting the changeV1 bit or the changeV2 bit will</span>
<span class="cm"> * change that vector to be the opposite of its default. Therefore to</span>
<span class="cm"> * have two force vectors, set changeV1 to 1.</span>
<span class="cm"> */</span>

<span class="cm">/* vect_bits appears to be unused at this time */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">fx</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">fy</span> <span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">fz</span> <span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">mx</span> <span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">my</span> <span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">mz</span> <span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">changeV2</span> <span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="n">changeV1</span> <span class="o">=</span> <span class="mh">0x0080</span>
<span class="p">}</span> <span class="n">vect_bits_t</span><span class="p">;</span>

<span class="cm">/* WARNING_BITS */</span>
<span class="cm">/* The warning_bits structure shows the bit pattern for the warning</span>
<span class="cm"> * word. The bit fields are shown from bit 0 (lsb) to bit 15 (msb).</span>
<span class="cm"> */</span>

<span class="cm">/*  XX_NEAR_SET */</span>
<span class="cm">/* The xx_near_sat bits signify that the indicated axis has reached or</span>
<span class="cm"> * exceeded the near saturation value.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">fx_near_sat</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">fy_near_sat</span> <span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">fz_near_sat</span> <span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">mx_near_sat</span> <span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">my_near_sat</span> <span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">mz_near_sat</span> <span class="o">=</span> <span class="mh">0x0020</span>
<span class="p">}</span> <span class="n">warning_bits_t</span><span class="p">;</span>

<span class="cm">/*  ERROR_BITS */</span>
<span class="cm">/*  XX_SAT */</span>
<span class="cm">/*  MEMORY_ERROR */</span>
<span class="cm">/*  SENSOR_CHANGE */</span>

<span class="cm">/* The error_bits structure shows the bit pattern for the error word.</span>
<span class="cm"> * The bit fields are shown from bit 0 (lsb) to bit 15 (msb). The</span>
<span class="cm"> * xx_sat bits signify that the indicated axis has reached or exceeded</span>
<span class="cm"> * the saturation value. The memory_error bit indicates that a problem</span>
<span class="cm"> * was detected in the on-board RAM during the power-up</span>
<span class="cm"> * initialization. The sensor_change bit indicates that a sensor other</span>
<span class="cm"> * than the one originally plugged in has passed its CRC check. This</span>
<span class="cm"> * bit latches, and must be reset by the user.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*  SYSTEM_BUSY */</span>

<span class="cm">/* The system_busy bit indicates that the JR3 DSP is currently busy</span>
<span class="cm"> * and is not calculating force data. This occurs when a new</span>
<span class="cm"> * coordinate transformation, or new sensor full scale is set by the</span>
<span class="cm"> * user. A very fast system using the force data for feedback might</span>
<span class="cm"> * become unstable during the approximately 4 ms needed to accomplish</span>
<span class="cm"> * these calculations. This bit will also become active when a new</span>
<span class="cm"> * sensor is plugged in and the system needs to recalculate the</span>
<span class="cm"> * calibration CRC.</span>
<span class="cm"> */</span>

<span class="cm">/*  CAL_CRC_BAD */</span>

<span class="cm">/* The cal_crc_bad bit indicates that the calibration CRC has not</span>
<span class="cm"> * calculated to zero. CRC is short for cyclic redundancy code. It is</span>
<span class="cm"> * a method for determining the integrity of messages in data</span>
<span class="cm"> * communication. The calibration data stored inside the sensor is</span>
<span class="cm"> * transmitted to the JR3 DSP along with the sensor data. The</span>
<span class="cm"> * calibration data has a CRC attached to the end of it, to assist in</span>
<span class="cm"> * determining the completeness and integrity of the calibration data</span>
<span class="cm"> * received from the sensor. There are two reasons the CRC may not</span>
<span class="cm"> * have calculated to zero. The first is that all the calibration data</span>
<span class="cm"> * has not yet been received, the second is that the calibration data</span>
<span class="cm"> * has been corrupted. A typical sensor transmits the entire contents</span>
<span class="cm"> * of its calibration matrix over 30 times a second. Therefore, if</span>
<span class="cm"> * this bit is not zero within a couple of seconds after the sensor</span>
<span class="cm"> * has been plugged in, there is a problem with the sensor&#39;s</span>
<span class="cm"> * calibration data.</span>
<span class="cm"> */</span>

<span class="cm">/* WATCH_DOG */</span>
<span class="cm">/* WATCH_DOG2 */</span>

<span class="cm">/* The watch_dog and watch_dog2 bits are sensor, not processor, watch</span>
<span class="cm"> * dog bits. Watch_dog indicates that the sensor data line seems to be</span>
<span class="cm"> * acting correctly, while watch_dog2 indicates that sensor data and</span>
<span class="cm"> * clock are being received. It is possible for watch_dog2 to go off</span>
<span class="cm"> * while watch_dog does not. This would indicate an improper clock</span>
<span class="cm"> * signal, while data is acting correctly. If either watch dog barks,</span>
<span class="cm"> * the sensor data is not being received correctly.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">error_bits_t</span> <span class="p">{</span>
	<span class="n">fx_sat</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">fy_sat</span> <span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">fz_sat</span> <span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">mx_sat</span> <span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">my_sat</span> <span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">mz_sat</span> <span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">memory_error</span> <span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span>
	<span class="n">sensor_change</span> <span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span>
	<span class="n">system_busy</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="n">cal_crc_bad</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">watch_dog2</span> <span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="n">watch_dog</span> <span class="o">=</span> <span class="mh">0x8000</span>
<span class="p">};</span>

<span class="cm">/*  THRESH_STRUCT */</span>

<span class="cm">/* This structure shows the layout for a single threshold packet inside of a</span>
<span class="cm"> * load envelope. Each load envelope can contain several threshold structures.</span>
<span class="cm"> * 1. data_address contains the address of the data for that threshold. This</span>
<span class="cm"> *    includes filtered, unfiltered, raw, rate, counters, error and warning data</span>
<span class="cm"> * 2. threshold is the is the value at which, if data is above or below, the</span>
<span class="cm"> *    bits will be set ... (pag.24).</span>
<span class="cm"> * 3. bit_pattern contains the bits that will be set if the threshold value is</span>
<span class="cm"> *    met or exceeded.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">thresh_struct</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">data_address</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">threshold</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">bit_pattern</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*  LE_STRUCT */</span>

<span class="cm">/* Layout of a load enveloped packet. Four thresholds are showed ... for more</span>
<span class="cm"> * see manual (pag.25)</span>
<span class="cm"> * 1. latch_bits is a bit pattern that show which bits the user wants to latch.</span>
<span class="cm"> *    The latched bits will not be reset once the threshold which set them is</span>
<span class="cm"> *    no longer true. In that case the user must reset them using the reset_bit</span>
<span class="cm"> *    command.</span>
<span class="cm"> * 2. number_of_xx_thresholds specify how many GE/LE threshold there are.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">le_struct</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">latch_bits</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">number_of_ge_thresholds</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">number_of_le_thresholds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thresh_struct</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">s32</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*  LINK_TYPES */</span>
<span class="cm">/* Link types is an enumerated value showing the different possible transform</span>
<span class="cm"> * link types.</span>
<span class="cm"> * 0 - end transform packet</span>
<span class="cm"> * 1 - translate along X axis (TX)</span>
<span class="cm"> * 2 - translate along Y axis (TY)</span>
<span class="cm"> * 3 - translate along Z axis (TZ)</span>
<span class="cm"> * 4 - rotate about X axis (RX)</span>
<span class="cm"> * 5 - rotate about Y axis (RY)</span>
<span class="cm"> * 6 - rotate about Z axis (RZ)</span>
<span class="cm"> * 7 - negate all axes (NEG)</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">link_types</span> <span class="p">{</span>
	<span class="n">end_x_form</span><span class="p">,</span>
	<span class="n">tx</span><span class="p">,</span>
	<span class="n">ty</span><span class="p">,</span>
	<span class="n">tz</span><span class="p">,</span>
	<span class="n">rx</span><span class="p">,</span>
	<span class="n">ry</span><span class="p">,</span>
	<span class="n">rz</span><span class="p">,</span>
	<span class="n">neg</span>
<span class="p">};</span>

<span class="cm">/*  TRANSFORM */</span>
<span class="cm">/*  Structure used to describe a transform. */</span>
<span class="k">struct</span> <span class="n">intern_transform</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">link_type</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">link_amount</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">link</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*  JR3 force/torque sensor data definition. For more information see sensor and */</span>
<span class="cm">/*  hardware manuals. */</span>

<span class="k">struct</span> <span class="n">jr3_channel</span> <span class="p">{</span>
	<span class="cm">/*  Raw_channels is the area used to store the raw data coming from */</span>
	<span class="cm">/*  the sensor. */</span>

	<span class="k">struct</span> <span class="n">raw_channel</span> <span class="n">raw_channels</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* offset 0x0000 */</span>

	<span class="cm">/*  Copyright is a null terminated ASCII string containing the JR3 */</span>
	<span class="cm">/*  copyright notice. */</span>

	<span class="n">u32</span> <span class="n">copyright</span><span class="p">[</span><span class="mh">0x0018</span><span class="p">];</span>	<span class="cm">/* offset 0x0040 */</span>
	<span class="n">s32</span> <span class="n">reserved1</span><span class="p">[</span><span class="mh">0x0008</span><span class="p">];</span>	<span class="cm">/* offset 0x0058 */</span>

	<span class="cm">/* Shunts contains the sensor shunt readings. Some JR3 sensors have</span>
<span class="cm">	 * the ability to have their gains adjusted. This allows the</span>
<span class="cm">	 * hardware full scales to be adjusted to potentially allow</span>
<span class="cm">	 * better resolution or dynamic range. For sensors that have</span>
<span class="cm">	 * this ability, the gain of each sensor channel is measured at</span>
<span class="cm">	 * the time of calibration using a shunt resistor. The shunt</span>
<span class="cm">	 * resistor is placed across one arm of the resistor bridge, and</span>
<span class="cm">	 * the resulting change in the output of that channel is</span>
<span class="cm">	 * measured. This measurement is called the shunt reading, and</span>
<span class="cm">	 * is recorded here. If the user has changed the gain of the //</span>
<span class="cm">	 * sensor, and made new shunt measurements, those shunt</span>
<span class="cm">	 * measurements can be placed here. The JR3 DSP will then scale</span>
<span class="cm">	 * the calibration matrix such so that the gains are again</span>
<span class="cm">	 * proper for the indicated shunt readings. If shunts is 0, then</span>
<span class="cm">	 * the sensor cannot have its gain changed. For details on</span>
<span class="cm">	 * changing the sensor gain, and making shunts readings, please</span>
<span class="cm">	 * see the sensor manual. To make these values take effect the</span>
<span class="cm">	 * user must call either command (5) use transform # (pg. 33) or</span>
<span class="cm">	 * command (10) set new full scales (pg. 38).</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">six_axis_array</span> <span class="n">shunts</span><span class="p">;</span>	<span class="cm">/* offset 0x0060 */</span>
	<span class="n">s32</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* offset 0x0066 */</span>

	<span class="cm">/* Default_FS contains the full scale that is used if the user does */</span>
	<span class="cm">/* not set a full scale. */</span>

	<span class="k">struct</span> <span class="n">six_axis_array</span> <span class="n">default_FS</span><span class="p">;</span>	<span class="cm">/* offset 0x0068 */</span>
	<span class="n">s32</span> <span class="n">reserved3</span><span class="p">;</span>		<span class="cm">/* offset 0x006e */</span>

	<span class="cm">/* Load_envelope_num is the load envelope number that is currently</span>
<span class="cm">	 * in use. This value is set by the user after one of the load</span>
<span class="cm">	 * envelopes has been initialized.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">load_envelope_num</span><span class="p">;</span>	<span class="cm">/* offset 0x006f */</span>

	<span class="cm">/* Min_full_scale is the recommend minimum full scale. */</span>

	<span class="cm">/* These values in conjunction with max_full_scale (pg. 9) helps</span>
<span class="cm">	 * determine the appropriate value for setting the full scales. The</span>
<span class="cm">	 * software allows the user to set the sensor full scale to an</span>
<span class="cm">	 * arbitrary value. But setting the full scales has some hazards. If</span>
<span class="cm">	 * the full scale is set too low, the data will saturate</span>
<span class="cm">	 * prematurely, and dynamic range will be lost. If the full scale is</span>
<span class="cm">	 * set too high, then resolution is lost as the data is shifted to</span>
<span class="cm">	 * the right and the least significant bits are lost. Therefore the</span>
<span class="cm">	 * maximum full scale is the maximum value at which no resolution is</span>
<span class="cm">	 * lost, and the minimum full scale is the value at which the data</span>
<span class="cm">	 * will not saturate prematurely. These values are calculated</span>
<span class="cm">	 * whenever a new coordinate transformation is calculated. It is</span>
<span class="cm">	 * possible for the recommended maximum to be less than the</span>
<span class="cm">	 * recommended minimum. This comes about primarily when using</span>
<span class="cm">	 * coordinate translations. If this is the case, it means that any</span>
<span class="cm">	 * full scale selection will be a compromise between dynamic range</span>
<span class="cm">	 * and resolution. It is usually recommended to compromise in favor</span>
<span class="cm">	 * of resolution which means that the recommend maximum full scale</span>
<span class="cm">	 * should be chosen.</span>
<span class="cm">	 *</span>
<span class="cm">	 * WARNING: Be sure that the full scale is no less than 0.4% of the</span>
<span class="cm">	 * recommended minimum full scale. Full scales below this value will</span>
<span class="cm">	 * cause erroneous results.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">six_axis_array</span> <span class="n">min_full_scale</span><span class="p">;</span>	<span class="cm">/* offset 0x0070 */</span>
	<span class="n">s32</span> <span class="n">reserved4</span><span class="p">;</span>		<span class="cm">/* offset 0x0076 */</span>

	<span class="cm">/* Transform_num is the transform number that is currently in use.</span>
<span class="cm">	 * This value is set by the JR3 DSP after the user has used command</span>
<span class="cm">	 * (5) use transform # (pg. 33).</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">transform_num</span><span class="p">;</span>	<span class="cm">/* offset 0x0077 */</span>

	<span class="cm">/*  Max_full_scale is the recommended maximum full scale. See */</span>
	<span class="cm">/*  min_full_scale (pg. 9) for more details. */</span>

	<span class="k">struct</span> <span class="n">six_axis_array</span> <span class="n">max_full_scale</span><span class="p">;</span>	<span class="cm">/* offset 0x0078 */</span>
	<span class="n">s32</span> <span class="n">reserved5</span><span class="p">;</span>		<span class="cm">/* offset 0x007e */</span>

	<span class="cm">/* Peak_address is the address of the data which will be monitored</span>
<span class="cm">	 * by the peak routine. This value is set by the user. The peak</span>
<span class="cm">	 * routine will monitor any 8 contiguous addresses for peak values.</span>
<span class="cm">	 * (ex. to watch filter3 data for peaks, set this value to 0x00a8).</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">peak_address</span><span class="p">;</span>	<span class="cm">/* offset 0x007f */</span>

	<span class="cm">/* Full_scale is the sensor full scales which are currently in use.</span>
<span class="cm">	 * Decoupled and filtered data is scaled so that +/- 16384 is equal</span>
<span class="cm">	 * to the full scales. The engineering units used are indicated by</span>
<span class="cm">	 * the units value discussed on page 16. The full scales for Fx, Fy,</span>
<span class="cm">	 * Fz, Mx, My and Mz can be written by the user prior to calling</span>
<span class="cm">	 * command (10) set new full scales (pg. 38). The full scales for V1</span>
<span class="cm">	 * and V2 are set whenever the full scales are changed or when the</span>
<span class="cm">	 * axes used to calculate the vectors are changed. The full scale of</span>
<span class="cm">	 * V1 and V2 will always be equal to the largest full scale of the</span>
<span class="cm">	 * axes used for each vector respectively.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">force_array</span> <span class="n">full_scale</span><span class="p">;</span>	<span class="cm">/* offset 0x0080 */</span>

	<span class="cm">/* Offsets contains the sensor offsets. These values are subtracted from</span>
<span class="cm">	 * the sensor data to obtain the decoupled data. The offsets are set a</span>
<span class="cm">	 * few seconds (&lt; 10) after the calibration data has been received.</span>
<span class="cm">	 * They are set so that the output data will be zero. These values</span>
<span class="cm">	 * can be written as well as read. The JR3 DSP will use the values</span>
<span class="cm">	 * written here within 2 ms of being written. To set future</span>
<span class="cm">	 * decoupled data to zero, add these values to the current decoupled</span>
<span class="cm">	 * data values and place the sum here. The JR3 DSP will change these</span>
<span class="cm">	 * values when a new transform is applied. So if the offsets are</span>
<span class="cm">	 * such that FX is 5 and all other values are zero, after rotating</span>
<span class="cm">	 * about Z by 90 degrees, FY would be 5 and all others would be zero.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">six_axis_array</span> <span class="n">offsets</span><span class="p">;</span>	<span class="cm">/* offset 0x0088 */</span>

	<span class="cm">/* Offset_num is the number of the offset currently in use. This</span>
<span class="cm">	 * value is set by the JR3 DSP after the user has executed the use</span>
<span class="cm">	 * offset # command (pg. 34). It can vary between 0 and 15.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">offset_num</span><span class="p">;</span>		<span class="cm">/* offset 0x008e */</span>

	<span class="cm">/* Vect_axes is a bit map showing which of the axes are being used</span>
<span class="cm">	 * in the vector calculations. This value is set by the JR3 DSP</span>
<span class="cm">	 * after the user has executed the set vector axes command (pg. 37).</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">vect_axes</span><span class="p">;</span>		<span class="cm">/* offset 0x008f */</span>

	<span class="cm">/* Filter0 is the decoupled, unfiltered data from the JR3 sensor.</span>
<span class="cm">	 * This data has had the offsets removed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * These force_arrays hold the filtered data. The decoupled data is</span>
<span class="cm">	 * passed through cascaded low pass filters. Each succeeding filter</span>
<span class="cm">	 * has a cutoff frequency of 1/4 of the preceding filter. The cutoff</span>
<span class="cm">	 * frequency of filter1 is 1/16 of the sample rate from the sensor.</span>
<span class="cm">	 * For a typical sensor with a sample rate of 8 kHz, the cutoff</span>
<span class="cm">	 * frequency of filter1 would be 500 Hz. The following filters would</span>
<span class="cm">	 * cutoff at 125 Hz, 31.25 Hz, 7.813 Hz, 1.953 Hz and 0.4883 Hz.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">force_array</span> <span class="n">filter</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>	<span class="cm">/* offset 0x0090,</span>
<span class="cm">					   offset 0x0098,</span>
<span class="cm">					   offset 0x00a0,</span>
<span class="cm">					   offset 0x00a8,</span>
<span class="cm">					   offset 0x00b0,</span>
<span class="cm">					   offset 0x00b8 ,</span>
<span class="cm">					   offset 0x00c0 */</span>

	<span class="cm">/* Rate_data is the calculated rate data. It is a first derivative</span>
<span class="cm">	 * calculation. It is calculated at a frequency specified by the</span>
<span class="cm">	 * variable rate_divisor (pg. 12). The data on which the rate is</span>
<span class="cm">	 * calculated is specified by the variable rate_address (pg. 12).</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">force_array</span> <span class="n">rate_data</span><span class="p">;</span>	<span class="cm">/* offset 0x00c8 */</span>

	<span class="cm">/* Minimum_data &amp; maximum_data are the minimum and maximum (peak)</span>
<span class="cm">	 * data values. The JR3 DSP can monitor any 8 contiguous data items</span>
<span class="cm">	 * for minimums and maximums at full sensor bandwidth. This area is</span>
<span class="cm">	 * only updated at user request. This is done so that the user does</span>
<span class="cm">	 * not miss any peaks. To read the data, use either the read peaks</span>
<span class="cm">	 * command (pg. 40), or the read and reset peaks command (pg. 39).</span>
<span class="cm">	 * The address of the data to watch for peaks is stored in the</span>
<span class="cm">	 * variable peak_address (pg. 10). Peak data is lost when executing</span>
<span class="cm">	 * a coordinate transformation or a full scale change. Peak data is</span>
<span class="cm">	 * also lost when plugging in a new sensor.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">force_array</span> <span class="n">minimum_data</span><span class="p">;</span>	<span class="cm">/* offset 0x00d0 */</span>
	<span class="k">struct</span> <span class="n">force_array</span> <span class="n">maximum_data</span><span class="p">;</span>	<span class="cm">/* offset 0x00d8 */</span>

	<span class="cm">/* Near_sat_value &amp; sat_value contain the value used to determine if</span>
<span class="cm">	 * the raw sensor is saturated. Because of decoupling and offset</span>
<span class="cm">	 * removal, it is difficult to tell from the processed data if the</span>
<span class="cm">	 * sensor is saturated. These values, in conjunction with the error</span>
<span class="cm">	 * and warning words (pg. 14), provide this critical information.</span>
<span class="cm">	 * These two values may be set by the host processor. These values</span>
<span class="cm">	 * are positive signed values, since the saturation logic uses the</span>
<span class="cm">	 * absolute values of the raw data. The near_sat_value defaults to</span>
<span class="cm">	 * approximately 80% of the ADC&#39;s full scale, which is 26214, while</span>
<span class="cm">	 * sat_value defaults to the ADC&#39;s full scale:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   sat_value = 32768 - 2^(16 - ADC bits)</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">near_sat_value</span><span class="p">;</span>	<span class="cm">/* offset 0x00e0 */</span>
	<span class="n">s32</span> <span class="n">sat_value</span><span class="p">;</span>		<span class="cm">/* offset 0x00e1 */</span>

	<span class="cm">/* Rate_address, rate_divisor &amp; rate_count contain the data used to</span>
<span class="cm">	 * control the calculations of the rates. Rate_address is the</span>
<span class="cm">	 * address of the data used for the rate calculation. The JR3 DSP</span>
<span class="cm">	 * will calculate rates for any 8 contiguous values (ex. to</span>
<span class="cm">	 * calculate rates for filter3 data set rate_address to 0x00a8).</span>
<span class="cm">	 * Rate_divisor is how often the rate is calculated. If rate_divisor</span>
<span class="cm">	 * is 1, the rates are calculated at full sensor bandwidth. If</span>
<span class="cm">	 * rate_divisor is 200, rates are calculated every 200 samples.</span>
<span class="cm">	 * Rate_divisor can be any value between 1 and 65536. Set</span>
<span class="cm">	 * rate_divisor to 0 to calculate rates every 65536 samples.</span>
<span class="cm">	 * Rate_count starts at zero and counts until it equals</span>
<span class="cm">	 * rate_divisor, at which point the rates are calculated, and</span>
<span class="cm">	 * rate_count is reset to 0. When setting a new rate divisor, it is</span>
<span class="cm">	 * a good idea to set rate_count to one less than rate divisor. This</span>
<span class="cm">	 * will minimize the time necessary to start the rate calculations.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">rate_address</span><span class="p">;</span>	<span class="cm">/* offset 0x00e2 */</span>
	<span class="n">u32</span> <span class="n">rate_divisor</span><span class="p">;</span>	<span class="cm">/* offset 0x00e3 */</span>
	<span class="n">u32</span> <span class="n">rate_count</span><span class="p">;</span>		<span class="cm">/* offset 0x00e4 */</span>

	<span class="cm">/* Command_word2 through command_word0 are the locations used to</span>
<span class="cm">	 * send commands to the JR3 DSP. Their usage varies with the command</span>
<span class="cm">	 * and is detailed later in the Command Definitions section (pg.</span>
<span class="cm">	 * 29). In general the user places values into various memory</span>
<span class="cm">	 * locations, and then places the command word into command_word0.</span>
<span class="cm">	 * The JR3 DSP will process the command and place a 0 into</span>
<span class="cm">	 * command_word0 to indicate successful completion. Alternatively</span>
<span class="cm">	 * the JR3 DSP will place a negative number into command_word0 to</span>
<span class="cm">	 * indicate an error condition. Please note the command locations</span>
<span class="cm">	 * are numbered backwards. (I.E. command_word2 comes before</span>
<span class="cm">	 * command_word1).</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">command_word2</span><span class="p">;</span>	<span class="cm">/* offset 0x00e5 */</span>
	<span class="n">s32</span> <span class="n">command_word1</span><span class="p">;</span>	<span class="cm">/* offset 0x00e6 */</span>
	<span class="n">s32</span> <span class="n">command_word0</span><span class="p">;</span>	<span class="cm">/* offset 0x00e7 */</span>

	<span class="cm">/* Count1 through count6 are unsigned counters which are incremented</span>
<span class="cm">	 * every time the matching filters are calculated. Filter1 is</span>
<span class="cm">	 * calculated at the sensor data bandwidth. So this counter would</span>
<span class="cm">	 * increment at 8 kHz for a typical sensor. The rest of the counters</span>
<span class="cm">	 * are incremented at 1/4 the interval of the counter immediately</span>
<span class="cm">	 * preceding it, so they would count at 2 kHz, 500 Hz, 125 Hz etc.</span>
<span class="cm">	 * These counters can be used to wait for data. Each time the</span>
<span class="cm">	 * counter changes, the corresponding data set can be sampled, and</span>
<span class="cm">	 * this will insure that the user gets each sample, once, and only</span>
<span class="cm">	 * once.</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">count1</span><span class="p">;</span>		<span class="cm">/* offset 0x00e8 */</span>
	<span class="n">u32</span> <span class="n">count2</span><span class="p">;</span>		<span class="cm">/* offset 0x00e9 */</span>
	<span class="n">u32</span> <span class="n">count3</span><span class="p">;</span>		<span class="cm">/* offset 0x00ea */</span>
	<span class="n">u32</span> <span class="n">count4</span><span class="p">;</span>		<span class="cm">/* offset 0x00eb */</span>
	<span class="n">u32</span> <span class="n">count5</span><span class="p">;</span>		<span class="cm">/* offset 0x00ec */</span>
	<span class="n">u32</span> <span class="n">count6</span><span class="p">;</span>		<span class="cm">/* offset 0x00ed */</span>

	<span class="cm">/* Error_count is a running count of data reception errors. If this</span>
<span class="cm">	 * counter is changing rapidly, it probably indicates a bad sensor</span>
<span class="cm">	 * cable connection or other hardware problem. In most installations</span>
<span class="cm">	 * error_count should not change at all. But it is possible in an</span>
<span class="cm">	 * extremely noisy environment to experience occasional errors even</span>
<span class="cm">	 * without a hardware problem. If the sensor is well grounded, this</span>
<span class="cm">	 * is probably unavoidable in these environments. On the occasions</span>
<span class="cm">	 * where this counter counts a bad sample, that sample is ignored.</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">error_count</span><span class="p">;</span>	<span class="cm">/* offset 0x00ee */</span>

	<span class="cm">/* Count_x is a counter which is incremented every time the JR3 DSP</span>
<span class="cm">	 * searches its job queues and finds nothing to do. It indicates the</span>
<span class="cm">	 * amount of idle time the JR3 DSP has available. It can also be</span>
<span class="cm">	 * used to determine if the JR3 DSP is alive. See the Performance</span>
<span class="cm">	 * Issues section on pg. 49 for more details.</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">count_x</span><span class="p">;</span>		<span class="cm">/* offset 0x00ef */</span>

	<span class="cm">/* Warnings &amp; errors contain the warning and error bits</span>
<span class="cm">	 * respectively. The format of these two words is discussed on page</span>
<span class="cm">	 * 21 under the headings warnings_bits and error_bits.</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">warnings</span><span class="p">;</span>		<span class="cm">/* offset 0x00f0 */</span>
	<span class="n">u32</span> <span class="n">errors</span><span class="p">;</span>		<span class="cm">/* offset 0x00f1 */</span>

	<span class="cm">/* Threshold_bits is a word containing the bits that are set by the</span>
<span class="cm">	 * load envelopes. See load_envelopes (pg. 17) and thresh_struct</span>
<span class="cm">	 * (pg. 23) for more details.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">threshold_bits</span><span class="p">;</span>	<span class="cm">/* offset 0x00f2 */</span>

	<span class="cm">/* Last_crc is the value that shows the actual calculated CRC. CRC</span>
<span class="cm">	 * is short for cyclic redundancy code. It should be zero. See the</span>
<span class="cm">	 * description for cal_crc_bad (pg. 21) for more information.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">last_CRC</span><span class="p">;</span>		<span class="cm">/* offset 0x00f3 */</span>

	<span class="cm">/* EEProm_ver_no contains the version number of the sensor EEProm.</span>
<span class="cm">	 * EEProm version numbers can vary between 0 and 255.</span>
<span class="cm">	 * Software_ver_no contains the software version number. Version</span>
<span class="cm">	 * 3.02 would be stored as 302.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">eeprom_ver_no</span><span class="p">;</span>	<span class="cm">/* offset 0x00f4 */</span>
	<span class="n">s32</span> <span class="n">software_ver_no</span><span class="p">;</span>	<span class="cm">/* offset 0x00f5 */</span>

	<span class="cm">/* Software_day &amp; software_year are the release date of the software</span>
<span class="cm">	 * the JR3 DSP is currently running. Day is the day of the year,</span>
<span class="cm">	 * with January 1 being 1, and December 31, being 365 for non leap</span>
<span class="cm">	 * years.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">software_day</span><span class="p">;</span>	<span class="cm">/* offset 0x00f6 */</span>
	<span class="n">s32</span> <span class="n">software_year</span><span class="p">;</span>	<span class="cm">/* offset 0x00f7 */</span>

	<span class="cm">/* Serial_no &amp; model_no are the two values which uniquely identify a</span>
<span class="cm">	 * sensor. This model number does not directly correspond to the JR3</span>
<span class="cm">	 * model number, but it will provide a unique identifier for</span>
<span class="cm">	 * different sensor configurations.</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">serial_no</span><span class="p">;</span>		<span class="cm">/* offset 0x00f8 */</span>
	<span class="n">u32</span> <span class="n">model_no</span><span class="p">;</span>		<span class="cm">/* offset 0x00f9 */</span>

	<span class="cm">/* Cal_day &amp; cal_year are the sensor calibration date. Day is the</span>
<span class="cm">	 * day of the year, with January 1 being 1, and December 31, being</span>
<span class="cm">	 * 366 for leap years.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">cal_day</span><span class="p">;</span>		<span class="cm">/* offset 0x00fa */</span>
	<span class="n">s32</span> <span class="n">cal_year</span><span class="p">;</span>		<span class="cm">/* offset 0x00fb */</span>

	<span class="cm">/* Units is an enumerated read only value defining the engineering</span>
<span class="cm">	 * units used in the sensor full scale. The meanings of particular</span>
<span class="cm">	 * values are discussed in the section detailing the force_units</span>
<span class="cm">	 * structure on page 22. The engineering units are setto customer</span>
<span class="cm">	 * specifications during sensor manufacture and cannot be changed by</span>
<span class="cm">	 * writing to Units.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Bits contains the number of bits of resolution of the ADC</span>
<span class="cm">	 * currently in use.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Channels is a bit field showing which channels the current sensor</span>
<span class="cm">	 * is capable of sending. If bit 0 is active, this sensor can send</span>
<span class="cm">	 * channel 0, if bit 13 is active, this sensor can send channel 13,</span>
<span class="cm">	 * etc. This bit can be active, even if the sensor is not currently</span>
<span class="cm">	 * sending this channel. Some sensors are configurable as to which</span>
<span class="cm">	 * channels to send, and this field only contains information on the</span>
<span class="cm">	 * channels available to send, not on the current configuration. To</span>
<span class="cm">	 * find which channels are currently being sent, monitor the</span>
<span class="cm">	 * Raw_time fields (pg. 19) in the raw_channels array (pg. 7). If</span>
<span class="cm">	 * the time is changing periodically, then that channel is being</span>
<span class="cm">	 * received.</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">units</span><span class="p">;</span>		<span class="cm">/* offset 0x00fc */</span>
	<span class="n">s32</span> <span class="n">bits</span><span class="p">;</span>		<span class="cm">/* offset 0x00fd */</span>
	<span class="n">s32</span> <span class="n">channels</span><span class="p">;</span>		<span class="cm">/* offset 0x00fe */</span>

	<span class="cm">/* Thickness specifies the overall thickness of the sensor from</span>
<span class="cm">	 * flange to flange. The engineering units for this value are</span>
<span class="cm">	 * contained in units (pg. 16). The sensor calibration is relative</span>
<span class="cm">	 * to the center of the sensor. This value allows easy coordinate</span>
<span class="cm">	 * transformation from the center of the sensor to either flange.</span>
<span class="cm">	 */</span>

	<span class="n">s32</span> <span class="n">thickness</span><span class="p">;</span>		<span class="cm">/* offset 0x00ff */</span>

	<span class="cm">/* Load_envelopes is a table containing the load envelope</span>
<span class="cm">	 * descriptions. There are 16 possible load envelope slots in the</span>
<span class="cm">	 * table. The slots are on 16 word boundaries and are numbered 0-15.</span>
<span class="cm">	 * Each load envelope needs to start at the beginning of a slot but</span>
<span class="cm">	 * need not be fully contained in that slot. That is to say that a</span>
<span class="cm">	 * single load envelope can be larger than a single slot. The</span>
<span class="cm">	 * software has been tested and ran satisfactorily with 50</span>
<span class="cm">	 * thresholds active. A single load envelope this large would take</span>
<span class="cm">	 * up 5 of the 16 slots. The load envelope data is laid out in an</span>
<span class="cm">	 * order that is most efficient for the JR3 DSP. The structure is</span>
<span class="cm">	 * detailed later in the section showing the definition of the</span>
<span class="cm">	 * le_struct structure (pg. 23).</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">le_struct</span> <span class="n">load_envelopes</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>	<span class="cm">/* offset 0x0100 */</span>

	<span class="cm">/* Transforms is a table containing the transform descriptions.</span>
<span class="cm">	 * There are 16 possible transform slots in the table. The slots are</span>
<span class="cm">	 * on 16 word boundaries and are numbered 0-15. Each transform needs</span>
<span class="cm">	 * to start at the beginning of a slot but need not be fully</span>
<span class="cm">	 * contained in that slot. That is to say that a single transform</span>
<span class="cm">	 * can be larger than a single slot. A transform is 2 * no of links</span>
<span class="cm">	 * + 1 words in length. So a single slot can contain a transform</span>
<span class="cm">	 * with 7 links. Two slots can contain a transform that is 15 links.</span>
<span class="cm">	 * The layout is detailed later in the section showing the</span>
<span class="cm">	 * definition of the transform structure (pg. 26).</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">intern_transform</span> <span class="n">transforms</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>	<span class="cm">/* offset 0x0200 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">jr3_t</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">program_low</span><span class="p">[</span><span class="mh">0x4000</span><span class="p">];</span>	<span class="cm">/*  0x00000 - 0x10000 */</span>
		<span class="k">struct</span> <span class="n">jr3_channel</span> <span class="n">data</span><span class="p">;</span>	<span class="cm">/*  0x10000 - 0x10c00 */</span>
		<span class="kt">char</span> <span class="n">pad2</span><span class="p">[</span><span class="mh">0x30000</span> <span class="o">-</span> <span class="mh">0x00c00</span><span class="p">];</span>	<span class="cm">/*  0x10c00 - 0x40000 */</span>
		<span class="n">u32</span> <span class="n">program_high</span><span class="p">[</span><span class="mh">0x8000</span><span class="p">];</span>	<span class="cm">/*  0x40000 - 0x60000 */</span>
		<span class="n">u32</span> <span class="n">reset</span><span class="p">;</span>	<span class="cm">/*  0x60000 - 0x60004 */</span>
		<span class="kt">char</span> <span class="n">pad3</span><span class="p">[</span><span class="mh">0x20000</span> <span class="o">-</span> <span class="mh">0x00004</span><span class="p">];</span>	<span class="cm">/*  0x60004 - 0x80000 */</span>
	<span class="p">}</span> <span class="n">channel</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
