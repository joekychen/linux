<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › comedi › comedi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>comedi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    include/comedi.h (installed as /usr/include/comedi.h)</span>
<span class="cm">    header file for comedi</span>

<span class="cm">    COMEDI - Linux Control and Measurement Device Interface</span>
<span class="cm">    Copyright (C) 1998-2001 David A. Schleef &lt;ds@schleef.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm">*/</span>

<span class="cp">#ifndef _COMEDI_H</span>
<span class="cp">#define _COMEDI_H</span>

<span class="cp">#define COMEDI_MAJORVERSION	0</span>
<span class="cp">#define COMEDI_MINORVERSION	7</span>
<span class="cp">#define COMEDI_MICROVERSION	76</span>
<span class="cp">#define VERSION	&quot;0.7.76&quot;</span>

<span class="cm">/* comedi&#39;s major device number */</span>
<span class="cp">#define COMEDI_MAJOR 98</span>

<span class="cm">/*</span>
<span class="cm">   maximum number of minor devices.  This can be increased, although</span>
<span class="cm">   kernel structures are currently statically allocated, thus you</span>
<span class="cm">   don&#39;t want this to be much more than you actually use.</span>
<span class="cm"> */</span>
<span class="cp">#define COMEDI_NDEVICES 16</span>

<span class="cm">/* number of config options in the config structure */</span>
<span class="cp">#define COMEDI_NDEVCONFOPTS 32</span>
<span class="cm">/*length of nth chunk of firmware data*/</span>
<span class="cp">#define COMEDI_DEVCONF_AUX_DATA3_LENGTH		25</span>
<span class="cp">#define COMEDI_DEVCONF_AUX_DATA2_LENGTH		26</span>
<span class="cp">#define COMEDI_DEVCONF_AUX_DATA1_LENGTH		27</span>
<span class="cp">#define COMEDI_DEVCONF_AUX_DATA0_LENGTH		28</span>
<span class="cm">/* most significant 32 bits of pointer address (if needed) */</span>
<span class="cp">#define COMEDI_DEVCONF_AUX_DATA_HI		29</span>
<span class="cm">/* least significant 32 bits of pointer address */</span>
<span class="cp">#define COMEDI_DEVCONF_AUX_DATA_LO		30</span>
<span class="cp">#define COMEDI_DEVCONF_AUX_DATA_LENGTH		31	</span><span class="cm">/* total data length */</span><span class="cp"></span>

<span class="cm">/* max length of device and driver names */</span>
<span class="cp">#define COMEDI_NAMELEN 20</span>

<span class="cm">/* packs and unpacks a channel/range number */</span>

<span class="cp">#define CR_PACK(chan, rng, aref)					\</span>
<span class="cp">	((((aref)&amp;0x3)&lt;&lt;24) | (((rng)&amp;0xff)&lt;&lt;16) | (chan))</span>
<span class="cp">#define CR_PACK_FLAGS(chan, range, aref, flags)				\</span>
<span class="cp">	(CR_PACK(chan, range, aref) | ((flags) &amp; CR_FLAGS_MASK))</span>

<span class="cp">#define CR_CHAN(a)	((a)&amp;0xffff)</span>
<span class="cp">#define CR_RANGE(a)	(((a)&gt;&gt;16)&amp;0xff)</span>
<span class="cp">#define CR_AREF(a)	(((a)&gt;&gt;24)&amp;0x03)</span>

<span class="cp">#define CR_FLAGS_MASK	0xfc000000</span>
<span class="cp">#define CR_ALT_FILTER	(1&lt;&lt;26)</span>
<span class="cp">#define CR_DITHER	CR_ALT_FILTER</span>
<span class="cp">#define CR_DEGLITCH	CR_ALT_FILTER</span>
<span class="cp">#define CR_ALT_SOURCE	(1&lt;&lt;27)</span>
<span class="cp">#define CR_EDGE		(1&lt;&lt;30)</span>
<span class="cp">#define CR_INVERT	(1&lt;&lt;31)</span>

<span class="cp">#define AREF_GROUND	0x00	</span><span class="cm">/* analog ref = analog ground */</span><span class="cp"></span>
<span class="cp">#define AREF_COMMON	0x01	</span><span class="cm">/* analog ref = analog common */</span><span class="cp"></span>
<span class="cp">#define AREF_DIFF	0x02	</span><span class="cm">/* analog ref = differential */</span><span class="cp"></span>
<span class="cp">#define AREF_OTHER	0x03	</span><span class="cm">/* analog ref = other (undefined) */</span><span class="cp"></span>

<span class="cm">/* counters -- these are arbitrary values */</span>
<span class="cp">#define GPCT_RESET		0x0001</span>
<span class="cp">#define GPCT_SET_SOURCE		0x0002</span>
<span class="cp">#define GPCT_SET_GATE		0x0004</span>
<span class="cp">#define GPCT_SET_DIRECTION	0x0008</span>
<span class="cp">#define GPCT_SET_OPERATION	0x0010</span>
<span class="cp">#define GPCT_ARM		0x0020</span>
<span class="cp">#define GPCT_DISARM		0x0040</span>
<span class="cp">#define GPCT_GET_INT_CLK_FRQ	0x0080</span>

<span class="cp">#define GPCT_INT_CLOCK		0x0001</span>
<span class="cp">#define GPCT_EXT_PIN		0x0002</span>
<span class="cp">#define GPCT_NO_GATE		0x0004</span>
<span class="cp">#define GPCT_UP			0x0008</span>
<span class="cp">#define GPCT_DOWN		0x0010</span>
<span class="cp">#define GPCT_HWUD		0x0020</span>
<span class="cp">#define GPCT_SIMPLE_EVENT	0x0040</span>
<span class="cp">#define GPCT_SINGLE_PERIOD	0x0080</span>
<span class="cp">#define GPCT_SINGLE_PW		0x0100</span>
<span class="cp">#define GPCT_CONT_PULSE_OUT	0x0200</span>
<span class="cp">#define GPCT_SINGLE_PULSE_OUT	0x0400</span>

<span class="cm">/* instructions */</span>

<span class="cp">#define INSN_MASK_WRITE		0x8000000</span>
<span class="cp">#define INSN_MASK_READ		0x4000000</span>
<span class="cp">#define INSN_MASK_SPECIAL	0x2000000</span>

<span class="cp">#define INSN_READ		(0 | INSN_MASK_READ)</span>
<span class="cp">#define INSN_WRITE		(1 | INSN_MASK_WRITE)</span>
<span class="cp">#define INSN_BITS		(2 | INSN_MASK_READ|INSN_MASK_WRITE)</span>
<span class="cp">#define INSN_CONFIG		(3 | INSN_MASK_READ|INSN_MASK_WRITE)</span>
<span class="cp">#define INSN_GTOD		(4 | INSN_MASK_READ|INSN_MASK_SPECIAL)</span>
<span class="cp">#define INSN_WAIT		(5 | INSN_MASK_WRITE|INSN_MASK_SPECIAL)</span>
<span class="cp">#define INSN_INTTRIG		(6 | INSN_MASK_WRITE|INSN_MASK_SPECIAL)</span>

<span class="cm">/* trigger flags */</span>
<span class="cm">/* These flags are used in comedi_trig structures */</span>

<span class="cp">#define TRIG_BOGUS	0x0001	</span><span class="cm">/* do the motions */</span><span class="cp"></span>
<span class="cp">#define TRIG_DITHER	0x0002	</span><span class="cm">/* enable dithering */</span><span class="cp"></span>
<span class="cp">#define TRIG_DEGLITCH	0x0004	</span><span class="cm">/* enable deglitching */</span><span class="cp"></span>
	<span class="cm">/*#define TRIG_RT       0x0008 *//* perform op in real time */</span>
<span class="cp">#define TRIG_CONFIG	0x0010	</span><span class="cm">/* perform configuration, not triggering */</span><span class="cp"></span>
<span class="cp">#define TRIG_WAKE_EOS	0x0020	</span><span class="cm">/* wake up on end-of-scan events */</span><span class="cp"></span>
	<span class="cm">/*#define TRIG_WRITE    0x0040*//* write to bidirectional devices */</span>

<span class="cm">/* command flags */</span>
<span class="cm">/* These flags are used in comedi_cmd structures */</span>

<span class="cm">/* try to use a real-time interrupt while performing command */</span>
<span class="cp">#define CMDF_PRIORITY		0x00000008</span>

<span class="cp">#define TRIG_RT		CMDF_PRIORITY	</span><span class="cm">/* compatibility definition */</span><span class="cp"></span>

<span class="cp">#define CMDF_WRITE		0x00000040</span>
<span class="cp">#define TRIG_WRITE	CMDF_WRITE	</span><span class="cm">/* compatibility definition */</span><span class="cp"></span>

<span class="cp">#define CMDF_RAWDATA		0x00000080</span>

<span class="cp">#define COMEDI_EV_START		0x00040000</span>
<span class="cp">#define COMEDI_EV_SCAN_BEGIN	0x00080000</span>
<span class="cp">#define COMEDI_EV_CONVERT	0x00100000</span>
<span class="cp">#define COMEDI_EV_SCAN_END	0x00200000</span>
<span class="cp">#define COMEDI_EV_STOP		0x00400000</span>

<span class="cp">#define TRIG_ROUND_MASK		0x00030000</span>
<span class="cp">#define TRIG_ROUND_NEAREST	0x00000000</span>
<span class="cp">#define TRIG_ROUND_DOWN		0x00010000</span>
<span class="cp">#define TRIG_ROUND_UP		0x00020000</span>
<span class="cp">#define TRIG_ROUND_UP_NEXT	0x00030000</span>

<span class="cm">/* trigger sources */</span>

<span class="cp">#define TRIG_ANY	0xffffffff</span>
<span class="cp">#define TRIG_INVALID	0x00000000</span>

<span class="cp">#define TRIG_NONE	0x00000001 </span><span class="cm">/* never trigger */</span><span class="cp"></span>
<span class="cp">#define TRIG_NOW	0x00000002 </span><span class="cm">/* trigger now + N ns */</span><span class="cp"></span>
<span class="cp">#define TRIG_FOLLOW	0x00000004 </span><span class="cm">/* trigger on next lower level trig */</span><span class="cp"></span>
<span class="cp">#define TRIG_TIME	0x00000008 </span><span class="cm">/* trigger at time N ns */</span><span class="cp"></span>
<span class="cp">#define TRIG_TIMER	0x00000010 </span><span class="cm">/* trigger at rate N ns */</span><span class="cp"></span>
<span class="cp">#define TRIG_COUNT	0x00000020 </span><span class="cm">/* trigger when count reaches N */</span><span class="cp"></span>
<span class="cp">#define TRIG_EXT	0x00000040 </span><span class="cm">/* trigger on external signal N */</span><span class="cp"></span>
<span class="cp">#define TRIG_INT	0x00000080 </span><span class="cm">/* trigger on comedi-internal signal N */</span><span class="cp"></span>
<span class="cp">#define TRIG_OTHER	0x00000100 </span><span class="cm">/* driver defined */</span><span class="cp"></span>

<span class="cm">/* subdevice flags */</span>

<span class="cp">#define SDF_BUSY	0x0001	</span><span class="cm">/* device is busy */</span><span class="cp"></span>
<span class="cp">#define SDF_BUSY_OWNER	0x0002	</span><span class="cm">/* device is busy with your job */</span><span class="cp"></span>
<span class="cp">#define SDF_LOCKED	0x0004	</span><span class="cm">/* subdevice is locked */</span><span class="cp"></span>
<span class="cp">#define SDF_LOCK_OWNER	0x0008	</span><span class="cm">/* you own lock */</span><span class="cp"></span>
<span class="cp">#define SDF_MAXDATA	0x0010	</span><span class="cm">/* maxdata depends on channel */</span><span class="cp"></span>
<span class="cp">#define SDF_FLAGS	0x0020	</span><span class="cm">/* flags depend on channel */</span><span class="cp"></span>
<span class="cp">#define SDF_RANGETYPE	0x0040	</span><span class="cm">/* range type depends on channel */</span><span class="cp"></span>
<span class="cp">#define SDF_MODE0	0x0080	</span><span class="cm">/* can do mode 0 */</span><span class="cp"></span>
<span class="cp">#define SDF_MODE1	0x0100	</span><span class="cm">/* can do mode 1 */</span><span class="cp"></span>
<span class="cp">#define SDF_MODE2	0x0200	</span><span class="cm">/* can do mode 2 */</span><span class="cp"></span>
<span class="cp">#define SDF_MODE3	0x0400	</span><span class="cm">/* can do mode 3 */</span><span class="cp"></span>
<span class="cp">#define SDF_MODE4	0x0800	</span><span class="cm">/* can do mode 4 */</span><span class="cp"></span>
<span class="cp">#define SDF_CMD		0x1000	</span><span class="cm">/* can do commands (deprecated) */</span><span class="cp"></span>
<span class="cp">#define SDF_SOFT_CALIBRATED	0x2000 </span><span class="cm">/* subdevice uses software calibration */</span><span class="cp"></span>
<span class="cp">#define SDF_CMD_WRITE		0x4000 </span><span class="cm">/* can do output commands */</span><span class="cp"></span>
<span class="cp">#define SDF_CMD_READ		0x8000 </span><span class="cm">/* can do input commands */</span><span class="cp"></span>

<span class="cm">/* subdevice can be read (e.g. analog input) */</span>
<span class="cp">#define SDF_READABLE	0x00010000</span>
<span class="cm">/* subdevice can be written (e.g. analog output) */</span>
<span class="cp">#define SDF_WRITABLE	0x00020000</span>
<span class="cp">#define SDF_WRITEABLE	SDF_WRITABLE	</span><span class="cm">/* spelling error in API */</span><span class="cp"></span>
<span class="cm">/* subdevice does not have externally visible lines */</span>
<span class="cp">#define SDF_INTERNAL	0x00040000</span>
<span class="cp">#define SDF_GROUND	0x00100000	</span><span class="cm">/* can do aref=ground */</span><span class="cp"></span>
<span class="cp">#define SDF_COMMON	0x00200000	</span><span class="cm">/* can do aref=common */</span><span class="cp"></span>
<span class="cp">#define SDF_DIFF	0x00400000	</span><span class="cm">/* can do aref=diff */</span><span class="cp"></span>
<span class="cp">#define SDF_OTHER	0x00800000	</span><span class="cm">/* can do aref=other */</span><span class="cp"></span>
<span class="cp">#define SDF_DITHER	0x01000000	</span><span class="cm">/* can do dithering */</span><span class="cp"></span>
<span class="cp">#define SDF_DEGLITCH	0x02000000	</span><span class="cm">/* can do deglitching */</span><span class="cp"></span>
<span class="cp">#define SDF_MMAP	0x04000000	</span><span class="cm">/* can do mmap() */</span><span class="cp"></span>
<span class="cp">#define SDF_RUNNING	0x08000000	</span><span class="cm">/* subdevice is acquiring data */</span><span class="cp"></span>
<span class="cp">#define SDF_LSAMPL	0x10000000	</span><span class="cm">/* subdevice uses 32-bit samples */</span><span class="cp"></span>
<span class="cp">#define SDF_PACKED	0x20000000	</span><span class="cm">/* subdevice can do packed DIO */</span><span class="cp"></span>
<span class="cm">/* re recyle these flags for PWM */</span>
<span class="cp">#define SDF_PWM_COUNTER SDF_MODE0	</span><span class="cm">/* PWM can automatically switch off */</span><span class="cp"></span>
<span class="cp">#define SDF_PWM_HBRIDGE SDF_MODE1	</span><span class="cm">/* PWM is signed (H-bridge) */</span><span class="cp"></span>

<span class="cm">/* subdevice types */</span>

	<span class="k">enum</span> <span class="n">comedi_subdevice_type</span> <span class="p">{</span>
		<span class="n">COMEDI_SUBD_UNUSED</span><span class="p">,</span>	<span class="cm">/* unused by driver */</span>
		<span class="n">COMEDI_SUBD_AI</span><span class="p">,</span>	<span class="cm">/* analog input */</span>
		<span class="n">COMEDI_SUBD_AO</span><span class="p">,</span>	<span class="cm">/* analog output */</span>
		<span class="n">COMEDI_SUBD_DI</span><span class="p">,</span>	<span class="cm">/* digital input */</span>
		<span class="n">COMEDI_SUBD_DO</span><span class="p">,</span>	<span class="cm">/* digital output */</span>
		<span class="n">COMEDI_SUBD_DIO</span><span class="p">,</span>	<span class="cm">/* digital input/output */</span>
		<span class="n">COMEDI_SUBD_COUNTER</span><span class="p">,</span>	<span class="cm">/* counter */</span>
		<span class="n">COMEDI_SUBD_TIMER</span><span class="p">,</span>	<span class="cm">/* timer */</span>
		<span class="n">COMEDI_SUBD_MEMORY</span><span class="p">,</span>	<span class="cm">/* memory, EEPROM, DPRAM */</span>
		<span class="n">COMEDI_SUBD_CALIB</span><span class="p">,</span>	<span class="cm">/* calibration DACs */</span>
		<span class="n">COMEDI_SUBD_PROC</span><span class="p">,</span>	<span class="cm">/* processor, DSP */</span>
		<span class="n">COMEDI_SUBD_SERIAL</span><span class="p">,</span>	<span class="cm">/* serial IO */</span>
		<span class="n">COMEDI_SUBD_PWM</span>	<span class="cm">/* PWM */</span>
	<span class="p">};</span>

<span class="cm">/* configuration instructions */</span>

	<span class="k">enum</span> <span class="n">configuration_ids</span> <span class="p">{</span>
		<span class="n">INSN_CONFIG_DIO_INPUT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_DIO_OUTPUT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_DIO_OPENDRAIN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_ANALOG_TRIG</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="cm">/*	INSN_CONFIG_WAVEFORM = 17, */</span>
<span class="cm">/*	INSN_CONFIG_TRIG = 18, */</span>
<span class="cm">/*	INSN_CONFIG_COUNTER = 19, */</span>
		<span class="n">INSN_CONFIG_ALT_SOURCE</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_DIGITAL_TRIG</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_TIMER_1</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_FILTER</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_CHANGE_NOTIFY</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>

		 <span class="cm">/*ALPHA*/</span> <span class="n">INSN_CONFIG_SERIAL_CLOCK</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_BIDIRECTIONAL_DATA</span> <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_DIO_QUERY</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_PWM_OUTPUT</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_GET_PWM_OUTPUT</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_ARM</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_DISARM</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_GET_COUNTER_STATUS</span> <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_RESET</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>
		<span class="cm">/* Use CTR as single pulsegenerator */</span>
		<span class="n">INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span>
		<span class="cm">/* Use CTR as pulsetraingenerator */</span>
		<span class="n">INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR</span> <span class="o">=</span> <span class="mi">1002</span><span class="p">,</span>
		<span class="cm">/* Use the counter as encoder */</span>
		<span class="n">INSN_CONFIG_GPCT_QUADRATURE_ENCODER</span> <span class="o">=</span> <span class="mi">1003</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_SET_GATE_SRC</span> <span class="o">=</span> <span class="mi">2001</span><span class="p">,</span>	<span class="cm">/* Set gate source */</span>
		<span class="n">INSN_CONFIG_GET_GATE_SRC</span> <span class="o">=</span> <span class="mi">2002</span><span class="p">,</span>	<span class="cm">/* Get gate source */</span>
		<span class="cm">/* Set master clock source */</span>
		<span class="n">INSN_CONFIG_SET_CLOCK_SRC</span> <span class="o">=</span> <span class="mi">2003</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_GET_CLOCK_SRC</span> <span class="o">=</span> <span class="mi">2004</span><span class="p">,</span> <span class="cm">/* Get master clock source */</span>
		<span class="n">INSN_CONFIG_SET_OTHER_SRC</span> <span class="o">=</span> <span class="mi">2005</span><span class="p">,</span> <span class="cm">/* Set other source */</span>
		<span class="cm">/* INSN_CONFIG_GET_OTHER_SRC = 2006,*//* Get other source */</span>
		<span class="cm">/* Get size in bytes of subdevice&#39;s on-board fifos used during</span>
<span class="cm">		 * streaming input/output */</span>
		<span class="n">INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">2006</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_SET_COUNTER_MODE</span> <span class="o">=</span> <span class="mi">4097</span><span class="p">,</span>
		<span class="cm">/* INSN_CONFIG_8254_SET_MODE is deprecated */</span>
		<span class="n">INSN_CONFIG_8254_SET_MODE</span> <span class="o">=</span> <span class="n">INSN_CONFIG_SET_COUNTER_MODE</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_8254_READ_STATUS</span> <span class="o">=</span> <span class="mi">4098</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_SET_ROUTING</span> <span class="o">=</span> <span class="mi">4099</span><span class="p">,</span>
		<span class="n">INSN_CONFIG_GET_ROUTING</span> <span class="o">=</span> <span class="mi">4109</span><span class="p">,</span>
<span class="cm">/* PWM */</span>
		<span class="n">INSN_CONFIG_PWM_SET_PERIOD</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>	<span class="cm">/* sets frequency */</span>
		<span class="n">INSN_CONFIG_PWM_GET_PERIOD</span> <span class="o">=</span> <span class="mi">5001</span><span class="p">,</span>	<span class="cm">/* gets frequency */</span>
		<span class="n">INSN_CONFIG_GET_PWM_STATUS</span> <span class="o">=</span> <span class="mi">5002</span><span class="p">,</span>	<span class="cm">/* is it running? */</span>
		<span class="cm">/* sets H bridge: duty cycle and sign bit for a relay at the</span>
<span class="cm">		 * same time */</span>
		<span class="n">INSN_CONFIG_PWM_SET_H_BRIDGE</span> <span class="o">=</span> <span class="mi">5003</span><span class="p">,</span>
		<span class="cm">/* gets H bridge data: duty cycle and the sign bit */</span>
		<span class="n">INSN_CONFIG_PWM_GET_H_BRIDGE</span> <span class="o">=</span> <span class="mi">5004</span>
	<span class="p">};</span>

	<span class="k">enum</span> <span class="n">comedi_io_direction</span> <span class="p">{</span>
		<span class="n">COMEDI_INPUT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">COMEDI_OUTPUT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">COMEDI_OPENDRAIN</span> <span class="o">=</span> <span class="mi">2</span>
	<span class="p">};</span>

	<span class="k">enum</span> <span class="n">comedi_support_level</span> <span class="p">{</span>
		<span class="n">COMEDI_UNKNOWN_SUPPORT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">COMEDI_SUPPORTED</span><span class="p">,</span>
		<span class="n">COMEDI_UNSUPPORTED</span>
	<span class="p">};</span>

<span class="cm">/* ioctls */</span>

<span class="cp">#define CIO &#39;d&#39;</span>
<span class="cp">#define COMEDI_DEVCONFIG _IOW(CIO, 0, struct comedi_devconfig)</span>
<span class="cp">#define COMEDI_DEVINFO _IOR(CIO, 1, struct comedi_devinfo)</span>
<span class="cp">#define COMEDI_SUBDINFO _IOR(CIO, 2, struct comedi_subdinfo)</span>
<span class="cp">#define COMEDI_CHANINFO _IOR(CIO, 3, struct comedi_chaninfo)</span>
<span class="cp">#define COMEDI_TRIG _IOWR(CIO, 4, comedi_trig)</span>
<span class="cp">#define COMEDI_LOCK _IO(CIO, 5)</span>
<span class="cp">#define COMEDI_UNLOCK _IO(CIO, 6)</span>
<span class="cp">#define COMEDI_CANCEL _IO(CIO, 7)</span>
<span class="cp">#define COMEDI_RANGEINFO _IOR(CIO, 8, struct comedi_rangeinfo)</span>
<span class="cp">#define COMEDI_CMD _IOR(CIO, 9, struct comedi_cmd)</span>
<span class="cp">#define COMEDI_CMDTEST _IOR(CIO, 10, struct comedi_cmd)</span>
<span class="cp">#define COMEDI_INSNLIST _IOR(CIO, 11, struct comedi_insnlist)</span>
<span class="cp">#define COMEDI_INSN _IOR(CIO, 12, struct comedi_insn)</span>
<span class="cp">#define COMEDI_BUFCONFIG _IOR(CIO, 13, struct comedi_bufconfig)</span>
<span class="cp">#define COMEDI_BUFINFO _IOWR(CIO, 14, struct comedi_bufinfo)</span>
<span class="cp">#define COMEDI_POLL _IO(CIO, 15)</span>

<span class="cm">/* structures */</span>

	<span class="k">struct</span> <span class="n">comedi_trig</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdev</span><span class="p">;</span>	<span class="cm">/* subdevice */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>	<span class="cm">/* mode */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_chan</span><span class="p">;</span>	<span class="cm">/* number of channels */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">chanlist</span><span class="p">;</span>	<span class="cm">/* channel/range list */</span>
		<span class="kt">short</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>	<span class="cm">/* data list, size depends on subd flags */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>	<span class="cm">/* number of scans */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trigsrc</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trigvar</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trigvar1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdev</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chanspec</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_insnlist</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_insns</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">comedi_insn</span> <span class="n">__user</span> <span class="o">*</span><span class="n">insns</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_cmd</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdev</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start_src</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start_arg</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_begin_src</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_begin_arg</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">convert_src</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">convert_arg</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_end_src</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_end_arg</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stop_src</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stop_arg</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">chanlist</span><span class="p">;</span>	<span class="cm">/* channel/range list */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chanlist_len</span><span class="p">;</span>

		<span class="kt">short</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span> <span class="cm">/* data list, size depends on subd flags */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_chaninfo</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdev</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">maxdata_list</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">flaglist</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rangelist</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_rangeinfo</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range_type</span><span class="p">;</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">range_ptr</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_krange</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">min</span><span class="p">;</span>	<span class="cm">/* fixed point, multiply by 1e-6 */</span>
		<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>	<span class="cm">/* fixed point, multiply by 1e-6 */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_subdinfo</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_chan</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subd_flags</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_type</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len_chanlist</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxdata</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* channel flags */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range_type</span><span class="p">;</span>	<span class="cm">/* lookup in kernel */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">settling_time_0</span><span class="p">;</span>
		<span class="cm">/* see support_level enum for values */</span>
		<span class="kt">unsigned</span> <span class="n">insn_bits_support</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_devinfo</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">version_code</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_subdevs</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">driver_name</span><span class="p">[</span><span class="n">COMEDI_NAMELEN</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">board_name</span><span class="p">[</span><span class="n">COMEDI_NAMELEN</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">read_subdevice</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">write_subdevice</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_devconfig</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">board_name</span><span class="p">[</span><span class="n">COMEDI_NAMELEN</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">options</span><span class="p">[</span><span class="n">COMEDI_NDEVCONFOPTS</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_bufconfig</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevice</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maximum_size</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">comedi_bufinfo</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevice</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_read</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_write_ptr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_read_ptr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_write_count</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_read_count</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_written</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">};</span>

<span class="cm">/* range stuff */</span>

<span class="cp">#define __RANGE(a, b)	((((a)&amp;0xffff)&lt;&lt;16)|((b)&amp;0xffff))</span>

<span class="cp">#define RANGE_OFFSET(a)		(((a)&gt;&gt;16)&amp;0xffff)</span>
<span class="cp">#define RANGE_LENGTH(b)		((b)&amp;0xffff)</span>

<span class="cp">#define RF_UNIT(flags)		((flags)&amp;0xff)</span>
<span class="cp">#define RF_EXTERNAL		(1&lt;&lt;8)</span>

<span class="cp">#define UNIT_volt		0</span>
<span class="cp">#define UNIT_mA			1</span>
<span class="cp">#define UNIT_none		2</span>

<span class="cp">#define COMEDI_MIN_SPEED	((unsigned int)0xffffffff)</span>

<span class="cm">/* callback stuff */</span>
<span class="cm">/* only relevant to kernel modules. */</span>

<span class="cp">#define COMEDI_CB_EOS		1	</span><span class="cm">/* end of scan */</span><span class="cp"></span>
<span class="cp">#define COMEDI_CB_EOA		2	</span><span class="cm">/* end of acquisition/output */</span><span class="cp"></span>
<span class="cp">#define COMEDI_CB_BLOCK		4	</span><span class="cm">/* data has arrived:</span>
<span class="cm">					 * wakes up read() / write() */</span><span class="cp"></span>
<span class="cp">#define COMEDI_CB_EOBUF		8	</span><span class="cm">/* DEPRECATED: end of buffer */</span><span class="cp"></span>
<span class="cp">#define COMEDI_CB_ERROR		16	</span><span class="cm">/* card error during acquisition */</span><span class="cp"></span>
<span class="cp">#define COMEDI_CB_OVERFLOW	32	</span><span class="cm">/* buffer overflow/underflow */</span><span class="cp"></span>

<span class="cm">/**********************************************************/</span>
<span class="cm">/* everything after this line is ALPHA */</span>
<span class="cm">/**********************************************************/</span>

<span class="cm">/*</span>
<span class="cm">  8254 specific configuration.</span>

<span class="cm">  It supports two config commands:</span>

<span class="cm">  0 ID: INSN_CONFIG_SET_COUNTER_MODE</span>
<span class="cm">  1 8254 Mode</span>
<span class="cm">    I8254_MODE0, I8254_MODE1, ..., I8254_MODE5</span>
<span class="cm">    OR&#39;ed with:</span>
<span class="cm">    I8254_BCD, I8254_BINARY</span>

<span class="cm">  0 ID: INSN_CONFIG_8254_READ_STATUS</span>
<span class="cm">  1 &lt;-- Status byte returned here.</span>
<span class="cm">    B7 = Output</span>
<span class="cm">    B6 = NULL Count</span>
<span class="cm">    B5 - B0 Current mode.</span>

<span class="cm">*/</span>

	<span class="k">enum</span> <span class="n">i8254_mode</span> <span class="p">{</span>
		<span class="n">I8254_MODE0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* Interrupt on terminal count */</span>
		<span class="n">I8254_MODE1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* Hardware retriggerable one-shot */</span>
		<span class="n">I8254_MODE2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* Rate generator */</span>
		<span class="n">I8254_MODE3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* Square wave mode */</span>
		<span class="n">I8254_MODE4</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* Software triggered strobe */</span>
		<span class="n">I8254_MODE5</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* Hardware triggered strobe</span>
<span class="cm">					 * (retriggerable) */</span>
		<span class="n">I8254_BCD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* use binary-coded decimal instead of binary</span>
<span class="cm">				 * (pretty useless) */</span>
		<span class="n">I8254_BINARY</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_USUAL_PFI_SELECT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pfi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfi_channel</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
			<span class="k">return</span> <span class="mh">0x1</span> <span class="o">+</span> <span class="n">pfi_channel</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">pfi_channel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_USUAL_RTSI_SELECT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">rtsi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtsi_channel</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">)</span>
			<span class="k">return</span> <span class="mh">0xb</span> <span class="o">+</span> <span class="n">rtsi_channel</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mh">0x1b</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* mode bits for NI general-purpose counters, set with</span>
<span class="cm"> * INSN_CONFIG_SET_COUNTER_MODE */</span>
<span class="cp">#define NI_GPCT_COUNTING_MODE_SHIFT 16</span>
<span class="cp">#define NI_GPCT_INDEX_PHASE_BITSHIFT 20</span>
<span class="cp">#define NI_GPCT_COUNTING_DIRECTION_SHIFT 24</span>
	<span class="k">enum</span> <span class="n">ni_gpct_mode_bits</span> <span class="p">{</span>
		<span class="n">NI_GPCT_GATE_ON_BOTH_EDGES_BIT</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
		<span class="n">NI_GPCT_EDGE_GATE_MODE_MASK</span> <span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span>
		<span class="n">NI_GPCT_EDGE_GATE_STARTS_STOPS_BITS</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">NI_GPCT_EDGE_GATE_STOPS_STARTS_BITS</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
		<span class="n">NI_GPCT_EDGE_GATE_STARTS_BITS</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
		<span class="n">NI_GPCT_EDGE_GATE_NO_STARTS_NO_STOPS_BITS</span> <span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span>
		<span class="n">NI_GPCT_STOP_MODE_MASK</span> <span class="o">=</span> <span class="mh">0x60</span><span class="p">,</span>
		<span class="n">NI_GPCT_STOP_ON_GATE_BITS</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
		<span class="n">NI_GPCT_STOP_ON_GATE_OR_TC_BITS</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
		<span class="n">NI_GPCT_STOP_ON_GATE_OR_SECOND_TC_BITS</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
		<span class="n">NI_GPCT_LOAD_B_SELECT_BIT</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
		<span class="n">NI_GPCT_OUTPUT_MODE_MASK</span> <span class="o">=</span> <span class="mh">0x300</span><span class="p">,</span>
		<span class="n">NI_GPCT_OUTPUT_TC_PULSE_BITS</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
		<span class="n">NI_GPCT_OUTPUT_TC_TOGGLE_BITS</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
		<span class="n">NI_GPCT_OUTPUT_TC_OR_GATE_TOGGLE_BITS</span> <span class="o">=</span> <span class="mh">0x300</span><span class="p">,</span>
		<span class="n">NI_GPCT_HARDWARE_DISARM_MASK</span> <span class="o">=</span> <span class="mh">0xc00</span><span class="p">,</span>
		<span class="n">NI_GPCT_NO_HARDWARE_DISARM_BITS</span> <span class="o">=</span> <span class="mh">0x000</span><span class="p">,</span>
		<span class="n">NI_GPCT_DISARM_AT_TC_BITS</span> <span class="o">=</span> <span class="mh">0x400</span><span class="p">,</span>
		<span class="n">NI_GPCT_DISARM_AT_GATE_BITS</span> <span class="o">=</span> <span class="mh">0x800</span><span class="p">,</span>
		<span class="n">NI_GPCT_DISARM_AT_TC_OR_GATE_BITS</span> <span class="o">=</span> <span class="mh">0xc00</span><span class="p">,</span>
		<span class="n">NI_GPCT_LOADING_ON_TC_BIT</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
		<span class="n">NI_GPCT_LOADING_ON_GATE_BIT</span> <span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_MODE_MASK</span> <span class="o">=</span> <span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_MODE_NORMAL_BITS</span> <span class="o">=</span>
		    <span class="mh">0x0</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_MODE_QUADRATURE_X1_BITS</span> <span class="o">=</span>
		    <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_MODE_QUADRATURE_X2_BITS</span> <span class="o">=</span>
		    <span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_MODE_QUADRATURE_X4_BITS</span> <span class="o">=</span>
		    <span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_MODE_TWO_PULSE_BITS</span> <span class="o">=</span>
		    <span class="mh">0x4</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_MODE_SYNC_SOURCE_BITS</span> <span class="o">=</span>
		    <span class="mh">0x6</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_MODE_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_INDEX_PHASE_MASK</span> <span class="o">=</span> <span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_INDEX_PHASE_BITSHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_INDEX_PHASE_LOW_A_LOW_B_BITS</span> <span class="o">=</span>
		    <span class="mh">0x0</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_INDEX_PHASE_BITSHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_INDEX_PHASE_LOW_A_HIGH_B_BITS</span> <span class="o">=</span>
		    <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_INDEX_PHASE_BITSHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_INDEX_PHASE_HIGH_A_LOW_B_BITS</span> <span class="o">=</span>
		    <span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_INDEX_PHASE_BITSHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_INDEX_PHASE_HIGH_A_HIGH_B_BITS</span> <span class="o">=</span>
		    <span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_INDEX_PHASE_BITSHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_INDEX_ENABLE_BIT</span> <span class="o">=</span> <span class="mh">0x400000</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_DIRECTION_MASK</span> <span class="o">=</span>
		    <span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_DIRECTION_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_DIRECTION_DOWN_BITS</span> <span class="o">=</span>
		    <span class="mh">0x00</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_DIRECTION_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_DIRECTION_UP_BITS</span> <span class="o">=</span>
		    <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_DIRECTION_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_DIRECTION_HW_UP_DOWN_BITS</span> <span class="o">=</span>
		    <span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_DIRECTION_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_COUNTING_DIRECTION_HW_GATE_BITS</span> <span class="o">=</span>
		    <span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">NI_GPCT_COUNTING_DIRECTION_SHIFT</span><span class="p">,</span>
		<span class="n">NI_GPCT_RELOAD_SOURCE_MASK</span> <span class="o">=</span> <span class="mh">0xc000000</span><span class="p">,</span>
		<span class="n">NI_GPCT_RELOAD_SOURCE_FIXED_BITS</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS</span> <span class="o">=</span> <span class="mh">0x4000000</span><span class="p">,</span>
		<span class="n">NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS</span> <span class="o">=</span> <span class="mh">0x8000000</span><span class="p">,</span>
		<span class="n">NI_GPCT_OR_GATE_BIT</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
		<span class="n">NI_GPCT_INVERT_OUTPUT_BIT</span> <span class="o">=</span> <span class="mh">0x20000000</span>
	<span class="p">};</span>

<span class="cm">/* Bits for setting a clock source with</span>
<span class="cm"> * INSN_CONFIG_SET_CLOCK_SRC when using NI general-purpose counters. */</span>
	<span class="k">enum</span> <span class="n">ni_gpct_clock_source_bits</span> <span class="p">{</span>
		<span class="n">NI_GPCT_CLOCK_SRC_SELECT_MASK</span> <span class="o">=</span> <span class="mh">0x3f</span><span class="p">,</span>
		<span class="n">NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
		<span class="n">NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
		<span class="n">NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
		<span class="n">NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
		<span class="n">NI_GPCT_NEXT_TC_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>
		<span class="cm">/* NI 660x-specific */</span>
		<span class="n">NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span>
		<span class="n">NI_GPCT_PXI10_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>
		<span class="n">NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
		<span class="n">NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x9</span><span class="p">,</span>
		<span class="n">NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK</span> <span class="o">=</span> <span class="mh">0x30000000</span><span class="p">,</span>
		<span class="n">NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="cm">/* divide source by 2 */</span>
		<span class="n">NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
		<span class="cm">/* divide source by 8 */</span>
		<span class="n">NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>
		<span class="n">NI_GPCT_INVERT_CLOCK_SRC_BIT</span> <span class="o">=</span> <span class="mh">0x80000000</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* NI 660x-specific */</span>
		<span class="k">return</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_RTSI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mh">0x18</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_PFI_CLOCK_SRC_BITS</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* no pfi on NI 660x */</span>
		<span class="k">return</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* Possibilities for setting a gate source with</span>
<span class="cm">INSN_CONFIG_SET_GATE_SRC when using NI general-purpose counters.</span>
<span class="cm">May be bitwise-or&#39;d with CR_EDGE or CR_INVERT. */</span>
	<span class="k">enum</span> <span class="n">ni_gpct_gate_select</span> <span class="p">{</span>
		<span class="cm">/* m-series gates */</span>
		<span class="n">NI_GPCT_TIMESTAMP_MUX_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">NI_GPCT_AI_START2_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>
		<span class="n">NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
		<span class="n">NI_GPCT_NEXT_OUT_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
		<span class="n">NI_GPCT_AI_START1_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x1c</span><span class="p">,</span>
		<span class="n">NI_GPCT_NEXT_SOURCE_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x1d</span><span class="p">,</span>
		<span class="n">NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x1e</span><span class="p">,</span>
		<span class="n">NI_GPCT_LOGIC_LOW_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>
		<span class="cm">/* more gates for 660x */</span>
		<span class="n">NI_GPCT_SOURCE_PIN_i_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
		<span class="n">NI_GPCT_GATE_PIN_i_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x101</span><span class="p">,</span>
		<span class="cm">/* more gates for 660x &quot;second gate&quot; */</span>
		<span class="n">NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x201</span><span class="p">,</span>
		<span class="n">NI_GPCT_SELECTED_GATE_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x21e</span><span class="p">,</span>
		<span class="cm">/* m-series &quot;second gate&quot; sources are unknown,</span>
<span class="cm">		 * we should add them here with an offset of 0x300 when</span>
<span class="cm">		 * known. */</span>
		<span class="n">NI_GPCT_DISABLED_GATE_SELECT</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_GATE_PIN_GATE_SELECT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mh">0x102</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_RTSI_GATE_SELECT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_RTSI_SELECT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_PFI_GATE_SELECT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_PFI_SELECT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_UP_DOWN_PIN_GATE_SELECT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mh">0x202</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* Possibilities for setting a source with</span>
<span class="cm">INSN_CONFIG_SET_OTHER_SRC when using NI general-purpose counters. */</span>
	<span class="k">enum</span> <span class="n">ni_gpct_other_index</span> <span class="p">{</span>
		<span class="n">NI_GPCT_SOURCE_ENCODER_A</span><span class="p">,</span>
		<span class="n">NI_GPCT_SOURCE_ENCODER_B</span><span class="p">,</span>
		<span class="n">NI_GPCT_SOURCE_ENCODER_Z</span>
	<span class="p">};</span>
	<span class="k">enum</span> <span class="n">ni_gpct_other_select</span> <span class="p">{</span>
		<span class="cm">/* m-series gates */</span>
		<span class="cm">/* Still unknown, probably only need NI_GPCT_PFI_OTHER_SELECT */</span>
		<span class="n">NI_GPCT_DISABLED_OTHER_SELECT</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_GPCT_PFI_OTHER_SELECT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_PFI_SELECT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cm">/* start sources for ni general-purpose counters for use with</span>
<span class="cm">INSN_CONFIG_ARM */</span>
	<span class="k">enum</span> <span class="n">ni_gpct_arm_source</span> <span class="p">{</span>
		<span class="n">NI_GPCT_ARM_IMMEDIATE</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">NI_GPCT_ARM_PAIRED_IMMEDIATE</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span> <span class="cm">/* Start both the counter</span>
<span class="cm">						     * and the adjacent paired</span>
<span class="cm">						     * counter simultaneously */</span>
		<span class="cm">/* NI doesn&#39;t document bits for selecting hardware arm triggers.</span>
<span class="cm">		 * If the NI_GPCT_ARM_UNKNOWN bit is set, we will pass the least</span>
<span class="cm">		 * significant bits (3 bits for 660x or 5 bits for m-series)</span>
<span class="cm">		 * through to the hardware.  This will at least allow someone to</span>
<span class="cm">		 * figure out what the bits do later. */</span>
		<span class="n">NI_GPCT_ARM_UNKNOWN</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="p">};</span>

<span class="cm">/* digital filtering options for ni 660x for use with INSN_CONFIG_FILTER. */</span>
	<span class="k">enum</span> <span class="n">ni_gpct_filter_select</span> <span class="p">{</span>
		<span class="n">NI_GPCT_FILTER_OFF</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">NI_GPCT_FILTER_TIMEBASE_3_SYNC</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
		<span class="n">NI_GPCT_FILTER_100x_TIMEBASE_1</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
		<span class="n">NI_GPCT_FILTER_20x_TIMEBASE_1</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
		<span class="n">NI_GPCT_FILTER_10x_TIMEBASE_1</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
		<span class="n">NI_GPCT_FILTER_2x_TIMEBASE_1</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>
		<span class="n">NI_GPCT_FILTER_2x_TIMEBASE_3</span> <span class="o">=</span> <span class="mh">0x6</span>
	<span class="p">};</span>

<span class="cm">/* PFI digital filtering options for ni m-series for use with</span>
<span class="cm"> * INSN_CONFIG_FILTER. */</span>
	<span class="k">enum</span> <span class="n">ni_pfi_filter_select</span> <span class="p">{</span>
		<span class="n">NI_PFI_FILTER_OFF</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">NI_PFI_FILTER_125ns</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
		<span class="n">NI_PFI_FILTER_6425ns</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
		<span class="n">NI_PFI_FILTER_2550us</span> <span class="o">=</span> <span class="mh">0x3</span>
	<span class="p">};</span>

<span class="cm">/* master clock sources for ni mio boards and INSN_CONFIG_SET_CLOCK_SRC */</span>
	<span class="k">enum</span> <span class="n">ni_mio_clock_source</span> <span class="p">{</span>
		<span class="n">NI_MIO_INTERNAL_CLOCK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">NI_MIO_RTSI_CLOCK</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* doesn&#39;t work for m-series, use</span>
<span class="cm">					   NI_MIO_PLL_RTSI_CLOCK() */</span>
		<span class="cm">/* the NI_MIO_PLL_* sources are m-series only */</span>
		<span class="n">NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">NI_MIO_PLL_PXI10_CLOCK</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="n">NI_MIO_PLL_RTSI0_CLOCK</span> <span class="o">=</span> <span class="mi">4</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_MIO_PLL_RTSI_CLOCK</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">rtsi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_MIO_PLL_RTSI0_CLOCK</span> <span class="o">+</span> <span class="n">rtsi_channel</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* Signals which can be routed to an NI RTSI pin with INSN_CONFIG_SET_ROUTING.</span>
<span class="cm"> The numbers assigned are not arbitrary, they correspond to the bits required</span>
<span class="cm"> to program the board. */</span>
	<span class="k">enum</span> <span class="n">ni_rtsi_routing</span> <span class="p">{</span>
		<span class="n">NI_RTSI_OUTPUT_ADR_START1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_ADR_START2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_SCLKG</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_DACUPDN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_DA_START1</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_G_SRC0</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_G_GATE0</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_RGOUT0</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_RTSI_BRD_0</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="n">NI_RTSI_OUTPUT_RTSI_OSC</span> <span class="o">=</span> <span class="mi">12</span>	<span class="cm">/* pre-m-series always have RTSI</span>
<span class="cm">						 * clock on line 7 */</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_RTSI_OUTPUT_RTSI_BRD</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_RTSI_OUTPUT_RTSI_BRD_0</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* Signals which can be routed to an NI PFI pin on an m-series board with</span>
<span class="cm"> * INSN_CONFIG_SET_ROUTING.  These numbers are also returned by</span>
<span class="cm"> * INSN_CONFIG_GET_ROUTING on pre-m-series boards, even though their routing</span>
<span class="cm"> * cannot be changed.  The numbers assigned are not arbitrary, they correspond</span>
<span class="cm"> * to the bits required to program the board. */</span>
	<span class="k">enum</span> <span class="n">ni_pfi_routing</span> <span class="p">{</span>
		<span class="n">NI_PFI_OUTPUT_PFI_DEFAULT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_AI_START1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_AI_START2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_AI_CONVERT</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_G_SRC1</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_G_GATE1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_AO_UPDATE_N</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_AO_START1</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_AI_START_PULSE</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_G_SRC0</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_G_GATE0</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_EXT_STROBE</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_AI_EXT_MUX_CLK</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_GOUT0</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_GOUT1</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_FREQ_OUT</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_PFI_DO</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_I_ATRIG</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_RTSI0</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_PXI_STAR_TRIGGER_IN</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_SCXI_TRIG1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_DIO_CHANGE_DETECT_RTSI</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_CDI_SAMPLE</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
		<span class="n">NI_PFI_OUTPUT_CDO_UPDATE</span> <span class="o">=</span> <span class="mi">30</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_PFI_OUTPUT_RTSI</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">rtsi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_PFI_OUTPUT_RTSI0</span> <span class="o">+</span> <span class="n">rtsi_channel</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* Signals which can be routed to output on a NI PFI pin on a 660x board</span>
<span class="cm"> with INSN_CONFIG_SET_ROUTING.  The numbers assigned are</span>
<span class="cm"> not arbitrary, they correspond to the bits required</span>
<span class="cm"> to program the board.  Lines 0 to 7 can only be set to</span>
<span class="cm"> NI_660X_PFI_OUTPUT_DIO.  Lines 32 to 39 can only be set to</span>
<span class="cm"> NI_660X_PFI_OUTPUT_COUNTER. */</span>
	<span class="k">enum</span> <span class="n">ni_660x_pfi_routing</span> <span class="p">{</span>
		<span class="n">NI_660X_PFI_OUTPUT_COUNTER</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* counter */</span>
		<span class="n">NI_660X_PFI_OUTPUT_DIO</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* static digital output */</span>
	<span class="p">};</span>

<span class="cm">/* NI External Trigger lines.  These values are not arbitrary, but are related</span>
<span class="cm"> * to the bits required to program the board (offset by 1 for historical</span>
<span class="cm"> * reasons). */</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_EXT_PFI</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pfi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_PFI_SELECT</span><span class="p">(</span><span class="n">pfi_channel</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_EXT_RTSI</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">rtsi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_RTSI_SELECT</span><span class="p">(</span><span class="n">rtsi_channel</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/* status bits for INSN_CONFIG_GET_COUNTER_STATUS */</span>
	<span class="k">enum</span> <span class="n">comedi_counter_status_flags</span> <span class="p">{</span>
		<span class="n">COMEDI_COUNTER_ARMED</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
		<span class="n">COMEDI_COUNTER_COUNTING</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
		<span class="n">COMEDI_COUNTER_TERMINAL_COUNT</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="p">};</span>

<span class="cm">/* Clock sources for CDIO subdevice on NI m-series boards.  Used as the</span>
<span class="cm"> * scan_begin_arg for a comedi_command. These sources may also be bitwise-or&#39;d</span>
<span class="cm"> * with CR_INVERT to change polarity. */</span>
	<span class="k">enum</span> <span class="n">ni_m_series_cdio_scan_begin_src</span> <span class="p">{</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_GROUND</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_AI_START</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_AI_CONVERT</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_PXI_STAR_TRIGGER</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_G0_OUT</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_G1_OUT</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_ANALOG_TRIGGER</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_AO_UPDATE</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_FREQ_OUT</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
		<span class="n">NI_CDIO_SCAN_BEGIN_SRC_DIO_CHANGE_DETECT_IRQ</span> <span class="o">=</span> <span class="mi">33</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_CDIO_SCAN_BEGIN_SRC_PFI</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pfi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_PFI_SELECT</span><span class="p">(</span><span class="n">pfi_channel</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
		<span class="nf">NI_CDIO_SCAN_BEGIN_SRC_RTSI</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">rtsi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_RTSI_SELECT</span><span class="p">(</span><span class="n">rtsi_channel</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cm">/* scan_begin_src for scan_begin_arg==TRIG_EXT with analog output command on NI</span>
<span class="cm"> * boards.  These scan begin sources can also be bitwise-or&#39;d with CR_INVERT to</span>
<span class="cm"> * change polarity. */</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_AO_SCAN_BEGIN_SRC_PFI</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pfi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_PFI_SELECT</span><span class="p">(</span><span class="n">pfi_channel</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">NI_AO_SCAN_BEGIN_SRC_RTSI</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">rtsi_channel</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">NI_USUAL_RTSI_SELECT</span><span class="p">(</span><span class="n">rtsi_channel</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cm">/* Bits for setting a clock source with</span>
<span class="cm"> * INSN_CONFIG_SET_CLOCK_SRC when using NI frequency output subdevice. */</span>
	<span class="k">enum</span> <span class="n">ni_freq_out_clock_source_bits</span> <span class="p">{</span>
		<span class="n">NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC</span><span class="p">,</span>	<span class="cm">/* 10 MHz */</span>
		<span class="n">NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC</span>	<span class="cm">/* 100 KHz */</span>
	<span class="p">};</span>

<span class="cm">/* Values for setting a clock source with INSN_CONFIG_SET_CLOCK_SRC for</span>
<span class="cm"> * 8254 counter subdevices on Amplicon DIO boards (amplc_dio200 driver). */</span>
	<span class="k">enum</span> <span class="n">amplc_dio_clock_source</span> <span class="p">{</span>
		<span class="n">AMPLC_DIO_CLK_CLKN</span><span class="p">,</span>	<span class="cm">/* per channel external clock</span>
<span class="cm">					   input/output pin (pin is only an</span>
<span class="cm">					   input when clock source set to this</span>
<span class="cm">					   value, otherwise it is an output) */</span>
		<span class="n">AMPLC_DIO_CLK_10MHZ</span><span class="p">,</span>	<span class="cm">/* 10 MHz internal clock */</span>
		<span class="n">AMPLC_DIO_CLK_1MHZ</span><span class="p">,</span>	<span class="cm">/* 1 MHz internal clock */</span>
		<span class="n">AMPLC_DIO_CLK_100KHZ</span><span class="p">,</span>	<span class="cm">/* 100 kHz internal clock */</span>
		<span class="n">AMPLC_DIO_CLK_10KHZ</span><span class="p">,</span>	<span class="cm">/* 10 kHz internal clock */</span>
		<span class="n">AMPLC_DIO_CLK_1KHZ</span><span class="p">,</span>	<span class="cm">/* 1 kHz internal clock */</span>
		<span class="n">AMPLC_DIO_CLK_OUTNM1</span><span class="p">,</span>	<span class="cm">/* output of preceding counter channel</span>
<span class="cm">					   (for channel 0, preceding counter</span>
<span class="cm">					   channel is channel 2 on preceding</span>
<span class="cm">					   counter subdevice, for first counter</span>
<span class="cm">					   subdevice, preceding counter</span>
<span class="cm">					   subdevice is the last counter</span>
<span class="cm">					   subdevice) */</span>
		<span class="n">AMPLC_DIO_CLK_EXT</span>	<span class="cm">/* per chip external input pin */</span>
	<span class="p">};</span>

<span class="cm">/* Values for setting a gate source with INSN_CONFIG_SET_GATE_SRC for</span>
<span class="cm"> * 8254 counter subdevices on Amplicon DIO boards (amplc_dio200 driver). */</span>
	<span class="k">enum</span> <span class="n">amplc_dio_gate_source</span> <span class="p">{</span>
		<span class="n">AMPLC_DIO_GAT_VCC</span><span class="p">,</span>	<span class="cm">/* internal high logic level */</span>
		<span class="n">AMPLC_DIO_GAT_GND</span><span class="p">,</span>	<span class="cm">/* internal low logic level */</span>
		<span class="n">AMPLC_DIO_GAT_GATN</span><span class="p">,</span>	<span class="cm">/* per channel external gate input */</span>
		<span class="n">AMPLC_DIO_GAT_NOUTNM2</span><span class="p">,</span>	<span class="cm">/* negated output of counter channel</span>
<span class="cm">					   minus 2 (for channels 0 or 1,</span>
<span class="cm">					   channel minus 2 is channel 1 or 2 on</span>
<span class="cm">					   the preceding counter subdevice, for</span>
<span class="cm">					   the first counter subdevice the</span>
<span class="cm">					   preceding counter subdevice is the</span>
<span class="cm">					   last counter subdevice) */</span>
		<span class="n">AMPLC_DIO_GAT_RESERVED4</span><span class="p">,</span>
		<span class="n">AMPLC_DIO_GAT_RESERVED5</span><span class="p">,</span>
		<span class="n">AMPLC_DIO_GAT_RESERVED6</span><span class="p">,</span>
		<span class="n">AMPLC_DIO_GAT_RESERVED7</span>
	<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* _COMEDI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
