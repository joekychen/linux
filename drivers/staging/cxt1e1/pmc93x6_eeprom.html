<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › cxt1e1 › pmc93x6_eeprom.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pmc93x6_eeprom.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* pmc93x6_eeprom.c - PMC&#39;s 93LC46 EEPROM Device</span>
<span class="cm"> *</span>
<span class="cm"> *    The 93LC46 is a low-power, serial Electrically Erasable and</span>
<span class="cm"> *    Programmable Read Only Memory organized as 128 8-bit bytes.</span>
<span class="cm"> *</span>
<span class="cm"> *    Accesses to the 93LC46 are done in a bit serial stream, organized</span>
<span class="cm"> *    in a 3 wire format.  Writes are internally timed by the device</span>
<span class="cm"> *    (the In data bit is pulled low until the write is complete and</span>
<span class="cm"> *    then is pulled high) and take about 6 milliseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003-2005  SBE, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &quot;pmcc4_sysdep.h&quot;</span>
<span class="cp">#include &quot;sbecom_inline_linux.h&quot;</span>
<span class="cp">#include &quot;pmcc4.h&quot;</span>
<span class="cp">#include &quot;sbe_promformat.h&quot;</span>

<span class="cp">#ifndef TRUE</span>
<span class="cp">#define TRUE   1</span>
<span class="cp">#define FALSE  0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SBE_INCLUDE_SYMBOLS</span>
<span class="cp">#define STATIC</span>
<span class="cp">#else</span>
<span class="cp">#define STATIC  static</span>
<span class="cp">#endif</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      EEPROM address definitions</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      The offset in the definitions below allows the test to skip over</span>
<span class="cm"> *      areas of the EEPROM that other programs (such a VxWorks) are</span>
<span class="cm"> *      using.</span>
<span class="cm"> */</span>

<span class="cp">#define EE_MFG      (long)0     </span><span class="cm">/* Index to manufacturing record */</span><span class="cp"></span>
<span class="cp">#define EE_FIRST    0x28        </span><span class="cm">/* Index to start testing at */</span><span class="cp"></span>
<span class="cp">#define EE_LIMIT    128         </span><span class="cm">/* Index to end testing at */</span><span class="cp"></span>


<span class="cm">/*  Bit Ordering for Instructions</span>
<span class="cm">**</span>
<span class="cm">**  A0, A1, A2, A3, A4, A5, A6, OP0, OP1, SB   (lsb, or 1st bit out)</span>
<span class="cm">**</span>
<span class="cm">*/</span>

<span class="cp">#define EPROM_EWEN      0x0019  </span><span class="cm">/* Erase/Write enable (reversed) */</span><span class="cp"></span>
<span class="cp">#define EPROM_EWDS      0x0001  </span><span class="cm">/* Erase/Write disable (reversed) */</span><span class="cp"></span>
<span class="cp">#define EPROM_READ      0x0003  </span><span class="cm">/* Read (reversed) */</span><span class="cp"></span>
<span class="cp">#define EPROM_WRITE     0x0005  </span><span class="cm">/* Write (reversed) */</span><span class="cp"></span>
<span class="cp">#define EPROM_ERASE     0x0007  </span><span class="cm">/* Erase (reversed) */</span><span class="cp"></span>
<span class="cp">#define EPROM_ERAL      0x0009  </span><span class="cm">/* Erase All (reversed) */</span><span class="cp"></span>
<span class="cp">#define EPROM_WRAL      0x0011  </span><span class="cm">/* Write All (reversed) */</span><span class="cp"></span>

<span class="cp">#define EPROM_ADR_SZ    7       </span><span class="cm">/* Number of bits in offset address */</span><span class="cp"></span>
<span class="cp">#define EPROM_OP_SZ     3       </span><span class="cm">/* Number of bits in command */</span><span class="cp"></span>
<span class="cp">#define SIZE_ADDR_OP    (EPROM_ADR_SZ + EPROM_OP_SZ)</span>
<span class="cp">#define LC46A_MAX_OPS   10      </span><span class="cm">/* Number of bits in Instruction */</span><span class="cp"></span>
<span class="cp">#define NUM_OF_BITS     8       </span><span class="cm">/* Number of bits in data */</span><span class="cp"></span>


<span class="cm">/* EEPROM signal bits */</span>
<span class="cp">#define EPROM_ACTIVE_OUT_BIT    0x0001  </span><span class="cm">/* Out data bit */</span><span class="cp"></span>
<span class="cp">#define EPROM_ACTIVE_IN_BIT     0x0002  </span><span class="cm">/* In data bit */</span><span class="cp"></span>
<span class="cp">#define ACTIVE_IN_BIT_SHIFT     0x0001  </span><span class="cm">/* Shift In data bit to LSB */</span><span class="cp"></span>
<span class="cp">#define EPROM_ENCS              0x0004  </span><span class="cm">/* Set EEPROM CS during operation */</span><span class="cp"></span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      The ByteReverse table is used to reverses the 8 bits within a byte</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ByteReverse</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">ByteReverseBuilt</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      mfg_template - initial serial EEPROM data structure</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="kt">short</span>       <span class="n">mfg_template</span><span class="p">[</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">FLD_TYPE2</span><span class="p">)]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">PROM_FORMAT_TYPE2</span><span class="p">,</span>          <span class="cm">/* type; */</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x1A</span><span class="p">,</span>                 <span class="cm">/* length[2]; */</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>     <span class="cm">/* Crc32[4]; */</span>
    <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x76</span><span class="p">,</span>                 <span class="cm">/* Id[2]; */</span>
    <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span>                 <span class="cm">/* SubId[2] E1; */</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xA0</span><span class="p">,</span> <span class="mh">0xD6</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* Serial[6]; */</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>     <span class="cm">/* CreateTime[4]; */</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>     <span class="cm">/* HeatRunTime[4]; */</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>     <span class="cm">/* HeatRunIterations[4]; */</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>     <span class="cm">/* HeatRunErrors[4]; */</span>
<span class="p">};</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      BuildByteReverse - build the 8-bit reverse table</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      The &#39;ByteReverse&#39; table reverses the 8 bits within a byte</span>
<span class="cm"> *      (the MSB becomes the LSB etc.).</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">BuildByteReverse</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span>        <span class="n">half</span><span class="p">;</span>           <span class="cm">/* Used to build by powers to 2 */</span>
    <span class="kt">int</span>         <span class="n">i</span><span class="p">;</span>

    <span class="n">ByteReverse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">half</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">half</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">ByteReverse</span><span class="p">);</span> <span class="n">half</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">half</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">ByteReverse</span><span class="p">[</span><span class="n">half</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">ByteReverse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x80</span> <span class="o">/</span> <span class="n">half</span><span class="p">));</span>

    <span class="n">ByteReverseBuilt</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      eeprom_delay - small delay for EEPROM timing</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">eeprom_delay</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>         <span class="n">timeout</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="n">timeout</span><span class="p">;</span> <span class="o">--</span><span class="n">timeout</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">OS_uwait_dummy</span> <span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      eeprom_put_byte - Send a byte to the EEPROM serially</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      Given the PCI address and the data, this routine serially sends</span>
<span class="cm"> *      the data to the EEPROM.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">eeprom_put_byte</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u_int32_t</span> <span class="n">output</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">EPROM_ACTIVE_OUT_BIT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Get next data bit */</span>
        <span class="n">output</span> <span class="o">|=</span> <span class="n">EPROM_ENCS</span><span class="p">;</span>       <span class="cm">/* Add Chip Select */</span>
        <span class="n">data</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">eeprom_delay</span> <span class="p">();</span>
        <span class="n">pci_write_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>      <span class="cm">/* Output it */</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      eeprom_get_byte - Receive a byte from the EEPROM serially</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      Given the PCI address, this routine serially fetches the data</span>
<span class="cm"> *      from the  EEPROM.</span>
<span class="cm"> */</span>

<span class="n">u_int32_t</span>
<span class="nf">eeprom_get_byte</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u_int32_t</span>   <span class="n">input</span><span class="p">;</span>
    <span class="n">u_int32_t</span>   <span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span>         <span class="n">count</span><span class="p">;</span>

<span class="cm">/*  Start the Reading of DATA</span>
<span class="cm">**</span>
<span class="cm">**  The first read is a dummy as the data is latched in the</span>
<span class="cm">**  EPLD and read on the next read access to the EEPROM.</span>
<span class="cm">*/</span>

    <span class="n">input</span> <span class="o">=</span> <span class="n">pci_read_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">NUM_OF_BITS</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">eeprom_delay</span> <span class="p">();</span>
        <span class="n">input</span> <span class="o">=</span> <span class="n">pci_read_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

        <span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>                 <span class="cm">/* Shift data over */</span>
        <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">input</span> <span class="o">&amp;</span> <span class="n">EPROM_ACTIVE_IN_BIT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      disable_pmc_eeprom - Disable writes to the EEPROM</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      Issue the EEPROM command to disable writes.</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">disable_pmc_eeprom</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">eeprom_put_byte</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">EPROM_EWDS</span><span class="p">,</span> <span class="n">SIZE_ADDR_OP</span><span class="p">);</span>

    <span class="n">pci_write_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>       <span class="cm">/* this removes Chip Select</span>
<span class="cm">                                                 * from EEPROM */</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      enable_pmc_eeprom - Enable writes to the EEPROM</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      Issue the EEPROM command to enable writes.</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">enable_pmc_eeprom</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">eeprom_put_byte</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">EPROM_EWEN</span><span class="p">,</span> <span class="n">SIZE_ADDR_OP</span><span class="p">);</span>

    <span class="n">pci_write_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>       <span class="cm">/* this removes Chip Select</span>
<span class="cm">                                                 * from EEPROM */</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmc_eeprom_read - EEPROM location read</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      Given a EEPROM PCI address and location offset, this routine returns</span>
<span class="cm"> *      the contents of the specified location to the calling routine.</span>
<span class="cm"> */</span>

<span class="n">u_int32_t</span>
<span class="nf">pmc_eeprom_read</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">mem_offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u_int32_t</span>   <span class="n">data</span><span class="p">;</span>           <span class="cm">/* Data from chip */</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ByteReverseBuilt</span><span class="p">)</span>
        <span class="n">BuildByteReverse</span> <span class="p">();</span>

    <span class="n">mem_offset</span> <span class="o">=</span> <span class="n">ByteReverse</span><span class="p">[</span><span class="mh">0x7F</span> <span class="o">&amp;</span> <span class="n">mem_offset</span><span class="p">];</span>        <span class="cm">/* Reverse address */</span>
    <span class="cm">/*</span>
<span class="cm">     * NOTE: The max offset address is 128 or half the reversal table. So the</span>
<span class="cm">     * LSB is always zero and counts as a built in shift of one bit.  So even</span>
<span class="cm">     * though we need to shift 3 bits to make room for the command, we only</span>
<span class="cm">     * need to shift twice more because of the built in shift.</span>
<span class="cm">     */</span>
    <span class="n">mem_offset</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>               <span class="cm">/* Shift for command */</span>
    <span class="n">mem_offset</span> <span class="o">|=</span> <span class="n">EPROM_READ</span><span class="p">;</span>       <span class="cm">/* Add command */</span>

    <span class="n">eeprom_put_byte</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mem_offset</span><span class="p">,</span> <span class="n">SIZE_ADDR_OP</span><span class="p">);</span>   <span class="cm">/* Output chip address */</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">eeprom_get_byte</span> <span class="p">(</span><span class="n">addr</span><span class="p">);</span>  <span class="cm">/* Read chip data */</span>

    <span class="n">pci_write_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>       <span class="cm">/* Remove Chip Select from</span>
<span class="cm">                                                 * EEPROM */</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmc_eeprom_write - EEPROM location write</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      Given a EEPROM PCI address, location offset and value, this</span>
<span class="cm"> *      routine writes the value to the specified location.</span>
<span class="cm"> *</span>
<span class="cm"> *      Note: it is up to the caller to determine if the write</span>
<span class="cm"> *      operation succeeded.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">pmc_eeprom_write</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">mem_offset</span><span class="p">,</span> <span class="n">u_int32_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">volatile</span> <span class="n">u_int32_t</span> <span class="n">temp</span><span class="p">;</span>
    <span class="kt">int</span>         <span class="n">count</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ByteReverseBuilt</span><span class="p">)</span>
        <span class="n">BuildByteReverse</span> <span class="p">();</span>

    <span class="n">mem_offset</span> <span class="o">=</span> <span class="n">ByteReverse</span><span class="p">[</span><span class="mh">0x7F</span> <span class="o">&amp;</span> <span class="n">mem_offset</span><span class="p">];</span>        <span class="cm">/* Reverse address */</span>
    <span class="cm">/*</span>
<span class="cm">     * NOTE: The max offset address is 128 or half the reversal table. So the</span>
<span class="cm">     * LSB is always zero and counts as a built in shift of one bit.  So even</span>
<span class="cm">     * though we need to shift 3 bits to make room for the command, we only</span>
<span class="cm">     * need to shift twice more because of the built in shift.</span>
<span class="cm">     */</span>
    <span class="n">mem_offset</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>               <span class="cm">/* Shift for command */</span>
    <span class="n">mem_offset</span> <span class="o">|=</span> <span class="n">EPROM_WRITE</span><span class="p">;</span>      <span class="cm">/* Add command */</span>

    <span class="n">eeprom_put_byte</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mem_offset</span><span class="p">,</span> <span class="n">SIZE_ADDR_OP</span><span class="p">);</span>   <span class="cm">/* Output chip address */</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">ByteReverse</span><span class="p">[</span><span class="mh">0xFF</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">];</span><span class="cm">/* Reverse data */</span>
    <span class="n">eeprom_put_byte</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">NUM_OF_BITS</span><span class="p">);</span>  <span class="cm">/* Output chip data */</span>

    <span class="n">pci_write_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>       <span class="cm">/* Remove Chip Select from</span>
<span class="cm">                                                 * EEPROM */</span>

<span class="cm">/*</span>
<span class="cm">**  Must see Data In at a low state before completing this transaction.</span>
<span class="cm">**</span>
<span class="cm">**  Afterwards, the data bit will return to a high state, ~6 ms, terminating</span>
<span class="cm">**  the operation.</span>
<span class="cm">*/</span>
    <span class="n">pci_write_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">EPROM_ENCS</span><span class="p">);</span>      <span class="cm">/* Re-enable Chip Select */</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">pci_read_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>    <span class="cm">/* discard first read */</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">pci_read_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">EPROM_ACTIVE_IN_BIT</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">pci_read_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">EPROM_ACTIVE_IN_BIT</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pci_write_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>       <span class="cm">/* Remove Chip Select</span>
<span class="cm">                                                         * from EEPROM */</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="n">temp</span><span class="o">++</span><span class="p">)</span>
            <span class="n">OS_uwait_dummy</span> <span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pci_read_32</span> <span class="p">((</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EPROM_ACTIVE_IN_BIT</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmcGetBuffValue - read the specified value from buffer</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="kt">long</span>
<span class="nf">pmcGetBuffValue</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span>        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span>         <span class="n">index</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">value</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">value</span> <span class="o">|=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmcSetBuffValue - save the specified value to buffer</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">pmcSetBuffValue</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>         <span class="n">index</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ptr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
        <span class="n">value</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmc_eeprom_read_buffer - read EEPROM data into specified buffer</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">pmc_eeprom_read_buffer</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">mem_offset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">*</span><span class="n">dest_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">pmc_eeprom_read</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mem_offset</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmc_eeprom_write_buffer - write EEPROM data from specified buffer</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">pmc_eeprom_write_buffer</span> <span class="p">(</span><span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">mem_offset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">enable_pmc_eeprom</span> <span class="p">(</span><span class="n">addr</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pmc_eeprom_write</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mem_offset</span><span class="o">++</span><span class="p">,</span> <span class="o">*</span><span class="n">dest_ptr</span><span class="o">++</span><span class="p">);</span>

    <span class="n">disable_pmc_eeprom</span> <span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmcCalcCrc - calculate the CRC for the serial EEPROM structure</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="n">u_int32_t</span>
<span class="nf">pmcCalcCrc_T01</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bufp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FLD_TYPE2</span>  <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">;</span>
    <span class="n">u_int32_t</span>   <span class="n">crc</span><span class="p">;</span>            <span class="cm">/* CRC of the structure */</span>

    <span class="cm">/* Calc CRC for type and length fields */</span>
    <span class="n">sbeCrc</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
            <span class="p">(</span><span class="n">u_int32_t</span><span class="p">)</span> <span class="n">STRUCT_OFFSET</span> <span class="p">(</span><span class="n">FLD_TYPE1</span><span class="p">,</span> <span class="n">Crc32</span><span class="p">),</span>
            <span class="p">(</span><span class="n">u_int32_t</span><span class="p">)</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">(</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">crc</span><span class="p">);</span>

<span class="cp">#ifdef EEPROM_TYPE_DEBUG</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;sbeCrc: crc 1 calculated as %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">crc</span><span class="p">);</span> <span class="cm">/* RLD DEBUG */</span>
<span class="cp">#endif</span>
    <span class="k">return</span> <span class="o">~</span><span class="n">crc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u_int32_t</span>
<span class="nf">pmcCalcCrc_T02</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bufp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FLD_TYPE2</span>  <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">;</span>
    <span class="n">u_int32_t</span>   <span class="n">crc</span><span class="p">;</span>            <span class="cm">/* CRC of the structure */</span>

    <span class="cm">/* Calc CRC for type and length fields */</span>
    <span class="n">sbeCrc</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
            <span class="p">(</span><span class="n">u_int32_t</span><span class="p">)</span> <span class="n">STRUCT_OFFSET</span> <span class="p">(</span><span class="n">FLD_TYPE2</span><span class="p">,</span> <span class="n">Crc32</span><span class="p">),</span>
            <span class="p">(</span><span class="n">u_int32_t</span><span class="p">)</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">(</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">crc</span><span class="p">);</span>

    <span class="cm">/* Calc CRC for remaining fields */</span>
    <span class="n">sbeCrc</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">(</span><span class="n">u_int32_t</span><span class="p">)</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">FLD_TYPE2</span><span class="p">)</span> <span class="o">-</span> <span class="n">STRUCT_OFFSET</span> <span class="p">(</span><span class="n">FLD_TYPE2</span><span class="p">,</span> <span class="n">Id</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">u_int32_t</span><span class="p">)</span> <span class="n">crc</span><span class="p">,</span>
            <span class="p">(</span><span class="n">u_int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">crc</span><span class="p">);</span>

<span class="cp">#ifdef EEPROM_TYPE_DEBUG</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;sbeCrc: crc 2 calculated as %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">crc</span><span class="p">);</span> <span class="cm">/* RLD DEBUG */</span>
<span class="cp">#endif</span>
    <span class="k">return</span> <span class="n">crc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------------</span>
<span class="cm"> *      pmc_init_seeprom - initialize the serial EEPROM structure</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *      At the front of the serial EEPROM there is a record that contains</span>
<span class="cm"> *      manufacturing information.  If the info does not already exist, it</span>
<span class="cm"> *      is created.  The only field modifiable by the operator is the</span>
<span class="cm"> *      serial number field.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">pmc_init_seeprom</span> <span class="p">(</span><span class="n">u_int32_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u_int32_t</span> <span class="n">serialNum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PROMFORMAT</span>  <span class="n">buffer</span><span class="p">;</span>         <span class="cm">/* Memory image of structure */</span>
    <span class="n">u_int32_t</span>   <span class="n">crc</span><span class="p">;</span>            <span class="cm">/* CRC of structure */</span>
    <span class="kt">time_t</span>      <span class="n">createTime</span><span class="p">;</span>
    <span class="kt">int</span>         <span class="n">i</span><span class="p">;</span>

    <span class="n">createTime</span> <span class="o">=</span> <span class="n">get_seconds</span> <span class="p">();</span>

    <span class="cm">/* use template data */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">FLD_TYPE2</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">buffer</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mfg_template</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="cm">/* Update serial number field in buffer */</span>
    <span class="n">pmcSetBuffValue</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">.</span><span class="n">fldType2</span><span class="p">.</span><span class="n">Serial</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">serialNum</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="cm">/* Update create time field in buffer */</span>
    <span class="n">pmcSetBuffValue</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">.</span><span class="n">fldType2</span><span class="p">.</span><span class="n">CreateTime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">createTime</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="cm">/* Update CRC field in buffer */</span>
    <span class="n">crc</span> <span class="o">=</span> <span class="n">pmcCalcCrc_T02</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="n">pmcSetBuffValue</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">.</span><span class="n">fldType2</span><span class="p">.</span><span class="n">Crc32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">crc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">FLD_TYPE2</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;[%02X] = %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">buffer</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="cm">/* Write structure to serial EEPROM */</span>
    <span class="n">pmc_eeprom_write_buffer</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">EE_MFG</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">FLD_TYPE2</span><span class="p">));</span>
<span class="p">}</span>


<span class="kt">char</span>
<span class="nf">pmc_verify_cksum</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bufp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FLD_TYPE1</span>  <span class="o">*</span><span class="n">buf1</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">;</span>
    <span class="n">FLD_TYPE2</span>  <span class="o">*</span><span class="n">buf2</span> <span class="o">=</span> <span class="n">bufp</span><span class="p">;</span>
    <span class="n">u_int32_t</span>   <span class="n">crc1</span><span class="p">,</span> <span class="n">crc2</span><span class="p">;</span>     <span class="cm">/* CRC read from EEPROM */</span>

    <span class="cm">/* Retrieve contents of CRC field */</span>
    <span class="n">crc1</span> <span class="o">=</span> <span class="n">pmcGetBuffValue</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buf1</span><span class="o">-&gt;</span><span class="n">Crc32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">buf1</span><span class="o">-&gt;</span><span class="n">Crc32</span><span class="p">));</span>
<span class="cp">#ifdef EEPROM_TYPE_DEBUG</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;EEPROM: chksum 1 reads   as %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">crc1</span><span class="p">);</span>        <span class="cm">/* RLD DEBUG */</span>
<span class="cp">#endif</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">buf1</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PROM_FORMAT_TYPE1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">pmcCalcCrc_T01</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf1</span><span class="p">)</span> <span class="o">==</span> <span class="n">crc1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PROM_FORMAT_TYPE1</span><span class="p">;</span>   <span class="cm">/* checksum type 1 verified */</span>

    <span class="n">crc2</span> <span class="o">=</span> <span class="n">pmcGetBuffValue</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buf2</span><span class="o">-&gt;</span><span class="n">Crc32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">buf2</span><span class="o">-&gt;</span><span class="n">Crc32</span><span class="p">));</span>
<span class="cp">#ifdef EEPROM_TYPE_DEBUG</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;EEPROM: chksum 2 reads   as %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">crc2</span><span class="p">);</span>        <span class="cm">/* RLD DEBUG */</span>
<span class="cp">#endif</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">buf2</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PROM_FORMAT_TYPE2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">pmcCalcCrc_T02</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf2</span><span class="p">)</span> <span class="o">==</span> <span class="n">crc2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PROM_FORMAT_TYPE2</span><span class="p">;</span>   <span class="cm">/* checksum type 2 verified */</span>

    <span class="k">return</span> <span class="n">PROM_FORMAT_Unk</span><span class="p">;</span>         <span class="cm">/* failed to validate */</span>
<span class="p">}</span>


<span class="cm">/*** End-of-File ***/</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
