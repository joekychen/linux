<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › winbond › wb35reg.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>wb35reg.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &quot;wb35reg_f.h&quot;</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">phy_calibration_winbond</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">phw_data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">frequency</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * true  : read command process successfully</span>
<span class="cm"> * false : register not support</span>
<span class="cm"> * RegisterNo : start base</span>
<span class="cm"> * pRegisterData : data point</span>
<span class="cm"> * NumberOfData : number of register data</span>
<span class="cm"> * Flag : AUTO_INCREMENT - RegisterNo will auto increment 4</span>
<span class="cm"> *	  NO_INCREMENT - Function will write data into the same register</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Wb35Reg_BurstWrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pRegisterData</span><span class="p">,</span> <span class="n">u8</span> <span class="n">NumberOfData</span><span class="p">,</span> <span class="n">u8</span> <span class="n">Flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span>		<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg_queue</span>	<span class="o">*</span><span class="n">reg_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">UrbSize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">i</span><span class="p">,</span> <span class="n">DataSize</span> <span class="o">=</span> <span class="n">NumberOfData</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Module shutdown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Trying to use burst write function if use new hardware */</span>
	<span class="n">UrbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">)</span> <span class="o">+</span> <span class="n">DataSize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">);</span>
	<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">UrbSize</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">&amp;&amp;</span> <span class="n">reg_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">DIRECT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* burst write register */</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">INDEX</span> <span class="o">=</span> <span class="n">RegisterNo</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">reg_queue</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pBuffer</span><span class="p">,</span> <span class="n">pRegisterData</span><span class="p">,</span> <span class="n">DataSize</span><span class="p">);</span>
		<span class="cm">/* the function for reversing register data from little endian to big endian */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumberOfData</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">dr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">reg_queue</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">)</span> <span class="o">+</span> <span class="n">DataSize</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">;</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span> <span class="cm">/* USB or vendor-defined request code, burst mode */</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">Flag</span><span class="p">);</span> <span class="cm">/* 0: Register number auto-increment, 1: No auto increment */</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">RegisterNo</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DataSize</span><span class="p">);</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pUsbReq</span> <span class="o">=</span> <span class="n">dr</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

		<span class="cm">/* Start EP0VM */</span>
		<span class="n">Wb35Reg_EP0VM_start</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span>
			<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">reg_queue</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
   <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Wb35Reg_Update</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">,</span>  <span class="n">u16</span> <span class="n">RegisterNo</span><span class="p">,</span>  <span class="n">u32</span> <span class="n">RegisterValue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">RegisterNo</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x3b0</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">U1B0</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x3bc</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">U1BC_LEDConfigure</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x400</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">D00_DmaControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x800</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M00_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x804</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M04_MulticastAddress1</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x808</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M08_MulticastAddress2</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x824</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M24_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x828</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M28_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x82c</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M2C_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x838</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M38_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x840</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M40_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x844</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M44_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x848</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M48_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x84c</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M4C_MacStatus</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x860</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M60_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x868</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M68_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x870</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M70_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x874</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M74_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x878</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M78_ERPInformation</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x87C</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M7C_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x880</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M80_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x884</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M84_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x888</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M88_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x898</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">M98_MacControl</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x100c</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB0C</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x102c</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB2C</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1030</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB30</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x103c</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB3C</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1048</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB48</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x104c</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB4C</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1050</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB50</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1054</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB54</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1058</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB58</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x105c</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB5C</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1060</span>: <span class="n">reg</span><span class="o">-&gt;</span><span class="n">BB60</span> <span class="o">=</span> <span class="n">RegisterValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * true  : read command process successfully</span>
<span class="cm"> * false : register not support</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Wb35Reg_WriteSync</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">RegisterValue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Module shutdown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">RegisterValue</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">RegisterValue</span><span class="p">);</span>

	<span class="cm">/* update the register by send usb message */</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">SyncIoPause</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Wait until EP0VM stop */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">!=</span> <span class="n">VM_STOP</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* Sync IoCallDriver */</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_RUNNING</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			       <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			       <span class="mh">0x03</span><span class="p">,</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span> <span class="o">|</span> <span class="n">USB_DIR_OUT</span><span class="p">,</span>
			       <span class="mh">0x0</span><span class="p">,</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RegisterValue</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_STOP</span><span class="p">;</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">SyncIoPause</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Wb35Reg_EP0VM_start</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EP0 Write register usb message sending error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * true  : read command process successfully</span>
<span class="cm"> * false : register not support</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Wb35Reg_Write</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">RegisterValue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span>		<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg_queue</span>	<span class="o">*</span><span class="n">reg_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">UrbSize</span><span class="p">;</span>

	<span class="cm">/* Module shutdown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* update the register by send urb request */</span>
	<span class="n">UrbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">);</span>
	<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">UrbSize</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">&amp;&amp;</span> <span class="n">reg_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">DIRECT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* burst write register */</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">INDEX</span> <span class="o">=</span> <span class="n">RegisterNo</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">VALUE</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">RegisterValue</span><span class="p">);</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">RESERVED_VALID</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">dr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">reg_queue</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">));</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">;</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span> <span class="cm">/* USB or vendor-defined request code, burst mode */</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">RegisterNo</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

		<span class="cm">/* Enter the sending queue */</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pUsbReq</span> <span class="o">=</span> <span class="n">dr</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

		<span class="cm">/* Start EP0VM */</span>
		<span class="n">Wb35Reg_EP0VM_start</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span>
			<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">reg_queue</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This command will be executed with a user defined value. When it completes,</span>
<span class="cm"> * this value is useful. For example, hal_set_current_channel will use it.</span>
<span class="cm"> * true  : read command process successfully</span>
<span class="cm"> * false : register not support</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Wb35Reg_WriteWithCallbackValue</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">,</span>
						<span class="n">u16</span> <span class="n">RegisterNo</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">RegisterValue</span><span class="p">,</span>
						<span class="n">s8</span> <span class="o">*</span><span class="n">pValue</span><span class="p">,</span>
						<span class="n">s8</span> <span class="n">Len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span>		<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg_queue</span>	<span class="o">*</span><span class="n">reg_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">UrbSize</span><span class="p">;</span>

	<span class="cm">/* Module shutdown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* update the register by send urb request */</span>
	<span class="n">UrbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">);</span>
	<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">UrbSize</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">&amp;&amp;</span> <span class="n">reg_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">DIRECT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* burst write register */</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">INDEX</span> <span class="o">=</span> <span class="n">RegisterNo</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">VALUE</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">RegisterValue</span><span class="p">);</span>
		<span class="cm">/* NOTE : Users must guarantee the size of value will not exceed the buffer size. */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">RESERVED</span><span class="p">,</span> <span class="n">pValue</span><span class="p">,</span> <span class="n">Len</span><span class="p">);</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">RESERVED_VALID</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">dr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">reg_queue</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">));</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">;</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span> <span class="cm">/* USB or vendor-defined request code, burst mode */</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">RegisterNo</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

		<span class="cm">/* Enter the sending queue */</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pUsbReq</span> <span class="o">=</span> <span class="n">dr</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

		<span class="cm">/* Start EP0VM */</span>
		<span class="n">Wb35Reg_EP0VM_start</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span>
			<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">reg_queue</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * true  : read command process successfully</span>
<span class="cm"> * false : register not support</span>
<span class="cm"> * pRegisterValue : It must be a resident buffer due to</span>
<span class="cm"> *		    asynchronous read register.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Wb35Reg_ReadSync</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pRegisterValue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="o">*</span><span class="n">pltmp</span> <span class="o">=</span> <span class="n">pRegisterValue</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Module shutdown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Read the register by send usb message */</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">SyncIoPause</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Wait until EP0VM stop */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">!=</span> <span class="n">VM_STOP</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_RUNNING</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			       <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			       <span class="mh">0x01</span><span class="p">,</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span> <span class="o">|</span> <span class="n">USB_DIR_IN</span><span class="p">,</span>
			       <span class="mh">0x0</span><span class="p">,</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="n">pltmp</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

	<span class="o">*</span><span class="n">pRegisterValue</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">pltmp</span><span class="p">);</span>

	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_STOP</span><span class="p">;</span>

	<span class="n">Wb35Reg_Update</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="o">*</span><span class="n">pRegisterValue</span><span class="p">);</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">SyncIoPause</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Wb35Reg_EP0VM_start</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EP0 Read register usb message sending error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * true  : read command process successfully</span>
<span class="cm"> * false : register not support</span>
<span class="cm"> * pRegisterValue : It must be a resident buffer due to</span>
<span class="cm"> *		    asynchronous read register.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Wb35Reg_Read</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegisterNo</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pRegisterValue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span>		<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg_queue</span>	<span class="o">*</span><span class="n">reg_queue</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">UrbSize</span><span class="p">;</span>

	<span class="cm">/* Module shutdown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* update the variable by send Urb to read register */</span>
	<span class="n">UrbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span><span class="p">);</span>
	<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">UrbSize</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">&amp;&amp;</span> <span class="n">reg_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">DIRECT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* read register */</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">INDEX</span> <span class="o">=</span> <span class="n">RegisterNo</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pBuffer</span> <span class="o">=</span> <span class="n">pRegisterValue</span><span class="p">;</span>
		<span class="n">dr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">reg_queue</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">wb35_reg_queue</span><span class="p">));</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequestType</span> <span class="o">=</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span> <span class="o">|</span> <span class="n">USB_DIR_IN</span><span class="p">;</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">bRequest</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* USB or vendor-defined request code, burst mode */</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wIndex</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">RegisterNo</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">wLength</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

		<span class="cm">/* Enter the sending queue */</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pUsbReq</span> <span class="o">=</span> <span class="n">dr</span><span class="p">;</span>
		<span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

		<span class="cm">/* Start EP0VM */</span>
		<span class="n">Wb35Reg_EP0VM_start</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span>
			<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">reg_queue</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">Wb35Reg_EP0VM_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">RegFireCount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_RUNNING</span><span class="p">;</span>
		<span class="n">Wb35Reg_EP0VM</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">RegFireCount</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Wb35Reg_EP0VM</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span>		<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ctrlrequest</span>	<span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="o">*</span><span class="n">pBuffer</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg_queue</span>	<span class="o">*</span><span class="n">reg_queue</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">SyncIoPause</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="cm">/* Get the register data and send to USB through Irp */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
	<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg_queue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="cm">/* Get an Urb, send it */</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">)</span><span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pUsbReq</span><span class="p">;</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
	<span class="n">pBuffer</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">pBuffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">DIRECT</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* output */</span>
		<span class="n">pBuffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">VALUE</span><span class="p">;</span>

	<span class="n">usb_fill_control_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			      <span class="n">REG_DIRECTION</span><span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">reg_queue</span><span class="p">),</span>
			      <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">dr</span><span class="p">,</span> <span class="n">pBuffer</span><span class="p">,</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">),</span>
			      <span class="n">Wb35Reg_EP0VM_complete</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_RUNNING</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EP0 Irp sending error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">cleanup:</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_STOP</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">RegFireCount</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">Wb35Reg_EP0VM_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_data</span>		<span class="o">*</span><span class="n">pHwData</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span>		<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg_queue</span>	<span class="o">*</span><span class="n">reg_queue</span><span class="p">;</span>


	<span class="cm">/* Variable setting */</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_COMPLETED</span><span class="p">;</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Let WbWlanHalt to handle surprise remove */</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_STOP</span><span class="p">;</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">RegFireCount</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Complete to send, remove the URB from the first */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
		<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_queue</span> <span class="o">==</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span><span class="p">)</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EP0 IoCompleteRoutine return error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">=</span> <span class="n">VM_STOP</span><span class="p">;</span>
			<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Success. Update the result */</span>

			<span class="cm">/* Start the next send */</span>
			<span class="n">Wb35Reg_EP0VM</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">reg_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">Wb35Reg_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span>		<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb35_reg_queue</span>	<span class="o">*</span><span class="n">reg_queue</span><span class="p">;</span>

	<span class="n">Uxx_power_off_procedure</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="cm">/* Wait for Reg operation completed */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="cm">/* Delay for waiting function enter */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0vm_state</span> <span class="o">!=</span> <span class="n">VM_STOP</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="cm">/* Delay for waiting function enter */</span>

	<span class="cm">/* Release all the data in RegQueue */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
	<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">reg_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_queue</span> <span class="o">==</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span><span class="p">)</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>

		<span class="n">urb</span> <span class="o">=</span> <span class="n">reg_queue</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">reg_queue</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EP0 queue release error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

		<span class="n">reg_queue</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg_first</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * =======================================================================</span>
<span class="cm"> * The function can be run in passive-level only.</span>
<span class="cm"> * =========================================================================</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">Wb35Reg_initial</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb35_reg</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ltmp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">SoftwareSet</span><span class="p">,</span> <span class="n">VCO_trim</span><span class="p">,</span> <span class="n">TxVga</span><span class="p">,</span> <span class="n">Region_ScanInterval</span><span class="p">;</span>

	<span class="cm">/* Spin lock is acquired for read and write IRP command */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EP0VM_spin_lock</span><span class="p">);</span>

	<span class="cm">/* Getting RF module type from EEPROM */</span>
	<span class="n">Wb35Reg_WriteSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="mh">0x080d0000</span><span class="p">);</span> <span class="cm">/* Start EEPROM access + Read + address(0x0d) */</span>
	<span class="n">Wb35Reg_ReadSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltmp</span><span class="p">);</span>

	<span class="cm">/* Update RF module type and determine the PHY type by inf or EEPROM */</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">ltmp</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * 0 V MAX2825, 1 V MAX2827, 2 V MAX2828, 3 V MAX2829</span>
<span class="cm">	 * 16V AL2230, 17 - AL7230, 18 - AL2230S</span>
<span class="cm">	 * 32 Reserved</span>
<span class="cm">	 * 33 - W89RF242(TxVGA 0~19), 34 - W89RF242(TxVGA 0~34)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">!=</span> <span class="n">RF_DECIDE_BY_INF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_MAXIM_2825</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_MAXIM_2827</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_MAXIM_2828</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_MAXIM_2829</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_MAXIM_V1</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_AIROHA_2230</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_AIROHA_2230S</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_AIROHA_7230</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_WB_242</span><span class="p">)</span>	<span class="o">||</span>
			<span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span> <span class="o">==</span> <span class="n">RF_WB_242_1</span><span class="p">))</span>
			<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMPhyType</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Power On procedure running. The relative parameter will be set according to phy_type */</span>
	<span class="n">Uxx_power_on_procedure</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="cm">/* Reading MAC address */</span>
	<span class="n">Uxx_ReadEthernetAddress</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="cm">/* Read VCO trim for RF parameter */</span>
	<span class="n">Wb35Reg_WriteSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="mh">0x08200000</span><span class="p">);</span>
	<span class="n">Wb35Reg_ReadSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VCO_trim</span><span class="p">);</span>

	<span class="cm">/* Read Antenna On/Off of software flag */</span>
	<span class="n">Wb35Reg_WriteSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="mh">0x08210000</span><span class="p">);</span>
	<span class="n">Wb35Reg_ReadSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SoftwareSet</span><span class="p">);</span>

	<span class="cm">/* Read TXVGA */</span>
	<span class="n">Wb35Reg_WriteSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="mh">0x08100000</span><span class="p">);</span>
	<span class="n">Wb35Reg_ReadSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">TxVga</span><span class="p">);</span>

	<span class="cm">/* Get Scan interval setting from EEPROM offset 0x1c */</span>
	<span class="n">Wb35Reg_WriteSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="mh">0x081d0000</span><span class="p">);</span>
	<span class="n">Wb35Reg_ReadSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x03b4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Region_ScanInterval</span><span class="p">);</span>

	<span class="cm">/* Update Ethernet address */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">CurrentMacAddress</span><span class="p">,</span> <span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">PermanentMacAddress</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="cm">/* Update software variable */</span>
	<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SoftwareSet</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">SoftwareSet</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">TxVga</span> <span class="o">&amp;=</span> <span class="mh">0x000000ff</span><span class="p">;</span>
	<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">PowerIndexFromEEPROM</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">TxVga</span><span class="p">;</span>
	<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">VCO_trim</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">VCO_trim</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">VCO_trim</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">VCO_trim</span> <span class="o">=</span> <span class="mh">0x28</span><span class="p">;</span>

	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMRegion</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">Region_ScanInterval</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMRegion</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMRegion</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">EEPROMRegion</span> <span class="o">=</span> <span class="n">REGION_AUTO</span><span class="p">;</span>

	<span class="cm">/* For Get Tx VGA from EEPROM */</span>
	<span class="n">GetTxVgaFromEEPROM</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="cm">/* Set Scan Interval */</span>
	<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">Scan_Interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">Region_ScanInterval</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">Scan_Interval</span> <span class="o">==</span> <span class="mi">2550</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">Scan_Interval</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">))</span> <span class="cm">/* Is default setting 0xff * 10 */</span>
		<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">Scan_Interval</span> <span class="o">=</span> <span class="n">SCAN_MAX_CHNL_TIME</span><span class="p">;</span>

	<span class="cm">/* Initial register */</span>
	<span class="n">RFSynthesizer_initial</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="n">BBProcessor_initial</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span> <span class="cm">/* Async write, must wait until complete */</span>

	<span class="n">Wb35Reg_phy_calibration</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="n">Mxx_initial</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>
	<span class="n">Dxx_initial</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">SurpriseRemove</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* Initial fail */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ================================================================</span>
<span class="cm"> *  CardComputeCrc --</span>
<span class="cm"> *</span>
<span class="cm"> *  Description:</span>
<span class="cm"> *    Runs the AUTODIN II CRC algorithm on buffer Buffer of length, Length.</span>
<span class="cm"> *</span>
<span class="cm"> *  Arguments:</span>
<span class="cm"> *    Buffer - the input buffer</span>
<span class="cm"> *    Length - the length of Buffer</span>
<span class="cm"> *</span>
<span class="cm"> *  Return Value:</span>
<span class="cm"> *    The 32-bit CRC value.</span>
<span class="cm"> * ===================================================================</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">CardComputeCrc</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">Length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">Crc</span><span class="p">,</span> <span class="n">Carry</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">CurByte</span><span class="p">;</span>

	<span class="n">Crc</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CurByte</span> <span class="o">=</span> <span class="n">Buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Carry</span> <span class="o">=</span> <span class="p">((</span><span class="n">Crc</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">CurByte</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">);</span>
			<span class="n">Crc</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">CurByte</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Carry</span><span class="p">)</span>
				<span class="n">Crc</span> <span class="o">=</span> <span class="p">(</span><span class="n">Crc</span> <span class="o">^</span> <span class="mh">0x04c11db6</span><span class="p">)</span> <span class="o">|</span> <span class="n">Carry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">Crc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ==================================================================</span>
<span class="cm"> * BitReverse --</span>
<span class="cm"> *   Reverse the bits in the input argument, dwData, which is</span>
<span class="cm"> *   regarded as a string of bits with the length, DataLength.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dwData     :</span>
<span class="cm"> *   DataLength :</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *   The converted value.</span>
<span class="cm"> * ==================================================================</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">BitReverse</span><span class="p">(</span><span class="n">u32</span> <span class="n">dwData</span><span class="p">,</span> <span class="n">u32</span> <span class="n">DataLength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">HalfLength</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">BitA</span><span class="p">,</span> <span class="n">BitB</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DataLength</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* No conversion is done. */</span>
	<span class="n">dwData</span> <span class="o">=</span> <span class="n">dwData</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xffffffff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">DataLength</span><span class="p">));</span>

	<span class="n">HalfLength</span> <span class="o">=</span> <span class="n">DataLength</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">DataLength</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HalfLength</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BitA</span> <span class="o">=</span> <span class="n">GetBit</span><span class="p">(</span><span class="n">dwData</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">BitB</span> <span class="o">=</span> <span class="n">GetBit</span><span class="p">(</span><span class="n">dwData</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BitA</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">BitB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dwData</span> <span class="o">=</span> <span class="n">ClearBit</span><span class="p">(</span><span class="n">dwData</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">dwData</span> <span class="o">=</span> <span class="n">SetBit</span><span class="p">(</span><span class="n">dwData</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BitA</span> <span class="o">&amp;&amp;</span> <span class="n">BitB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dwData</span> <span class="o">=</span> <span class="n">SetBit</span><span class="p">(</span><span class="n">dwData</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">dwData</span> <span class="o">=</span> <span class="n">ClearBit</span><span class="p">(</span><span class="n">dwData</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Do nothing since these two bits are of the save values. */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dwData</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Wb35Reg_phy_calibration</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_data</span> <span class="o">*</span><span class="n">pHwData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">BB3c</span><span class="p">,</span> <span class="n">BB54</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">RF_WB_242</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">RF_WB_242_1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phy_calibration_winbond</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mi">2412</span><span class="p">);</span> <span class="cm">/* Sync operation */</span>
		<span class="n">Wb35Reg_ReadSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x103c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BB3c</span><span class="p">);</span>
		<span class="n">Wb35Reg_ReadSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x1054</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BB54</span><span class="p">);</span>

		<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">BB3c_cal</span> <span class="o">=</span> <span class="n">BB3c</span><span class="p">;</span>
		<span class="n">pHwData</span><span class="o">-&gt;</span><span class="n">BB54_cal</span> <span class="o">=</span> <span class="n">BB54</span><span class="p">;</span>

		<span class="n">RFSynthesizer_initial</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span>
		<span class="n">BBProcessor_initial</span><span class="p">(</span><span class="n">pHwData</span><span class="p">);</span> <span class="cm">/* Async operation */</span>

		<span class="n">Wb35Reg_WriteSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x103c</span><span class="p">,</span> <span class="n">BB3c</span><span class="p">);</span>
		<span class="n">Wb35Reg_WriteSync</span><span class="p">(</span><span class="n">pHwData</span><span class="p">,</span> <span class="mh">0x1054</span><span class="p">,</span> <span class="n">BB54</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
