<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › omapdrm › omap_drv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap_drv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/staging/omapdrm/omap_drv.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Texas Instruments</span>
<span class="cm"> * Author: Rob Clark &lt;rob@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;omap_drv.h&quot;</span>

<span class="cp">#include &quot;drm_crtc_helper.h&quot;</span>
<span class="cp">#include &quot;drm_fb_helper.h&quot;</span>
<span class="cp">#include &quot;omap_dmm_tiler.h&quot;</span>

<span class="cp">#define DRIVER_NAME		MODULE_NAME</span>
<span class="cp">#define DRIVER_DESC		&quot;OMAP DRM&quot;</span>
<span class="cp">#define DRIVER_DATE		&quot;20110917&quot;</span>
<span class="cp">#define DRIVER_MAJOR		1</span>
<span class="cp">#define DRIVER_MINOR		0</span>
<span class="cp">#define DRIVER_PATCHLEVEL	0</span>

<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">drm_device</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">num_crtc</span> <span class="o">=</span> <span class="n">CONFIG_DRM_OMAP_NUM_CRTCS</span><span class="p">;</span>

<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">num_crtc</span><span class="p">,</span> <span class="s">&quot;Number of overlays to use as CRTCs&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">num_crtc</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * mode config funcs</span>
<span class="cm"> */</span>

<span class="cm">/* Notes about mapping DSS and DRM entities:</span>
<span class="cm"> *    CRTC:        overlay</span>
<span class="cm"> *    encoder:     manager.. with some extension to allow one primary CRTC</span>
<span class="cm"> *                 and zero or more video CRTC&#39;s to be mapped to one encoder?</span>
<span class="cm"> *    connector:   dssdev.. manager can be attached/detached from different</span>
<span class="cm"> *                 devices</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_fb_output_poll_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fbdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drm_fb_helper_hotplug_event</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fbdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_mode_config_funcs</span> <span class="n">omap_mode_config_funcs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fb_create</span> <span class="o">=</span> <span class="n">omap_framebuffer_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">output_poll_changed</span> <span class="o">=</span> <span class="n">omap_fb_output_poll_changed</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_connector_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_dss_device</span> <span class="o">*</span><span class="n">dssdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OMAP_DISPLAY_TYPE_HDMI</span>:
		<span class="k">return</span> <span class="n">DRM_MODE_CONNECTOR_HDMIA</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OMAP_DISPLAY_TYPE_DPI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;dvi&quot;</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">DRM_MODE_CONNECTOR_DVID</span><span class="p">;</span>
		<span class="cm">/* fallthrough */</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">DRM_MODE_CONNECTOR_Unknown</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* enable when dss2 supports hotplug */</span>
<span class="c">static int omap_drm_notifier(struct notifier_block *nb,</span>
<span class="c">		unsigned long evt, void *arg)</span>
<span class="c">{</span>
<span class="c">	switch (evt) {</span>
<span class="c">	case OMAP_DSS_SIZE_CHANGE:</span>
<span class="c">	case OMAP_DSS_HOTPLUG_CONNECT:</span>
<span class="c">	case OMAP_DSS_HOTPLUG_DISCONNECT: {</span>
<span class="c">		struct drm_device *dev = drm_device;</span>
<span class="c">		DBG(&quot;hotplug event: evt=%d, dev=%p&quot;, evt, dev);</span>
<span class="c">		if (dev) {</span>
<span class="c">			drm_sysfs_hotplug_event(dev);</span>
<span class="c">		}</span>
<span class="c">		return NOTIFY_OK;</span>
<span class="c">	}</span>
<span class="c">	default:  /* don&#39;t care about other events for now */</span>
<span class="c">		return NOTIFY_DONE;</span>
<span class="c">	}</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_video_chains</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;dumping video chains: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">omap_dss_get_num_overlays</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_overlay</span> <span class="o">*</span><span class="n">ovl</span> <span class="o">=</span> <span class="n">omap_dss_get_overlay</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">omap_overlay_manager</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="n">ovl</span><span class="o">-&gt;</span><span class="n">manager</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">omap_dss_device</span> <span class="o">*</span><span class="n">dssdev</span> <span class="o">=</span> <span class="n">mgr</span> <span class="o">?</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dssdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%d: %s -&gt; %s -&gt; %s&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ovl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mgr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%d: %s -&gt; %s&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ovl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%d: %s&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ovl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* create encoders for each manager */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_encoder</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">omap_overlay_manager</span> <span class="o">*</span><span class="n">mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">omap_encoder_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mgr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">encoder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not create encoder: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_encoders</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">encoders</span><span class="p">));</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">encoders</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_encoders</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* create connectors for each display device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_connector</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">omap_dss_device</span> <span class="o">*</span><span class="n">dssdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s has no driver.. skipping it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_timings</span> <span class="o">||</span>
				<span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">read_edid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s driver does not support &quot;</span>
			<span class="s">&quot;get_timings or read_edid.. skipping it!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">connector</span> <span class="o">=</span> <span class="n">omap_connector_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">get_connector_type</span><span class="p">(</span><span class="n">dssdev</span><span class="p">),</span> <span class="n">dssdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">connector</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not create connector: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_connectors</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">connectors</span><span class="p">));</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">connectors</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_connectors</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">connector</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"> /* enable when dss2 supports hotplug */</span>
<span class="c">	notifier = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);</span>
<span class="c">	notifier-&gt;notifier_call = omap_drm_notifier;</span>
<span class="c">	omap_dss_add_notify(dssdev, notifier);</span>
<span class="cp">#else</span>
	<span class="n">notifier</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_encoders</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_overlay_manager</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span>
			<span class="n">omap_encoder_get_manager</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">encoders</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">dssdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drm_mode_connector_attach_encoder</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">encoders</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* create up to max_overlays CRTCs mapping to overlays.. by default,</span>
<span class="cm"> * connect the overlays to different managers/encoders, giving priority</span>
<span class="cm"> * to encoders connected to connectors with a detected connection</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_crtc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_overlay</span> <span class="o">*</span><span class="n">ovl</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">connected_connectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_overlay_manager</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">;</span>

	<span class="cm">/* find next best connector, ones with detected connection first</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_connectors</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">connected_connectors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span> <span class="o">=</span>
				<span class="n">omap_connector_attached_encoder</span><span class="p">(</span>
						<span class="n">priv</span><span class="o">-&gt;</span><span class="n">connectors</span><span class="p">[</span><span class="o">*</span><span class="n">j</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">encoder</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mgr</span> <span class="o">=</span> <span class="n">omap_encoder_get_manager</span><span class="p">(</span><span class="n">encoder</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we couldn&#39;t find another connected connector, lets start</span>
<span class="cm">	 * looking at the unconnected connectors:</span>
<span class="cm">	 *</span>
<span class="cm">	 * note: it might not be immediately apparent, but thanks to</span>
<span class="cm">	 * the !mgr check in both this loop and the one above, the only</span>
<span class="cm">	 * way to enter this loop is with *j == priv-&gt;num_connectors,</span>
<span class="cm">	 * so idx can never go negative.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_connectors</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mgr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">j</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_connectors</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">connected_connectors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span> <span class="o">=</span>
				<span class="n">omap_connector_attached_encoder</span><span class="p">(</span>
						<span class="n">priv</span><span class="o">-&gt;</span><span class="n">connectors</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">encoder</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mgr</span> <span class="o">=</span> <span class="n">omap_encoder_get_manager</span><span class="p">(</span><span class="n">encoder</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">crtc</span> <span class="o">=</span> <span class="n">omap_crtc_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ovl</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crtc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not create CRTC: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ovl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_crtcs</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">crtcs</span><span class="p">));</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">crtcs</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">crtc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_plane</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_overlay</span> <span class="o">*</span><span class="n">ovl</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">possible_crtcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_plane</span> <span class="o">*</span><span class="n">plane</span> <span class="o">=</span>
			<span class="n">omap_plane_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ovl</span><span class="p">,</span> <span class="n">possible_crtcs</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not create plane: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ovl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">));</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">plane</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_dev_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_dss_device</span> <span class="o">*</span><span class="n">dssdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dssdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">detect_connectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">connected_connectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_connectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">connectors</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap_connector_detect</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">connector_status_connected</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">connected_connectors</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">connected_connectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_modeset_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">omap_drm_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_kms_platform_data</span> <span class="o">*</span><span class="n">kms_pdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_dss_device</span> <span class="o">*</span><span class="n">dssdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">connected_connectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">drm_mode_config_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">kms_pdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kms_pdata</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">kms_pdata</span><span class="p">;</span>

		<span class="cm">/* if platform data is provided by the board file, use it to</span>
<span class="cm">		 * control which overlays, managers, and devices we own.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">mgr_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">omap_overlay_manager</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span>
				<span class="n">omap_dss_get_overlay_manager</span><span class="p">(</span>
						<span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">mgr_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">create_encoder</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mgr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">dev_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">omap_dss_device</span> <span class="o">*</span><span class="n">dssdev</span> <span class="o">=</span>
				<span class="n">omap_dss_find_device</span><span class="p">(</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">dev_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">match_dev_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dssdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no such dssdev: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">dev_names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">create_connector</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dssdev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">connected_connectors</span> <span class="o">=</span> <span class="n">detect_connectors</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">ovl_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">omap_overlay</span> <span class="o">*</span><span class="n">ovl</span> <span class="o">=</span>
				<span class="n">omap_dss_get_overlay</span><span class="p">(</span><span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">ovl_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">create_crtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ovl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">,</span> <span class="n">connected_connectors</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">pln_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">omap_overlay</span> <span class="o">*</span><span class="n">ovl</span> <span class="o">=</span>
				<span class="n">omap_dss_get_overlay</span><span class="p">(</span><span class="n">kms_pdata</span><span class="o">-&gt;</span><span class="n">pln_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">create_plane</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ovl</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* otherwise just grab up to CONFIG_DRM_OMAP_NUM_CRTCS and try</span>
<span class="cm">		 * to make educated guesses about everything else</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">max_overlays</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">omap_dss_get_num_overlays</span><span class="p">(),</span> <span class="n">num_crtc</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">omap_dss_get_num_overlay_managers</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">create_encoder</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">omap_dss_get_overlay_manager</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">for_each_dss_dev</span><span class="p">(</span><span class="n">dssdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">create_connector</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dssdev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">connected_connectors</span> <span class="o">=</span> <span class="n">detect_connectors</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_overlays</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">create_crtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">omap_dss_get_overlay</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">j</span><span class="p">,</span> <span class="n">connected_connectors</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* use any remaining overlays as drm planes */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">omap_dss_get_num_overlays</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">omap_overlay</span> <span class="o">*</span><span class="n">ovl</span> <span class="o">=</span> <span class="n">omap_dss_get_overlay</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="n">create_plane</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ovl</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* for now keep the mapping of CRTCs and encoders static.. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_encoders</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">encoders</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">omap_overlay_manager</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span>
				<span class="n">omap_encoder_get_manager</span><span class="p">(</span><span class="n">encoder</span><span class="p">);</span>

		<span class="n">encoder</span><span class="o">-&gt;</span><span class="n">possible_crtcs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%s: possible_crtcs=%08x&quot;</span><span class="p">,</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">encoder</span><span class="o">-&gt;</span><span class="n">possible_crtcs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dump_video_chains</span><span class="p">();</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode_config</span><span class="p">.</span><span class="n">min_width</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode_config</span><span class="p">.</span><span class="n">min_height</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/* note: eventually will need some cpu_is_omapXYZ() type stuff here</span>
<span class="cm">	 * to fill in these limits properly on different OMAP generations..</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode_config</span><span class="p">.</span><span class="n">max_width</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode_config</span><span class="p">.</span><span class="n">max_height</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode_config</span><span class="p">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_mode_config_funcs</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_modeset_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drm_mode_config_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * drm ioctl funcs</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_get_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_omap_param</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%p: param=%llu&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OMAP_PARAM_CHIPSET_ID</span>:
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">GET_OMAP_TYPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;unknown parameter %lld&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_set_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_omap_param</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;unknown parameter %lld&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_gem_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_omap_gem_new</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%p:%p: size=0x%08x, flags=%08x&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">omap_gem_new_handle</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_gem_cpu_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_omap_gem_cpu_prep</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">VERB</span><span class="p">(</span><span class="s">&quot;%p:%p: handle=%d, op=%x&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_gem_op_sync</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_gem_op_start</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_gem_cpu_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_omap_gem_cpu_fini</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">VERB</span><span class="p">(</span><span class="s">&quot;%p:%p: handle=%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* XXX flushy, flushy */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_gem_op_finish</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_gem_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_omap_gem_info</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%p:%p: handle=%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">omap_gem_mmap_size</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">omap_gem_mmap_offset</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">drm_ioctl_desc</span> <span class="n">ioctls</span><span class="p">[</span><span class="n">DRM_COMMAND_END</span> <span class="o">-</span> <span class="n">DRM_COMMAND_BASE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">DRM_IOCTL_DEF_DRV</span><span class="p">(</span><span class="n">OMAP_GET_PARAM</span><span class="p">,</span> <span class="n">ioctl_get_param</span><span class="p">,</span> <span class="n">DRM_UNLOCKED</span><span class="o">|</span><span class="n">DRM_AUTH</span><span class="p">),</span>
	<span class="n">DRM_IOCTL_DEF_DRV</span><span class="p">(</span><span class="n">OMAP_SET_PARAM</span><span class="p">,</span> <span class="n">ioctl_set_param</span><span class="p">,</span> <span class="n">DRM_UNLOCKED</span><span class="o">|</span><span class="n">DRM_AUTH</span><span class="o">|</span><span class="n">DRM_MASTER</span><span class="o">|</span><span class="n">DRM_ROOT_ONLY</span><span class="p">),</span>
	<span class="n">DRM_IOCTL_DEF_DRV</span><span class="p">(</span><span class="n">OMAP_GEM_NEW</span><span class="p">,</span> <span class="n">ioctl_gem_new</span><span class="p">,</span> <span class="n">DRM_UNLOCKED</span><span class="o">|</span><span class="n">DRM_AUTH</span><span class="p">),</span>
	<span class="n">DRM_IOCTL_DEF_DRV</span><span class="p">(</span><span class="n">OMAP_GEM_CPU_PREP</span><span class="p">,</span> <span class="n">ioctl_gem_cpu_prep</span><span class="p">,</span> <span class="n">DRM_UNLOCKED</span><span class="o">|</span><span class="n">DRM_AUTH</span><span class="p">),</span>
	<span class="n">DRM_IOCTL_DEF_DRV</span><span class="p">(</span><span class="n">OMAP_GEM_CPU_FINI</span><span class="p">,</span> <span class="n">ioctl_gem_cpu_fini</span><span class="p">,</span> <span class="n">DRM_UNLOCKED</span><span class="o">|</span><span class="n">DRM_AUTH</span><span class="p">),</span>
	<span class="n">DRM_IOCTL_DEF_DRV</span><span class="p">(</span><span class="n">OMAP_GEM_INFO</span><span class="p">,</span> <span class="n">ioctl_gem_info</span><span class="p">,</span> <span class="n">DRM_UNLOCKED</span><span class="o">|</span><span class="n">DRM_AUTH</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * drm driver funcs</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * load - setup chip and create an initial config</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @flags: startup flags</span>
<span class="cm"> *</span>
<span class="cm"> * The driver load routine has to do several things:</span>
<span class="cm"> *   - initialize the memory manager</span>
<span class="cm"> *   - allocate initial config memory</span>
<span class="cm"> *   - setup the DRM framebuffer with the allocated memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;load: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">drm_device</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate priv</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;omapdrm&quot;</span><span class="p">,</span>
			<span class="n">WQ_UNBOUND</span> <span class="o">|</span> <span class="n">WQ_NON_REENTRANT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">obj_list</span><span class="p">);</span>

	<span class="n">omap_gem_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_modeset_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;omap_modeset_init failed: ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">fbdev</span> <span class="o">=</span> <span class="n">omap_fbdev_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fbdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;omap_fbdev_init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* well, limp along without an fbdev.. maybe X11 will work? */</span>
	<span class="p">}</span>

	<span class="n">drm_kms_helper_poll_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">drm_vblank_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not init vblank</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_unload</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;unload: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">drm_vblank_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">drm_kms_helper_poll_fini</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">omap_fbdev_free</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">omap_modeset_free</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">omap_gem_deinit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">driver_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;open: dev=%p, file=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_firstopen</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;firstopen: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lastclose - clean up after all DRM clients have exited</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> *</span>
<span class="cm"> * Take care of cleaning up after all DRM clients have exited.  In the</span>
<span class="cm"> * mode setting case, we want to restore the kernel&#39;s initial mode (just</span>
<span class="cm"> * in case the last client left us in a bad state).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_lastclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we don&#39;t support vga-switcheroo.. so just make sure the fbdev</span>
<span class="cm">	 * mode is active</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;lastclose: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">drm_fb_helper_restore_fbdev_mode</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fbdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;failed to restore crtc mode&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_preclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;preclose: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_postclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;postclose: dev=%p, file=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * enable_vblank - enable vblank interrupt events</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: which irq to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Enable vblank interrupts for @crtc.  If the device doesn&#39;t have</span>
<span class="cm"> * a hardware vblank counter, this routine should be a no-op, since</span>
<span class="cm"> * interrupts will have to stay on to keep the count accurate.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS</span>
<span class="cm"> * Zero on success, appropriate errno if the given @crtc&#39;s vblank</span>
<span class="cm"> * interrupt cannot be enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_enable_vblank</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;enable_vblank: dev=%p, crtc=%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disable_vblank - disable vblank interrupt events</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: which irq to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Disable vblank interrupts for @crtc.  If the device doesn&#39;t have</span>
<span class="cm"> * a hardware vblank counter, this routine should be a no-op, since</span>
<span class="cm"> * interrupts will have to stay on to keep the count accurate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_disable_vblank</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;disable_vblank: dev=%p, crtc=%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dev_irq_handler</span><span class="p">(</span><span class="n">DRM_IRQ_ARGS</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_irq_preinstall</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;irq_preinstall: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_irq_postinstall</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;irq_postinstall: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_irq_uninstall</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;irq_uninstall: dev=%p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">omap_gem_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">omap_gem_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">drm_gem_vm_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">drm_gem_vm_close</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">omapdriver_fops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">drm_open</span><span class="p">,</span>
		<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">drm_ioctl</span><span class="p">,</span>
		<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">drm_release</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">omap_gem_mmap</span><span class="p">,</span>
		<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">drm_poll</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fasync</span> <span class="o">=</span> <span class="n">drm_fasync</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">drm_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">drm_driver</span> <span class="n">omap_drm_driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">driver_features</span> <span class="o">=</span>
				<span class="n">DRIVER_HAVE_IRQ</span> <span class="o">|</span> <span class="n">DRIVER_MODESET</span> <span class="o">|</span> <span class="n">DRIVER_GEM</span> <span class="o">|</span> <span class="n">DRIVER_PRIME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">load</span> <span class="o">=</span> <span class="n">dev_load</span><span class="p">,</span>
		<span class="p">.</span><span class="n">unload</span> <span class="o">=</span> <span class="n">dev_unload</span><span class="p">,</span>
		<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">dev_open</span><span class="p">,</span>
		<span class="p">.</span><span class="n">firstopen</span> <span class="o">=</span> <span class="n">dev_firstopen</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lastclose</span> <span class="o">=</span> <span class="n">dev_lastclose</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preclose</span> <span class="o">=</span> <span class="n">dev_preclose</span><span class="p">,</span>
		<span class="p">.</span><span class="n">postclose</span> <span class="o">=</span> <span class="n">dev_postclose</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get_vblank_counter</span> <span class="o">=</span> <span class="n">drm_vblank_count</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enable_vblank</span> <span class="o">=</span> <span class="n">dev_enable_vblank</span><span class="p">,</span>
		<span class="p">.</span><span class="n">disable_vblank</span> <span class="o">=</span> <span class="n">dev_disable_vblank</span><span class="p">,</span>
		<span class="p">.</span><span class="n">irq_preinstall</span> <span class="o">=</span> <span class="n">dev_irq_preinstall</span><span class="p">,</span>
		<span class="p">.</span><span class="n">irq_postinstall</span> <span class="o">=</span> <span class="n">dev_irq_postinstall</span><span class="p">,</span>
		<span class="p">.</span><span class="n">irq_uninstall</span> <span class="o">=</span> <span class="n">dev_irq_uninstall</span><span class="p">,</span>
		<span class="p">.</span><span class="n">irq_handler</span> <span class="o">=</span> <span class="n">dev_irq_handler</span><span class="p">,</span>
		<span class="p">.</span><span class="n">reclaim_buffers</span> <span class="o">=</span> <span class="n">drm_core_reclaim_buffers</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
		<span class="p">.</span><span class="n">debugfs_init</span> <span class="o">=</span> <span class="n">omap_debugfs_init</span><span class="p">,</span>
		<span class="p">.</span><span class="n">debugfs_cleanup</span> <span class="o">=</span> <span class="n">omap_debugfs_cleanup</span><span class="p">,</span>
<span class="cp">#endif</span>
		<span class="p">.</span><span class="n">prime_handle_to_fd</span> <span class="o">=</span> <span class="n">drm_gem_prime_handle_to_fd</span><span class="p">,</span>
		<span class="p">.</span><span class="n">prime_fd_to_handle</span> <span class="o">=</span> <span class="n">drm_gem_prime_fd_to_handle</span><span class="p">,</span>
		<span class="p">.</span><span class="n">gem_prime_export</span> <span class="o">=</span> <span class="n">omap_gem_prime_export</span><span class="p">,</span>
		<span class="p">.</span><span class="n">gem_prime_import</span> <span class="o">=</span> <span class="n">omap_gem_prime_import</span><span class="p">,</span>
		<span class="p">.</span><span class="n">gem_init_object</span> <span class="o">=</span> <span class="n">omap_gem_init_object</span><span class="p">,</span>
		<span class="p">.</span><span class="n">gem_free_object</span> <span class="o">=</span> <span class="n">omap_gem_free_object</span><span class="p">,</span>
		<span class="p">.</span><span class="n">gem_vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_gem_vm_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dumb_create</span> <span class="o">=</span> <span class="n">omap_gem_dumb_create</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dumb_map_offset</span> <span class="o">=</span> <span class="n">omap_gem_dumb_map_offset</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dumb_destroy</span> <span class="o">=</span> <span class="n">omap_gem_dumb_destroy</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ioctls</span> <span class="o">=</span> <span class="n">ioctls</span><span class="p">,</span>
		<span class="p">.</span><span class="n">num_ioctls</span> <span class="o">=</span> <span class="n">DRM_OMAP_NUM_IOCTLS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omapdriver_fops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">DRIVER_DESC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">DRIVER_DATE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="n">DRIVER_MAJOR</span><span class="p">,</span>
		<span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">DRIVER_MINOR</span><span class="p">,</span>
		<span class="p">.</span><span class="n">patchlevel</span> <span class="o">=</span> <span class="n">DRIVER_PATCHLEVEL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pdev_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pDevice</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pdev_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pdev_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pdev_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">drm_platform_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap_drm_driver</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pdev_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">drm_platform_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap_drm_driver</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap_dmm_driver</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">pdev</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
			<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">pdev_probe</span><span class="p">,</span>
		<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">pdev_remove</span><span class="p">,</span>
		<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">pdev_suspend</span><span class="p">,</span>
		<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">pdev_resume</span><span class="p">,</span>
		<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">pdev_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_drm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap_dmm_driver</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we can continue on without DMM.. so not fatal */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DMM registration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">omap_drm_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;fini&quot;</span><span class="p">);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* need late_initcall() so we load after dss_driver&#39;s are loaded */</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">omap_drm_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">omap_drm_fini</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Rob Clark &lt;rob@ti.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;OMAP DRM Display Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:&quot;</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
