<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › omapdrm › omap_gem.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap_gem.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/staging/omapdrm/omap_gem.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Texas Instruments</span>
<span class="cm"> * Author: Rob Clark &lt;rob.clark@linaro.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/shmem_fs.h&gt;</span>

<span class="cp">#include &quot;omap_drv.h&quot;</span>
<span class="cp">#include &quot;omap_dmm_tiler.h&quot;</span>

<span class="cm">/* remove these once drm core helpers are merged */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span> <span class="n">_drm_gem_get_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpmask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">_drm_gem_put_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">bool</span> <span class="n">accessed</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">_drm_gem_create_mmap_offset_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GEM buffer object implementation.</span>
<span class="cm"> */</span>

<span class="cp">#define to_omap_bo(x) container_of(x, struct omap_gem_object, base)</span>

<span class="cm">/* note: we use upper 8 bits of flags for driver-internal flags: */</span>
<span class="cp">#define OMAP_BO_DMA			0x01000000	</span><span class="cm">/* actually is physically contiguous */</span><span class="cp"></span>
<span class="cp">#define OMAP_BO_EXT_SYNC	0x02000000	</span><span class="cm">/* externally allocated sync object */</span><span class="cp"></span>
<span class="cp">#define OMAP_BO_EXT_MEM		0x04000000	</span><span class="cm">/* externally allocated memory */</span><span class="cp"></span>


<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="n">base</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mm_list</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/** width/height for tiled formats (rounded up to slot boundaries) */</span>
	<span class="kt">uint16_t</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>

	<span class="cm">/** roll applied when mapping to DMM */</span>
	<span class="kt">uint32_t</span> <span class="n">roll</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * If buffer is allocated physically contiguous, the OMAP_BO_DMA flag</span>
<span class="cm">	 * is set and the paddr is valid.  Also if the buffer is remapped in</span>
<span class="cm">	 * TILER and paddr_cnt &gt; 0, then paddr is valid.  But if you are using</span>
<span class="cm">	 * the physical address and OMAP_BO_DMA is not set, then you should</span>
<span class="cm">	 * be going thru omap_gem_{get,put}_paddr() to ensure the mapping is</span>
<span class="cm">	 * not removed from under your feet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that OMAP_BO_SCANOUT is a hint from userspace that DMA capable</span>
<span class="cm">	 * buffer is requested, but doesn&#39;t mean that it is.  Use the</span>
<span class="cm">	 * OMAP_BO_DMA flag to determine if the buffer has a DMA capable</span>
<span class="cm">	 * physical address.</span>
<span class="cm">	 */</span>
	<span class="n">dma_addr_t</span> <span class="n">paddr</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * # of users of paddr</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">paddr_cnt</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * tiler block used when buffer is remapped in DMM/TILER.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">tiler_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Array of backing pages, if allocated.  Note that pages are never</span>
<span class="cm">	 * allocated for buffers originally allocated from contiguous memory</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>

	<span class="cm">/** addresses corresponding to pages in above array */</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Virtual address, if mapped.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * sync-object allocated on demand (if needed)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Per-buffer sync-object for tracking pending and completed hw/dma</span>
<span class="cm">	 * read and write operations.  The layout in memory is dictated by</span>
<span class="cm">	 * the SGX firmware, which uses this information to stall the command</span>
<span class="cm">	 * stream if a surface is not ready yet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that when buffer is used by SGX, the sync-object needs to be</span>
<span class="cm">	 * allocated from a special heap of sync-objects.  This way many sync</span>
<span class="cm">	 * objects can be packed in a page, and not waste GPU virtual address</span>
<span class="cm">	 * space.  Because of this we have to have a omap_gem_set_sync_object()</span>
<span class="cm">	 * API to allow replacement of the syncobj after it has (potentially)</span>
<span class="cm">	 * already been allocated.  A bit ugly but I haven&#39;t thought of a</span>
<span class="cm">	 * better alternative.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">write_pending</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">write_complete</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">read_pending</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">read_complete</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">sync</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">get_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">***</span><span class="n">pages</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">mmap_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>

<span class="cm">/* To deal with userspace mmap&#39;ings of 2d tiled buffers, which (a) are</span>
<span class="cm"> * not necessarily pinned in TILER all the time, and (b) when they are</span>
<span class="cm"> * they are not necessarily page aligned, we reserve one or more small</span>
<span class="cm"> * regions in each of the 2d containers to use as a user-GART where we</span>
<span class="cm"> * can create a second page-aligned mapping of parts of the buffer</span>
<span class="cm"> * being accessed from userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we could optimize slightly when we know that multiple</span>
<span class="cm"> * tiler containers are backed by the same PAT.. but I&#39;ll leave that</span>
<span class="cm"> * for later..</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_USERGART_ENTRIES 2</span>
<span class="k">struct</span> <span class="n">usergart_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tiler_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>	<span class="cm">/* the reserved tiler block */</span>
	<span class="n">dma_addr_t</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>	<span class="cm">/* the current pinned obj */</span>
	<span class="n">pgoff_t</span> <span class="n">obj_pgoff</span><span class="p">;</span>		<span class="cm">/* page offset of obj currently</span>
<span class="cm">					   mapped in */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usergart_entry</span> <span class="n">entry</span><span class="p">[</span><span class="n">NUM_USERGART_ENTRIES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">height</span><span class="p">;</span>				<span class="cm">/* height in rows */</span>
	<span class="kt">int</span> <span class="n">height_shift</span><span class="p">;</span>		<span class="cm">/* ilog2(height in rows) */</span>
	<span class="kt">int</span> <span class="n">slot_shift</span><span class="p">;</span>			<span class="cm">/* ilog2(width per slot) */</span>
	<span class="kt">int</span> <span class="n">stride_pfn</span><span class="p">;</span>			<span class="cm">/* stride in pages */</span>
	<span class="kt">int</span> <span class="n">last</span><span class="p">;</span>				<span class="cm">/* index of last used entry */</span>
<span class="p">}</span> <span class="o">*</span><span class="n">usergart</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">evict_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">tiler_fmt</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usergart_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">height</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">off</span> <span class="o">=</span> <span class="n">mmap_offset</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="cm">/* if stride &gt; than PAGE_SIZE then sparse mapping: */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_mapping</span><span class="p">,</span>
						<span class="n">off</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">off</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">m</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_mapping</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Evict a buffer from usergart, if it is mapped there */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">evict</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_TILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">tiler_fmt</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">gem2fmt</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usergart</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_USERGART_ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usergart_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">==</span> <span class="n">obj</span><span class="p">)</span>
				<span class="n">evict_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* GEM objects can either be allocated from contiguous memory (in which</span>
<span class="cm"> * case obj-&gt;filp==NULL), or w/ shmem backing (obj-&gt;filp!=NULL).  But non</span>
<span class="cm"> * contiguous buffers can be remapped in TILER/DMM if they need to be</span>
<span class="cm"> * contiguous... but we don&#39;t do this all the time to reduce pressure</span>
<span class="cm"> * on TILER/DMM space when we know at allocation time that the buffer</span>
<span class="cm"> * will need to be scanned out.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_shmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">filp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * shmem buffers that are mapped cached can simulate coherency via using</span>
<span class="cm"> * page faulting to keep track of dirty pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_cached_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">is_shmem</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_CACHE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">OMAP_BO_CACHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">sync_lock</span><span class="p">);</span>

<span class="cm">/** ensure backing pages are allocated */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_gem_attach_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/* TODO: __GFP_DMA32 .. but somehow GFP_HIGHMEM is coming from the</span>
<span class="cm">	 * mapping_gfp_mask(mapping) which conflicts w/ GFP_DMA32.. probably</span>
<span class="cm">	 * we actually want CMA memory for it all anyways..</span>
<span class="cm">	 */</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">_drm_gem_get_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not get pages: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pages</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* for non-cached buffers, ensure the new pages are clean because</span>
<span class="cm">	 * DSS, GPU, etc. are not cache coherent:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">OMAP_BO_WC</span><span class="o">|</span><span class="n">OMAP_BO_UNCACHED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">addrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">npages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addrs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">npages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** release backing pages */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_gem_detach_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="cm">/* for non-cached buffers, ensure the new pages are clean because</span>
<span class="cm">	 * DSS, GPU, etc. are not cache coherent:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">OMAP_BO_WC</span><span class="o">|</span><span class="n">OMAP_BO_UNCACHED</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">);</span>
	<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_drm_gem_put_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get buffer flags */</span>
<span class="kt">uint32_t</span> <span class="nf">omap_gem_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** get mmap offset */</span>
<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">mmap_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_list</span><span class="p">.</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make it mmapable */</span>
		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">omap_gem_mmap_size</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">_drm_gem_create_mmap_offset_size</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate mmap offset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_list</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">omap_gem_mmap_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">mmap_offset</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** get mmap size */</span>
<span class="kt">size_t</span> <span class="nf">omap_gem_mmap_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_TILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* for tiled buffers, the virtual size has stride rounded up</span>
<span class="cm">		 * to 4kb.. (to hide the fact that row n+1 might start 16kb or</span>
<span class="cm">		 * 32kb later!).  But we don&#39;t back the entire buffer with</span>
<span class="cm">		 * pages, only the valid picture part.. so need to adjust for</span>
<span class="cm">		 * this in the size used to mmap and generate mmap offset</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">tiler_vsize</span><span class="p">(</span><span class="n">gem2fmt</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">),</span>
				<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Normal handling for the case of faulting in non-tiled buffers */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fault_1d</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t use vmf-&gt;pgoff since that has the fake offset: */</span>
	<span class="n">pgoff</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span> <span class="o">-</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap_gem_cpu_sync</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">);</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">pgoff</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_DMA</span><span class="p">));</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">VERB</span><span class="p">(</span><span class="s">&quot;Inserting %p pfn %lx, pa %lx&quot;</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span><span class="p">,</span>
			<span class="n">pfn</span><span class="p">,</span> <span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vm_insert_mixed</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Special handling for the case of faulting in 2d tiled buffers */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fault_2d</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usergart_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">tiler_fmt</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">gem2fmt</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>  <span class="cm">/* XXX is this too much to have on stack? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">base_pgoff</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">slots</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note the height of the slot is also equal to the number of pages</span>
<span class="cm">	 * that need to be mapped in to fill 4kb wide CPU page.  If the slot</span>
<span class="cm">	 * height is 64, then 64 pages fill a 4kb wide by 64 row region.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">height</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n_shift</span> <span class="o">=</span> <span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">height_shift</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If buffer width in bytes &gt; PAGE_SIZE then the virtual stride is</span>
<span class="cm">	 * rounded up to next multiple of PAGE_SIZE.. this need to be taken</span>
<span class="cm">	 * into account in some of the math, so figure out virtual stride</span>
<span class="cm">	 * in pages</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&lt;&lt;</span> <span class="n">fmt</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t use vmf-&gt;pgoff since that has the fake offset: */</span>
	<span class="n">pgoff</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span> <span class="o">-</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Actual address we start mapping at is rounded down to previous slot</span>
<span class="cm">	 * boundary in the y direction:</span>
<span class="cm">	 */</span>
	<span class="n">base_pgoff</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">pgoff</span><span class="p">,</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">n_shift</span><span class="p">);</span>

	<span class="cm">/* figure out buffer width in slots */</span>
	<span class="n">slots</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">slot_shift</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span> <span class="o">-</span> <span class="p">((</span><span class="n">pgoff</span> <span class="o">-</span> <span class="n">base_pgoff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">entry</span><span class="p">[</span><span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">last</span><span class="p">];</span>

	<span class="cm">/* evict previous buffer using this usergart entry, if any: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">)</span>
		<span class="n">evict_entry</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj_pgoff</span> <span class="o">=</span> <span class="n">base_pgoff</span><span class="p">;</span>

	<span class="cm">/* now convert base_pgoff to phys offset from virt offset: */</span>
	<span class="n">base_pgoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">base_pgoff</span> <span class="o">&gt;&gt;</span> <span class="n">n_shift</span><span class="p">)</span> <span class="o">*</span> <span class="n">slots</span><span class="p">;</span>

	<span class="cm">/* for wider-than 4k.. figure out which part of the slot-row we want: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">pgoff</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">obj_pgoff</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
		<span class="n">base_pgoff</span> <span class="o">/=</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">slots</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">slots</span> <span class="o">-</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;&lt;</span> <span class="n">n_shift</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">base_pgoff</span> <span class="o">+=</span> <span class="n">off</span> <span class="o">&lt;&lt;</span> <span class="n">n_shift</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">off</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map in pages. Beyond the valid pixel part of the buffer, we set</span>
<span class="cm">	 * pages[i] to NULL to get a dummy page mapped in.. if someone</span>
<span class="cm">	 * reads/writes it they will get random/undefined content, but at</span>
<span class="cm">	 * least it won&#39;t be corrupting whatever other random page used to</span>
<span class="cm">	 * be mapped in, or other undefined behavior.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">base_pgoff</span><span class="p">],</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">slots</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">slots</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">slots</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tiler_pin</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pages</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to pin: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pfn</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">VERB</span><span class="p">(</span><span class="s">&quot;Inserting %p pfn %lx, pa %lx&quot;</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span><span class="p">,</span>
			<span class="n">pfn</span><span class="p">,</span> <span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vm_insert_mixed</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
		<span class="n">pfn</span> <span class="o">+=</span> <span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">stride_pfn</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* simple round-robin: */</span>
	<span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">usergart</span><span class="p">[</span><span class="n">fmt</span><span class="p">].</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NUM_USERGART_ENTRIES</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_gem_fault		-	pagefault handler for GEM objects</span>
<span class="cm"> * @vma: the VMA of the GEM object</span>
<span class="cm"> * @vmf: fault detail</span>
<span class="cm"> *</span>
<span class="cm"> * Invoked when a fault occurs on an mmap of a GEM managed area. GEM</span>
<span class="cm"> * does most of the work for us including the actual map/unmap calls</span>
<span class="cm"> * but we need to do the actual page work.</span>
<span class="cm"> *</span>
<span class="cm"> * The VMA was set up by GEM. In doing so it also ensured that the</span>
<span class="cm"> * vma-&gt;vm_private_data points to the GEM object that is backing this</span>
<span class="cm"> * mapping.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Make sure we don&#39;t parallel update on a fault, nor move or remove</span>
<span class="cm">	 * something from beneath our feet</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="cm">/* if a shmem backed object, make sure we have pages attached now */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* where should we do corresponding put_pages().. we are mapping</span>
<span class="cm">	 * the original page, rather than thru a GART, so we can&#39;t rely</span>
<span class="cm">	 * on eviction to trigger this.  But munmap() or all mappings should</span>
<span class="cm">	 * probably trigger put_pages()?</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_TILED</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fault_2d</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fault_1d</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">);</span>


<span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ERESTARTSYS</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EINTR</span>:
		<span class="k">return</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOMEM</span>:
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/** We override mainly to fix up some of the vm mapping flags.. */</span>
<span class="kt">int</span> <span class="nf">omap_gem_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">drm_gem_mmap</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;mmap failed: %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">omap_gem_mmap_obj</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">omap_gem_mmap_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_MIXEDMAP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_WC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_writecombine</span><span class="p">(</span><span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_UNCACHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We do have some private objects, at least for scanout buffers</span>
<span class="cm">		 * on hardware without DMM/TILER.  But these are allocated write-</span>
<span class="cm">		 * combine</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Shunt off cached objs to shmem file so they have their own</span>
<span class="cm">		 * address_space (so unmap_mapping_range does what we want,</span>
<span class="cm">		 * in particular in the case of mmap&#39;d dmabufs)</span>
<span class="cm">		 */</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">);</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span>  <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">;</span>

		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * omap_gem_dumb_create	-	create a dumb buffer</span>
<span class="cm"> * @drm_file: our client file</span>
<span class="cm"> * @dev: our device</span>
<span class="cm"> * @args: the requested arguments copied from userspace</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a buffer suitable for use for a frame buffer of the</span>
<span class="cm"> * form described by user space. Give userspace a handle by which</span>
<span class="cm"> * to reference it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_dumb_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_mode_create_dumb</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">omap_gem_size</span> <span class="n">gsize</span><span class="p">;</span>

	<span class="cm">/* in case someone tries to feed us a completely bogus stride: */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">pitch</span> <span class="o">=</span> <span class="n">align_pitch</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">pitch</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">bpp</span><span class="p">);</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">pitch</span> <span class="o">*</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>

	<span class="n">gsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">omap_gem_size</span><span class="p">){</span>
		<span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">omap_gem_new_handle</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">gsize</span><span class="p">,</span>
			<span class="n">OMAP_BO_SCANOUT</span> <span class="o">|</span> <span class="n">OMAP_BO_WC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_gem_dumb_destroy	-	destroy a dumb buffer</span>
<span class="cm"> * @file: client file</span>
<span class="cm"> * @dev: our DRM device</span>
<span class="cm"> * @handle: the object handle</span>
<span class="cm"> *</span>
<span class="cm"> * Destroy a handle that was created via omap_gem_dumb_create.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_dumb_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* No special work needed, drop the reference and see what falls out */</span>
	<span class="k">return</span> <span class="n">drm_gem_handle_delete</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_gem_dumb_map	-	buffer mapping for dumb interface</span>
<span class="cm"> * @file: our drm client file</span>
<span class="cm"> * @dev: drm device</span>
<span class="cm"> * @handle: GEM handle to the object (from dumb_create)</span>
<span class="cm"> *</span>
<span class="cm"> * Do the necessary setup to allow the mapping of the frame buffer</span>
<span class="cm"> * into user memory. We don&#39;t have to do much here at the moment.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_dumb_map_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* GEM does all our handle to object mapping */</span>
	<span class="n">obj</span> <span class="o">=</span> <span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">omap_gem_mmap_offset</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set scrolling position.  This allows us to implement fast scrolling</span>
<span class="cm"> * for console.</span>
<span class="cm"> *</span>
<span class="cm"> * Call only from non-atomic contexts.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_roll</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">roll</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">roll</span> <span class="o">&gt;</span> <span class="n">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid roll: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">roll</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">roll</span> <span class="o">=</span> <span class="n">roll</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="cm">/* if we aren&#39;t mapped yet, we don&#39;t need to do anything */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tiler_pin</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">roll</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not repin: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Sync the buffer for CPU access.. note pages should already be</span>
<span class="cm"> * attached, ie. omap_gem_get_pages()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap_gem_cpu_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cached_coherent</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">pgoff</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">pgoff</span><span class="p">],</span>
				<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">pgoff</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* sync the buffer for DMA access */</span>
<span class="kt">void</span> <span class="nf">omap_gem_dma_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cached_coherent</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
				<span class="n">dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">omap_gem_mmap_size</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Get physical address for DMA.. if &#39;remap&#39; is true, and the buffer is not</span>
<span class="cm"> * already contiguous, remap it to pin in physically contiguous memory.. (ie.</span>
<span class="cm"> * map in TILER)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_get_paddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">remap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remap</span> <span class="o">&amp;&amp;</span> <span class="n">is_shmem</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">has_dmm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="k">enum</span> <span class="n">tiler_fmt</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">gem2fmt</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">tiler_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_TILED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">block</span> <span class="o">=</span> <span class="n">tiler_reserve_2d</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span>
						<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
						<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">block</span> <span class="o">=</span> <span class="n">tiler_reserve_1d</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">block</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;could not remap: %d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* TODO: enable async refill.. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tiler_pin</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span>
					<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">roll</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tiler_release</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;could not pin: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span> <span class="o">=</span> <span class="n">tiler_ssptr</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>

			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;got paddr: %08x&quot;</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr_cnt</span><span class="o">++</span><span class="p">;</span>

		<span class="o">*</span><span class="n">paddr</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_DMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">paddr</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Release physical address, when DMA is no longer being performed.. this</span>
<span class="cm"> * could potentially unpin and unmap buffers from TILER</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_put_paddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tiler_unpin</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;could not unpin pages: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tiler_release</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;could not release unmap: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* acquire pages when needed (for example, for DMA where physically</span>
<span class="cm"> * contiguous buffer is not required</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">***</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shmem</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_gem_attach_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not attach pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* TODO: even phys-contig.. we should have a list of pages? */</span>
	<span class="o">*</span><span class="n">pages</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* if !remap, and we don&#39;t have pages backing, then fail, rather than</span>
<span class="cm"> * increasing the pin count (which we don&#39;t really do yet anyways,</span>
<span class="cm"> * because we don&#39;t support swapping pages back out).  And &#39;remap&#39;</span>
<span class="cm"> * might not be quite the right name, but I wanted to keep it working</span>
<span class="cm"> * similarly to omap_gem_get_paddr().  Note though that mutex is not</span>
<span class="cm"> * aquired if !remap (because this can be called in atomic ctxt),</span>
<span class="cm"> * but probably omap_gem_get_paddr() should be changed to work in the</span>
<span class="cm"> * same way.  If !remap, a matching omap_gem_put_pages() call is not</span>
<span class="cm"> * required (and should not be made).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_get_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">***</span><span class="n">pages</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">remap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pages</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* release pages when DMA no longer being performed */</span>
<span class="kt">int</span> <span class="nf">omap_gem_put_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* do something here if we dynamically attach/detach pages.. at</span>
<span class="cm">	 * least they would no longer need to be pinned if everyone has</span>
<span class="cm">	 * released the pages..</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get kernel virtual address for CPU access.. this more or less only</span>
<span class="cm"> * exists for omap_fbdev.  This should be called with struct_mutex</span>
<span class="cm"> * held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">omap_gem_vaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span> <span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">get_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
				<span class="n">VM_MAP</span><span class="p">,</span> <span class="n">pgprot_writecombine</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="kt">void</span> <span class="nf">omap_gem_describe</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">uint64_t</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span> <span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_list</span><span class="p">.</span><span class="n">map</span><span class="p">)</span>
		<span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_list</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%08x: %2d (%2d) %08llx %08Zx (%2d) %p %4d&quot;</span><span class="p">,</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">.</span><span class="n">refcount</span><span class="p">.</span><span class="n">counter</span><span class="p">,</span>
			<span class="n">off</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr_cnt</span><span class="p">,</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">roll</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_TILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %dx%d&quot;</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">;</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; (%dx%d, %dx%d)&quot;</span><span class="p">,</span>
					<span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>
					<span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">omap_gem_describe_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">omap_obj</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">mm_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;   &quot;</span><span class="p">);</span>
		<span class="n">omap_gem_describe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Total %d objects, %zu bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Buffer Synchronization:</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">omap_gem_sync_waiter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">omap_gem_op</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">read_target</span><span class="p">,</span> <span class="n">write_target</span><span class="p">;</span>
	<span class="cm">/* notify called w/ sync_lock held */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* list of omap_gem_sync_waiter.. the notify fxn gets called back when</span>
<span class="cm"> * the read and/or write target count is achieved which can call a user</span>
<span class="cm"> * callback (ex. to kick 3d and/or 2d), wakeup blocked task (prep for</span>
<span class="cm"> * cpu access), etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">waiters</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_waiting</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_gem_sync_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">omap_obj</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">OMAP_GEM_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">read_complete</span> <span class="o">&lt;</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">read_target</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">OMAP_GEM_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">write_complete</span> <span class="o">&lt;</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">write_target</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* macro for sync debug.. */</span>
<span class="cp">#define SYNCDBG 0</span>
<span class="cp">#define SYNC(fmt, ...) do { if (SYNCDBG) \</span>
<span class="cp">		printk(KERN_ERR &quot;%s:%d: &quot;fmt&quot;\n&quot;, \</span>
<span class="cp">				__func__, __LINE__, ##__VA_ARGS__); \</span>
<span class="cp">	} while (0)</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_op_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_sync_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">waiter</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiters</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_waiting</span><span class="p">(</span><span class="n">waiter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">SYNC</span><span class="p">(</span><span class="s">&quot;notify: %p&quot;</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>
			<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sync_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">omap_gem_op</span> <span class="n">op</span><span class="p">,</span> <span class="n">bool</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">OMAP_GEM_READ</span><span class="p">)</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">read_pending</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">OMAP_GEM_WRITE</span><span class="p">)</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">write_pending</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">OMAP_GEM_READ</span><span class="p">)</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">read_complete</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">OMAP_GEM_WRITE</span><span class="p">)</span>
			<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">write_complete</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sync_op_update</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* it is a bit lame to handle updates in this sort of polling way, but</span>
<span class="cm"> * in case of PVR, the GPU can directly update read/write complete</span>
<span class="cm"> * values, and not really tell us which ones it updated.. this also</span>
<span class="cm"> * means that sync_lock is not quite sufficient.  So we&#39;ll need to</span>
<span class="cm"> * do something a bit better when it comes time to add support for</span>
<span class="cm"> * separate 2d hw..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap_gem_op_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
	<span class="n">sync_op_update</span><span class="p">();</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mark the start of read and/or write operation */</span>
<span class="kt">int</span> <span class="nf">omap_gem_op_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">enum</span> <span class="n">omap_gem_op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sync_op</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">omap_gem_op_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">enum</span> <span class="n">omap_gem_op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sync_op</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">sync_event</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_notify</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">**</span><span class="n">waiter_task</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="o">*</span><span class="n">waiter_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">omap_gem_op_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">enum</span> <span class="n">omap_gem_op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">waiter_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">omap_gem_sync_waiter</span> <span class="o">*</span><span class="n">waiter</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">waiter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waiter</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">read_target</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">read_pending</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">write_target</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">write_pending</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">notify</span> <span class="o">=</span> <span class="n">sync_notify</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">waiter_task</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_waiting</span><span class="p">(</span><span class="n">waiter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SYNC</span><span class="p">(</span><span class="s">&quot;waited: %p&quot;</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiters</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">sync_event</span><span class="p">,</span>
					<span class="p">(</span><span class="n">waiter_task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">));</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waiter_task</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SYNC</span><span class="p">(</span><span class="s">&quot;interrupted: %p&quot;</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>
				<span class="cm">/* we were interrupted */</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">waiter_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* freed in sync_op_update() */</span>
				<span class="n">waiter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* call fxn(arg), either synchronously or asynchronously if the op</span>
<span class="cm"> * is currently blocked..  fxn() can be called from any context</span>
<span class="cm"> *</span>
<span class="cm"> * (TODO for now fxn is called back from whichever context calls</span>
<span class="cm"> * omap_gem_op_update().. but this could be better defined later</span>
<span class="cm"> * if needed)</span>
<span class="cm"> *</span>
<span class="cm"> * TODO more code in common w/ _sync()..</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_op_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">enum</span> <span class="n">omap_gem_op</span> <span class="n">op</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fxn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_gem_sync_waiter</span> <span class="o">*</span><span class="n">waiter</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">waiter</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waiter</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">read_target</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">read_pending</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">write_target</span> <span class="o">=</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">write_pending</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">notify</span> <span class="o">=</span> <span class="n">fxn</span><span class="p">;</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_waiting</span><span class="p">(</span><span class="n">waiter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SYNC</span><span class="p">(</span><span class="s">&quot;waited: %p&quot;</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiters</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* no waiting.. */</span>
	<span class="n">fxn</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* special API so PVR can update the buffer to use a sync-object allocated</span>
<span class="cm"> * from it&#39;s sync-obj heap.  Only used for a newly allocated (from PVR&#39;s</span>
<span class="cm"> * perspective) sync-object, so we overwrite the new syncobj w/ values</span>
<span class="cm"> * from the already allocated syncobj (if there is one)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_gem_set_sync_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">syncobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_EXT_SYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">syncobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* clearing a previously set syncobj */</span>
		<span class="n">syncobj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">syncobj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">syncobj</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">));</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OMAP_BO_EXT_SYNC</span><span class="p">;</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="n">syncobj</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">syncobj</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_EXT_SYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* replacing an existing syncobj */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">syncobj</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">OMAP_BO_EXT_SYNC</span><span class="p">;</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="n">syncobj</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">omap_gem_init_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>          <span class="cm">/* unused */</span>
<span class="p">}</span>

<span class="cm">/* don&#39;t call directly.. called from GEM core when it is time to actually</span>
<span class="cm"> * free the object..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap_gem_free_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span> <span class="o">=</span> <span class="n">to_omap_bo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="n">evict</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">));</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_list</span><span class="p">.</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drm_gem_free_mmap_offset</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* this means the object is still pinned.. which really should</span>
<span class="cm">	 * not happen.  I think..</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* don&#39;t free externally allocated backing memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_EXT_MEM</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">omap_gem_detach_pages</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shmem</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dma_free_writecombine</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vunmap</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* don&#39;t free externally allocated syncobj */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_EXT_SYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">drm_gem_object_release</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* convenience method to construct a GEM buffer object, and userspace handle */</span>
<span class="kt">int</span> <span class="nf">omap_gem_new_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">omap_gem_size</span> <span class="n">gsize</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">omap_gem_new</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">gsize</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">drm_gem_handle_create</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drm_gem_object_release</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="cm">/* TODO isn&#39;t there a dtor to call? just copying i915 */</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* drop reference from allocate - handle holds it now */</span>
	<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* GEM buffer object constructor */</span>
<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="nf">omap_gem_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">omap_gem_size</span> <span class="n">gsize</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_gem_object</span> <span class="o">*</span><span class="n">omap_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_TILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usergart</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tiled buffers require DMM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* tiled buffers are always shmem paged backed.. when they are</span>
<span class="cm">		 * scanned out, they are remapped into DMM/TILER</span>
<span class="cm">		 */</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OMAP_BO_SCANOUT</span><span class="p">;</span>

		<span class="cm">/* currently don&#39;t allow cached buffers.. there is some caching</span>
<span class="cm">		 * stuff that needs to be handled better</span>
<span class="cm">		 */</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">OMAP_BO_CACHED</span><span class="o">|</span><span class="n">OMAP_BO_UNCACHED</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">OMAP_BO_WC</span><span class="p">;</span>

		<span class="cm">/* align dimensions to slot boundaries... */</span>
		<span class="n">tiler_align</span><span class="p">(</span><span class="n">gem2fmt</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">gsize</span><span class="p">.</span><span class="n">tiled</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gsize</span><span class="p">.</span><span class="n">tiled</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

		<span class="cm">/* ...and calculate size based on aligned dimensions */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">tiler_size</span><span class="p">(</span><span class="n">gem2fmt</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span>
				<span class="n">gsize</span><span class="p">.</span><span class="n">tiled</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">gsize</span><span class="p">.</span><span class="n">tiled</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">gsize</span><span class="p">.</span><span class="n">bytes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">omap_obj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">omap_obj</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">omap_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate GEM object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">obj_list</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_SCANOUT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">has_dmm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* attempt to allocate contiguous memory if we don&#39;t</span>
<span class="cm">		 * have DMM for remappign discontiguous buffers</span>
<span class="cm">		 */</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span>  <span class="n">dma_alloc_writecombine</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">OMAP_BO_DMA</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_BO_TILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">gsize</span><span class="p">.</span><span class="n">tiled</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
		<span class="n">omap_obj</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">gsize</span><span class="p">.</span><span class="n">tiled</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">OMAP_BO_DMA</span><span class="o">|</span><span class="n">OMAP_BO_EXT_MEM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drm_gem_private_object_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drm_gem_object_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap_gem_free_object</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* init/cleanup.. if DMM is used, we need to set some stuff up.. */</span>
<span class="kt">void</span> <span class="nf">omap_gem_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_drm_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">enum</span> <span class="n">tiler_fmt</span> <span class="n">fmts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">TILFMT_8BIT</span><span class="p">,</span> <span class="n">TILFMT_16BIT</span><span class="p">,</span> <span class="n">TILFMT_32BIT</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmm_is_initialized</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* DMM only supported on OMAP4 and later, so this isn&#39;t fatal */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMM not available, disable DMM support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usergart</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">usergart</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usergart</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate usergart</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reserve 4k aligned/wide regions for userspace mappings: */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fmts</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">tiler_align</span><span class="p">(</span><span class="n">fmts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
		<span class="cm">/* note: since each region is 1 4kb page wide, and minimum</span>
<span class="cm">		 * number of rows, the height ends up being the same as the</span>
<span class="cm">		 * # of pages in the region</span>
<span class="cm">		 */</span>
		<span class="n">usergart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">height</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
		<span class="n">usergart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">height_shift</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="n">usergart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stride_pfn</span> <span class="o">=</span> <span class="n">tiler_stride</span><span class="p">(</span><span class="n">fmts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">usergart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slot_shift</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">((</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NUM_USERGART_ENTRIES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usergart_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usergart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">tiler_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span>
					<span class="n">tiler_reserve_2d</span><span class="p">(</span><span class="n">fmts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
							<span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">block</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;reserve failed: %d, %d, %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">block</span><span class="p">));</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span> <span class="o">=</span> <span class="n">tiler_ssptr</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>

			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;%d:%d: %dx%d: paddr=%08x stride=%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					<span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span>
					<span class="n">usergart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stride_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">has_dmm</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">omap_gem_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* I believe we can rely on there being no more outstanding GEM</span>
<span class="cm">	 * objects which could depend on usergart/dmm at this point.</span>
<span class="cm">	 */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usergart</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
