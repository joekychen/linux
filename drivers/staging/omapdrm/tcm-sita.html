<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › omapdrm › tcm-sita.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tcm-sita.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * tcm-sita.c</span>
<span class="cm"> *</span>
<span class="cm"> * SImple Tiler Allocator (SiTA): 2D and 1D allocation(reservation) algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Ravi Ramachandra &lt;r.ramachandra@ti.com&gt;,</span>
<span class="cm"> *          Lajos Molnar &lt;molnar@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2010 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This package is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS PACKAGE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &quot;tcm-sita.h&quot;</span>

<span class="cp">#define ALIGN_DOWN(value, align) ((value) &amp; ~((align) - 1))</span>

<span class="cm">/* Individual selection criteria for different scan areas */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">CR_L2R_T2B</span> <span class="o">=</span> <span class="n">CR_BIAS_HORIZONTAL</span><span class="p">;</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">CR_R2L_T2B</span> <span class="o">=</span> <span class="n">CR_DIAGONAL_BALANCE</span><span class="p">;</span>

<span class="cm">/*********************************************</span>
<span class="cm"> *	TCM API - Sita Implementation</span>
<span class="cm"> *********************************************/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">sita_reserve_2d</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u8</span> <span class="n">align</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">sita_reserve_1d</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">slots</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">sita_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sita_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">);</span>

<span class="cm">/*********************************************</span>
<span class="cm"> *	Main Scanner functions</span>
<span class="cm"> *********************************************/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">scan_areas_and_find_fit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">align</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">scan_l2r_t2b</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">align</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">scan_r2l_t2b</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">align</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">scan_r2l_b2t_one_dim</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">num_slots</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>

<span class="cm">/*********************************************</span>
<span class="cm"> *	Support Infrastructure Methods</span>
<span class="cm"> *********************************************/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">is_area_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">***</span><span class="n">map</span><span class="p">,</span> <span class="n">u16</span> <span class="n">x0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">y0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">);</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">update_candidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">x0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">y0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="n">s32</span> <span class="n">criteria</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">score</span> <span class="o">*</span><span class="n">best</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">get_nearness_factor</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">candidate</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">nearness_factor</span> <span class="o">*</span><span class="n">nf</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">get_neighbor_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">neighbor_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fill_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>


<span class="cm">/*********************************************/</span>

<span class="cm">/*********************************************</span>
<span class="cm"> *	Utility Methods</span>
<span class="cm"> *********************************************/</span>
<span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="nf">sita_init</span><span class="p">(</span><span class="n">u16</span> <span class="n">width</span><span class="p">,</span> <span class="n">u16</span> <span class="n">height</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_pt</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="n">area</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">s32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tcm</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tcm</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">pvt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcm</span> <span class="o">||</span> <span class="o">!</span><span class="n">pvt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tcm</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvt</span><span class="p">));</span>

	<span class="cm">/* Updating the pointers to SiTA implementation APIs */</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">reserve_2d</span> <span class="o">=</span> <span class="n">sita_reserve_2d</span><span class="p">;</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">reserve_1d</span> <span class="o">=</span> <span class="n">sita_reserve_1d</span><span class="p">;</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">sita_free</span><span class="p">;</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">deinit</span> <span class="o">=</span> <span class="n">sita_deinit</span><span class="p">;</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pvt</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>

	<span class="cm">/* Creating tam map */</span>
	<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">)</span> <span class="o">*</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">**</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">)</span> <span class="o">*</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">;</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Defaulting to 3:1 ratio on width for 2D area split */</span>
		<span class="cm">/* Defaulting to 3:1 ratio on height for 2D and 1D split */</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">fill_area</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">area</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">tcm</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tcm</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sita_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="n">area</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">s32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">area</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">area</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="n">fill_area</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">area</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pvt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Reserve a 1D area in the container</span>
<span class="cm"> *</span>
<span class="cm"> * @param num_slots	size of 1D area</span>
<span class="cm"> * @param area		pointer to the area that will be populated with the</span>
<span class="cm"> *			reserved area</span>
<span class="cm"> *</span>
<span class="cm"> * @return 0 on success, non-0 error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">sita_reserve_1d</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">num_slots</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="n">field</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>

	<span class="cm">/* Scanning entire container */</span>
	<span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_r2l_b2t_one_dim</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">num_slots</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="cm">/* update map */</span>
		<span class="n">fill_area</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Reserve a 2D area in the container</span>
<span class="cm"> *</span>
<span class="cm"> * @param w	width</span>
<span class="cm"> * @param h	height</span>
<span class="cm"> * @param area	pointer to the area that will be populated with the reserved</span>
<span class="cm"> *		area</span>
<span class="cm"> *</span>
<span class="cm"> * @return 0 on success, non-0 error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">sita_reserve_2d</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u8</span> <span class="n">align</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>

	<span class="cm">/* not supporting more than 64 as alignment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">align</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* we prefer 1, 32 and 64 as alignment */</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">align</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">align</span> <span class="o">&lt;=</span> <span class="mi">32</span> <span class="o">?</span> <span class="mi">32</span> <span class="o">:</span> <span class="mi">64</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_areas_and_find_fit</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="cm">/* update map */</span>
		<span class="n">fill_area</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Unreserve a previously allocated 2D or 1D area</span>
<span class="cm"> * @param area	area to be freed</span>
<span class="cm"> * @return 0 - success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">sita_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>

	<span class="cm">/* check that this is in fact an existing area */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="n">area</span> <span class="o">||</span>
		<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="n">area</span><span class="p">);</span>

	<span class="cm">/* Clear the contents of the associated tiles in the map */</span>
	<span class="n">fill_area</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Note: In general the cordinates in the scan field area relevant to the can</span>
<span class="cm"> * sweep directions. The scan origin (e.g. top-left corner) will always be</span>
<span class="cm"> * the p0 member of the field.  Therfore, for a scan from top-left p0.x &lt;= p1.x</span>
<span class="cm"> * and p0.y &lt;= p1.y; whereas, for a scan from bottom-right p1.x &lt;= p0.x and p1.y</span>
<span class="cm"> * &lt;= p0.y</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Raster scan horizontally right to left from top to bottom to find a place for</span>
<span class="cm"> * a 2D area of given size inside a scan field.</span>
<span class="cm"> *</span>
<span class="cm"> * @param w	width of desired area</span>
<span class="cm"> * @param h	height of desired area</span>
<span class="cm"> * @param align	desired area alignment</span>
<span class="cm"> * @param area	pointer to the area that will be set to the best position</span>
<span class="cm"> * @param field	area to scan (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * @return 0 on success, non-0 error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">scan_r2l_t2b</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">align</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">start_x</span><span class="p">,</span> <span class="n">end_x</span><span class="p">,</span> <span class="n">start_y</span><span class="p">,</span> <span class="n">end_y</span><span class="p">,</span> <span class="n">found_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">***</span><span class="n">map</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">score</span> <span class="n">best</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="mi">0</span><span class="p">};</span>

	<span class="n">start_x</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">end_x</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">start_y</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
	<span class="n">end_y</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

	<span class="cm">/* check scan area co-ordinates */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span>
	    <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check if allocation would fit in scan area */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">LEN</span><span class="p">(</span><span class="n">start_x</span><span class="p">,</span> <span class="n">end_x</span><span class="p">)</span> <span class="o">||</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">LEN</span><span class="p">(</span><span class="n">end_y</span><span class="p">,</span> <span class="n">start_y</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* adjust start_x and end_y, as allocation would not fit beyond */</span>
	<span class="n">start_x</span> <span class="o">=</span> <span class="n">ALIGN_DOWN</span><span class="p">(</span><span class="n">start_x</span> <span class="o">-</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span> <span class="cm">/* - 1 to be inclusive */</span>
	<span class="n">end_y</span> <span class="o">=</span> <span class="n">end_y</span> <span class="o">-</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* check if allocation would still fit in scan area */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_x</span> <span class="o">&lt;</span> <span class="n">end_x</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* scan field top-to-bottom, right-to-left */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">start_y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">end_y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">start_x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">end_x</span><span class="p">;</span> <span class="n">x</span> <span class="o">-=</span> <span class="n">align</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_area_free</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

				<span class="cm">/* update best candidate */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">update_candidate</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span>
							<span class="n">CR_R2L_T2B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">best</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

				<span class="cm">/* change upper x bound */</span>
				<span class="n">end_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is2d</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* step over 2D areas */</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* break if you find a free area shouldering the scan field */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_x</span> <span class="o">==</span> <span class="n">start_x</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">tcm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="n">assign</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Raster scan horizontally left to right from top to bottom to find a place for</span>
<span class="cm"> * a 2D area of given size inside a scan field.</span>
<span class="cm"> *</span>
<span class="cm"> * @param w	width of desired area</span>
<span class="cm"> * @param h	height of desired area</span>
<span class="cm"> * @param align	desired area alignment</span>
<span class="cm"> * @param area	pointer to the area that will be set to the best position</span>
<span class="cm"> * @param field	area to scan (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * @return 0 on success, non-0 error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">scan_l2r_t2b</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">align</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">start_x</span><span class="p">,</span> <span class="n">end_x</span><span class="p">,</span> <span class="n">start_y</span><span class="p">,</span> <span class="n">end_y</span><span class="p">,</span> <span class="n">found_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">***</span><span class="n">map</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">score</span> <span class="n">best</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="mi">0</span><span class="p">};</span>

	<span class="n">start_x</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">end_x</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">start_y</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
	<span class="n">end_y</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

	<span class="cm">/* check scan area co-ordinates */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span>
	    <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check if allocation would fit in scan area */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">LEN</span><span class="p">(</span><span class="n">end_x</span><span class="p">,</span> <span class="n">start_x</span><span class="p">)</span> <span class="o">||</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">LEN</span><span class="p">(</span><span class="n">end_y</span><span class="p">,</span> <span class="n">start_y</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">start_x</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">start_x</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>

	<span class="cm">/* check if allocation would still fit in scan area */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">LEN</span><span class="p">(</span><span class="n">end_x</span><span class="p">,</span> <span class="n">start_x</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* adjust end_x and end_y, as allocation would not fit beyond */</span>
	<span class="n">end_x</span> <span class="o">=</span> <span class="n">end_x</span> <span class="o">-</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* + 1 to be inclusive */</span>
	<span class="n">end_y</span> <span class="o">=</span> <span class="n">end_y</span> <span class="o">-</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* scan field top-to-bottom, left-to-right */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">start_y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">end_y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">start_x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">end_x</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">align</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_area_free</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

				<span class="cm">/* update best candidate */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">update_candidate</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span>
							<span class="n">CR_L2R_T2B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">best</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
				<span class="cm">/* change upper x bound */</span>
				<span class="n">end_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is2d</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* step over 2D areas */</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">ALIGN_DOWN</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* break if you find a free area shouldering the scan field */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_x</span> <span class="o">==</span> <span class="n">start_x</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">tcm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="n">assign</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">best</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Raster scan horizontally right to left from bottom to top to find a place</span>
<span class="cm"> * for a 1D area of given size inside a scan field.</span>
<span class="cm"> *</span>
<span class="cm"> * @param num_slots	size of desired area</span>
<span class="cm"> * @param align		desired area alignment</span>
<span class="cm"> * @param area		pointer to the area that will be set to the best</span>
<span class="cm"> *			position</span>
<span class="cm"> * @param field		area to scan (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * @return 0 on success, non-0 error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">scan_r2l_b2t_one_dim</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">num_slots</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* check scan area co-ordinates */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Currently we only support full width 1D scan field, which makes sense</span>
<span class="cm">	 * since 1D slot-ordering spans the full container width.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">!=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check if allocation would fit in scan area */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_slots</span> <span class="o">&gt;</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">LEN</span><span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">x</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">y</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

	<span class="cm">/* find num_slots consecutive free slots to the left */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="n">num_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

		<span class="cm">/* remember bottom-right corner */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* skip busy regions */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* move to left of 2D areas, top left of 1D */</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">is2d</span><span class="p">)</span>
				<span class="n">y</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

			<span class="cm">/* start over */</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* count consecutive free slots */</span>
			<span class="n">found</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="n">num_slots</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* move to the left */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">y</span><span class="o">--</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">?</span> <span class="o">:</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/* set top-left corner */</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Find a place for a 2D area of given size inside a scan field based on its</span>
<span class="cm"> * alignment needs.</span>
<span class="cm"> *</span>
<span class="cm"> * @param w	width of desired area</span>
<span class="cm"> * @param h	height of desired area</span>
<span class="cm"> * @param align	desired area alignment</span>
<span class="cm"> * @param area	pointer to the area that will be set to the best position</span>
<span class="cm"> *</span>
<span class="cm"> * @return 0 on success, non-0 error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">scan_areas_and_find_fit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span> <span class="n">u16</span> <span class="n">align</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="n">field</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">u16</span> <span class="n">boundary_x</span><span class="p">,</span> <span class="n">boundary_y</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">align</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* prefer top-left corner */</span>
		<span class="n">boundary_x</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">boundary_y</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* expand width and height if needed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
			<span class="n">boundary_x</span> <span class="o">=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
			<span class="n">boundary_y</span> <span class="o">=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boundary_x</span><span class="p">,</span> <span class="n">boundary_y</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_l2r_t2b</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>

		<span class="cm">/* scan whole container if failed, but do not scan 2x */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">boundary_x</span> <span class="o">!=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span>
				 <span class="n">boundary_y</span> <span class="o">!=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* scan the entire container if nothing found */</span>
			<span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_l2r_t2b</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">align</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* prefer top-right corner */</span>
		<span class="n">boundary_x</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
		<span class="n">boundary_y</span> <span class="o">=</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* expand width and height if needed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">x</span><span class="p">))</span>
			<span class="n">boundary_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">pvt</span><span class="o">-&gt;</span><span class="n">div_pt</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
			<span class="n">boundary_y</span> <span class="o">=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boundary_x</span><span class="p">,</span> <span class="n">boundary_y</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_r2l_t2b</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>

		<span class="cm">/* scan whole container if failed, but do not scan 2x */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">boundary_x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
				 <span class="n">boundary_y</span> <span class="o">!=</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* scan the entire container if nothing found */</span>
			<span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">field</span><span class="p">,</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_r2l_t2b</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field</span><span class="p">,</span>
					   <span class="n">area</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check if an entire area is free */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">is_area_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">***</span><span class="n">map</span><span class="p">,</span> <span class="n">u16</span> <span class="n">x0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">y0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">h</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">w</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* fills an area with a parent tcm_area */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcm_area</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_</span><span class="p">;</span>

	<span class="cm">/* set area&#39;s tcm; otherwise, enumerator considers it invalid */</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">tcm</span> <span class="o">=</span> <span class="n">tcm</span><span class="p">;</span>

	<span class="n">tcm_for_each_slice</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="n">a_</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
				<span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Compares a candidate area to the current best area, and if it is a better</span>
<span class="cm"> * fit, it updates the best to this one.</span>
<span class="cm"> *</span>
<span class="cm"> * @param x0, y0, w, h		top, left, width, height of candidate area</span>
<span class="cm"> * @param field			scan field</span>
<span class="cm"> * @param criteria		scan criteria</span>
<span class="cm"> * @param best			best candidate and its scores</span>
<span class="cm"> *</span>
<span class="cm"> * @return 1 (true) if the candidate area is known to be the final best, so no</span>
<span class="cm"> * more searching should be performed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">update_candidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="n">u16</span> <span class="n">x0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">y0</span><span class="p">,</span> <span class="n">u16</span> <span class="n">w</span><span class="p">,</span> <span class="n">u16</span> <span class="n">h</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="n">s32</span> <span class="n">criteria</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">score</span> <span class="o">*</span><span class="n">best</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">score</span> <span class="n">me</span><span class="p">;</span>	<span class="cm">/* score for area */</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: For horizontal bias we always give the first found, because our</span>
<span class="cm">	 * scan is horizontal-raster-based and the first candidate will always</span>
<span class="cm">	 * have the horizontal bias.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="n">criteria</span> <span class="o">&amp;</span> <span class="n">CR_BIAS_HORIZONTAL</span><span class="p">;</span>

	<span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* calculate score for current candidate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_neighbor_stats</span><span class="p">(</span><span class="n">tcm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="p">.</span><span class="n">n</span><span class="p">);</span>
		<span class="n">me</span><span class="p">.</span><span class="n">neighs</span> <span class="o">=</span> <span class="n">me</span><span class="p">.</span><span class="n">n</span><span class="p">.</span><span class="n">edge</span> <span class="o">+</span> <span class="n">me</span><span class="p">.</span><span class="n">n</span><span class="p">.</span><span class="n">busy</span><span class="p">;</span>
		<span class="n">get_nearness_factor</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="p">.</span><span class="n">f</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* the 1st candidate is always the best */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">tcm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">better</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>

	<span class="cm">/* diagonal balance check */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">criteria</span> <span class="o">&amp;</span> <span class="n">CR_DIAGONAL_BALANCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">best</span><span class="o">-&gt;</span><span class="n">neighs</span> <span class="o">&lt;=</span> <span class="n">me</span><span class="p">.</span><span class="n">neighs</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">neighs</span> <span class="o">&lt;</span> <span class="n">me</span><span class="p">.</span><span class="n">neighs</span> <span class="o">||</span>
		 <span class="cm">/* this implies that neighs and occupied match */</span>
		 <span class="n">best</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">.</span><span class="n">busy</span> <span class="o">&lt;</span> <span class="n">me</span><span class="p">.</span><span class="n">n</span><span class="p">.</span><span class="n">busy</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">.</span><span class="n">busy</span> <span class="o">==</span> <span class="n">me</span><span class="p">.</span><span class="n">n</span><span class="p">.</span><span class="n">busy</span> <span class="o">&amp;&amp;</span>
		  <span class="cm">/* check the nearness factor */</span>
		  <span class="n">best</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">me</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">me</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">y</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">better</span><span class="p">;</span>

	<span class="cm">/* not better, keep going */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">better:</span>
	<span class="cm">/* save current area as best */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">me</span><span class="p">));</span>
	<span class="n">best</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">tcm</span> <span class="o">=</span> <span class="n">tcm</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Calculate the nearness factor of an area in a search field.  The nearness</span>
<span class="cm"> * factor is smaller if the area is closer to the search origin.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_nearness_factor</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">nearness_factor</span> <span class="o">*</span><span class="n">nf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * Using signed math as field coordinates may be reversed if</span>
<span class="cm">	 * search direction is right-to-left or bottom-to-top.</span>
<span class="cm">	 */</span>
	<span class="n">nf</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span>
		<span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
	<span class="n">nf</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span>
		<span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* get neighbor statistics */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_neighbor_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcm</span> <span class="o">*</span><span class="n">tcm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcm_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">neighbor_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s16</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="n">pvt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sita_pvt</span> <span class="o">*</span><span class="p">)</span><span class="n">tcm</span><span class="o">-&gt;</span><span class="n">pvt</span><span class="p">;</span>

	<span class="cm">/* Clearing any exisiting values */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stat</span><span class="p">));</span>

	<span class="cm">/* process top &amp; bottom edges */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">edge</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">busy</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">edge</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">busy</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* process left &amp; right edges */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">edge</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">])</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">busy</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">tcm</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">edge</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pvt</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">])</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">busy</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
