<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › wlan-ng › hfa384x_usb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hfa384x_usb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* src/prism2/driver/hfa384x_usb.c</span>
<span class="cm">*</span>
<span class="cm">* Functions that talk to the USB variantof the Intersil hfa384x MAC</span>
<span class="cm">*</span>
<span class="cm">* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.</span>
<span class="cm">* --------------------------------------------------------------------</span>
<span class="cm">*</span>
<span class="cm">* linux-wlan</span>
<span class="cm">*</span>
<span class="cm">*   The contents of this file are subject to the Mozilla Public</span>
<span class="cm">*   License Version 1.1 (the &quot;License&quot;); you may not use this file</span>
<span class="cm">*   except in compliance with the License. You may obtain a copy of</span>
<span class="cm">*   the License at http://www.mozilla.org/MPL/</span>
<span class="cm">*</span>
<span class="cm">*   Software distributed under the License is distributed on an &quot;AS</span>
<span class="cm">*   IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or</span>
<span class="cm">*   implied. See the License for the specific language governing</span>
<span class="cm">*   rights and limitations under the License.</span>
<span class="cm">*</span>
<span class="cm">*   Alternatively, the contents of this file may be used under the</span>
<span class="cm">*   terms of the GNU Public License version 2 (the &quot;GPL&quot;), in which</span>
<span class="cm">*   case the provisions of the GPL are applicable instead of the</span>
<span class="cm">*   above.  If you wish to allow the use of your version of this file</span>
<span class="cm">*   only under the terms of the GPL and not to allow others to use</span>
<span class="cm">*   your version of this file under the MPL, indicate your decision</span>
<span class="cm">*   by deleting the provisions above and replace them with the notice</span>
<span class="cm">*   and other provisions required by the GPL.  If you do not delete</span>
<span class="cm">*   the provisions above, a recipient may use your version of this</span>
<span class="cm">*   file under either the MPL or the GPL.</span>
<span class="cm">*</span>
<span class="cm">* --------------------------------------------------------------------</span>
<span class="cm">*</span>
<span class="cm">* Inquiries regarding the linux-wlan Open Source project can be</span>
<span class="cm">* made directly to:</span>
<span class="cm">*</span>
<span class="cm">* AbsoluteValue Systems Inc.</span>
<span class="cm">* info@linux-wlan.com</span>
<span class="cm">* http://www.linux-wlan.com</span>
<span class="cm">*</span>
<span class="cm">* --------------------------------------------------------------------</span>
<span class="cm">*</span>
<span class="cm">* Portions of the development of this software were funded by</span>
<span class="cm">* Intersil Corporation as part of PRISM(R) chipset product development.</span>
<span class="cm">*</span>
<span class="cm">* --------------------------------------------------------------------</span>
<span class="cm">*</span>
<span class="cm">* This file implements functions that correspond to the prism2/hfa384x</span>
<span class="cm">* 802.11 MAC hardware and firmware host interface.</span>
<span class="cm">*</span>
<span class="cm">* The functions can be considered to represent several levels of</span>
<span class="cm">* abstraction.  The lowest level functions are simply C-callable wrappers</span>
<span class="cm">* around the register accesses.  The next higher level represents C-callable</span>
<span class="cm">* prism2 API functions that match the Intersil documentation as closely</span>
<span class="cm">* as is reasonable.  The next higher layer implements common sequences</span>
<span class="cm">* of invocations of the API layer (e.g. write to bap, followed by cmd).</span>
<span class="cm">*</span>
<span class="cm">* Common sequences:</span>
<span class="cm">* hfa384x_drvr_xxx	Highest level abstractions provided by the</span>
<span class="cm">*			hfa384x code.  They are driver defined wrappers</span>
<span class="cm">*			for common sequences.  These functions generally</span>
<span class="cm">*			use the services of the lower levels.</span>
<span class="cm">*</span>
<span class="cm">* hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These</span>
<span class="cm">*			functions are wrappers for the RID get/set</span>
<span class="cm">*			sequence. They call copy_[to|from]_bap() and</span>
<span class="cm">*			cmd_access(). These functions operate on the</span>
<span class="cm">*			RIDs and buffers without validation. The caller</span>
<span class="cm">*			is responsible for that.</span>
<span class="cm">*</span>
<span class="cm">* API wrapper functions:</span>
<span class="cm">* hfa384x_cmd_xxx	functions that provide access to the f/w commands.</span>
<span class="cm">*			The function arguments correspond to each command</span>
<span class="cm">*			argument, even command arguments that get packed</span>
<span class="cm">*			into single registers.  These functions _just_</span>
<span class="cm">*			issue the command by setting the cmd/parm regs</span>
<span class="cm">*			&amp; reading the status/resp regs.  Additional</span>
<span class="cm">*			activities required to fully use a command</span>
<span class="cm">*			(read/write from/to bap, get/set int status etc.)</span>
<span class="cm">*			are implemented separately.  Think of these as</span>
<span class="cm">*			C-callable prism2 commands.</span>
<span class="cm">*</span>
<span class="cm">* Lowest Layer Functions:</span>
<span class="cm">* hfa384x_docmd_xxx	These functions implement the sequence required</span>
<span class="cm">*			to issue any prism2 command.  Primarily used by the</span>
<span class="cm">*			hfa384x_cmd_xxx functions.</span>
<span class="cm">*</span>
<span class="cm">* hfa384x_bap_xxx	BAP read/write access functions.</span>
<span class="cm">*			Note: we usually use BAP0 for non-interrupt context</span>
<span class="cm">*			 and BAP1 for interrupt context.</span>
<span class="cm">*</span>
<span class="cm">* hfa384x_dl_xxx	download related functions.</span>
<span class="cm">*</span>
<span class="cm">* Driver State Issues:</span>
<span class="cm">* Note that there are two pairs of functions that manage the</span>
<span class="cm">* &#39;initialized&#39; and &#39;running&#39; states of the hw/MAC combo.  The four</span>
<span class="cm">* functions are create(), destroy(), start(), and stop().  create()</span>
<span class="cm">* sets up the data structures required to support the hfa384x_*</span>
<span class="cm">* functions and destroy() cleans them up.  The start() function gets</span>
<span class="cm">* the actual hardware running and enables the interrupts.  The stop()</span>
<span class="cm">* function shuts the hardware down.  The sequence should be:</span>
<span class="cm">* create()</span>
<span class="cm">* start()</span>
<span class="cm">*  .</span>
<span class="cm">*  .  Do interesting things w/ the hardware</span>
<span class="cm">*  .</span>
<span class="cm">* stop()</span>
<span class="cm">* destroy()</span>
<span class="cm">*</span>
<span class="cm">* Note that destroy() can be called without calling stop() first.</span>
<span class="cm">* --------------------------------------------------------------------</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/wireless.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/byteorder/generic.h&gt;</span>

<span class="cp">#define SUBMIT_URB(u, f)  usb_submit_urb(u, f)</span>

<span class="cp">#include &quot;p80211types.h&quot;</span>
<span class="cp">#include &quot;p80211hdr.h&quot;</span>
<span class="cp">#include &quot;p80211mgmt.h&quot;</span>
<span class="cp">#include &quot;p80211conv.h&quot;</span>
<span class="cp">#include &quot;p80211msg.h&quot;</span>
<span class="cp">#include &quot;p80211netdev.h&quot;</span>
<span class="cp">#include &quot;p80211req.h&quot;</span>
<span class="cp">#include &quot;p80211metadef.h&quot;</span>
<span class="cp">#include &quot;p80211metastruct.h&quot;</span>
<span class="cp">#include &quot;hfa384x.h&quot;</span>
<span class="cp">#include &quot;prism2mgmt.h&quot;</span>

<span class="k">enum</span> <span class="n">cmd_mode</span> <span class="p">{</span>
	<span class="n">DOWAIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DOASYNC</span>
<span class="p">};</span>

<span class="cp">#define THROTTLE_JIFFIES	(HZ/8)</span>
<span class="cp">#define URB_ASYNC_UNLINK 0</span>
<span class="cp">#define USB_QUEUE_BULK 0</span>

<span class="cp">#define ROUNDUP64(a) (((a)+63)&amp;~63)</span>

<span class="cp">#ifdef DEBUG_USB</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dbprint_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">hfa384x_int_rxmonitor</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">hfa384x_usb_rxfrm_t</span> <span class="o">*</span><span class="n">rxfrm</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usb_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">submit_rx_urb</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">submit_tx_urb</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">tx_urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*---------------------------------------------------*/</span>
<span class="cm">/* Callbacks */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbout_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_ctlxout_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbin_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">hfa384x_usbin_txcompl</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">hfa384x_usbin_t</span> <span class="o">*</span> <span class="n">usbin</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbin_rx</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbin_info</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">hfa384x_usbin_t</span> <span class="o">*</span> <span class="n">usbin</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">hfa384x_usbout_tx</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">hfa384x_usbout_t</span> <span class="o">*</span><span class="n">usbout</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbin_ctlx</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="n">usbin</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">urb_status</span><span class="p">);</span>

<span class="cm">/*---------------------------------------------------*/</span>
<span class="cm">/* Functions to support the prism2 usb command queue */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbctlx_reqtimerfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbctlx_resptimerfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usb_throttlefn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbctlx_completion_task</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_usbctlx_reaper_task</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hfa384x_usbctlx_submit</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">unlocked_usbctlx_complete</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">complete</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">hfa384x_usbctlx_complete_sync</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			      <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="n">completor</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">unlocked_usbctlx_cancel_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_cb_status</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">const</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hfa384x_cb_rrid</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">const</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">usbctlx_get_status</span><span class="p">(</span><span class="k">const</span> <span class="n">hfa384x_usb_cmdresp_t</span> <span class="o">*</span><span class="n">cmdresp</span><span class="p">,</span>
		   <span class="n">hfa384x_cmdresult_t</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">usbctlx_get_rridresult</span><span class="p">(</span><span class="k">const</span> <span class="n">hfa384x_usb_rridresp_t</span> <span class="o">*</span><span class="n">rridresp</span><span class="p">,</span>
		       <span class="n">hfa384x_rridresult_t</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>

<span class="cm">/*---------------------------------------------------*/</span>
<span class="cm">/* Low level req/resp CTLX formatters and submitters */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">hfa384x_docmd</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	      <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	      <span class="n">hfa384x_metacmd_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	      <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">hfa384x_dorrid</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">hfa384x_dowrid</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">hfa384x_dormem</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">page</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">hfa384x_dowmem</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">page</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hfa384x_isgood_pdrcode</span><span class="p">(</span><span class="n">u16</span> <span class="n">pdrcode</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ctlxstr</span><span class="p">(</span><span class="n">CTLX_STATE</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctlx_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Initial state&quot;</span><span class="p">,</span>
		<span class="s">&quot;Complete&quot;</span><span class="p">,</span>
		<span class="s">&quot;Request failed&quot;</span><span class="p">,</span>
		<span class="s">&quot;Request pending&quot;</span><span class="p">,</span>
		<span class="s">&quot;Request packet submitted&quot;</span><span class="p">,</span>
		<span class="s">&quot;Request packet completed&quot;</span><span class="p">,</span>
		<span class="s">&quot;Response packet completed&quot;</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">ctlx_str</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="nf">get_active_ctlx</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span> <span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG_USB</span>
<span class="kt">void</span> <span class="nf">dbprint_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;pipe=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;status=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;transfer_flags=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;transfer_buffer=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;transfer_buffer_length=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;actual_length=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;bandwidth=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">bandwidth</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;setup_packet(ctl)=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;start_frame(iso/irq)=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;interval(irq)=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;error_count(iso)=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;timeout=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;context=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;complete=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* submit_rx_urb</span>
<span class="cm">*</span>
<span class="cm">* Listen for input data on the BULK-IN pipe. If the pipe has</span>
<span class="cm">* stalled then schedule it to be reset.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device struct</span>
<span class="cm">*	memflags	memory allocation flags</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	error code from submission</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	Any</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">submit_rx_urb</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">memflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hfa384x_usbin_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Post the IN urb */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			  <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_in</span><span class="p">,</span>
			  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hfa384x_usbin_t</span><span class="p">),</span>
			  <span class="n">hfa384x_usbin_callback</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">WORK_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">SUBMIT_URB</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">,</span> <span class="n">memflags</span><span class="p">);</span>

		<span class="cm">/* Check whether we need to reset the RX pipe */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;%s rx pipe stalled: requesting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t leak memory if anything should go wrong */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* submit_tx_urb</span>
<span class="cm">*</span>
<span class="cm">* Prepares and submits the URB of transmitted data. If the</span>
<span class="cm">* submission fails then it will schedule the output pipe to</span>
<span class="cm">* be reset.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device struct</span>
<span class="cm">*	tx_urb		URB of data for tranmission</span>
<span class="cm">*	memflags	memory allocation flags</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	error code from submission</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	Any</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">submit_tx_urb</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">tx_urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">memflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">SUBMIT_URB</span><span class="p">(</span><span class="n">tx_urb</span><span class="p">,</span> <span class="n">memflags</span><span class="p">);</span>

			<span class="cm">/* Test whether we need to reset the TX pipe */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				       <span class="s">&quot;%s tx pipe stalled: requesting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa394x_usb_defer</span>
<span class="cm">*</span>
<span class="cm">* There are some things that the USB stack cannot do while</span>
<span class="cm">* in interrupt context, so we arrange this function to run</span>
<span class="cm">* in process context.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw	device structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process (by design)</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usb_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfa384x</span><span class="p">,</span> <span class="n">usb_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t bother trying to reset anything if the plug</span>
<span class="cm">	 * has been pulled ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reception has stopped: try to reset the input pipe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">WORK_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span> <span class="cm">/* Cannot be holding spinlock! */</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_in</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;Failed to clear rx pipe for %s: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s rx pipe reset complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">WORK_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">WORK_RX_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Resume receiving data back from the device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">WORK_RX_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">submit_rx_urb</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;Failed to resume %s rx pipe.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">WORK_RX_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Transmission has stopped: try to reset the output pipe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_out</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;Failed to clear tx pipe for %s: err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s tx pipe reset complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">WORK_TX_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>

			<span class="cm">/* Stopping the BULK-OUT pipe also blocked</span>
<span class="cm">			 * us from sending any more CTLX URBs, so</span>
<span class="cm">			 * we need to re-run our queue ...</span>
<span class="cm">			 */</span>
			<span class="n">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Resume transmitting. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">WORK_TX_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_create</span>
<span class="cm">*</span>
<span class="cm">* Sets up the hfa384x_t data structure for use.  Note this</span>
<span class="cm">* does _not_ initialize the actual hardware, just the data structures</span>
<span class="cm">* we use to keep track of its state.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	irq		device irq number</span>
<span class="cm">*	iobase		i/o base address for register access</span>
<span class="cm">*	membase		memory base address for register access</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">void</span> <span class="nf">hfa384x_create</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hfa384x_t</span><span class="p">));</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span> <span class="o">=</span> <span class="n">usb</span><span class="p">;</span>

	<span class="cm">/* set up the endpoints */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_in</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_out</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Set up the waitq */</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">cmdq</span><span class="p">);</span>

	<span class="cm">/* Initialize the command queue */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">pending</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">completing</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">reapable</span><span class="p">);</span>

	<span class="cm">/* Initialize the authentication queue */</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">authq</span><span class="p">);</span>

	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reaper_bh</span><span class="p">,</span>
		     <span class="n">hfa384x_usbctlx_reaper_task</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">completion_bh</span><span class="p">,</span>
		     <span class="n">hfa384x_usbctlx_completion_task</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">link_bh</span><span class="p">,</span> <span class="n">prism2sta_processing_defer</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">,</span> <span class="n">hfa384x_usb_defer</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">throttle</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">throttle</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hfa384x_usb_throttlefn</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">throttle</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_resptimerfn</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reqtimer</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">reqtimer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_reqtimerfn</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">reqtimer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">usb_init_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>
	<span class="n">usb_init_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
	<span class="n">usb_init_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">link_status</span> <span class="o">=</span> <span class="n">HFA384x_LINK_NOTCONNECTED</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HFA384x_STATE_INIT</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">commsqual_bh</span><span class="p">,</span> <span class="n">prism2sta_commsqual_defer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">commsqual_timer</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">commsqual_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">commsqual_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">prism2sta_commsqual_timer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_destroy</span>
<span class="cm">*</span>
<span class="cm">* Partner to hfa384x_create().  This function cleans up the hw</span>
<span class="cm">* structure so that it can be freed by the caller using a simple</span>
<span class="cm">* kfree.  Currently, this function is just a placeholder.  If, at some</span>
<span class="cm">* point in the future, an hw in the &#39;shutdown&#39; state requires a &#39;deep&#39;</span>
<span class="cm">* kfree, this is where it should be done.  Note that if this function</span>
<span class="cm">* is called on a _running_ hw structure, the drvr_stop() function is</span>
<span class="cm">* called.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing, this function is not allowed to fail.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">void</span> <span class="nf">hfa384x_destroy</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">HFA384x_STATE_RUNNING</span><span class="p">)</span>
		<span class="n">hfa384x_drvr_stop</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HFA384x_STATE_PREINIT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">scanresults</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">scanresults</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Now to clean out the auth queue */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">authq</span><span class="p">)))</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="nf">usbctlx_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctlx</span><span class="p">),</span> <span class="n">in_interrupt</span><span class="p">()</span> <span class="o">?</span> <span class="n">GFP_ATOMIC</span> <span class="o">:</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ctlx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctlx</span><span class="p">));</span>
		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ctlx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">usbctlx_get_status</span><span class="p">(</span><span class="k">const</span> <span class="n">hfa384x_usb_cmdresp_t</span> <span class="o">*</span><span class="n">cmdresp</span><span class="p">,</span>
		   <span class="n">hfa384x_cmdresult_t</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmdresp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">resp0</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmdresp</span><span class="o">-&gt;</span><span class="n">resp0</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">resp1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmdresp</span><span class="o">-&gt;</span><span class="n">resp1</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">resp2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cmdresp</span><span class="o">-&gt;</span><span class="n">resp2</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cmdresult:status=0x%04x &quot;</span>
		 <span class="s">&quot;resp0=0x%04x resp1=0x%04x resp2=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">result</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">resp0</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">resp1</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">resp2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HFA384x_STATUS_RESULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">usbctlx_get_rridresult</span><span class="p">(</span><span class="k">const</span> <span class="n">hfa384x_usb_rridresp_t</span> <span class="o">*</span><span class="n">rridresp</span><span class="p">,</span>
		       <span class="n">hfa384x_rridresult_t</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">rid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rridresp</span><span class="o">-&gt;</span><span class="n">rid</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">riddata</span> <span class="o">=</span> <span class="n">rridresp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">riddata_len</span> <span class="o">=</span> <span class="p">((</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rridresp</span><span class="o">-&gt;</span><span class="n">frmlen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* Completor object:</span>
<span class="cm">* This completor must be passed to hfa384x_usbctlx_complete_sync()</span>
<span class="cm">* when processing a CTLX that returns a hfa384x_cmdresult_t structure.</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">struct</span> <span class="n">usbctlx_cmd_completor</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">const</span> <span class="n">hfa384x_usb_cmdresp_t</span> <span class="o">*</span><span class="n">cmdresp</span><span class="p">;</span>
	<span class="n">hfa384x_cmdresult_t</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usbctlx_cmd_completor_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbctlx_cmd_completor</span> <span class="o">*</span><span class="n">complete</span><span class="p">;</span>

	<span class="n">complete</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbctlx_cmd_completor</span> <span class="o">*</span><span class="p">)</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usbctlx_get_status</span><span class="p">(</span><span class="n">complete</span><span class="o">-&gt;</span><span class="n">cmdresp</span><span class="p">,</span> <span class="n">complete</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="nf">init_cmd_completor</span><span class="p">(</span>
						<span class="k">struct</span> <span class="n">usbctlx_cmd_completor</span>
							<span class="o">*</span><span class="n">completor</span><span class="p">,</span>
						<span class="k">const</span> <span class="n">hfa384x_usb_cmdresp_t</span>
							<span class="o">*</span><span class="n">cmdresp</span><span class="p">,</span>
						<span class="n">hfa384x_cmdresult_t</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">usbctlx_cmd_completor_fn</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">cmdresp</span> <span class="o">=</span> <span class="n">cmdresp</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">completor</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* Completor object:</span>
<span class="cm">* This completor must be passed to hfa384x_usbctlx_complete_sync()</span>
<span class="cm">* when processing a CTLX that reads a RID.</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">struct</span> <span class="n">usbctlx_rrid_completor</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">const</span> <span class="n">hfa384x_usb_rridresp_t</span> <span class="o">*</span><span class="n">rridresp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbctlx_rrid_completor_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbctlx_rrid_completor</span> <span class="o">*</span><span class="n">complete</span><span class="p">;</span>
	<span class="n">hfa384x_rridresult_t</span> <span class="n">rridresult</span><span class="p">;</span>

	<span class="n">complete</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usbctlx_rrid_completor</span> <span class="o">*</span><span class="p">)</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">usbctlx_get_rridresult</span><span class="p">(</span><span class="n">complete</span><span class="o">-&gt;</span><span class="n">rridresp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rridresult</span><span class="p">);</span>

	<span class="cm">/* Validate the length, note body len calculation in bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rridresult</span><span class="p">.</span><span class="n">riddata_len</span> <span class="o">!=</span> <span class="n">complete</span><span class="o">-&gt;</span><span class="n">riddatalen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;RID len mismatch, rid=0x%04x hlen=%d fwlen=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">rridresult</span><span class="p">.</span><span class="n">rid</span><span class="p">,</span>
		       <span class="n">complete</span><span class="o">-&gt;</span><span class="n">riddatalen</span><span class="p">,</span> <span class="n">rridresult</span><span class="p">.</span><span class="n">riddata_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">complete</span><span class="o">-&gt;</span><span class="n">riddata</span><span class="p">,</span> <span class="n">rridresult</span><span class="p">.</span><span class="n">riddata</span><span class="p">,</span> <span class="n">complete</span><span class="o">-&gt;</span><span class="n">riddatalen</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="nf">init_rrid_completor</span><span class="p">(</span>
						<span class="k">struct</span> <span class="n">usbctlx_rrid_completor</span>
							<span class="o">*</span><span class="n">completor</span><span class="p">,</span>
						<span class="k">const</span> <span class="n">hfa384x_usb_rridresp_t</span>
							<span class="o">*</span><span class="n">rridresp</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">usbctlx_rrid_completor_fn</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">rridresp</span> <span class="o">=</span> <span class="n">rridresp</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">riddata</span> <span class="o">=</span> <span class="n">riddata</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">riddatalen</span> <span class="o">=</span> <span class="n">riddatalen</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">completor</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* Completor object:</span>
<span class="cm">* Interprets the results of a synchronous RID-write</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">usbctlx_cmd_completor</span> <span class="n">usbctlx_wrid_completor_t</span><span class="p">;</span>
<span class="cp">#define init_wrid_completor  init_cmd_completor</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* Completor object:</span>
<span class="cm">* Interprets the results of a synchronous memory-write</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">usbctlx_cmd_completor</span> <span class="n">usbctlx_wmem_completor_t</span><span class="p">;</span>
<span class="cp">#define init_wmem_completor  init_cmd_completor</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* Completor object:</span>
<span class="cm">* Interprets the results of a synchronous memory-read</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">struct</span> <span class="n">usbctlx_rmem_completor</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">const</span> <span class="n">hfa384x_usb_rmemresp_t</span> <span class="o">*</span><span class="n">rmemresp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">usbctlx_rmem_completor</span> <span class="n">usbctlx_rmem_completor_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usbctlx_rmem_completor_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usbctlx_rmem_completor_t</span> <span class="o">*</span><span class="n">complete</span> <span class="o">=</span> <span class="p">(</span><span class="n">usbctlx_rmem_completor_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">head</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;rmemresp:len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">complete</span><span class="o">-&gt;</span><span class="n">rmemresp</span><span class="o">-&gt;</span><span class="n">frmlen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">complete</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">complete</span><span class="o">-&gt;</span><span class="n">rmemresp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">complete</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="nf">init_rmem_completor</span><span class="p">(</span>
						<span class="n">usbctlx_rmem_completor_t</span>
							<span class="o">*</span><span class="n">completor</span><span class="p">,</span>
						<span class="n">hfa384x_usb_rmemresp_t</span>
							<span class="o">*</span><span class="n">rmemresp</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">usbctlx_rmem_completor_fn</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">rmemresp</span> <span class="o">=</span> <span class="n">rmemresp</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">completor</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">completor</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_cb_status</span>
<span class="cm">*</span>
<span class="cm">* Ctlx_complete handler for async CMD type control exchanges.</span>
<span class="cm">* mark the hw struct as such.</span>
<span class="cm">*</span>
<span class="cm">* Note: If the handling is changed here, it should probably be</span>
<span class="cm">*       changed in docmd as well.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		hw struct</span>
<span class="cm">*	ctlx		completed CTLX</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_cb_status</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">const</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hfa384x_cmdresult_t</span> <span class="n">cmdresult</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">CTLX_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmdresult</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmdresult</span><span class="p">));</span>
			<span class="n">cmdresult</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span>
			    <span class="n">HFA384x_STATUS_RESULT_SET</span><span class="p">(</span><span class="n">HFA384x_CMD_ERR</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">usbctlx_get_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">.</span><span class="n">cmdresp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmdresult</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmdresult</span><span class="p">,</span> <span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb_data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_cb_rrid</span>
<span class="cm">*</span>
<span class="cm">* CTLX completion handler for async RRID type control exchanges.</span>
<span class="cm">*</span>
<span class="cm">* Note: If the handling is changed here, it should probably be</span>
<span class="cm">*       changed in dorrid as well.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		hw struct</span>
<span class="cm">*	ctlx		completed CTLX</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_cb_rrid</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">const</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hfa384x_rridresult_t</span> <span class="n">rridresult</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">CTLX_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rridresult</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rridresult</span><span class="p">));</span>
			<span class="n">rridresult</span><span class="p">.</span><span class="n">rid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rridreq</span><span class="p">.</span><span class="n">rid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">usbctlx_get_rridresult</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">.</span><span class="n">rridresp</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">rridresult</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rridresult</span><span class="p">,</span> <span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb_data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hfa384x_docmd_wait</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_metacmd_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_docmd</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOWAIT</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_docmd_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		    <span class="n">hfa384x_metacmd_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		    <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_docmd</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOASYNC</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">usercb</span><span class="p">,</span> <span class="n">usercb_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dorrid_wait</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dorrid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOWAIT</span><span class="p">,</span>
			      <span class="n">rid</span><span class="p">,</span> <span class="n">riddata</span><span class="p">,</span> <span class="n">riddatalen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dorrid_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		     <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">,</span>
		     <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span>
		     <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dorrid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOASYNC</span><span class="p">,</span>
			      <span class="n">rid</span><span class="p">,</span> <span class="n">riddata</span><span class="p">,</span> <span class="n">riddatalen</span><span class="p">,</span>
			      <span class="n">cmdcb</span><span class="p">,</span> <span class="n">usercb</span><span class="p">,</span> <span class="n">usercb_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dowrid_wait</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dowrid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOWAIT</span><span class="p">,</span>
			      <span class="n">rid</span><span class="p">,</span> <span class="n">riddata</span><span class="p">,</span> <span class="n">riddatalen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dowrid_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		     <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">,</span>
		     <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span>
		     <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dowrid</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOASYNC</span><span class="p">,</span>
			      <span class="n">rid</span><span class="p">,</span> <span class="n">riddata</span><span class="p">,</span> <span class="n">riddatalen</span><span class="p">,</span>
			      <span class="n">cmdcb</span><span class="p">,</span> <span class="n">usercb</span><span class="p">,</span> <span class="n">usercb_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dormem_wait</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		    <span class="n">u16</span> <span class="n">page</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dormem</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOWAIT</span><span class="p">,</span>
			      <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dormem_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		     <span class="n">u16</span> <span class="n">page</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		     <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span>
		     <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dormem</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOASYNC</span><span class="p">,</span>
			      <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			      <span class="n">cmdcb</span><span class="p">,</span> <span class="n">usercb</span><span class="p">,</span> <span class="n">usercb_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dowmem_wait</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		    <span class="n">u16</span> <span class="n">page</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dowmem</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOWAIT</span><span class="p">,</span>
			      <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hfa384x_dowmem_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		     <span class="n">u16</span> <span class="n">page</span><span class="p">,</span>
		     <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		     <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span>
		     <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dowmem</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DOASYNC</span><span class="p">,</span>
			      <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			      <span class="n">cmdcb</span><span class="p">,</span> <span class="n">usercb</span><span class="p">,</span> <span class="n">usercb_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_cmd_initialize</span>
<span class="cm">*</span>
<span class="cm">* Issues the initialize command and sets the hw-&gt;state based</span>
<span class="cm">* on the result.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_cmd_initialize</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">hfa384x_metacmd_t</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">HFA384x_CMDCODE_INIT</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_docmd_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cmdresp.init: &quot;</span>
		 <span class="s">&quot;status=0x%04x, resp0=0x%04x, &quot;</span>
		 <span class="s">&quot;resp1=0x%04x, resp2=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">cmd</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
		 <span class="n">cmd</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">resp0</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">resp1</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">resp2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HFA384x_NUMPORTS_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">link_status</span> <span class="o">=</span> <span class="n">HFA384x_LINK_NOTCONNECTED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_cmd_disable</span>
<span class="cm">*</span>
<span class="cm">* Issues the disable command to stop communications on one of</span>
<span class="cm">* the MACs &#39;ports&#39;.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	macport		MAC port number (host order)</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported failure - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error (timeout|bad arg)</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_cmd_disable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">macport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hfa384x_metacmd_t</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">HFA384x_CMD_CMDCODE_SET</span><span class="p">(</span><span class="n">HFA384x_CMDCODE_DISABLE</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">HFA384x_CMD_MACPORT_SET</span><span class="p">(</span><span class="n">macport</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_docmd_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_cmd_enable</span>
<span class="cm">*</span>
<span class="cm">* Issues the enable command to enable communications on one of</span>
<span class="cm">* the MACs &#39;ports&#39;.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	macport		MAC port number</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported failure - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error (timeout|bad arg)</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_cmd_enable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">macport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hfa384x_metacmd_t</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">HFA384x_CMD_CMDCODE_SET</span><span class="p">(</span><span class="n">HFA384x_CMDCODE_ENABLE</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">HFA384x_CMD_MACPORT_SET</span><span class="p">(</span><span class="n">macport</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_docmd_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_cmd_monitor</span>
<span class="cm">*</span>
<span class="cm">* Enables the &#39;monitor mode&#39; of the MAC.  Here&#39;s the description of</span>
<span class="cm">* monitor mode that I&#39;ve received thus far:</span>
<span class="cm">*</span>
<span class="cm">*  &quot;The &quot;monitor mode&quot; of operation is that the MAC passes all</span>
<span class="cm">*  frames for which the PLCP checks are correct. All received</span>
<span class="cm">*  MPDUs are passed to the host with MAC Port = 7, with a</span>
<span class="cm">*  receive status of good, FCS error, or undecryptable. Passing</span>
<span class="cm">*  certain MPDUs is a violation of the 802.11 standard, but useful</span>
<span class="cm">*  for a debugging tool.&quot;  Normal communication is not possible</span>
<span class="cm">*  while monitor mode is enabled.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	enable		a code (0x0b|0x0f) that enables/disables</span>
<span class="cm">*			monitor mode. (host order)</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported failure - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error (timeout|bad arg)</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_cmd_monitor</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hfa384x_metacmd_t</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">HFA384x_CMD_CMDCODE_SET</span><span class="p">(</span><span class="n">HFA384x_CMDCODE_MONITOR</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">HFA384x_CMD_AINFO_SET</span><span class="p">(</span><span class="n">enable</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_docmd_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_cmd_download</span>
<span class="cm">*</span>
<span class="cm">* Sets the controls for the MAC controller code/data download</span>
<span class="cm">* process.  The arguments set the mode and address associated</span>
<span class="cm">* with a download.  Note that the aux registers should be enabled</span>
<span class="cm">* prior to setting one of the download enable modes.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	mode		0 - Disable programming and begin code exec</span>
<span class="cm">*			1 - Enable volatile mem programming</span>
<span class="cm">*			2 - Enable non-volatile mem programming</span>
<span class="cm">*			3 - Program non-volatile section from NV download</span>
<span class="cm">*			    buffer.</span>
<span class="cm">*			(host order)</span>
<span class="cm">*	lowaddr</span>
<span class="cm">*	highaddr	For mode 1, sets the high &amp; low order bits of</span>
<span class="cm">*			the &quot;destination address&quot;.  This address will be</span>
<span class="cm">*			the execution start address when download is</span>
<span class="cm">*			subsequently disabled.</span>
<span class="cm">*			For mode 2, sets the high &amp; low order bits of</span>
<span class="cm">*			the destination in NV ram.</span>
<span class="cm">*			For modes 0 &amp; 3, should be zero. (host order)</span>
<span class="cm">*			NOTE: these are CMD format.</span>
<span class="cm">*	codelen		Length of the data to write in mode 2,</span>
<span class="cm">*			zero otherwise. (host order)</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported failure - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error (timeout|bad arg)</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_cmd_download</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u16</span> <span class="n">lowaddr</span><span class="p">,</span>
			 <span class="n">u16</span> <span class="n">highaddr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">codelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hfa384x_metacmd_t</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">mode</span><span class="p">,</span> <span class="n">lowaddr</span><span class="p">,</span> <span class="n">highaddr</span><span class="p">,</span> <span class="n">codelen</span><span class="p">);</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">HFA384x_CMD_CMDCODE_SET</span><span class="p">(</span><span class="n">HFA384x_CMDCODE_DOWNLD</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">HFA384x_CMD_PROGMODE_SET</span><span class="p">(</span><span class="n">mode</span><span class="p">));</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">parm0</span> <span class="o">=</span> <span class="n">lowaddr</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm1</span> <span class="o">=</span> <span class="n">highaddr</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm2</span> <span class="o">=</span> <span class="n">codelen</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_docmd_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_corereset</span>
<span class="cm">*</span>
<span class="cm">* Perform a reset of the hfa38xx MAC core.  We assume that the hw</span>
<span class="cm">* structure is in its &quot;created&quot; state.  That is, it is initialized</span>
<span class="cm">* with proper values.  Note that if a reset is done after the</span>
<span class="cm">* device has been active for awhile, the caller might have to clean</span>
<span class="cm">* up some leftover cruft in the hw structure.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	holdtime	how long (in ms) to hold the reset</span>
<span class="cm">*	settletime	how long (in ms) to wait after releasing</span>
<span class="cm">*			the reset</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_corereset</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">holdtime</span><span class="p">,</span> <span class="kt">int</span> <span class="n">settletime</span><span class="p">,</span> <span class="kt">int</span> <span class="n">genesis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_reset_device</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;usb_reset_device() failed, result=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbctlx_complete_sync</span>
<span class="cm">*</span>
<span class="cm">* Waits for a synchronous CTLX object to complete,</span>
<span class="cm">* and then handles the response.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	ctlx		CTLX ptr</span>
<span class="cm">*	completor	functor object to decide what to</span>
<span class="cm">*			do with the CTLX&#39;s result.</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		Success</span>
<span class="cm">*	-ERESTARTSYS	Interrupted by a signal</span>
<span class="cm">*	-EIO		CTLX failed</span>
<span class="cm">*	-ENODEV		Adapter was unplugged</span>
<span class="cm">*	???		Result from completor</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hfa384x_usbctlx_complete_sync</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					 <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">usbctlx_completor</span> <span class="o">*</span><span class="n">completor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can only handle the CTLX if the USB disconnect</span>
<span class="cm">	 * function has not run yet ...</span>
<span class="cm">	 */</span>
<span class="nl">cleanup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">runqueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We were probably interrupted, so delete</span>
<span class="cm">		 * this CTLX asynchronously, kill the timers</span>
<span class="cm">		 * and the URB, and then start the next</span>
<span class="cm">		 * pending CTLX.</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOTE: We can only delete the timers and</span>
<span class="cm">		 *       the URB if this CTLX is active.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span> <span class="o">==</span> <span class="n">get_active_ctlx</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">del_singleshot_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reqtimer</span><span class="p">);</span>
			<span class="n">del_singleshot_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">req_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">);</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">runqueue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * This scenario is so unlikely that I&#39;m</span>
<span class="cm">			 * happy with a grubby &quot;goto&quot; solution ...</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The completion task will send this CTLX</span>
<span class="cm">		 * to the reaper the next time it runs. We</span>
<span class="cm">		 * are no longer in a hurry.</span>
<span class="cm">		 */</span>
		<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">reapable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_REQ_FAILED</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">completing</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">runqueue</span><span class="p">)</span>
			<span class="n">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">CTLX_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">completor</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">completor</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;CTLX[%d] error: state(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">type</span><span class="p">),</span>
			       <span class="n">ctlxstr</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctlx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_docmd</span>
<span class="cm">*</span>
<span class="cm">* Constructs a command CTLX and submits it.</span>
<span class="cm">*</span>
<span class="cm">* NOTE: Any changes to the &#39;post-submit&#39; code in this function</span>
<span class="cm">*       need to be carried over to hfa384x_cbcmd() since the handling</span>
<span class="cm">*       is virtually identical.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	mode		DOWAIT or DOASYNC</span>
<span class="cm">*       cmd             cmd structure.  Includes all arguments and result</span>
<span class="cm">*                       data points.  All in host order. in host order</span>
<span class="cm">*	cmdcb		command-specific callback</span>
<span class="cm">*	usercb		user callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb_data	user supplied data pointer for async calls, NULL</span>
<span class="cm">*			for DOASYNC calls</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	-EIO		CTLX failure</span>
<span class="cm">*	-ERESTARTSYS	Awakened on signal</span>
<span class="cm">*	&gt;0		command indicated error, Status and Resp0-2 are</span>
<span class="cm">*			in hw structure.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hfa384x_docmd</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	      <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	      <span class="n">hfa384x_metacmd_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	      <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">usbctlx_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the command */</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">cmdreq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">HFA384x_USB_CMDREQ</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">cmdreq</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">cmdreq</span><span class="p">.</span><span class="n">parm0</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">parm0</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">cmdreq</span><span class="p">.</span><span class="n">parm1</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">parm1</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">cmdreq</span><span class="p">.</span><span class="n">parm2</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">parm2</span><span class="p">);</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbufsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">cmdreq</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cmdreq: cmd=0x%04x &quot;</span>
		 <span class="s">&quot;parm0=0x%04x parm1=0x%04x parm2=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">parm0</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">parm1</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">parm2</span><span class="p">);</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">reapable</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span> <span class="o">=</span> <span class="n">cmdcb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span> <span class="o">=</span> <span class="n">usercb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb_data</span> <span class="o">=</span> <span class="n">usercb_data</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_submit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctlx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DOWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usbctlx_cmd_completor</span> <span class="n">completor</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span>
		    <span class="n">hfa384x_usbctlx_complete_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">,</span>
						  <span class="n">init_cmd_completor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completor</span><span class="p">,</span>
								     <span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span>
								     <span class="n">inbuf</span><span class="p">.</span>
								     <span class="n">cmdresp</span><span class="p">,</span>
								     <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span>
								     <span class="n">result</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_dorrid</span>
<span class="cm">*</span>
<span class="cm">* Constructs a read rid CTLX and issues it.</span>
<span class="cm">*</span>
<span class="cm">* NOTE: Any changes to the &#39;post-submit&#39; code in this function</span>
<span class="cm">*       need to be carried over to hfa384x_cbrrid() since the handling</span>
<span class="cm">*       is virtually identical.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	mode		DOWAIT or DOASYNC</span>
<span class="cm">*	rid		Read RID number (host order)</span>
<span class="cm">*	riddata		Caller supplied buffer that MAC formatted RID.data</span>
<span class="cm">*			record will be written to for DOWAIT calls. Should</span>
<span class="cm">*			be NULL for DOASYNC calls.</span>
<span class="cm">*	riddatalen	Buffer length for DOWAIT calls. Zero for DOASYNC calls.</span>
<span class="cm">*	cmdcb		command callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb		user callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb_data	user supplied data pointer for async calls, NULL</span>
<span class="cm">*			for DOWAIT calls</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	-EIO		CTLX failure</span>
<span class="cm">*	-ERESTARTSYS	Awakened on signal</span>
<span class="cm">*	-ENODATA	riddatalen != macdatalen</span>
<span class="cm">*	&gt;0		command indicated error, Status and Resp0-2 are</span>
<span class="cm">*			in hw structure.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt (DOASYNC)</span>
<span class="cm">*	process (DOWAIT or DOASYNC)</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hfa384x_dorrid</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">usbctlx_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the command */</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rridreq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">HFA384x_USB_RRIDREQ</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rridreq</span><span class="p">.</span><span class="n">frmlen</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rridreq</span><span class="p">.</span><span class="n">rid</span><span class="p">));</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rridreq</span><span class="p">.</span><span class="n">rid</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">rid</span><span class="p">);</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbufsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rridreq</span><span class="p">);</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">reapable</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span> <span class="o">=</span> <span class="n">cmdcb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span> <span class="o">=</span> <span class="n">usercb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb_data</span> <span class="o">=</span> <span class="n">usercb_data</span><span class="p">;</span>

	<span class="cm">/* Submit the CTLX */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_submit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctlx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DOWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usbctlx_rrid_completor</span> <span class="n">completor</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span>
		    <span class="n">hfa384x_usbctlx_complete_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">,</span>
						  <span class="n">init_rrid_completor</span>
						  <span class="p">(</span><span class="o">&amp;</span><span class="n">completor</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">.</span><span class="n">rridresp</span><span class="p">,</span>
						   <span class="n">riddata</span><span class="p">,</span> <span class="n">riddatalen</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_dowrid</span>
<span class="cm">*</span>
<span class="cm">* Constructs a write rid CTLX and issues it.</span>
<span class="cm">*</span>
<span class="cm">* NOTE: Any changes to the &#39;post-submit&#39; code in this function</span>
<span class="cm">*       need to be carried over to hfa384x_cbwrid() since the handling</span>
<span class="cm">*       is virtually identical.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	enum cmd_mode	DOWAIT or DOASYNC</span>
<span class="cm">*	rid		RID code</span>
<span class="cm">*	riddata		Data portion of RID formatted for MAC</span>
<span class="cm">*	riddatalen	Length of the data portion in bytes</span>
<span class="cm">*       cmdcb           command callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb		user callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb_data	user supplied data pointer for async calls</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	-ETIMEDOUT	timed out waiting for register ready or</span>
<span class="cm">*			command completion</span>
<span class="cm">*	&gt;0		command indicated error, Status and Resp0-2 are</span>
<span class="cm">*			in hw structure.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt (DOASYNC)</span>
<span class="cm">*	process (DOWAIT or DOASYNC)</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hfa384x_dowrid</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">riddata</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">riddatalen</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">usbctlx_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the command */</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">HFA384x_USB_WRIDREQ</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">frmlen</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="k">sizeof</span>
						   <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">rid</span><span class="p">)</span> <span class="o">+</span>
						   <span class="n">riddatalen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">rid</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">rid</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">riddata</span><span class="p">,</span> <span class="n">riddatalen</span><span class="p">);</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbufsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">frmlen</span><span class="p">)</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wridreq</span><span class="p">.</span><span class="n">rid</span><span class="p">)</span> <span class="o">+</span> <span class="n">riddatalen</span><span class="p">;</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">reapable</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span> <span class="o">=</span> <span class="n">cmdcb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span> <span class="o">=</span> <span class="n">usercb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb_data</span> <span class="o">=</span> <span class="n">usercb_data</span><span class="p">;</span>

	<span class="cm">/* Submit the CTLX */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_submit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctlx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DOWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usbctlx_wrid_completor_t</span> <span class="n">completor</span><span class="p">;</span>
		<span class="n">hfa384x_cmdresult_t</span> <span class="n">wridresult</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_complete_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						       <span class="n">ctlx</span><span class="p">,</span>
						       <span class="n">init_wrid_completor</span>
						       <span class="p">(</span><span class="o">&amp;</span><span class="n">completor</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">.</span><span class="n">wridresp</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">wridresult</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_dormem</span>
<span class="cm">*</span>
<span class="cm">* Constructs a readmem CTLX and issues it.</span>
<span class="cm">*</span>
<span class="cm">* NOTE: Any changes to the &#39;post-submit&#39; code in this function</span>
<span class="cm">*       need to be carried over to hfa384x_cbrmem() since the handling</span>
<span class="cm">*       is virtually identical.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	mode		DOWAIT or DOASYNC</span>
<span class="cm">*	page		MAC address space page (CMD format)</span>
<span class="cm">*	offset		MAC address space offset</span>
<span class="cm">*	data		Ptr to data buffer to receive read</span>
<span class="cm">*	len		Length of the data to read (max == 2048)</span>
<span class="cm">*	cmdcb		command callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb		user callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb_data	user supplied data pointer for async calls</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	-ETIMEDOUT	timed out waiting for register ready or</span>
<span class="cm">*			command completion</span>
<span class="cm">*	&gt;0		command indicated error, Status and Resp0-2 are</span>
<span class="cm">*			in hw structure.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt (DOASYNC)</span>
<span class="cm">*	process (DOWAIT or DOASYNC)</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hfa384x_dormem</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">page</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">usbctlx_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the command */</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">HFA384x_USB_RMEMREQ</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">frmlen</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbufsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;type=0x%04x frmlen=%d offset=0x%04x page=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
		 <span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">frmlen</span><span class="p">,</span>
		 <span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pktsize=%zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ROUNDUP64</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">rmemreq</span><span class="p">)));</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">reapable</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span> <span class="o">=</span> <span class="n">cmdcb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span> <span class="o">=</span> <span class="n">usercb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb_data</span> <span class="o">=</span> <span class="n">usercb_data</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_submit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctlx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DOWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usbctlx_rmem_completor_t</span> <span class="n">completor</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span>
		    <span class="n">hfa384x_usbctlx_complete_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">,</span>
						  <span class="n">init_rmem_completor</span>
						  <span class="p">(</span><span class="o">&amp;</span><span class="n">completor</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">.</span><span class="n">rmemresp</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
						   <span class="n">len</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_dowmem</span>
<span class="cm">*</span>
<span class="cm">* Constructs a writemem CTLX and issues it.</span>
<span class="cm">*</span>
<span class="cm">* NOTE: Any changes to the &#39;post-submit&#39; code in this function</span>
<span class="cm">*       need to be carried over to hfa384x_cbwmem() since the handling</span>
<span class="cm">*       is virtually identical.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	mode		DOWAIT or DOASYNC</span>
<span class="cm">*	page		MAC address space page (CMD format)</span>
<span class="cm">*	offset		MAC address space offset</span>
<span class="cm">*	data		Ptr to data buffer containing write data</span>
<span class="cm">*	len		Length of the data to read (max == 2048)</span>
<span class="cm">*	cmdcb		command callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb		user callback for async calls, NULL for DOWAIT calls</span>
<span class="cm">*	usercb_data	user supplied data pointer for async calls.</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	-ETIMEDOUT	timed out waiting for register ready or</span>
<span class="cm">*			command completion</span>
<span class="cm">*	&gt;0		command indicated error, Status and Resp0-2 are</span>
<span class="cm">*			in hw structure.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt (DOWAIT)</span>
<span class="cm">*	process (DOWAIT or DOASYNC)</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hfa384x_dowmem</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">cmd_mode</span> <span class="n">mode</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">page</span><span class="p">,</span>
	       <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
	       <span class="n">ctlx_cmdcb_t</span> <span class="n">cmdcb</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;page=0x%04x offset=0x%04x len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">usbctlx_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the command */</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">HFA384x_USB_WMEMREQ</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">frmlen</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbufsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">frmlen</span><span class="p">)</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">wmemreq</span><span class="p">.</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">reapable</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span> <span class="o">=</span> <span class="n">cmdcb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb</span> <span class="o">=</span> <span class="n">usercb</span><span class="p">;</span>
	<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">usercb_data</span> <span class="o">=</span> <span class="n">usercb_data</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_submit</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctlx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DOWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usbctlx_wmem_completor_t</span> <span class="n">completor</span><span class="p">;</span>
		<span class="n">hfa384x_cmdresult_t</span> <span class="n">wmemresult</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_usbctlx_complete_sync</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						       <span class="n">ctlx</span><span class="p">,</span>
						       <span class="n">init_wmem_completor</span>
						       <span class="p">(</span><span class="o">&amp;</span><span class="n">completor</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">.</span><span class="n">wmemresp</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">wmemresult</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_commtallies</span>
<span class="cm">*</span>
<span class="cm">* Send a commtallies inquiry to the MAC.  Note that this is an async</span>
<span class="cm">* call that will result in an info frame arriving sometime later.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	zero		success.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_commtallies</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_metacmd_t</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">HFA384x_CMDCODE_INQ</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm0</span> <span class="o">=</span> <span class="n">HFA384x_IT_COMMTALLIES</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">parm2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hfa384x_docmd_async</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_disable</span>
<span class="cm">*</span>
<span class="cm">* Issues the disable command to stop communications on one of</span>
<span class="cm">* the MACs &#39;ports&#39;.  Only macport 0 is valid  for stations.</span>
<span class="cm">* APs may also disable macports 1-6.  Only ports that have been</span>
<span class="cm">* previously enabled may be disabled.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	macport		MAC port number (host order)</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported failure - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error (timeout|bad arg)</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_disable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">macport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">isap</span> <span class="o">&amp;&amp;</span> <span class="n">macport</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">isap</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">macport</span> <span class="o">&lt;=</span> <span class="n">HFA384x_PORTID_MAX</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">macport</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_cmd_disable</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">macport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">macport</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_enable</span>
<span class="cm">*</span>
<span class="cm">* Issues the enable command to enable communications on one of</span>
<span class="cm">* the MACs &#39;ports&#39;.  Only macport 0 is valid  for stations.</span>
<span class="cm">* APs may also enable macports 1-6.  Only ports that are currently</span>
<span class="cm">* disabled may be enabled.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	macport		MAC port number</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported failure - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error (timeout|bad arg)</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_enable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">macport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">isap</span> <span class="o">&amp;&amp;</span> <span class="n">macport</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">isap</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">macport</span> <span class="o">&lt;=</span> <span class="n">HFA384x_PORTID_MAX</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">macport</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_cmd_enable</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">macport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">macport</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_flashdl_enable</span>
<span class="cm">*</span>
<span class="cm">* Begins the flash download state.  Checks to see that we&#39;re not</span>
<span class="cm">* already in a download state and that a port isn&#39;t enabled.</span>
<span class="cm">* Sets the download state and retrieves the flash download</span>
<span class="cm">* buffer location, buffer size, and timeout length.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_flashdl_enable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Check that a port isn&#39;t active */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HFA384x_PORTID_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;called when port enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check that we&#39;re not already in a download state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">!=</span> <span class="n">HFA384x_DLSTATE_DISABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Retrieve the buffer loc&amp;size and timeout */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_drvr_getconfig</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HFA384x_RID_DOWNLOADBUFFER</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_drvr_getconfig16</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HFA384x_RID_MAXLOADTIME</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dltimeout</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dltimeout</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dltimeout</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;flashdl_enable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">=</span> <span class="n">HFA384x_DLSTATE_FLASHENABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_flashdl_disable</span>
<span class="cm">*</span>
<span class="cm">* Ends the flash download state.  Note that this will cause the MAC</span>
<span class="cm">* firmware to restart.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_flashdl_disable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check that we&#39;re already in the download state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">!=</span> <span class="n">HFA384x_DLSTATE_FLASHENABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;flashdl_enable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* There isn&#39;t much we can do at this point, so I don&#39;t */</span>
	<span class="cm">/*  bother  w/ the return value */</span>
	<span class="n">hfa384x_cmd_download</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HFA384x_PROGMODE_DISABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">=</span> <span class="n">HFA384x_DLSTATE_DISABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_flashdl_write</span>
<span class="cm">*</span>
<span class="cm">* Performs a FLASH download of a chunk of data. First checks to see</span>
<span class="cm">* that we&#39;re in the FLASH download state, then sets the download</span>
<span class="cm">* mode, uses the aux functions to 1) copy the data to the flash</span>
<span class="cm">* buffer, 2) sets the download &#39;write flash&#39; mode, 3) readback and</span>
<span class="cm">* compare.  Lather rinse, repeat as many times an necessary to get</span>
<span class="cm">* all the given data into flash.</span>
<span class="cm">* When all data has been written using this function (possibly</span>
<span class="cm">* repeatedly), call drvr_flashdl_disable() to end the download state</span>
<span class="cm">* and restart the MAC.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	daddr		Card address to write to. (host order)</span>
<span class="cm">*	buf		Ptr to data to write.</span>
<span class="cm">*	len		Length of data (host order).</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_flashdl_write</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">daddr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dlbufaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nburns</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">burnlen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">burndaddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">burnlo</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">burnhi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nwrites</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">writebuf</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">writepage</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">writeoffset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">writelen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;daddr=0x%08x len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Check that we&#39;re in the flash download state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">!=</span> <span class="n">HFA384x_DLSTATE_FLASHENABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Download %d bytes to flash @0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>

	<span class="cm">/* Convert to flat address for arithmetic */</span>
	<span class="cm">/* NOTE: dlbuffer RID stores the address in AUX format */</span>
	<span class="n">dlbufaddr</span> <span class="o">=</span>
	    <span class="n">HFA384x_ADDR_AUX_MKFLAT</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">page</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">page</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">dlbufaddr</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(KERN_WARNING &quot;dlbuf@0x%06lx len=%d to=%d\n&quot;, dlbufaddr,</span>
<span class="c">	       hw-&gt;bufinfo.len, hw-&gt;dltimeout);</span>
<span class="cp">#endif</span>
	<span class="cm">/* Calculations to determine how many fills of the dlbuffer to do</span>
<span class="cm">	 * and how many USB wmemreq&#39;s to do for each fill.  At this point</span>
<span class="cm">	 * in time, the dlbuffer size and the wmemreq size are the same.</span>
<span class="cm">	 * Therefore, nwrites should always be 1.  The extra complexity</span>
<span class="cm">	 * here is a hedge against future changes.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Figure out how many times to do the flash programming */</span>
	<span class="n">nburns</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">nburns</span> <span class="o">+=</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* For each flash program cycle, how many USB wmemreq&#39;s are needed? */</span>
	<span class="n">nwrites</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">/</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">;</span>
	<span class="n">nwrites</span> <span class="o">+=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">%</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* For each burn */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nburns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the dest address and len */</span>
		<span class="n">burnlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">*</span> <span class="n">i</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">?</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">:</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">*</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">burndaddr</span> <span class="o">=</span> <span class="n">daddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">burnlo</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKOFF</span><span class="p">(</span><span class="n">burndaddr</span><span class="p">);</span>
		<span class="n">burnhi</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKPAGE</span><span class="p">(</span><span class="n">burndaddr</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Writing %d bytes to flash @0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">burnlen</span><span class="p">,</span> <span class="n">burndaddr</span><span class="p">);</span>

		<span class="cm">/* Set the download mode */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_cmd_download</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HFA384x_PROGMODE_NV</span><span class="p">,</span>
					      <span class="n">burnlo</span><span class="p">,</span> <span class="n">burnhi</span><span class="p">,</span> <span class="n">burnlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;download(NV,lo=%x,hi=%x,len=%x) &quot;</span>
			       <span class="s">&quot;cmd failed, result=%d. Aborting d/l</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">burnlo</span><span class="p">,</span> <span class="n">burnhi</span><span class="p">,</span> <span class="n">burnlen</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_proc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* copy the data to the flash download buffer */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nwrites</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writebuf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bufinfo</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">);</span>

			<span class="n">writepage</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKPAGE</span><span class="p">(</span><span class="n">dlbufaddr</span> <span class="o">+</span>
						<span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">));</span>
			<span class="n">writeoffset</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKOFF</span><span class="p">(</span><span class="n">dlbufaddr</span> <span class="o">+</span>
						<span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">));</span>

			<span class="n">writelen</span> <span class="o">=</span> <span class="n">burnlen</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">);</span>
			<span class="n">writelen</span> <span class="o">=</span> <span class="n">writelen</span> <span class="o">&gt;</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span> <span class="o">?</span>
			    <span class="n">HFA384x_USB_RWMEM_MAXLEN</span> <span class="o">:</span> <span class="n">writelen</span><span class="p">;</span>

			<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_dowmem_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						     <span class="n">writepage</span><span class="p">,</span>
						     <span class="n">writeoffset</span><span class="p">,</span>
						     <span class="n">writebuf</span><span class="p">,</span> <span class="n">writelen</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* set the download &#39;write flash&#39; mode */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_cmd_download</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					      <span class="n">HFA384x_PROGMODE_NVWRITE</span><span class="p">,</span>
					      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;download(NVWRITE,lo=%x,hi=%x,len=%x) &quot;</span>
			       <span class="s">&quot;cmd failed, result=%d. Aborting d/l</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">burnlo</span><span class="p">,</span> <span class="n">burnhi</span><span class="p">,</span> <span class="n">burnlen</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_proc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* TODO: We really should do a readback and compare. */</span>
	<span class="p">}</span>

<span class="nl">exit_proc:</span>

	<span class="cm">/* Leave the firmware in the &#39;post-prog&#39; mode.  flashdl_disable will */</span>
	<span class="cm">/*  actually disable programming mode.  Remember, that will cause the */</span>
	<span class="cm">/*  the firmware to effectively reset itself. */</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_getconfig</span>
<span class="cm">*</span>
<span class="cm">* Performs the sequence necessary to read a config/info item.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	rid		config/info record id (host order)</span>
<span class="cm">*	buf		host side record buffer.  Upon return it will</span>
<span class="cm">*			contain the body portion of the record (minus the</span>
<span class="cm">*			RID and len).</span>
<span class="cm">*	len		buffer length (in bytes, should match record length)</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*	-ENODATA	length mismatch between argument and retrieved</span>
<span class="cm">*			record.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_getconfig</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_dorrid_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">rid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm"> * hfa384x_drvr_getconfig_async</span>
<span class="cm"> *</span>
<span class="cm"> * Performs the sequence necessary to perform an async read of</span>
<span class="cm"> * of a config/info item.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *       hw              device structure</span>
<span class="cm"> *       rid             config/info record id (host order)</span>
<span class="cm"> *       buf             host side record buffer.  Upon return it will</span>
<span class="cm"> *                       contain the body portion of the record (minus the</span>
<span class="cm"> *                       RID and len).</span>
<span class="cm"> *       len             buffer length (in bytes, should match record length)</span>
<span class="cm"> *       cbfn            caller supplied callback, called when the command</span>
<span class="cm"> *                       is done (successful or not).</span>
<span class="cm"> *       cbfndata        pointer to some caller supplied data that will be</span>
<span class="cm"> *                       passed in as an argument to the cbfn.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *       nothing         the cbfn gets a status argument identifying if</span>
<span class="cm"> *                       any errors occur.</span>
<span class="cm"> * Side effects:</span>
<span class="cm"> *       Queues an hfa384x_usbcmd_t for subsequent execution.</span>
<span class="cm"> *</span>
<span class="cm"> * Call context:</span>
<span class="cm"> *       Any</span>
<span class="cm"> ----------------------------------------------------------------*/</span>
<span class="kt">int</span>
<span class="nf">hfa384x_drvr_getconfig_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dorrid_async</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">rid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">hfa384x_cb_rrid</span><span class="p">,</span> <span class="n">usercb</span><span class="p">,</span> <span class="n">usercb_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm"> * hfa384x_drvr_setconfig_async</span>
<span class="cm"> *</span>
<span class="cm"> * Performs the sequence necessary to write a config/info item.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *       hw              device structure</span>
<span class="cm"> *       rid             config/info record id (in host order)</span>
<span class="cm"> *       buf             host side record buffer</span>
<span class="cm"> *       len             buffer length (in bytes)</span>
<span class="cm"> *       usercb          completion callback</span>
<span class="cm"> *       usercb_data     completion callback argument</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *       0               success</span>
<span class="cm"> *       &gt;0              f/w reported error - f/w status code</span>
<span class="cm"> *       &lt;0              driver reported error</span>
<span class="cm"> *</span>
<span class="cm"> * Side effects:</span>
<span class="cm"> *</span>
<span class="cm"> * Call context:</span>
<span class="cm"> *       process</span>
<span class="cm"> ----------------------------------------------------------------*/</span>
<span class="kt">int</span>
<span class="nf">hfa384x_drvr_setconfig_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="n">ctlx_usercb_t</span> <span class="n">usercb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">usercb_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dowrid_async</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">rid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				    <span class="n">hfa384x_cb_status</span><span class="p">,</span> <span class="n">usercb</span><span class="p">,</span> <span class="n">usercb_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_ramdl_disable</span>
<span class="cm">*</span>
<span class="cm">* Ends the ram download state.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_ramdl_disable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check that we&#39;re already in the download state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">!=</span> <span class="n">HFA384x_DLSTATE_RAMENABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ramdl_disable()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* There isn&#39;t much we can do at this point, so I don&#39;t */</span>
	<span class="cm">/*  bother  w/ the return value */</span>
	<span class="n">hfa384x_cmd_download</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HFA384x_PROGMODE_DISABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">=</span> <span class="n">HFA384x_DLSTATE_DISABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_ramdl_enable</span>
<span class="cm">*</span>
<span class="cm">* Begins the ram download state.  Checks to see that we&#39;re not</span>
<span class="cm">* already in a download state and that a port isn&#39;t enabled.</span>
<span class="cm">* Sets the download state and calls cmd_download with the</span>
<span class="cm">* ENABLE_VOLATILE subcommand and the exeaddr argument.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	exeaddr		the card execution address that will be</span>
<span class="cm">*                       jumped to when ramdl_disable() is called</span>
<span class="cm">*			(host order).</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_ramdl_enable</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">exeaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">lowaddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hiaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Check that a port isn&#39;t active */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HFA384x_PORTID_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;Can&#39;t download with a macport enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check that we&#39;re not already in a download state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">!=</span> <span class="n">HFA384x_DLSTATE_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Download state not disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ramdl_enable, exeaddr=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">exeaddr</span><span class="p">);</span>

	<span class="cm">/* Call the download(1,addr) function */</span>
	<span class="n">lowaddr</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKOFF</span><span class="p">(</span><span class="n">exeaddr</span><span class="p">);</span>
	<span class="n">hiaddr</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKPAGE</span><span class="p">(</span><span class="n">exeaddr</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_cmd_download</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HFA384x_PROGMODE_RAM</span><span class="p">,</span>
				      <span class="n">lowaddr</span><span class="p">,</span> <span class="n">hiaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the download state */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">=</span> <span class="n">HFA384x_DLSTATE_RAMENABLED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cmd_download(0x%04x, 0x%04x) failed, result=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">lowaddr</span><span class="p">,</span> <span class="n">hiaddr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_ramdl_write</span>
<span class="cm">*</span>
<span class="cm">* Performs a RAM download of a chunk of data. First checks to see</span>
<span class="cm">* that we&#39;re in the RAM download state, then uses the [read|write]mem USB</span>
<span class="cm">* commands to 1) copy the data, 2) readback and compare.  The download</span>
<span class="cm">* state is unaffected.  When all data has been written using</span>
<span class="cm">* this function, call drvr_ramdl_disable() to end the download state</span>
<span class="cm">* and restart the MAC.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	daddr		Card address to write to. (host order)</span>
<span class="cm">*	buf		Ptr to data to write.</span>
<span class="cm">*	len		Length of data (host order).</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_ramdl_write</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">daddr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nwrites</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">curraddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">currpage</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">curroffset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">currlen</span><span class="p">;</span>

	<span class="cm">/* Check that we&#39;re in the ram download state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dlstate</span> <span class="o">!=</span> <span class="n">HFA384x_DLSTATE_RAMENABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Writing %d bytes to ram @0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>

	<span class="cm">/* How many dowmem calls?  */</span>
	<span class="n">nwrites</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">;</span>
	<span class="n">nwrites</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">%</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Do blocking wmem&#39;s */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nwrites</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* make address args */</span>
		<span class="n">curraddr</span> <span class="o">=</span> <span class="n">daddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">);</span>
		<span class="n">currpage</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKPAGE</span><span class="p">(</span><span class="n">curraddr</span><span class="p">);</span>
		<span class="n">curroffset</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKOFF</span><span class="p">(</span><span class="n">curraddr</span><span class="p">);</span>
		<span class="n">currlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">currlen</span> <span class="o">&gt;</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">)</span>
			<span class="n">currlen</span> <span class="o">=</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">;</span>

		<span class="cm">/* Do blocking ctlx */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_dowmem_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					     <span class="n">currpage</span><span class="p">,</span>
					     <span class="n">curroffset</span><span class="p">,</span>
					     <span class="n">data</span> <span class="o">+</span>
					     <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">HFA384x_USB_RWMEM_MAXLEN</span><span class="p">),</span>
					     <span class="n">currlen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* TODO: We really should have a readback. */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_readpda</span>
<span class="cm">*</span>
<span class="cm">* Performs the sequence to read the PDA space.  Note there is no</span>
<span class="cm">* drvr_writepda() function.  Writing a PDA is</span>
<span class="cm">* generally implemented by a calling component via calls to</span>
<span class="cm">* cmd_download and writing to the flash download buffer via the</span>
<span class="cm">* aux regs.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	buf		buffer to store PDA in</span>
<span class="cm">*	len		buffer length</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*	-ETIMEDOUT	timout waiting for the cmd regs to become</span>
<span class="cm">*			available, or waiting for the control reg</span>
<span class="cm">*			to indicate the Aux port is enabled.</span>
<span class="cm">*	-ENODATA	the buffer does NOT contain a valid PDA.</span>
<span class="cm">*			Either the card PDA is bad, or the auxdata</span>
<span class="cm">*			reads are giving us garbage.</span>

<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process or non-card interrupt.</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_readpda</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pda</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pdaok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">morepdrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">currpdr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* word offset of the current pdr */</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pdrlen</span><span class="p">;</span>		<span class="cm">/* pdr length in bytes, host order */</span>
	<span class="n">u16</span> <span class="n">pdrcode</span><span class="p">;</span>		<span class="cm">/* pdr code, host order */</span>
	<span class="n">u16</span> <span class="n">currpage</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">curroffset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdaloc</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cardaddr</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">auxctl</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">pdaloc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span>
		<span class="n">HFA3842_PDA_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span>
		<span class="n">HFA3841_PDA_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span>
		<span class="n">HFA3841_PDA_BOGUS_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="p">};</span>

	<span class="cm">/* Read the pda from each known address.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pdaloc</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make address */</span>
		<span class="n">currpage</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKPAGE</span><span class="p">(</span><span class="n">pdaloc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cardaddr</span><span class="p">);</span>
		<span class="n">curroffset</span> <span class="o">=</span> <span class="n">HFA384x_ADDR_CMD_MKOFF</span><span class="p">(</span><span class="n">pdaloc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cardaddr</span><span class="p">);</span>

		<span class="cm">/* units of bytes */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hfa384x_dormem_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">currpage</span><span class="p">,</span> <span class="n">curroffset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
						<span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;Read from index %zd failed, continuing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Test for garbage */</span>
		<span class="n">pdaok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* initially assume good */</span>
		<span class="n">morepdrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pdaok</span> <span class="o">&amp;&amp;</span> <span class="n">morepdrs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pdrlen</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pda</span><span class="p">[</span><span class="n">currpdr</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">pdrcode</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pda</span><span class="p">[</span><span class="n">currpdr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
			<span class="cm">/* Test the record length */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pdrlen</span> <span class="o">&gt;</span> <span class="n">HFA384x_PDR_LEN_MAX</span> <span class="o">||</span> <span class="n">pdrlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pdrlen invalid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdrlen</span><span class="p">);</span>
				<span class="n">pdaok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Test the code */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hfa384x_isgood_pdrcode</span><span class="p">(</span><span class="n">pdrcode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pdrcode invalid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">pdrcode</span><span class="p">);</span>
				<span class="n">pdaok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Test for completion */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pdrcode</span> <span class="o">==</span> <span class="n">HFA384x_PDR_END_OF_PDA</span><span class="p">)</span>
				<span class="n">morepdrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Move to the next pdr (if necessary) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">morepdrs</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* note the access to pda[], need words here */</span>
				<span class="n">currpdr</span> <span class="o">+=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pda</span><span class="p">[</span><span class="n">currpdr</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdaok</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;PDA Read from 0x%08x in %s space.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">pdaloc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cardaddr</span><span class="p">,</span>
			       <span class="n">pdaloc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">auxctl</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;EXTDS&quot;</span> <span class="o">:</span>
			       <span class="n">pdaloc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">auxctl</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;NV&quot;</span> <span class="o">:</span>
			       <span class="n">pdaloc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">auxctl</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="s">&quot;PHY&quot;</span> <span class="o">:</span>
			       <span class="n">pdaloc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">auxctl</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">?</span> <span class="s">&quot;ICSRAM&quot;</span> <span class="o">:</span>
			       <span class="s">&quot;&lt;bogus auxctl&gt;&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">pdaok</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Failure: pda is not okay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_setconfig</span>
<span class="cm">*</span>
<span class="cm">* Performs the sequence necessary to write a config/info item.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	rid		config/info record id (in host order)</span>
<span class="cm">*	buf		host side record buffer</span>
<span class="cm">*	len		buffer length (in bytes)</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_setconfig</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hfa384x_dowrid_wait</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">rid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_start</span>
<span class="cm">*</span>
<span class="cm">* Issues the MAC initialize command, sets up some data structures,</span>
<span class="cm">* and enables the interrupts.  After this function completes, the</span>
<span class="cm">* low-level stuff should be ready for any/all commands.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>

<span class="kt">int</span> <span class="nf">hfa384x_drvr_start</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="cm">/* Clear endpoint stalls - but only do this if the endpoint</span>
<span class="cm">	 * is showing a stall status. Some prism2 cards seem to behave</span>
<span class="cm">	 * badly if a clear_halt is called when the endpoint is already</span>
<span class="cm">	 * ok</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span>
	    <span class="n">usb_get_status</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Cannot get bulk in endpoint status.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_in</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to reset bulk in endpoint.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span>
	    <span class="n">usb_get_status</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">USB_RECIP_ENDPOINT</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Cannot get bulk out endpoint status.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_out</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to reset bulk out endpoint.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Synchronous unlink, in case we&#39;re trying to restart the driver */</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>

	<span class="cm">/* Post the IN urb */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">submit_rx_urb</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;Fatal, failed to submit RX URB, result=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Call initialize twice, with a 1 second sleep in between.</span>
<span class="cm">	 * This is a nasty work-around since many prism2 cards seem to</span>
<span class="cm">	 * need time to settle after an init from cold. The second</span>
<span class="cm">	 * call to initialize in theory is not necessary - but we call</span>
<span class="cm">	 * it anyway as a double insurance policy:</span>
<span class="cm">	 * 1) If the first init should fail, the second may well succeed</span>
<span class="cm">	 *    and the card can still be used</span>
<span class="cm">	 * 2) It helps ensures all is well with the card after the first</span>
<span class="cm">	 *    init and settle time.</span>
<span class="cm">	 */</span>
	<span class="n">result1</span> <span class="o">=</span> <span class="n">hfa384x_cmd_initialize</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">hfa384x_cmd_initialize</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;cmd_initialize() failed on two attempts, results %d and %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">);</span>
			<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;First cmd_initialize() failed (result %d),</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">result1</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;but second attempt succeeded. All should be ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;First cmd_initialize() succeeded, but second attempt failed (result=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result2</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;Most likely the card will be functional</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HFA384x_STATE_RUNNING</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_stop</span>
<span class="cm">*</span>
<span class="cm">* Shuts down the MAC to the point where it is safe to unload the</span>
<span class="cm">* driver.  Any subsystem that may be holding a data or function</span>
<span class="cm">* ptr into the driver must be cleared/deinitialized.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		success</span>
<span class="cm">*	&gt;0		f/w reported error - f/w status code</span>
<span class="cm">*	&lt;0		driver reported error</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_stop</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="cm">/* There&#39;s no need for spinlocks here. The USB &quot;disconnect&quot;</span>
<span class="cm">	 * function sets this &quot;removed&quot; flag and then calls us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Call initialize to leave the MAC in its &#39;reset&#39; state */</span>
		<span class="n">hfa384x_cmd_initialize</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Cancel the rxurb */</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">link_status</span> <span class="o">=</span> <span class="n">HFA384x_LINK_NOTCONNECTED</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">HFA384x_STATE_INIT</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">commsqual_timer</span><span class="p">);</span>

	<span class="cm">/* Clear all the port status */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HFA384x_NUMPORTS_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">port_enabled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_drvr_txframe</span>
<span class="cm">*</span>
<span class="cm">* Takes a frame from prism2sta and queues it for transmission.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		device structure</span>
<span class="cm">*	skb		packet buffer struct.  Contains an 802.11</span>
<span class="cm">*			data frame.</span>
<span class="cm">*       p80211_hdr      points to the 802.11 header for the packet.</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0		Success and more buffs available</span>
<span class="cm">*	1		Success but no more buffs</span>
<span class="cm">*	2		Allocation failure</span>
<span class="cm">*	4		Buffer full or queue busy</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="kt">int</span> <span class="nf">hfa384x_drvr_txframe</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			 <span class="k">union</span> <span class="n">p80211_hdr</span> <span class="o">*</span><span class="n">p80211_hdr</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">p80211_metawep</span> <span class="o">*</span><span class="n">p80211_wep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">usbpktlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hfa384x_tx_frame_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;TX URB already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Build Tx frame structure */</span>
	<span class="cm">/* Set up the control field */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">));</span>

	<span class="cm">/* Setup the usb type field */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">HFA384x_USB_TXFRM</span><span class="p">);</span>

	<span class="cm">/* Set up the sw_support field to identify this frame */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">sw_support</span> <span class="o">=</span> <span class="mh">0x0123</span><span class="p">;</span>

<span class="cm">/* Tx complete and Tx exception disable per dleach.  Might be causing</span>
<span class="cm"> * buf depletion</span>
<span class="cm"> */</span>
<span class="cm">/* #define DOEXC  SLP -- doboth breaks horribly under load, doexc less so. */</span>
<span class="cp">#if defined(DOBOTH)</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">tx_control</span> <span class="o">=</span>
	    <span class="n">HFA384x_TX_MACPORT_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">HFA384x_TX_STRUCTYPE_SET</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">HFA384x_TX_TXEX_SET</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">HFA384x_TX_TXOK_SET</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#elif defined(DOEXC)</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">tx_control</span> <span class="o">=</span>
	    <span class="n">HFA384x_TX_MACPORT_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">HFA384x_TX_STRUCTYPE_SET</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">HFA384x_TX_TXEX_SET</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">HFA384x_TX_TXOK_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">tx_control</span> <span class="o">=</span>
	    <span class="n">HFA384x_TX_MACPORT_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">HFA384x_TX_STRUCTYPE_SET</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">HFA384x_TX_TXEX_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">HFA384x_TX_TXOK_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">tx_control</span> <span class="o">=</span>
	    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">tx_control</span><span class="p">);</span>

	<span class="cm">/* copy the header over to the txdesc */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">frame_control</span><span class="p">),</span> <span class="n">p80211_hdr</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">p80211_hdr</span><span class="p">));</span>

	<span class="cm">/* if we&#39;re using host WEP, increase size by IV+ICV */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">usbpktlen</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usbpktlen</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* copy over the WEP IV if we are using host WEP */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">.</span><span class="n">txfrm</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">));</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">iv</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* copy over the packet data */</span>
	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* copy over the WEP ICV if we are using host WEP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">icv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p80211_wep</span><span class="o">-&gt;</span><span class="n">icv</span><span class="p">));</span>

	<span class="cm">/* Send the USB packet */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">),</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
			  <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_out</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">txbuff</span><span class="p">),</span> <span class="n">ROUNDUP64</span><span class="p">(</span><span class="n">usbpktlen</span><span class="p">),</span>
			  <span class="n">hfa384x_usbout_callback</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">.</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">USB_QUEUE_BULK</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">submit_tx_urb</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;submit_tx_urb() failed, error=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hfa384x_tx_timeout</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sched</span><span class="p">;</span>

		<span class="n">sched</span> <span class="o">=</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
		<span class="n">sched</span> <span class="o">|=</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sched</span><span class="p">)</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbctlx_reaper_task</span>
<span class="cm">*</span>
<span class="cm">* Tasklet to delete dead CTLX objects</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	data	ptr to a hfa384x_t</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	Interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbctlx_reaper_task</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* This list is guaranteed to be empty if someone</span>
<span class="cm">	 * has unplugged the adapter.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">reapable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

		<span class="n">ctlx</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctlx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbctlx_completion_task</span>
<span class="cm">*</span>
<span class="cm">* Tasklet to call completion handlers for returned CTLXs</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	data	ptr to hfa384x_t</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	Nothing</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	Interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbctlx_completion_task</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">reap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* This list is guaranteed to be empty if someone</span>
<span class="cm">	 * has unplugged the adapter ...</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">completing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>

		<span class="n">ctlx</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="cm">/* Call the completion function that this</span>
<span class="cm">		 * command was assigned, assuming it has one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* Make sure we don&#39;t try and complete</span>
<span class="cm">			 * this CTLX more than once!</span>
<span class="cm">			 */</span>
			<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">cmdcb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/* Did someone yank the adapter out</span>
<span class="cm">			 * while our list was (briefly) unlocked?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * &quot;Reapable&quot; CTLXs are ones which don&#39;t have any</span>
<span class="cm">		 * threads waiting for them to die. Hence they must</span>
<span class="cm">		 * be delivered to The Reaper!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">reapable</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Move the CTLX off the &quot;completing&quot; list (hopefully)</span>
<span class="cm">			 * on to the &quot;reapable&quot; list where the reaper task</span>
<span class="cm">			 * can find it. And &quot;reapable&quot; means that this CTLX</span>
<span class="cm">			 * isn&#39;t sitting on a wait-queue somewhere.</span>
<span class="cm">			 */</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">reapable</span><span class="p">);</span>
			<span class="n">reap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reap</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reaper_bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* unlocked_usbctlx_cancel_async</span>
<span class="cm">*</span>
<span class="cm">* Mark the CTLX dead asynchronously, and ensure that the</span>
<span class="cm">* next command on the queue is run afterwards.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw	ptr to the hfa384x_t structure</span>
<span class="cm">*	ctlx	ptr to a CTLX structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	0	the CTLX&#39;s URB is inactive</span>
<span class="cm">* -EINPROGRESS	the URB is currently being unlinked</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	Either process or interrupt, but presumably interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlocked_usbctlx_cancel_async</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					 <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to delete the URB containing our request packet.</span>
<span class="cm">	 * If we succeed, then its completion handler will be</span>
<span class="cm">	 * called with a status of -ECONNRESET.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">.</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_ASYNC_UNLINK</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_unlink_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The OUT URB had either already completed</span>
<span class="cm">		 * or was still in the pending queue, so the</span>
<span class="cm">		 * URB&#39;s completion function will not be called.</span>
<span class="cm">		 * We will have to complete the CTLX ourselves.</span>
<span class="cm">		 */</span>
		<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_REQ_FAILED</span><span class="p">;</span>
		<span class="n">unlocked_usbctlx_complete</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* unlocked_usbctlx_complete</span>
<span class="cm">*</span>
<span class="cm">* A CTLX has completed.  It may have been successful, it may not</span>
<span class="cm">* have been. At this point, the CTLX should be quiescent.  The URBs</span>
<span class="cm">* aren&#39;t active and the timers should have been stopped.</span>
<span class="cm">*</span>
<span class="cm">* The CTLX is migrated to the &quot;completing&quot; queue, and the completing</span>
<span class="cm">* tasklet is scheduled.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		ptr to a hfa384x_t structure</span>
<span class="cm">*	ctlx		ptr to a ctlx structure</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	Either, assume interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlocked_usbctlx_complete</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Timers have been stopped, and ctlx should be in</span>
<span class="cm">	 * a terminal state. Retire it from the &quot;active&quot;</span>
<span class="cm">	 * queue.</span>
<span class="cm">	 */</span>
	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">completing</span><span class="p">);</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">completion_bh</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CTLX_COMPLETE</span>:
	<span class="k">case</span> <span class="n">CTLX_REQ_FAILED</span>:
		<span class="cm">/* This are the correct terminating states. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CTLX[%d] not in a terminating state(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">type</span><span class="p">),</span> <span class="n">ctlxstr</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>			<span class="cm">/* switch */</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbctlxq_run</span>
<span class="cm">*</span>
<span class="cm">* Checks to see if the head item is running.  If not, starts it.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw	ptr to hfa384x_t</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	any</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* acquire lock */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Only one active CTLX at any one time, because there&#39;s no</span>
<span class="cm">	 * other (reliable) way to match the response URB to the</span>
<span class="cm">	 * correct CTLX.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Don&#39;t touch any of these CTLXs if the hardware</span>
<span class="cm">	 * has been removed or the USB subsystem is stalled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">)</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

		<span class="cm">/* This is the first pending command */</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">pending</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="n">hfa384x_usbctlx_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="cm">/* We need to split this off to avoid a race condition */</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">);</span>

		<span class="cm">/* Fill the out packet */</span>
		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">),</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb</span><span class="p">,</span>
				  <span class="n">hw</span><span class="o">-&gt;</span><span class="n">endp_out</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">),</span> <span class="n">ROUNDUP64</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">outbufsize</span><span class="p">),</span>
				  <span class="n">hfa384x_ctlxout_callback</span><span class="p">,</span> <span class="n">hw</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">.</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">USB_QUEUE_BULK</span><span class="p">;</span>

		<span class="cm">/* Now submit the URB and update the CTLX&#39;s state */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">SUBMIT_URB</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This CTLX is now running on the active queue */</span>
			<span class="n">head</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_REQ_SUBMITTED</span><span class="p">;</span>

			<span class="cm">/* Start the OUT wait timer */</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">req_timer_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">reqtimer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reqtimer</span><span class="p">);</span>

			<span class="cm">/* Start the IN wait timer */</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The OUT pipe needs resetting, so put</span>
<span class="cm">			 * this CTLX back in the &quot;pending&quot; queue</span>
<span class="cm">			 * and schedule a reset ...</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;%s tx pipe stalled: requesting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">pending</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s urb shutdown!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to submit CTLX[%d]: error=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">type</span><span class="p">),</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">unlocked_usbctlx_complete</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>			<span class="cm">/* while */</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbin_callback</span>
<span class="cm">*</span>
<span class="cm">* Callback for URBs on the BULKIN endpoint.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	urb		ptr to the completed urb</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbin_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="n">usbin</span> <span class="o">=</span> <span class="p">(</span><span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">urb_status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">USBIN_ACTION</span> <span class="p">{</span>
		<span class="n">HANDLE</span><span class="p">,</span>
		<span class="n">RESUBMIT</span><span class="p">,</span>
		<span class="n">ABORT</span>
	<span class="p">}</span> <span class="n">action</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wlandev</span> <span class="o">||</span> <span class="o">!</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">||</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">hw</span> <span class="o">=</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb_skb</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">||</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">));</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_urb_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check for error conditions within the URB */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">action</span> <span class="o">=</span> <span class="n">HANDLE</span><span class="p">;</span>

		<span class="cm">/* Check for short packet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">);</span>
			<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="p">);</span>
			<span class="n">action</span> <span class="o">=</span> <span class="n">RESUBMIT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s rx pipe stalled: requesting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_RX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
		<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">ABORT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EILSEQ</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EPROTO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">THROTTLE_RX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">throttle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">throttle</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">THROTTLE_JIFFIES</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">ABORT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EOVERFLOW</span>:
		<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">RESUBMIT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;status=%d, device removed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">ABORT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;status=%d, urb explicitly unlinked.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">ABORT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb status=%d, transfer flags=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">);</span>
		<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">RESUBMIT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">urb_status</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="n">ABORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Repost the RX URB */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">submit_rx_urb</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;Fatal, failed to resubmit rx_urb. error=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">result</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Handle any USB-IN packet */</span>
	<span class="cm">/* Note: the check of the sw_support field, the type field doesn&#39;t</span>
<span class="cm">	 *       have bit 12 set like the docs suggest.</span>
<span class="cm">	 */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HFA384x_USB_ISRXFRM</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">HANDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">txfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">sw_support</span> <span class="o">==</span> <span class="mh">0x0123</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hfa384x_usbin_txcompl</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">usbin</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">usbin</span><span class="p">));</span>
				<span class="n">hfa384x_usbin_rx</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HFA384x_USB_ISTXFRM</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">HANDLE</span><span class="p">)</span>
			<span class="n">hfa384x_usbin_txcompl</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">usbin</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HFA384x_USB_INFOFRM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">ABORT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">HANDLE</span><span class="p">)</span>
			<span class="n">hfa384x_usbin_info</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">usbin</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HFA384x_USB_CMDRESP</span>:
	<span class="k">case</span> <span class="n">HFA384x_USB_WRIDRESP</span>:
	<span class="k">case</span> <span class="n">HFA384x_USB_RRIDRESP</span>:
	<span class="k">case</span> <span class="n">HFA384x_USB_WMEMRESP</span>:
	<span class="k">case</span> <span class="n">HFA384x_USB_RMEMRESP</span>:
		<span class="cm">/* ALWAYS, ALWAYS, ALWAYS handle this CTLX!!!! */</span>
		<span class="n">hfa384x_usbin_ctlx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">usbin</span><span class="p">,</span> <span class="n">urb_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HFA384x_USB_BUFAVAIL</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Received BUFAVAIL packet, frmlen=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">usbin</span><span class="o">-&gt;</span><span class="n">bufavail</span><span class="p">.</span><span class="n">frmlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HFA384x_USB_ERROR</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Received USB_ERROR packet, errortype=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">usbin</span><span class="o">-&gt;</span><span class="n">usberror</span><span class="p">.</span><span class="n">errortype</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Unrecognized USBIN packet, type=%x, status=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">usbin</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">urb_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>			<span class="cm">/* switch */</span>

<span class="nl">exit:</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbin_ctlx</span>
<span class="cm">*</span>
<span class="cm">* We&#39;ve received a URB containing a Prism2 &quot;response&quot; message.</span>
<span class="cm">* This message needs to be matched up with a CTLX on the active</span>
<span class="cm">* queue and our state updated accordingly.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		ptr to hfa384x_t</span>
<span class="cm">*	usbin		ptr to USB IN packet</span>
<span class="cm">*	urb_status	status of this Bulk-In URB</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbin_ctlx</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="n">usbin</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">urb_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">run_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* There can be only one CTLX on the active queue</span>
<span class="cm">	 * at any one time, and this is the CTLX that the</span>
<span class="cm">	 * timers are waiting for.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* Remove the &quot;response timeout&quot;. It&#39;s possible that</span>
<span class="cm">	 * we are already too late, and that the timeout is</span>
<span class="cm">	 * already running. And that&#39;s just too bad for us,</span>
<span class="cm">	 * because we could lose our CTLX from the active</span>
<span class="cm">	 * queue here ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">get_active_ctlx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Bad CTLX, so get rid of it. But we only</span>
<span class="cm">		 * remove it from the active queue if we&#39;re no</span>
<span class="cm">		 * longer expecting the OUT URB to complete.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlocked_usbctlx_cancel_async</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">run_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u16</span> <span class="n">intype</span> <span class="o">=</span> <span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check that our message is what we&#39;re expecting ...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">intype</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;Expected IN[%d], received IN[%d] - ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">type</span><span class="p">),</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">intype</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* This URB has succeeded, so grab the data ... */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">usbin</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">));</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CTLX_REQ_SUBMITTED</span>:
			<span class="cm">/*</span>
<span class="cm">			 * We have received our response URB before</span>
<span class="cm">			 * our request has been acknowledged. Odd,</span>
<span class="cm">			 * but our OUT URB is still alive...</span>
<span class="cm">			 */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Causality violation: please reboot Universe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_RESP_COMPLETE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">CTLX_REQ_COMPLETE</span>:
			<span class="cm">/*</span>
<span class="cm">			 * This is the usual path: our request</span>
<span class="cm">			 * has already been acknowledged, and</span>
<span class="cm">			 * now we have received the reply too.</span>
<span class="cm">			 */</span>
			<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_COMPLETE</span><span class="p">;</span>
			<span class="n">unlocked_usbctlx_complete</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
			<span class="n">run_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/*</span>
<span class="cm">			 * Throw this CTLX away ...</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;Matched IN URB, CTLX[%d] in invalid state(%s).&quot;</span>
			       <span class="s">&quot; Discarded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">type</span><span class="p">),</span>
			       <span class="n">ctlxstr</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlocked_usbctlx_cancel_async</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">run_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>		<span class="cm">/* switch */</span>
	<span class="p">}</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">run_queue</span><span class="p">)</span>
		<span class="n">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbin_txcompl</span>
<span class="cm">*</span>
<span class="cm">* At this point we have the results of a previous transmit.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	wlandev		wlan device</span>
<span class="cm">*	usbin		ptr to the usb transfer buffer</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbin_txcompl</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span>
				  <span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="n">usbin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span> <span class="cm">/* yeah I know it says type... */</span>

	<span class="cm">/* Was there an error? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HFA384x_TXSTATUS_ISERROR</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="n">prism2sta_ev_txexc</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">prism2sta_ev_tx</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbin_rx</span>
<span class="cm">*</span>
<span class="cm">* At this point we have a successful received a rx frame packet.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	wlandev		wlan device</span>
<span class="cm">*	usbin		ptr to the usb transfer buffer</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbin_rx</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="n">usbin</span> <span class="o">=</span> <span class="p">(</span><span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">p80211_rxmeta</span> <span class="o">*</span><span class="n">rxmeta</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fc</span><span class="p">;</span>

	<span class="cm">/* Byte order convert once up front. */</span>
	<span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
	<span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>

	<span class="cm">/* Now handle frame based on port# */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">HFA384x_RXSTATUS_MACPORT_GET</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">fc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">frame_control</span><span class="p">);</span>

		<span class="cm">/* If exclude and we receive an unencrypted, drop it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hostwep</span> <span class="o">&amp;</span> <span class="n">HOSTWEP_EXCLUDEUNENCRYPTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">WLAN_GET_FC_ISWEP</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data_len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">data_len</span><span class="p">);</span>

		<span class="cm">/* How much header data do we have? */</span>
		<span class="n">hdrlen</span> <span class="o">=</span> <span class="n">p80211_headerlen</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>

		<span class="cm">/* Pull off the descriptor */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hfa384x_rx_frame_t</span><span class="p">));</span>

		<span class="cm">/* Now shunt the header block up against the data block</span>
<span class="cm">		 * with an &quot;overlapping&quot; copy</span>
<span class="cm">		 */</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">frame_control</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">);</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="cm">/* And set the frame length properly */</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">data_len</span> <span class="o">+</span> <span class="n">hdrlen</span><span class="p">);</span>

		<span class="cm">/* The prism2 series does not return the CRC */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">WLAN_CRC_LEN</span><span class="p">),</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">WLAN_CRC_LEN</span><span class="p">);</span>

		<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* Attach the rxmeta, set some stuff */</span>
		<span class="n">p80211skb_rxmeta_attach</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">rxmeta</span> <span class="o">=</span> <span class="n">P80211SKB_RXMETA</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">rxmeta</span><span class="o">-&gt;</span><span class="n">mactime</span> <span class="o">=</span> <span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">time</span><span class="p">;</span>
		<span class="n">rxmeta</span><span class="o">-&gt;</span><span class="n">rxrate</span> <span class="o">=</span> <span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">rate</span><span class="p">;</span>
		<span class="n">rxmeta</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="o">=</span> <span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">signal</span> <span class="o">-</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dbmadjust</span><span class="p">;</span>
		<span class="n">rxmeta</span><span class="o">-&gt;</span><span class="n">noise</span> <span class="o">=</span> <span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">silence</span> <span class="o">-</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dbmadjust</span><span class="p">;</span>

		<span class="n">prism2sta_ev_rx</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">7</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">HFA384x_RXSTATUS_ISFCSERR</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Copy to wlansnif skb */</span>
			<span class="n">hfa384x_int_rxmonitor</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Received monitor frame: FCSerr set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Received frame on unsupported port=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">HFA384x_RXSTATUS_MACPORT_GET</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">rxfrm</span><span class="p">.</span><span class="n">desc</span><span class="p">.</span><span class="n">status</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_int_rxmonitor</span>
<span class="cm">*</span>
<span class="cm">* Helper function for int_rx.  Handles monitor frames.</span>
<span class="cm">* Note that this function allocates space for the FCS and sets it</span>
<span class="cm">* to 0xffffffff.  The hfa384x doesn&#39;t give us the FCS value but the</span>
<span class="cm">* higher layers expect it.  0xffffffff is used as a flag to indicate</span>
<span class="cm">* the FCS is bogus.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	wlandev		wlan device structure</span>
<span class="cm">*	rxfrm		rx descriptor read from card in int_rx</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*	Allocates an skb and passes it up via the PF_PACKET interface.</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_int_rxmonitor</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span>
				  <span class="n">hfa384x_usb_rxfrm_t</span> <span class="o">*</span><span class="n">rxfrm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_rx_frame_t</span> <span class="o">*</span><span class="n">rxdesc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">rxfrm</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdrlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skblen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">datap</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* Remember the status, time, and data_len fields are in host order */</span>
	<span class="cm">/* Figure out how big the frame is */</span>
	<span class="n">fc</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rxdesc</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">);</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="n">p80211_headerlen</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
	<span class="n">datalen</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rxdesc</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>

	<span class="cm">/* Allocate an ind message+framesize skb */</span>
	<span class="n">skblen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">p80211_caphdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">hdrlen</span> <span class="o">+</span> <span class="n">datalen</span> <span class="o">+</span> <span class="n">WLAN_CRC_LEN</span><span class="p">;</span>

	<span class="cm">/* sanity check the length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skblen</span> <span class="o">&gt;</span>
	    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">p80211_caphdr</span><span class="p">)</span> <span class="o">+</span>
	     <span class="n">WLAN_HDR_A4_LEN</span> <span class="o">+</span> <span class="n">WLAN_DATA_MAXLEN</span> <span class="o">+</span> <span class="n">WLAN_CRC_LEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;overlen frm: len=%zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">skblen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">p80211_caphdr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">skblen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;alloc_skb failed trying to allocate %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">skblen</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* only prepend the prism header if in the right mode */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARPHRD_IEEE80211_PRISM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">sniffhdr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">p80211_caphdr</span> <span class="o">*</span><span class="n">caphdr</span><span class="p">;</span>
		<span class="cm">/* The NEW header format! */</span>
		<span class="n">datap</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">p80211_caphdr</span><span class="p">));</span>
		<span class="n">caphdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">p80211_caphdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">datap</span><span class="p">;</span>

		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">P80211CAPTURE_VERSION</span><span class="p">);</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">p80211_caphdr</span><span class="p">));</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">mactime</span> <span class="o">=</span> <span class="n">__cpu_to_be64</span><span class="p">(</span><span class="n">rxdesc</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">hosttime</span> <span class="o">=</span> <span class="n">__cpu_to_be64</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">phytype</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>	<span class="cm">/* dss_dot11_b */</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">sniff_channel</span><span class="p">);</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">datarate</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">rxdesc</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">antenna</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* unknown */</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* unknown */</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">ssi_type</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>	<span class="cm">/* rssi_raw */</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">ssi_signal</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">rxdesc</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">ssi_noise</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">rxdesc</span><span class="o">-&gt;</span><span class="n">silence</span><span class="p">);</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">preamble</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* unknown */</span>
		<span class="n">caphdr</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* cck */</span>
	<span class="p">}</span>

	<span class="cm">/* Copy the 802.11 header to the skb</span>
<span class="cm">	   (ctl frames may be less than a full header) */</span>
	<span class="n">datap</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">rxdesc</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">),</span> <span class="n">hdrlen</span><span class="p">);</span>

	<span class="cm">/* If any, copy the data from the card to the skb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">datap</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="n">rxfrm</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>

		<span class="cm">/* check for unencrypted stuff if WEP bit set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">datap</span> <span class="o">-</span> <span class="n">hdrlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>	<span class="cm">/* wep set */</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">datap</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xaa</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">datap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xaa</span><span class="p">))</span>
				<span class="cm">/* clear wep; it&#39;s the 802.2 header! */</span>
				<span class="o">*</span><span class="p">(</span><span class="n">datap</span> <span class="o">-</span> <span class="n">hdrlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="mh">0xbf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">sniff_fcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the FCS */</span>
		<span class="n">datap</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">WLAN_CRC_LEN</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">WLAN_CRC_LEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* pass it back up */</span>
	<span class="n">prism2sta_ev_rx</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbin_info</span>
<span class="cm">*</span>
<span class="cm">* At this point we have a successful received a Prism2 info frame.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	wlandev		wlan device</span>
<span class="cm">*	usbin		ptr to the usb transfer buffer</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbin_info</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">hfa384x_usbin_t</span> <span class="o">*</span><span class="n">usbin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usbin</span><span class="o">-&gt;</span><span class="n">infofrm</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">framelen</span> <span class="o">=</span>
	    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">infofrm</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">framelen</span><span class="p">);</span>
	<span class="n">prism2sta_ev_info</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usbin</span><span class="o">-&gt;</span><span class="n">infofrm</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbout_callback</span>
<span class="cm">*</span>
<span class="cm">* Callback for URBs on the BULKOUT endpoint.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	urb		ptr to the completed urb</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbout_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">hfa384x_usbout_t</span> <span class="o">*</span><span class="n">usbout</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_USB</span>
	<span class="n">dbprint_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wlandev</span> <span class="o">&amp;&amp;</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">hfa384x_usbout_tx</span><span class="p">(</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">usbout</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
			<span class="p">{</span>
				<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				       <span class="s">&quot;%s tx pipe stalled: requesting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span>
				    <span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span>
					<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
				<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="o">-</span><span class="n">EPROTO</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EILSEQ</span>:
			<span class="p">{</span>
				<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span>
				    <span class="p">(</span><span class="n">THROTTLE_TX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">throttle</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">throttle</span><span class="p">,</span>
						  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">THROTTLE_JIFFIES</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="p">);</span>
				<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:
			<span class="cm">/* Ignorable errors */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;unknown urb-&gt;status=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="o">++</span><span class="p">(</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">linux_stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>		<span class="cm">/* switch */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_ctlxout_callback</span>
<span class="cm">*</span>
<span class="cm">* Callback for control data on the BULKOUT endpoint.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	urb		ptr to the completed urb</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">* nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">* interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_ctlxout_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delete_resptimer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timer_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">run_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;urb-&gt;status=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_USB</span>
	<span class="n">dbprint_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only one CTLX at a time on the &quot;active&quot; list, and</span>
<span class="cm">	 * none at all if we are unplugged. However, we can</span>
<span class="cm">	 * rely on the disconnect function to clean everything</span>
<span class="cm">	 * up if someone unplugged the adapter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Having something on the &quot;active&quot; queue means</span>
<span class="cm">	 * that we have timers to worry about ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reqtimer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">req_timer_done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This timer was actually running while we</span>
<span class="cm">			 * were trying to delete it. Let it terminate</span>
<span class="cm">			 * gracefully instead.</span>
<span class="cm">			 */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">req_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctlx</span> <span class="o">=</span> <span class="n">get_active_ctlx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Request portion of a CTLX is successful */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CTLX_REQ_SUBMITTED</span>:
			<span class="cm">/* This OUT-ACK received before IN */</span>
			<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_REQ_COMPLETE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">CTLX_RESP_COMPLETE</span>:
			<span class="cm">/* IN already received before this OUT-ACK,</span>
<span class="cm">			 * so this command must now be complete.</span>
<span class="cm">			 */</span>
			<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_COMPLETE</span><span class="p">;</span>
			<span class="n">unlocked_usbctlx_complete</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
			<span class="n">run_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* This is NOT a valid CTLX &quot;success&quot; state! */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;Illegal CTLX[%d] success state(%s, %d) in OUT URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">.</span><span class="n">type</span><span class="p">),</span>
				<span class="n">ctlxstr</span><span class="p">(</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">),</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>		<span class="cm">/* switch */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If the pipe has stalled then we need to reset it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_TX_HALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;%s tx pipe stalled: requesting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* If someone cancels the OUT URB then its status</span>
<span class="cm">		 * should be either -ECONNRESET or -ENOENT.</span>
<span class="cm">		 */</span>
		<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_REQ_FAILED</span><span class="p">;</span>
		<span class="n">unlocked_usbctlx_complete</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">);</span>
		<span class="n">delete_resptimer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">run_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">delresp:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delete_resptimer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">timer_ok</span> <span class="o">=</span> <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_ok</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_ok</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">delresp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">run_queue</span><span class="p">)</span>
		<span class="n">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbctlx_reqtimerfn</span>
<span class="cm">*</span>
<span class="cm">* Timer response function for CTLX request timeouts.  If this</span>
<span class="cm">* function is called, it means that the callback for the OUT</span>
<span class="cm">* URB containing a Prism2.x XXX_Request was never called.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	data		a ptr to the hfa384x_t</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbctlx_reqtimerfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">req_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Removing the hardware automatically empties</span>
<span class="cm">	 * the active list ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must ensure that our URB is removed from</span>
<span class="cm">		 * the system, if it hasn&#39;t already expired.</span>
<span class="cm">		 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">.</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_ASYNC_UNLINK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usb_unlink_urb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlx_urb</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span> <span class="o">=</span> <span class="n">get_active_ctlx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

			<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_REQ_FAILED</span><span class="p">;</span>

			<span class="cm">/* This URB was active, but has now been</span>
<span class="cm">			 * cancelled. It will now have a status of</span>
<span class="cm">			 * -ECONNRESET in the callback function.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We are cancelling this CTLX, so we&#39;re</span>
<span class="cm">			 * not going to need to wait for a response.</span>
<span class="cm">			 * The URB&#39;s callback function will check</span>
<span class="cm">			 * that this timer is truly dead.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">resptimer</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbctlx_resptimerfn</span>
<span class="cm">*</span>
<span class="cm">* Timer response function for CTLX response timeouts.  If this</span>
<span class="cm">* function is called, it means that the callback for the IN</span>
<span class="cm">* URB containing a Prism2.x XXX_Response was never called.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	data		a ptr to the hfa384x_t</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbctlx_resptimerfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">resp_timer_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* The active list will be empty if the</span>
<span class="cm">	 * adapter has been unplugged ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span> <span class="o">=</span> <span class="n">get_active_ctlx</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlocked_usbctlx_cancel_async</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ctlx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usb_throttlefn</span>
<span class="cm">*</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	data	ptr to hw</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	Nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	Interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usb_throttlefn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to check BOTH the RX and the TX throttle controls,</span>
<span class="cm">	 * so we use the bitwise OR instead of the logical OR.</span>
<span class="cm">	 */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;flags=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">THROTTLE_RX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_RX_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span>
	     <span class="o">|</span>
	     <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">THROTTLE_TX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_TX_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_flags</span><span class="p">))</span>
	    <span class="p">))</span> <span class="p">{</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">usb_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbctlx_submit</span>
<span class="cm">*</span>
<span class="cm">* Called from the doxxx functions to submit a CTLX to the queue</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	hw		ptr to the hw struct</span>
<span class="cm">*	ctlx		ctlx structure to enqueue</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	-ENODEV if the adapter is unplugged</span>
<span class="cm">*	0</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	process or interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hfa384x_usbctlx_submit</span><span class="p">(</span><span class="n">hfa384x_t</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">hfa384x_usbctlx_t</span> <span class="o">*</span><span class="n">ctlx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wlandev</span><span class="o">-&gt;</span><span class="n">hwremoved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">CTLX_PENDING</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctlx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">pending</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ctlxq</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hfa384x_usbctlxq_run</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_usbout_tx</span>
<span class="cm">*</span>
<span class="cm">* At this point we have finished a send of a frame.  Mark the URB</span>
<span class="cm">* as available and call ev_alloc to notify higher layers we&#39;re</span>
<span class="cm">* ready for more.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	wlandev		wlan device</span>
<span class="cm">*	usbout		ptr to the usb transfer buffer</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	nothing</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">*	interrupt</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hfa384x_usbout_tx</span><span class="p">(</span><span class="n">wlandevice_t</span> <span class="o">*</span><span class="n">wlandev</span><span class="p">,</span> <span class="n">hfa384x_usbout_t</span> <span class="o">*</span><span class="n">usbout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prism2sta_ev_alloc</span><span class="p">(</span><span class="n">wlandev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------</span>
<span class="cm">* hfa384x_isgood_pdrcore</span>
<span class="cm">*</span>
<span class="cm">* Quick check of PDR codes.</span>
<span class="cm">*</span>
<span class="cm">* Arguments:</span>
<span class="cm">*	pdrcode		PDR code number (host order)</span>
<span class="cm">*</span>
<span class="cm">* Returns:</span>
<span class="cm">*	zero		not good.</span>
<span class="cm">*	one		is good.</span>
<span class="cm">*</span>
<span class="cm">* Side effects:</span>
<span class="cm">*</span>
<span class="cm">* Call context:</span>
<span class="cm">----------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hfa384x_isgood_pdrcode</span><span class="p">(</span><span class="n">u16</span> <span class="n">pdrcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pdrcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HFA384x_PDR_END_OF_PDA</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_PCB_PARTNUM</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_PDAVER</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_NIC_SERIAL</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_MKK_MEASUREMENTS</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_NIC_RAMSIZE</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_MFISUPRANGE</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_CFISUPRANGE</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_NICID</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_MAC_ADDRESS</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_REGDOMAIN</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_ALLOWED_CHANNEL</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_DEFAULT_CHANNEL</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_TEMPTYPE</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_IFR_SETTING</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_RFR_SETTING</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_HFA3861_BASELINE</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_HFA3861_SHADOW</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_HFA3861_IFRF</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_HFA3861_CHCALSP</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_HFA3861_CHCALI</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_3842_NIC_CONFIG</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_USB_ID</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_PCI_ID</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_PCI_IFCONF</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_PCI_PMCONF</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_RFENRGY</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_HFA3861_MANF_TESTSP</span>:
	<span class="k">case</span> <span class="n">HFA384x_PDR_HFA3861_MANF_TESTI</span>:
		<span class="cm">/* code is OK */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdrcode</span> <span class="o">&lt;</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* code is OK, but we don&#39;t know exactly what it is */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Encountered unknown PDR#=0x%04x, &quot;</span>
				 <span class="s">&quot;assuming it&#39;s ok.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdrcode</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* bad code */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Encountered unknown PDR#=0x%04x, &quot;</span>
				 <span class="s">&quot;(&gt;=0x1000), assuming it&#39;s bad.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdrcode</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* avoid compiler warnings */</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
