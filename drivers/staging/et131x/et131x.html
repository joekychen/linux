<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › et131x › et131x.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>et131x.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Agere Systems Inc.</span>
<span class="cm"> * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2005 Agere Systems Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *   http://www.agere.com</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2011 Mark Einon &lt;mark.einon@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *------------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * SOFTWARE LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * This software is provided subject to the following terms and conditions,</span>
<span class="cm"> * which you should read carefully before using the software.  Using this</span>
<span class="cm"> * software indicates your acceptance of these terms and conditions.  If you do</span>
<span class="cm"> * not agree with these terms and conditions, do not use the software.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2005 Agere Systems Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source or binary forms, with or without</span>
<span class="cm"> * modifications, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * . Redistributions of source code must retain the above copyright notice, this</span>
<span class="cm"> *    list of conditions and the following Disclaimer as comments in the code as</span>
<span class="cm"> *    well as in the documentation and/or other materials provided with the</span>
<span class="cm"> *    distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * . Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="cm"> *    this list of conditions and the following Disclaimer in the documentation</span>
<span class="cm"> *    and/or other materials provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * . Neither the name of Agere Systems Inc. nor the names of the contributors</span>
<span class="cm"> *    may be used to endorse or promote products derived from this software</span>
<span class="cm"> *    without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Disclaimer</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,</span>
<span class="cm"> * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY</span>
<span class="cm"> * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN</span>
<span class="cm"> * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY</span>
<span class="cm"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm"> * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT</span>
<span class="cm"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
<span class="cm"> * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
<span class="cm"> * DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/phy.h&gt;</span>

<span class="cp">#include &quot;et131x.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Victor Soriano &lt;vjsoriano@agere.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mark Einon &lt;mark.einon@gmail.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;10/100/1000 Base-T Ethernet Driver &quot;</span>
		   <span class="s">&quot;for the ET1310 by Agere Systems&quot;</span><span class="p">);</span>

<span class="cm">/* EEPROM defines */</span>
<span class="cp">#define MAX_NUM_REGISTER_POLLS          1000</span>
<span class="cp">#define MAX_NUM_WRITE_RETRIES           2</span>

<span class="cm">/* MAC defines */</span>
<span class="cp">#define COUNTER_WRAP_16_BIT 0x10000</span>
<span class="cp">#define COUNTER_WRAP_12_BIT 0x1000</span>

<span class="cm">/* PCI defines */</span>
<span class="cp">#define INTERNAL_MEM_SIZE       0x400	</span><span class="cm">/* 1024 of internal memory */</span><span class="cp"></span>
<span class="cp">#define INTERNAL_MEM_RX_OFFSET  0x1FF	</span><span class="cm">/* 50%   Tx, 50%   Rx */</span><span class="cp"></span>

<span class="cm">/* ISR defines */</span>
<span class="cm">/*</span>
<span class="cm"> * For interrupts, normal running is:</span>
<span class="cm"> *       rxdma_xfr_done, phy_interrupt, mac_stat_interrupt,</span>
<span class="cm"> *       watchdog_interrupt &amp; txdma_xfer_done</span>
<span class="cm"> *</span>
<span class="cm"> * In both cases, when flow control is enabled for either Tx or bi-direction,</span>
<span class="cm"> * we additional enable rx_fbr0_low and rx_fbr1_low, so we know when the</span>
<span class="cm"> * buffer rings are running low.</span>
<span class="cm"> */</span>
<span class="cp">#define INT_MASK_DISABLE            0xffffffff</span>

<span class="cm">/* NOTE: Masking out MAC_STAT Interrupt for now...</span>
<span class="cm"> * #define INT_MASK_ENABLE             0xfff6bf17</span>
<span class="cm"> * #define INT_MASK_ENABLE_NO_FLOW     0xfff6bfd7</span>
<span class="cm"> */</span>
<span class="cp">#define INT_MASK_ENABLE             0xfffebf17</span>
<span class="cp">#define INT_MASK_ENABLE_NO_FLOW     0xfffebfd7</span>

<span class="cm">/* General defines */</span>
<span class="cm">/* Packet and header sizes */</span>
<span class="cp">#define NIC_MIN_PACKET_SIZE	60</span>

<span class="cm">/* Multicast list size */</span>
<span class="cp">#define NIC_MAX_MCAST_LIST	128</span>

<span class="cm">/* Supported Filters */</span>
<span class="cp">#define ET131X_PACKET_TYPE_DIRECTED		0x0001</span>
<span class="cp">#define ET131X_PACKET_TYPE_MULTICAST		0x0002</span>
<span class="cp">#define ET131X_PACKET_TYPE_BROADCAST		0x0004</span>
<span class="cp">#define ET131X_PACKET_TYPE_PROMISCUOUS		0x0008</span>
<span class="cp">#define ET131X_PACKET_TYPE_ALL_MULTICAST	0x0010</span>

<span class="cm">/* Tx Timeout */</span>
<span class="cp">#define ET131X_TX_TIMEOUT	(1 * HZ)</span>
<span class="cp">#define NIC_SEND_HANG_THRESHOLD	0</span>

<span class="cm">/* MP_TCB flags */</span>
<span class="cp">#define fMP_DEST_MULTI			0x00000001</span>
<span class="cp">#define fMP_DEST_BROAD			0x00000002</span>

<span class="cm">/* MP_ADAPTER flags */</span>
<span class="cp">#define fMP_ADAPTER_RECV_LOOKASIDE	0x00000004</span>
<span class="cp">#define fMP_ADAPTER_INTERRUPT_IN_USE	0x00000008</span>

<span class="cm">/* MP_SHARED flags */</span>
<span class="cp">#define fMP_ADAPTER_LOWER_POWER		0x00200000</span>

<span class="cp">#define fMP_ADAPTER_NON_RECOVER_ERROR	0x00800000</span>
<span class="cp">#define fMP_ADAPTER_HARDWARE_ERROR	0x04000000</span>

<span class="cp">#define fMP_ADAPTER_FAIL_SEND_MASK	0x3ff00000</span>

<span class="cm">/* Some offsets in PCI config space that are actually used. */</span>
<span class="cp">#define ET1310_PCI_MAC_ADDRESS		0xA4</span>
<span class="cp">#define ET1310_PCI_EEPROM_STATUS	0xB2</span>
<span class="cp">#define ET1310_PCI_ACK_NACK		0xC0</span>
<span class="cp">#define ET1310_PCI_REPLAY		0xC2</span>
<span class="cp">#define ET1310_PCI_L0L1LATENCY		0xCF</span>

<span class="cm">/* PCI Product IDs */</span>
<span class="cp">#define ET131X_PCI_DEVICE_ID_GIG	0xED00	</span><span class="cm">/* ET1310 1000 Base-T 8 */</span><span class="cp"></span>
<span class="cp">#define ET131X_PCI_DEVICE_ID_FAST	0xED01	</span><span class="cm">/* ET1310 100  Base-T */</span><span class="cp"></span>

<span class="cm">/* Define order of magnitude converter */</span>
<span class="cp">#define NANO_IN_A_MICRO	1000</span>

<span class="cp">#define PARM_RX_NUM_BUFS_DEF    4</span>
<span class="cp">#define PARM_RX_TIME_INT_DEF    10</span>
<span class="cp">#define PARM_RX_MEM_END_DEF     0x2bc</span>
<span class="cp">#define PARM_TX_TIME_INT_DEF    40</span>
<span class="cp">#define PARM_TX_NUM_BUFS_DEF    4</span>
<span class="cp">#define PARM_DMA_CACHE_DEF      0</span>

<span class="cm">/* RX defines */</span>
<span class="cp">#define USE_FBR0 1</span>
<span class="cp">#define FBR_CHUNKS 32</span>
<span class="cp">#define MAX_DESC_PER_RING_RX         1024</span>

<span class="cm">/* number of RFDs - default and min */</span>
<span class="cp">#ifdef USE_FBR0</span>
<span class="cp">#define RFD_LOW_WATER_MARK	40</span>
<span class="cp">#define NIC_DEFAULT_NUM_RFD	1024</span>
<span class="cp">#define NUM_FBRS		2</span>
<span class="cp">#else</span>
<span class="cp">#define RFD_LOW_WATER_MARK	20</span>
<span class="cp">#define NIC_DEFAULT_NUM_RFD	256</span>
<span class="cp">#define NUM_FBRS		1</span>
<span class="cp">#endif</span>

<span class="cp">#define NIC_MIN_NUM_RFD		64</span>
<span class="cp">#define NUM_PACKETS_HANDLED	256</span>

<span class="cp">#define ALCATEL_MULTICAST_PKT	0x01000000</span>
<span class="cp">#define ALCATEL_BROADCAST_PKT	0x02000000</span>

<span class="cm">/* typedefs for Free Buffer Descriptors */</span>
<span class="k">struct</span> <span class="n">fbr_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word2</span><span class="p">;</span>		<span class="cm">/* Bits 10-31 reserved, 0-9 descriptor */</span>
<span class="p">};</span>

<span class="cm">/* Packet Status Ring Descriptors</span>
<span class="cm"> *</span>
<span class="cm"> * Word 0:</span>
<span class="cm"> *</span>
<span class="cm"> * top 16 bits are from the Alcatel Status Word as enumerated in</span>
<span class="cm"> * PE-MCXMAC Data Sheet IPD DS54 0210-1 (also IPD-DS80 0205-2)</span>
<span class="cm"> *</span>
<span class="cm"> * 0: hp			hash pass</span>
<span class="cm"> * 1: ipa			IP checksum assist</span>
<span class="cm"> * 2: ipp			IP checksum pass</span>
<span class="cm"> * 3: tcpa			TCP checksum assist</span>
<span class="cm"> * 4: tcpp			TCP checksum pass</span>
<span class="cm"> * 5: wol			WOL Event</span>
<span class="cm"> * 6: rxmac_error		RXMAC Error Indicator</span>
<span class="cm"> * 7: drop			Drop packet</span>
<span class="cm"> * 8: ft			Frame Truncated</span>
<span class="cm"> * 9: jp			Jumbo Packet</span>
<span class="cm"> * 10: vp			VLAN Packet</span>
<span class="cm"> * 11-15: unused</span>
<span class="cm"> * 16: asw_prev_pkt_dropped	e.g. IFG too small on previous</span>
<span class="cm"> * 17: asw_RX_DV_event		short receive event detected</span>
<span class="cm"> * 18: asw_false_carrier_event	bad carrier since last good packet</span>
<span class="cm"> * 19: asw_code_err		one or more nibbles signalled as errors</span>
<span class="cm"> * 20: asw_CRC_err		CRC error</span>
<span class="cm"> * 21: asw_len_chk_err		frame length field incorrect</span>
<span class="cm"> * 22: asw_too_long		frame length &gt; 1518 bytes</span>
<span class="cm"> * 23: asw_OK			valid CRC + no code error</span>
<span class="cm"> * 24: asw_multicast		has a multicast address</span>
<span class="cm"> * 25: asw_broadcast		has a broadcast address</span>
<span class="cm"> * 26: asw_dribble_nibble	spurious bits after EOP</span>
<span class="cm"> * 27: asw_control_frame	is a control frame</span>
<span class="cm"> * 28: asw_pause_frame		is a pause frame</span>
<span class="cm"> * 29: asw_unsupported_op	unsupported OP code</span>
<span class="cm"> * 30: asw_VLAN_tag		VLAN tag detected</span>
<span class="cm"> * 31: asw_long_evt		Rx long event</span>
<span class="cm"> *</span>
<span class="cm"> * Word 1:</span>
<span class="cm"> * 0-15: length			length in bytes</span>
<span class="cm"> * 16-25: bi			Buffer Index</span>
<span class="cm"> * 26-27: ri			Ring Index</span>
<span class="cm"> * 28-31: reserved</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pkt_stat_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">word0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Typedefs for the RX DMA status word */</span>

<span class="cm">/*</span>
<span class="cm"> * rx status word 0 holds part of the status bits of the Rx DMA engine</span>
<span class="cm"> * that get copied out to memory by the ET-1310.  Word 0 is a 32 bit word</span>
<span class="cm"> * which contains the Free Buffer ring 0 and 1 available offset.</span>
<span class="cm"> *</span>
<span class="cm"> * bit 0-9 FBR1 offset</span>
<span class="cm"> * bit 10 Wrap flag for FBR1</span>
<span class="cm"> * bit 16-25 FBR0 offset</span>
<span class="cm"> * bit 26 Wrap flag for FBR0</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * RXSTAT_WORD1_t structure holds part of the status bits of the Rx DMA engine</span>
<span class="cm"> * that get copied out to memory by the ET-1310.  Word 3 is a 32 bit word</span>
<span class="cm"> * which contains the Packet Status Ring available offset.</span>
<span class="cm"> *</span>
<span class="cm"> * bit 0-15 reserved</span>
<span class="cm"> * bit 16-27 PSRoffset</span>
<span class="cm"> * bit 28 PSRwrap</span>
<span class="cm"> * bit 29-31 unused</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * struct rx_status_block is a structure representing the status of the Rx</span>
<span class="cm"> * DMA engine it sits in free memory, and is pointed to by 0x101c / 0x1020</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rx_status_block</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">word0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure for look-up table holding free buffer ring pointers, addresses</span>
<span class="cm"> * and state.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fbr_lookup</span> <span class="p">{</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">virt</span><span class="p">[</span><span class="n">MAX_DESC_PER_RING_RX</span><span class="p">];</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">buffer1</span><span class="p">[</span><span class="n">MAX_DESC_PER_RING_RX</span><span class="p">];</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">buffer2</span><span class="p">[</span><span class="n">MAX_DESC_PER_RING_RX</span><span class="p">];</span>
	<span class="n">u32</span>		 <span class="n">bus_high</span><span class="p">[</span><span class="n">MAX_DESC_PER_RING_RX</span><span class="p">];</span>
	<span class="n">u32</span>		 <span class="n">bus_low</span><span class="p">[</span><span class="n">MAX_DESC_PER_RING_RX</span><span class="p">];</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">ring_virtaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	 <span class="n">ring_physaddr</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">MAX_DESC_PER_RING_RX</span> <span class="o">/</span> <span class="n">FBR_CHUNKS</span><span class="p">];</span>
	<span class="n">dma_addr_t</span>	 <span class="n">mem_physaddrs</span><span class="p">[</span><span class="n">MAX_DESC_PER_RING_RX</span> <span class="o">/</span> <span class="n">FBR_CHUNKS</span><span class="p">];</span>
	<span class="n">u64</span>		 <span class="n">real_physaddr</span><span class="p">;</span>
	<span class="n">u64</span>		 <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span>		 <span class="n">local_full</span><span class="p">;</span>
	<span class="n">u32</span>		 <span class="n">num_entries</span><span class="p">;</span>
	<span class="n">u32</span>		 <span class="n">buffsize</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct rx_ring is the sructure representing the adaptor&#39;s local</span>
<span class="cm"> * reference(s) to the rings</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> * IMPORTANT NOTE :- fbr_lookup *fbr[NUM_FBRS] uses index 0 to refer to FBR1</span>
<span class="cm"> *			and index 1 to refer to FRB0</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rx_ring</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fbr_lookup</span> <span class="o">*</span><span class="n">fbr</span><span class="p">[</span><span class="n">NUM_FBRS</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ps_ring_virtaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ps_ring_physaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">local_psr_full</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">psr_num_entries</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rx_status_block</span> <span class="o">*</span><span class="n">rx_status_block</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_status_bus</span><span class="p">;</span>

	<span class="cm">/* RECV */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">recv_list</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_ready_recv</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">num_rfd</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">unfinished_receives</span><span class="p">;</span>

	<span class="cm">/* lookaside lists */</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">recv_lookaside</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* TX defines */</span>
<span class="cm">/*</span>
<span class="cm"> * word 2 of the control bits in the Tx Descriptor ring for the ET-1310</span>
<span class="cm"> *</span>
<span class="cm"> * 0-15: length of packet</span>
<span class="cm"> * 16-27: VLAN tag</span>
<span class="cm"> * 28: VLAN CFI</span>
<span class="cm"> * 29-31: VLAN priority</span>
<span class="cm"> *</span>
<span class="cm"> * word 3 of the control bits in the Tx Descriptor ring for the ET-1310</span>
<span class="cm"> *</span>
<span class="cm"> * 0: last packet in the sequence</span>
<span class="cm"> * 1: first packet in the sequence</span>
<span class="cm"> * 2: interrupt the processor when this pkt sent</span>
<span class="cm"> * 3: Control word - no packet data</span>
<span class="cm"> * 4: Issue half-duplex backpressure : XON/XOFF</span>
<span class="cm"> * 5: send pause frame</span>
<span class="cm"> * 6: Tx frame has error</span>
<span class="cm"> * 7: append CRC</span>
<span class="cm"> * 8: MAC override</span>
<span class="cm"> * 9: pad packet</span>
<span class="cm"> * 10: Packet is a Huge packet</span>
<span class="cm"> * 11: append VLAN tag</span>
<span class="cm"> * 12: IP checksum assist</span>
<span class="cm"> * 13: TCP checksum assist</span>
<span class="cm"> * 14: UDP checksum assist</span>
<span class="cm"> */</span>

<span class="cm">/* struct tx_desc represents each descriptor on the ring */</span>
<span class="k">struct</span> <span class="n">tx_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len_vlan</span><span class="p">;</span>	<span class="cm">/* control words how to xmit the */</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* data (detailed above) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The status of the Tx DMA engine it sits in free memory, and is pointed to</span>
<span class="cm"> * by 0x101c / 0x1020. This is a DMA10 type</span>
<span class="cm"> */</span>

<span class="cm">/* TCB (Transmit Control Block: Host Side) */</span>
<span class="k">struct</span> <span class="n">tcb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/* Next entry in ring */</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Our flags for the packet */</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* Used to spot stuck/lost packets */</span>
	<span class="n">u32</span> <span class="n">stale</span><span class="p">;</span>		<span class="cm">/* Used to spot stuck/lost packets */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>	<span class="cm">/* Network skb we are tied to */</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* Ring indexes */</span>
	<span class="n">u32</span> <span class="n">index_start</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Structure representing our local reference(s) to the ring */</span>
<span class="k">struct</span> <span class="n">tx_ring</span> <span class="p">{</span>
	<span class="cm">/* TCB (Transmit Control Block) memory and lists */</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb_ring</span><span class="p">;</span>

	<span class="cm">/* List of TCBs that are ready to be used */</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb_qhead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb_qtail</span><span class="p">;</span>

	<span class="cm">/* list of TCBs that are currently being sent.  NOTE that access to all</span>
<span class="cm">	 * three of these (including used) are controlled via the</span>
<span class="cm">	 * TCBSendQLock.  This lock should be secured prior to incementing /</span>
<span class="cm">	 * decrementing used, or any queue manipulation on send_head /</span>
<span class="cm">	 * tail</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">send_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">send_tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>

	<span class="cm">/* The actual descriptor ring */</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">tx_desc_ring</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_desc_ring_pa</span><span class="p">;</span>

	<span class="cm">/* send_idx indicates where we last wrote to in the descriptor ring. */</span>
	<span class="n">u32</span> <span class="n">send_idx</span><span class="p">;</span>

	<span class="cm">/* The location of the write-back status block */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">tx_status</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_status_pa</span><span class="p">;</span>

	<span class="cm">/* Packets since the last IRQ: used for interrupt coalescing */</span>
	<span class="kt">int</span> <span class="n">since_irq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Do not change these values: if changed, then change also in respective</span>
<span class="cm"> * TXdma and Rxdma engines</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_DESC_PER_RING_TX         512    </span><span class="cm">/* TX Do not change these values */</span><span class="cp"></span>
<span class="cp">#define NUM_TCB                      64</span>

<span class="cm">/*</span>
<span class="cm"> * These values are all superseded by registry entries to facilitate tuning.</span>
<span class="cm"> * Once the desired performance has been achieved, the optimal registry values</span>
<span class="cm"> * should be re-populated to these #defines:</span>
<span class="cm"> */</span>
<span class="cp">#define TX_ERROR_PERIOD             1000</span>

<span class="cp">#define LO_MARK_PERCENT_FOR_PSR     15</span>
<span class="cp">#define LO_MARK_PERCENT_FOR_RX      15</span>

<span class="cm">/* RFD (Receive Frame Descriptor) */</span>
<span class="k">struct</span> <span class="n">rfd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* total size of receive frame */</span>
	<span class="n">u16</span> <span class="n">bufferindex</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ringindex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Flow Control */</span>
<span class="cp">#define FLOW_BOTH	0</span>
<span class="cp">#define FLOW_TXONLY	1</span>
<span class="cp">#define FLOW_RXONLY	2</span>
<span class="cp">#define FLOW_NONE	3</span>

<span class="cm">/* Struct to define some device statistics */</span>
<span class="k">struct</span> <span class="n">ce_stats</span> <span class="p">{</span>
	<span class="cm">/* MIB II variables</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: atomic_t types are only guaranteed to store 24-bits; if we</span>
<span class="cm">	 * MUST have 32, then we&#39;ll need another way to perform atomic</span>
<span class="cm">	 * operations</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>		<span class="n">unicast_pkts_rcvd</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">unicast_pkts_xmtd</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">multicast_pkts_rcvd</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">multicast_pkts_xmtd</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">broadcast_pkts_rcvd</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">broadcast_pkts_xmtd</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rcvd_pkts_dropped</span><span class="p">;</span>

	<span class="cm">/* Tx Statistics. */</span>
	<span class="n">u32</span>		<span class="n">tx_underflows</span><span class="p">;</span>

	<span class="n">u32</span>		<span class="n">tx_collisions</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">tx_excessive_collisions</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">tx_first_collisions</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">tx_late_collisions</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">tx_max_pkt_errs</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">tx_deferred</span><span class="p">;</span>

	<span class="cm">/* Rx Statistics. */</span>
	<span class="n">u32</span>		<span class="n">rx_overflows</span><span class="p">;</span>

	<span class="n">u32</span>		<span class="n">rx_length_errs</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rx_align_errs</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rx_crc_errs</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rx_code_violations</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rx_other_errs</span><span class="p">;</span>

	<span class="n">u32</span>		<span class="n">synchronous_iterations</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">interrupt_status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The private adapter structure */</span>
<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">mii_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">task</span><span class="p">;</span>

	<span class="cm">/* Flags that indicate current state of the adapter */</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* local link state, to determine if a state change has occurred */</span>
	<span class="kt">int</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/* Configuration  */</span>
	<span class="n">u8</span> <span class="n">rom_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">has_eeprom</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">eeprom_data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/* Spinlocks */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">tcb_send_qlock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">tcb_ready_qlock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">send_hw_lock</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">rcv_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">rcv_pend_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">fbr_lock</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">phy_lock</span><span class="p">;</span>

	<span class="cm">/* Packet Filter and look ahead size */</span>
	<span class="n">u32</span> <span class="n">packet_filter</span><span class="p">;</span>

	<span class="cm">/* multicast list */</span>
	<span class="n">u32</span> <span class="n">multicast_addr_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">multicast_list</span><span class="p">[</span><span class="n">NIC_MAX_MCAST_LIST</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="cm">/* Pointer to the device&#39;s PCI register space */</span>
	<span class="k">struct</span> <span class="n">address_map</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/* Registry parameters */</span>
	<span class="n">u8</span> <span class="n">wanted_flow</span><span class="p">;</span>		<span class="cm">/* Flow we want for 802.3x flow control */</span>
	<span class="n">u32</span> <span class="n">registry_jumbo_packet</span><span class="p">;</span>	<span class="cm">/* Max supported ethernet packet size */</span>

	<span class="cm">/* Derived from the registry: */</span>
	<span class="n">u8</span> <span class="n">flowcontrol</span><span class="p">;</span>		<span class="cm">/* flow control validated by the far-end */</span>

	<span class="cm">/* Minimize init-time */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">error_timer</span><span class="p">;</span>

	<span class="cm">/* variable putting the phy into coma mode when boot up with no cable</span>
<span class="cm">	 * plugged in after 5 seconds</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">boot_coma</span><span class="p">;</span>

	<span class="cm">/* Next two used to save power information at power down. This</span>
<span class="cm">	 * information will be used during power up to set up parts of Power</span>
<span class="cm">	 * Management in JAGCore</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">pdown_speed</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pdown_duplex</span><span class="p">;</span>

	<span class="cm">/* Tx Memory Variables */</span>
	<span class="k">struct</span> <span class="n">tx_ring</span> <span class="n">tx_ring</span><span class="p">;</span>

	<span class="cm">/* Rx Memory Variables */</span>
	<span class="k">struct</span> <span class="n">rx_ring</span> <span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Stats */</span>
	<span class="k">struct</span> <span class="n">ce_stats</span> <span class="n">stats</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">net_stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeprom_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 1. Check LBCIF Status Register for bits 6 &amp; 3:2 all equal to 0 and</span>
<span class="cm">	 *    bits 7,1:0 both equal to 1, at least once after reset.</span>
<span class="cm">	 *    Subsequent operations need only to check that bits 1:0 are equal</span>
<span class="cm">	 *    to 1 prior to starting a single byte read/write</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUM_REGISTER_POLLS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read registers grouped in DWORD1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LBCIF_DWORD1_GROUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/* I2C idle and Phy Queue Avail both true */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x3000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
				<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * eeprom_write - Write a byte to the ET1310&#39;s EEPROM</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> * @addr: the address to write</span>
<span class="cm"> * @data: the value to write</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 for a successful write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeprom_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i2c_wack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">writeok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For an EEPROM, an I2C single byte write is defined as a START</span>
<span class="cm">	 * condition followed by the device address, EEPROM address, one byte</span>
<span class="cm">	 * of data and a STOP condition.  The STOP condition will trigger the</span>
<span class="cm">	 * EEPROM&#39;s internally timed write cycle to the nonvolatile memory.</span>
<span class="cm">	 * All inputs are disabled during this write cycle and the EEPROM will</span>
<span class="cm">	 * not respond to any access until the internal write is complete.</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">eeprom_wait_ready</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	 <span class="cm">/*</span>
<span class="cm">	 * 2. Write to the LBCIF Control Register:  bit 7=1, bit 6=1, bit 3=0,</span>
<span class="cm">	 *    and bits 1:0 both =0.  Bit 5 should be set according to the</span>
<span class="cm">	 *    type of EEPROM being accessed (1=two byte addressing, 0=one</span>
<span class="cm">	 *    byte addressing).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LBCIF_CONTROL_REGISTER</span><span class="p">,</span>
			<span class="n">LBCIF_CONTROL_LBCIF_ENABLE</span> <span class="o">|</span> <span class="n">LBCIF_CONTROL_I2C_WRITE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">i2c_wack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Prepare EEPROM address for Step 3 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">MAX_NUM_WRITE_RETRIES</span><span class="p">;</span> <span class="n">retries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Write the address to the LBCIF Address Register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LBCIF_ADDRESS_REGISTER</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Write the data to the LBCIF Data Register (the I2C write</span>
<span class="cm">		 * will begin).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LBCIF_DATA_REGISTER</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Monitor bit 1:0 of the LBCIF Status Register.  When bits</span>
<span class="cm">		 * 1:0 are both equal to 1, the I2C write has completed and the</span>
<span class="cm">		 * internal write cycle of the EEPROM is about to start.</span>
<span class="cm">		 * (bits 1:0 = 01 is a legal state while waiting from both</span>
<span class="cm">		 * equal to 1, but bits 1:0 = 10 is invalid and implies that</span>
<span class="cm">		 * something is broken).</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">eeprom_wait_ready</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check bit 3 of the LBCIF Status Register.  If  equal to 1,</span>
<span class="cm">		 * an error has occurred.Don&#39;t break here if we are revision</span>
<span class="cm">		 * 1, this is so we do a blind write for load bug.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LBCIF_STATUS_GENERAL_ERROR</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check bit 2 of the LBCIF Status Register.  If equal to 1 an</span>
<span class="cm">		 * ACK error has occurred on the address phase of the write.</span>
<span class="cm">		 * This could be due to an actual hardware failure or the</span>
<span class="cm">		 * EEPROM may still be in its internal write cycle from a</span>
<span class="cm">		 * previous write. This write operation was ignored and must be</span>
<span class="cm">		  *repeated later.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LBCIF_STATUS_ACK_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This could be due to an actual hardware failure</span>
<span class="cm">			 * or the EEPROM may still be in its internal write</span>
<span class="cm">			 * cycle from a previous write. This write operation</span>
<span class="cm">			 * was ignored and must be repeated later.</span>
<span class="cm">			 */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">writeok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set bit 6 of the LBCIF Control Register = 0.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i2c_wack</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LBCIF_CONTROL_REGISTER</span><span class="p">,</span>
			<span class="n">LBCIF_CONTROL_LBCIF_ENABLE</span><span class="p">))</span>
			<span class="n">writeok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Do read until internal ACK_ERROR goes away meaning write</span>
<span class="cm">		 * completed</span>
<span class="cm">		 */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					       <span class="n">LBCIF_ADDRESS_REGISTER</span><span class="p">,</span>
					       <span class="n">addr</span><span class="p">);</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">LBCIF_DATA_REGISTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x00010000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x00040000</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xC000</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">10000</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">writeok</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeprom_read - Read a byte from the ET1310&#39;s EEPROM</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> * @addr: the address from which to read</span>
<span class="cm"> * @pdata: a pointer to a byte in which to store the value of the read</span>
<span class="cm"> * @eeprom_id: the ID of the EEPROM</span>
<span class="cm"> * @addrmode: how the EEPROM is to be accessed</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 for a successful read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeprom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A single byte read is similar to the single byte write, with the</span>
<span class="cm">	 * exception of the data flow:</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">eeprom_wait_ready</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Write to the LBCIF Control Register:  bit 7=1, bit 6=0, bit 3=0,</span>
<span class="cm">	 * and bits 1:0 both =0.  Bit 5 should be set according to the type</span>
<span class="cm">	 * of EEPROM being accessed (1=two byte addressing, 0=one byte</span>
<span class="cm">	 * addressing).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LBCIF_CONTROL_REGISTER</span><span class="p">,</span>
				  <span class="n">LBCIF_CONTROL_LBCIF_ENABLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Write the address to the LBCIF Address Register (I2C read will</span>
<span class="cm">	 * begin).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">LBCIF_ADDRESS_REGISTER</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Monitor bit 0 of the LBCIF Status Register.  When = 1, I2C read</span>
<span class="cm">	 * is complete. (if bit 1 =1 and bit 0 stays = 0, a hardware failure</span>
<span class="cm">	 * has occurred).</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">eeprom_wait_ready</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Regardless of error status, read data byte from LBCIF Data</span>
<span class="cm">	 * Register.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check bit 2 of the LBCIF Status Register.  If = 1,</span>
<span class="cm">	 * then an error has occurred.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LBCIF_STATUS_ACK_ERROR</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_init_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">eestatus</span><span class="p">;</span>

	<span class="cm">/* We first need to check the EEPROM Status code located at offset</span>
<span class="cm">	 * 0xB2 of config space</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ET1310_PCI_EEPROM_STATUS</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">eestatus</span><span class="p">);</span>

	<span class="cm">/* THIS IS A WORKAROUND:</span>
<span class="cm">	 * I need to call this function twice to get my card in a</span>
<span class="cm">	 * LG M1 Express Dual running. I tried also a msleep before this</span>
<span class="cm">	 * function, because I thought there could be some time condidions</span>
<span class="cm">	 * but it didn&#39;t work. Call the whole function twice also work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ET1310_PCI_EEPROM_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eestatus</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		       <span class="s">&quot;Could not read PCI config space for EEPROM Status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine if the error(s) we care about are present. If they are</span>
<span class="cm">	 * present we need to fail.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eestatus</span> <span class="o">&amp;</span> <span class="mh">0x4C</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">write_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
			<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">eedata</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xFE</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xFF</span> <span class="p">};</span>

			<span class="cm">/* Re-write the first 4 bytes if we have an eeprom</span>
<span class="cm">			 * present and the revision id is 1, this fixes the</span>
<span class="cm">			 * corruption seen with 1310 B Silicon</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">eeprom_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">eedata</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">write_failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span>  <span class="o">!=</span> <span class="mh">0x01</span> <span class="o">||</span> <span class="n">write_failed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;Fatal EEPROM Status Error - 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eestatus</span><span class="p">);</span>

			<span class="cm">/* This error could mean that there was an error</span>
<span class="cm">			 * reading the eeprom or that the eeprom doesn&#39;t exist.</span>
<span class="cm">			 * We will treat each case the same and not try to</span>
<span class="cm">			 * gather additional information that normally would</span>
<span class="cm">			 * come from the eeprom, like MAC Address</span>
<span class="cm">			 */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_eeprom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_eeprom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Read the EEPROM for information regarding LED behavior. Refer to</span>
<span class="cm">	 * ET1310_phy.c, et131x_xcvr_init(), for its use.</span>
<span class="cm">	 */</span>
	<span class="n">eeprom_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">eeprom_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mh">0x71</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xcd</span><span class="p">)</span>
		<span class="cm">/* Disable all optional features */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_rx_dma_enable - re-start of Rx_DMA on the ET1310.</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_rx_dma_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Setup the receive dma configuration register for normal operation */</span>
	<span class="n">u32</span> <span class="n">csr</span> <span class="o">=</span>  <span class="mh">0x2000</span><span class="p">;</span>	<span class="cm">/* FBR1 enable */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">)</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="mh">0x0800</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">==</span> <span class="mi">8192</span><span class="p">)</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="mh">0x1000</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">==</span> <span class="mi">16384</span><span class="p">)</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="mh">0x1800</span><span class="p">;</span>
<span class="cp">#ifdef USE_FBR0</span>
	<span class="n">csr</span> <span class="o">|=</span> <span class="mh">0x0400</span><span class="p">;</span>		<span class="cm">/* FBR0 enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">==</span> <span class="mi">256</span><span class="p">)</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="mh">0x0100</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">==</span> <span class="mi">512</span><span class="p">)</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="mh">0x0200</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">==</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="mh">0x0300</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>

	<span class="n">csr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="mh">0x00020000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="mh">0x00020000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;RX Dma failed to exit halt state.  CSR 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">csr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_rx_dma_disable - Stop of Rx_DMA on the ET1310</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_rx_dma_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">csr</span><span class="p">;</span>
	<span class="cm">/* Setup the receive dma configuration register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00002001</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
	<span class="n">csr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="mh">0x00020000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Check halt status (bit 17) */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">csr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">csr</span> <span class="o">&amp;</span> <span class="mh">0x00020000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;RX Dma failed to enter halt state. CSR 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">csr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_tx_dma_enable - re-start of Tx_DMA on the ET1310.</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Mainly used after a return to the D0 (full-power) state from a lower state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_tx_dma_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Setup the transmit dma configuration register for normal</span>
<span class="cm">	 * operation</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ET_TXDMA_SNGL_EPKT</span><span class="o">|</span><span class="p">(</span><span class="n">PARM_DMA_CACHE_DEF</span> <span class="o">&lt;&lt;</span> <span class="n">ET_TXDMA_CACHE_SHIFT</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_10bit</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">INDEX10</span><span class="p">(</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">ET_DMA10_WRAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_12bit</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">INDEX12</span><span class="p">(</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">ET_DMA12_WRAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et1310_config_mac_regs1 - Initialize the first part of MAC regs</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_config_mac_regs1</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">macregs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">station1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">station2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipg</span><span class="p">;</span>

	<span class="cm">/* First we need to reset everything.  Write to MAC configuration</span>
<span class="cm">	 * register 1 to perform reset.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xC00F0000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">cfg1</span><span class="p">);</span>

	<span class="cm">/* Next lets configure the MAC Inter-packet gap register */</span>
	<span class="n">ipg</span> <span class="o">=</span> <span class="mh">0x38005860</span><span class="p">;</span>		<span class="cm">/* IPG1 0x38 IPG2 0x58 B2B 0x60 */</span>
	<span class="n">ipg</span> <span class="o">|=</span> <span class="mh">0x50</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>		<span class="cm">/* ifg enforce 0x50 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ipg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">ipg</span><span class="p">);</span>

	<span class="cm">/* Next lets configure the MAC Half Duplex register */</span>
	<span class="cm">/* BEB trunc 0xA, Ex Defer, Rexmit 0xF Coll 0x37 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00A1F037</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">hfdp</span><span class="p">);</span>

	<span class="cm">/* Next lets configure the MAC Interface Control register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">if_ctrl</span><span class="p">);</span>

	<span class="cm">/* Let&#39;s move on to setting up the mii management configuration */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x07</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cfg</span><span class="p">);</span>	<span class="cm">/* Clock reset 0x7 */</span>

	<span class="cm">/* Next lets configure the MAC Station Address register.  These</span>
<span class="cm">	 * values are read from the EEPROM during initialization and stored</span>
<span class="cm">	 * in the adapter structure.  We write what is stored in the adapter</span>
<span class="cm">	 * structure to the MAC Station Address registers high and low.  This</span>
<span class="cm">	 * station address is used for generating and checking pause control</span>
<span class="cm">	 * packets.</span>
<span class="cm">	 */</span>
	<span class="n">station2</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_MAC_STATION_ADDR2_OC2_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_MAC_STATION_ADDR2_OC1_SHIFT</span><span class="p">);</span>
	<span class="n">station1</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_MAC_STATION_ADDR1_OC6_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_MAC_STATION_ADDR1_OC5_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_MAC_STATION_ADDR1_OC4_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">station1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">station_addr_1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">station2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">station_addr_2</span><span class="p">);</span>

	<span class="cm">/* Max ethernet packet in bytes that will be passed by the mac without</span>
<span class="cm">	 * being truncated.  Allow the MAC to pass 4 more than our max packet</span>
<span class="cm">	 * size.  This is 4 for the Ethernet CRC.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Packets larger than (registry_jumbo_packet) that do not contain a</span>
<span class="cm">	 * VLAN ID will be dropped by the Rx function.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">max_fm_len</span><span class="p">);</span>

	<span class="cm">/* clear out MAC config reset */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macregs</span><span class="o">-&gt;</span><span class="n">cfg1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et1310_config_mac_regs2 - Initialize the second part of MAC regs</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_config_mac_regs2</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int32_t</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ifctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctl</span><span class="p">;</span>

	<span class="n">ctl</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txmac</span><span class="p">.</span><span class="n">ctl</span><span class="p">);</span>
	<span class="n">cfg1</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">cfg1</span><span class="p">);</span>
	<span class="n">cfg2</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">cfg2</span><span class="p">);</span>
	<span class="n">ifctrl</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">if_ctrl</span><span class="p">);</span>

	<span class="cm">/* Set up the if mode bits */</span>
	<span class="n">cfg2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x300</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg2</span> <span class="o">|=</span> <span class="mh">0x200</span><span class="p">;</span>
		<span class="cm">/* Phy mode bit */</span>
		<span class="n">ifctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cfg2</span> <span class="o">|=</span> <span class="mh">0x100</span><span class="p">;</span>
		<span class="n">ifctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We need to enable Rx/Tx */</span>
	<span class="n">cfg1</span> <span class="o">|=</span> <span class="n">CFG1_RX_ENABLE</span> <span class="o">|</span> <span class="n">CFG1_TX_ENABLE</span> <span class="o">|</span> <span class="n">CFG1_TX_FLOW</span><span class="p">;</span>
	<span class="cm">/* Initialize loop back to off */</span>
	<span class="n">cfg1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CFG1_LOOPBACK</span> <span class="o">|</span> <span class="n">CFG1_RX_FLOW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_RXONLY</span> <span class="o">||</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_BOTH</span><span class="p">)</span>
		<span class="n">cfg1</span> <span class="o">|=</span> <span class="n">CFG1_RX_FLOW</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cfg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">cfg1</span><span class="p">);</span>

	<span class="cm">/* Now we need to initialize the MAC Configuration 2 register */</span>
	<span class="cm">/* preamble 7, check length, huge frame off, pad crc, crc enable</span>
<span class="cm">	   full duplex off */</span>
	<span class="n">cfg2</span> <span class="o">|=</span> <span class="mh">0x7016</span><span class="p">;</span>
	<span class="n">cfg2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x0021</span><span class="p">;</span>

	<span class="cm">/* Turn on duplex if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
		<span class="n">cfg2</span> <span class="o">|=</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="n">ifctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_HALF</span><span class="p">)</span>
		<span class="n">ifctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">);</span>	<span class="cm">/* Enable ghd */</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">ifctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">if_ctrl</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cfg2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">cfg2</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">delay</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cfg1</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">cfg1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">cfg1</span> <span class="o">&amp;</span> <span class="n">CFG1_WAIT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CFG1_WAIT</span> <span class="o">&amp;&amp;</span> <span class="n">delay</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		    <span class="s">&quot;Syncd bits did not respond correctly cfg1 word 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cfg1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable txmac */</span>
	<span class="n">ctl</span> <span class="o">|=</span> <span class="mh">0x09</span><span class="p">;</span>	<span class="cm">/* TX mac enable, FC disable */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ctl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txmac</span><span class="p">.</span><span class="n">ctl</span><span class="p">);</span>

	<span class="cm">/* Ready to start the RXDMA/TXDMA engine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_ADAPTER_LOWER_POWER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">et131x_rx_dma_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">et131x_tx_dma_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et1310_in_phy_coma - check if the device is in phy coma</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the device is not in phy coma, 1 if it is in phy coma</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et1310_in_phy_coma</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pmcsr</span><span class="p">;</span>

	<span class="n">pmcsr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ET_PM_PHY_SW_COMA</span> <span class="o">&amp;</span> <span class="n">pmcsr</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_setup_device_for_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxmac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rxmac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pm_csr</span><span class="p">;</span>

	<span class="cm">/* If ET131X_PACKET_TYPE_MULTICAST is specified, then we provision</span>
<span class="cm">	 * the multi-cast LIST.  If it is NOT specified, (and &quot;ALL&quot; is not</span>
<span class="cm">	 * specified) then we should pass NO multi-cast addresses to the</span>
<span class="cm">	 * driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;</span> <span class="n">ET131X_PACKET_TYPE_MULTICAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* Loop through our multicast array and set up the device */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_addr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">result</span><span class="p">;</span>

			<span class="n">result</span> <span class="o">=</span> <span class="n">ether_crc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0x3F800000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">23</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hash1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="mi">31</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">-=</span> <span class="mi">32</span><span class="p">;</span>
				<span class="n">hash2</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="mi">63</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">96</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">-=</span> <span class="mi">64</span><span class="p">;</span>
				<span class="n">hash3</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">-=</span> <span class="mi">96</span><span class="p">;</span>
				<span class="n">hash4</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Write out the new hash to the device */</span>
	<span class="n">pm_csr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">et1310_in_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hash1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">multi_hash1</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hash2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">multi_hash2</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hash3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">multi_hash3</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hash4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">multi_hash4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_setup_device_for_unicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxmac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rxmac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uni_pf1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uni_pf2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uni_pf3</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pm_csr</span><span class="p">;</span>

	<span class="cm">/* Set up unicast packet filter reg 3 to be the first two octets of</span>
<span class="cm">	 * the MAC address for both address</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set up unicast packet filter reg 2 to be the octets 2 - 5 of the</span>
<span class="cm">	 * MAC address for second address</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set up unicast packet filter reg 3 to be the octets 2 - 5 of the</span>
<span class="cm">	 * MAC address for first address</span>
<span class="cm">	 */</span>
	<span class="n">uni_pf3</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR2_1_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR2_2_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR1_1_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">uni_pf2</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR2_3_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR2_4_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR2_5_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="n">uni_pf1</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR1_3_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR1_4_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_UNI_PF_ADDR1_5_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="n">pm_csr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">et1310_in_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">uni_pf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">uni_pf_addr1</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">uni_pf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">uni_pf_addr2</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">uni_pf3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">uni_pf_addr3</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_config_rxmac_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxmac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rxmac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sa_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sa_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pf_ctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable the MAC while it is being configured (also disable WOL) */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="cm">/* Initialize WOL to disabled. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">crc0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">crc12</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">crc34</span><span class="p">);</span>

	<span class="cm">/* We need to set the WOL mask0 - mask4 next.  We initialize it to</span>
<span class="cm">	 * its default Values of 0x00000000 because there are not WOL masks</span>
<span class="cm">	 * as of this time.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask0_word0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask0_word1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask0_word2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask0_word3</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask1_word0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask1_word1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask1_word2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask1_word3</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask2_word0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask2_word1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask2_word2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask2_word3</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask3_word0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask3_word1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask3_word2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask3_word3</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask4_word0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask4_word1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask4_word2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mask4_word3</span><span class="p">);</span>

	<span class="cm">/* Lets setup the WOL Source Address */</span>
	<span class="n">sa_lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_WOL_LO_SA3_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_WOL_LO_SA4_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_WOL_LO_SA5_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">sa_lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">sa_lo</span><span class="p">);</span>

	<span class="n">sa_hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ET_WOL_HI_SA1_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">sa_hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">sa_hi</span><span class="p">);</span>

	<span class="cm">/* Disable all Packet Filtering */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">pf_ctrl</span><span class="p">);</span>

	<span class="cm">/* Let&#39;s initialize the Unicast Packet filtering address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;</span> <span class="n">ET131X_PACKET_TYPE_DIRECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">et1310_setup_device_for_unicast</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">pf_ctrl</span> <span class="o">|=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Unicast filter */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">uni_pf_addr1</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">uni_pf_addr2</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">uni_pf_addr3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Let&#39;s initialize the Multicast hash */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;</span> <span class="n">ET131X_PACKET_TYPE_ALL_MULTICAST</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pf_ctrl</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Multicast filter */</span>
		<span class="n">et1310_setup_device_for_multicast</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Runt packet filtering.  Didn&#39;t work in version A silicon. */</span>
	<span class="n">pf_ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NIC_MIN_PACKET_SIZE</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">pf_ctrl</span> <span class="o">|=</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* Fragment filter */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">)</span>
		<span class="cm">/* In order to transmit jumbo packets greater than 8k, the</span>
<span class="cm">		 * FIFO between RxMAC and RxDMA needs to be reduced in size</span>
<span class="cm">		 * to (16k - Jumbo packet size).  In order to implement this,</span>
<span class="cm">		 * we must use &quot;cut through&quot; mode in the RxMAC, which chops</span>
<span class="cm">		 * packets down into segments which are (max_size * 16).  In</span>
<span class="cm">		 * this case we selected 256 bytes, since this is the size of</span>
<span class="cm">		 * the PCI-Express TLP&#39;s that the 1310 uses.</span>
<span class="cm">		 *</span>
<span class="cm">		 * seg_en on, fc_en off, size 0x10</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x41</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mcif_ctrl_max_seg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mcif_ctrl_max_seg</span><span class="p">);</span>

	<span class="cm">/* Initialize the MCIF water marks */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mcif_water_mark</span><span class="p">);</span>

	<span class="cm">/*  Initialize the MIF control */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mif_ctrl</span><span class="p">);</span>

	<span class="cm">/* Initialize the Space Available Register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">space_avail</span><span class="p">);</span>

	<span class="cm">/* Initialize the the mif_ctrl register</span>
<span class="cm">	 * bit 3:  Receive code error. One or more nibbles were signaled as</span>
<span class="cm">	 *	   errors  during the reception of the packet.  Clear this</span>
<span class="cm">	 *	   bit in Gigabit, set it in 100Mbit.  This was derived</span>
<span class="cm">	 *	   experimentally at UNH.</span>
<span class="cm">	 * bit 4:  Receive CRC error. The packet&#39;s CRC did not match the</span>
<span class="cm">	 *	   internally generated CRC.</span>
<span class="cm">	 * bit 5:  Receive length check error. Indicates that frame length</span>
<span class="cm">	 *	   field value in the packet does not match the actual data</span>
<span class="cm">	 *	   byte length and is not a type field.</span>
<span class="cm">	 * bit 16: Receive frame truncated.</span>
<span class="cm">	 * bit 17: Drop packet enable</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_100</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x30038</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mif_ctrl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x30030</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">mif_ctrl</span><span class="p">);</span>

	<span class="cm">/* Finally we initialize RxMac to be enabled &amp; WOL disabled.  Packet</span>
<span class="cm">	 * filter is always enabled since it is where the runt packets are</span>
<span class="cm">	 * supposed to be dropped.  For version A silicon, runt packet</span>
<span class="cm">	 * dropping doesn&#39;t work, so it is disabled in the pf_ctrl register,</span>
<span class="cm">	 * but we still leave the packet filter on.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pf_ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">pf_ctrl</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxmac</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_config_txmac_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">txmac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">txmac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txmac</span><span class="p">;</span>

	<span class="cm">/* We need to update the Control Frame Parameters</span>
<span class="cm">	 * cfpt - control frame pause timer set to 64 (0x40)</span>
<span class="cm">	 * cfep - control frame extended pause timer set to 0x0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_NONE</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txmac</span><span class="o">-&gt;</span><span class="n">cf_param</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txmac</span><span class="o">-&gt;</span><span class="n">cf_param</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_config_macstat_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macstat_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">macstat</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">macstat</span><span class="p">;</span>

	<span class="cm">/* Next we need to initialize all the macstat registers to zero on</span>
<span class="cm">	 * the device.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">txrx_0_64_byte_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">txrx_65_127_byte_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">txrx_128_255_byte_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">txrx_256_511_byte_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">txrx_512_1023_byte_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">txrx_1024_1518_byte_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">txrx_1519_1522_gvln_frames</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_bytes</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_fcs_errs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_multicast_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_broadcast_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_control_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_pause_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_unknown_opcodes</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_align_errs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_frame_len_errs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_code_errs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_carrier_sense_errs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_undersize_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_oversize_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_fragment_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_jabbers</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_drops</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_bytes</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_multicast_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_broadcast_packets</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_pause_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_deferred</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_excessive_deferred</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_single_collisions</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_multiple_collisions</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_late_collisions</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_excessive_collisions</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_total_collisions</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_pause_honored_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_drops</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_jabbers</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_fcs_errs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_control_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_oversize_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_undersize_frames</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_fragments</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">carry_reg1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">carry_reg2</span><span class="p">);</span>

	<span class="cm">/* Unmask any counters that we want to track the overflow of.</span>
<span class="cm">	 * Initially this will be all counters.  It may become clear later</span>
<span class="cm">	 * that we do not need to track all counters.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFBE32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">carry_reg1_mask</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFE7E8B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">carry_reg2_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_phy_mii_read - Read from the PHY through the MII Interface on the MAC</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> * @addr: the address of the transceiver</span>
<span class="cm"> * @reg: the register to read</span>
<span class="cm"> * @value: pointer to a 16-bit value in which the value will be stored</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_phy_mii_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">,</span>
	      <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mii_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mii_cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mii_indicator</span><span class="p">;</span>

	<span class="cm">/* Save a local copy of the registers we are dealing with so we can</span>
<span class="cm">	 * set them back</span>
<span class="cm">	 */</span>
	<span class="n">mii_addr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_addr</span><span class="p">);</span>
	<span class="n">mii_cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="cm">/* Stop the current operation */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="cm">/* Set up the register we need to read from on the correct PHY */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">MII_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_addr</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">delay</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mii_indicator</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_indicator</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">mii_indicator</span> <span class="o">&amp;</span> <span class="n">MGMT_WAIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">delay</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">);</span>

	<span class="cm">/* If we hit the max delay, we could not read the register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">==</span> <span class="mi">50</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;reg 0x%08x could not be read</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;status is  0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">mii_indicator</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we hit here we were able to read the register and we need to</span>
<span class="cm">	 * return the value to the caller */</span>
	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_stat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>

	<span class="cm">/* Stop the read operation */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="cm">/* set the registers we touched back to the state at which we entered</span>
<span class="cm">	 * this function</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mii_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_addr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mii_cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_mii_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phydev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">et131x_phy_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_mii_write - Write to a PHY register through the MII interface of the MAC</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> * @reg: the register to read</span>
<span class="cm"> * @value: 16-bit value to write</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: one caller in netdev still</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_mii_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mac_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mii_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mii_cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mii_indicator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phydev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* Save a local copy of the registers we are dealing with so we can</span>
<span class="cm">	 * set them back</span>
<span class="cm">	 */</span>
	<span class="n">mii_addr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_addr</span><span class="p">);</span>
	<span class="n">mii_cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="cm">/* Stop the current operation */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="cm">/* Set up the register we need to write to on the correct PHY */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">MII_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_addr</span><span class="p">);</span>

	<span class="cm">/* Add the value to write to the registers to the mac */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_ctrl</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">delay</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mii_indicator</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_indicator</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">mii_indicator</span> <span class="o">&amp;</span> <span class="n">MGMT_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">delay</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* If we hit the max delay, we could not write the register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		    <span class="s">&quot;reg 0x%08x could not be written&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;status is  0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">mii_indicator</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;command is  0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">));</span>

		<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Stop the write operation */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set the registers we touched back to the state at which we entered</span>
<span class="cm">	 * this function</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mii_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_addr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mii_cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">mii_mgmt_cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Still used from _mac for BIT_READ */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_phy_access_mii_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">action</span><span class="p">,</span> <span class="n">u16</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bitnum</span><span class="p">,</span>
				      <span class="n">u8</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x0001</span> <span class="o">&lt;&lt;</span> <span class="n">bitnum</span><span class="p">;</span>

	<span class="cm">/* Read the requested register */</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRUEPHY_BIT_READ</span>:
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bitnum</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TRUEPHY_BIT_SET</span>:
		<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="n">mask</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TRUEPHY_BIT_CLEAR</span>:
		<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_config_flow_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_HALF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">=</span> <span class="n">FLOW_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">remote_pause</span><span class="p">,</span> <span class="n">remote_async_pause</span><span class="p">;</span>

		<span class="n">et1310_phy_access_mii_bit</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">TRUEPHY_BIT_READ</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remote_pause</span><span class="p">);</span>
		<span class="n">et1310_phy_access_mii_bit</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				<span class="n">TRUEPHY_BIT_READ</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">remote_async_pause</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">remote_pause</span> <span class="o">==</span> <span class="n">TRUEPHY_BIT_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">remote_async_pause</span> <span class="o">==</span> <span class="n">TRUEPHY_BIT_SET</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wanted_flow</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">remote_pause</span> <span class="o">==</span> <span class="n">TRUEPHY_BIT_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">remote_async_pause</span> <span class="o">==</span> <span class="n">TRUEPHY_BIT_CLEAR</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wanted_flow</span> <span class="o">==</span> <span class="n">FLOW_BOTH</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">=</span> <span class="n">FLOW_BOTH</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">=</span> <span class="n">FLOW_NONE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">remote_pause</span> <span class="o">==</span> <span class="n">TRUEPHY_BIT_CLEAR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">remote_async_pause</span> <span class="o">==</span> <span class="n">TRUEPHY_BIT_CLEAR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">=</span> <span class="n">FLOW_NONE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="cm">/* if (remote_pause == TRUEPHY_CLEAR_BIT &amp;&amp;</span>
<span class="cm">			       remote_async_pause == TRUEPHY_SET_BIT) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wanted_flow</span> <span class="o">==</span> <span class="n">FLOW_BOTH</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">=</span> <span class="n">FLOW_RXONLY</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">=</span> <span class="n">FLOW_NONE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et1310_update_macstat_host_counters - Update the local copy of the statistics</span>
<span class="cm"> * @adapter: pointer to the adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_update_macstat_host_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ce_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macstat_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">macstat</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">macstat</span><span class="p">;</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_collisions</span>	       <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_total_collisions</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_first_collisions</span>     <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_single_collisions</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_deferred</span>	       <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_deferred</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_excessive_collisions</span> <span class="o">+=</span>
				<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_multiple_collisions</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_late_collisions</span>      <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_late_collisions</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_underflows</span>	       <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_undersize_frames</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_max_pkt_errs</span>	       <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">tx_oversize_frames</span><span class="p">);</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_align_errs</span>        <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_align_errs</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errs</span>          <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_code_errs</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rcvd_pkts_dropped</span>    <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_drops</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_overflows</span>         <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_oversize_packets</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_code_violations</span>   <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_fcs_errs</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errs</span>       <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_frame_len_errs</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_other_errs</span>        <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macstat</span><span class="o">-&gt;</span><span class="n">rx_fragment_packets</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et1310_handle_macstat_interrupt</span>
<span class="cm"> * @adapter: pointer to the adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * One of the MACSTAT counters has wrapped.  Update the local copy of</span>
<span class="cm"> * the statistics held in the adapter structure, checking the &quot;wrap&quot;</span>
<span class="cm"> * bit for each counter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_handle_macstat_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">carry_reg1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">carry_reg2</span><span class="p">;</span>

	<span class="cm">/* Read the interrupt bits from the register(s).  These are Clear On</span>
<span class="cm">	 * Write.</span>
<span class="cm">	 */</span>
	<span class="n">carry_reg1</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">macstat</span><span class="p">.</span><span class="n">carry_reg1</span><span class="p">);</span>
	<span class="n">carry_reg2</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">macstat</span><span class="p">.</span><span class="n">carry_reg2</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">carry_reg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">macstat</span><span class="p">.</span><span class="n">carry_reg1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">carry_reg2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">macstat</span><span class="p">.</span><span class="n">carry_reg2</span><span class="p">);</span>

	<span class="cm">/* We need to do update the host copy of all the MAC_STAT counters.</span>
<span class="cm">	 * For each counter, check it&#39;s overflow bit.  If the overflow bit is</span>
<span class="cm">	 * set, then increment the host version of the count by one complete</span>
<span class="cm">	 * revolution of the counter.  This routine is called when the counter</span>
<span class="cm">	 * block indicates that one of the counters has wrapped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_code_violations</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_16_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_align_errs</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errs</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_16_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_other_errs</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_16_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errs</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_16_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_overflows</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_16_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rcvd_pkts_dropped</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_16_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_max_pkt_errs</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_underflows</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_first_collisions</span> <span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_deferred</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_excessive_collisions</span> <span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_late_collisions</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_reg2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_collisions</span>	<span class="o">+=</span> <span class="n">COUNTER_WRAP_12_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_mdio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">et131x_phy_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_mdio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_addr</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_mdio_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">BMCR_RESET</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	et1310_phy_power_down	-	PHY power control</span>
<span class="cm"> *	@adapter: device to control</span>
<span class="cm"> *	@down: true for off/false for back on</span>
<span class="cm"> *</span>
<span class="cm"> *	one hundred, ten, one thousand megs</span>
<span class="cm"> *	How would you like to have your LAN accessed</span>
<span class="cm"> *	Can&#39;t you see that this code processed</span>
<span class="cm"> *	Phy power, phy power..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_phy_power_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">bool</span> <span class="n">down</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BMCR_PDOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">down</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">BMCR_PDOWN</span><span class="p">;</span>
	<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_xcvr_init - Init the phy if we are setting it into force mode</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_xcvr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">imr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">isr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">lcr2</span><span class="p">;</span>

	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INTERRUPT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isr</span><span class="p">);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INTERRUPT_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imr</span><span class="p">);</span>

	<span class="cm">/* Set the link status interrupt only.  Bad behavior when link status</span>
<span class="cm">	 * and auto neg are set, we run into a nested interrupt problem</span>
<span class="cm">	 */</span>
	<span class="n">imr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ET_PHY_INT_MASK_AUTONEGSTAT</span> <span class="o">&amp;</span>
		<span class="n">ET_PHY_INT_MASK_LINKSTAT</span> <span class="o">&amp;</span>
		<span class="n">ET_PHY_INT_MASK_ENABLE</span><span class="p">);</span>

	<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INTERRUPT_MASK</span><span class="p">,</span> <span class="n">imr</span><span class="p">);</span>

	<span class="cm">/* Set the LED behavior such that LED 1 indicates speed (off =</span>
<span class="cm">	 * 10Mbits, blink = 100Mbits, on = 1000Mbits) and LED 2 indicates</span>
<span class="cm">	 * link and activity (on for link, blink off for activity).</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: Some customizations have been added here for specific</span>
<span class="cm">	 * vendors; The LED behavior is now determined by vendor data in the</span>
<span class="cm">	 * EEPROM. However, the above description is the default.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_LED_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcr2</span><span class="p">);</span>

		<span class="n">lcr2</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">ET_LED2_LED_100TX</span> <span class="o">&amp;</span> <span class="n">ET_LED2_LED_1000T</span><span class="p">);</span>
		<span class="n">lcr2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">LED_VAL_LINKON_ACTIVE</span> <span class="o">&lt;&lt;</span> <span class="n">LED_LINK_SHIFT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lcr2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">LED_VAL_1000BT_100BTX</span> <span class="o">&lt;&lt;</span> <span class="n">LED_TXRX_SHIFT</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lcr2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">LED_VAL_LINKON</span> <span class="o">&lt;&lt;</span> <span class="n">LED_TXRX_SHIFT</span><span class="p">);</span>

		<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_LED_2</span><span class="p">,</span> <span class="n">lcr2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_configure_global_regs	-	configure JAGCore global regs</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Used to configure the global registers on the JAGCore</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_configure_global_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxq_start_addr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">INTERNAL_MEM_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txq_end_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Tx / RxDMA and Tx/Rx MAC interfaces have a 1k word</span>
<span class="cm">		 * block of RAM that the driver can split between Tx</span>
<span class="cm">		 * and Rx as it desires.  Our default is to split it</span>
<span class="cm">		 * 50/50:</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PARM_RX_MEM_END_DEF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxq_end_addr</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PARM_RX_MEM_END_DEF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txq_start_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">&lt;</span> <span class="mi">8192</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For jumbo packets &gt; 2k but &lt; 8k, split 50-50. */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">INTERNAL_MEM_RX_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxq_end_addr</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">INTERNAL_MEM_RX_OFFSET</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txq_start_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 9216 is the only packet size greater than 8k that</span>
<span class="cm">		 * is available. The Tx buffer has to be big enough</span>
<span class="cm">		 * for one whole packet on the Tx side. We&#39;ll make</span>
<span class="cm">		 * the Tx 9408, and give the rest to Rx</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x01b3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxq_end_addr</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x01b4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txq_start_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the loopback register. Disable all loopbacks. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">loopback</span><span class="p">);</span>

	<span class="cm">/* MSI Register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msi_config</span><span class="p">);</span>

	<span class="cm">/* By default, disable the watchdog timer.  It will be enabled when</span>
<span class="cm">	 * a packet is queued.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_config_rx_dma_regs - Start of Rx_DMA init sequence</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_config_rx_dma_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxdma_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_ring</span> <span class="o">*</span><span class="n">rx_local</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fbr_desc</span> <span class="o">*</span><span class="n">fbr_entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">psr_num_des</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Halt RXDMA to perform the reconfigure.  */</span>
	<span class="n">et131x_rx_dma_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Load the completion writeback physical address</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE : dma_alloc_coherent(), used above to alloc DMA regions,</span>
<span class="cm">	 * ALWAYS returns SAC (32-bit) addresses. If DAC (64-bit) addresses</span>
<span class="cm">	 * are ever returned, make sure the high part is retrieved here</span>
<span class="cm">	 * before storing the adjusted address.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">rx_status_bus</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span>
	       <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">dma_wb_base_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">rx_status_bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">dma_wb_base_lo</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">rx_status_block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_status_block</span><span class="p">));</span>

	<span class="cm">/* Set the address and parameters of the packet status ring into the</span>
<span class="cm">	 * 1310&#39;s registers</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">ps_ring_physaddr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span>
	       <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">psr_base_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">ps_ring_physaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">psr_base_lo</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">psr_num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">psr_num_des</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">psr_full_offset</span><span class="p">);</span>

	<span class="n">psr_num_des</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">psr_num_des</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">psr_num_des</span> <span class="o">*</span> <span class="n">LO_MARK_PERCENT_FOR_PSR</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">psr_min_des</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* These local variables track the PSR in the adapter structure */</span>
	<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Now&#39;s the best time to initialize FBR1 contents */</span>
	<span class="n">fbr_entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fbr_entry</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_high</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="n">fbr_entry</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_low</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="n">fbr_entry</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">fbr_entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the address and parameters of Free buffer ring 1 (and 0 if</span>
<span class="cm">	 * required) into the 1310&#39;s registers</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span>
	       <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr1_base_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr1_base_lo</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr1_num_des</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ET_DMA10_WRAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr1_full_offset</span><span class="p">);</span>

	<span class="cm">/* This variable tracks the free buffer ring 1 full position, so it</span>
<span class="cm">	 * has to match the above.</span>
<span class="cm">	 */</span>
	<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">local_full</span> <span class="o">=</span> <span class="n">ET_DMA10_WRAP</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span>
	   <span class="p">((</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">*</span> <span class="n">LO_MARK_PERCENT_FOR_RX</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	   <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr1_min_des</span><span class="p">);</span>

<span class="cp">#ifdef USE_FBR0</span>
	<span class="cm">/* Now&#39;s the best time to initialize FBR0 contents */</span>
	<span class="n">fbr_entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fbr_entry</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_high</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="n">fbr_entry</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_low</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="n">fbr_entry</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">fbr_entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span>
	       <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr0_base_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr0_base_lo</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr0_num_des</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ET_DMA10_WRAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr0_full_offset</span><span class="p">);</span>

	<span class="cm">/* This variable tracks the free buffer ring 0 full position, so it</span>
<span class="cm">	 * has to match the above.</span>
<span class="cm">	 */</span>
	<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">local_full</span> <span class="o">=</span> <span class="n">ET_DMA10_WRAP</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span>
	   <span class="p">((</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">*</span> <span class="n">LO_MARK_PERCENT_FOR_RX</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	   <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr0_min_des</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Program the number of packets we will receive before generating an</span>
<span class="cm">	 * interrupt.</span>
<span class="cm">	 * For version B silicon, this value gets updated once autoneg is</span>
<span class="cm">	 *complete.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">PARM_RX_NUM_BUFS_DEF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">num_pkt_done</span><span class="p">);</span>

	<span class="cm">/* The &quot;time_done&quot; is not working correctly to coalesce interrupts</span>
<span class="cm">	 * after a given time period, but rather is giving us an interrupt</span>
<span class="cm">	 * regardless of whether we have received packets.</span>
<span class="cm">	 * This value gets updated once autoneg is complete.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">PARM_RX_TIME_INT_DEF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">max_pkt_time</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_config_tx_dma_regs - Set up the tx dma section of the JAGCore.</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the transmit engine with the ring buffers we have created</span>
<span class="cm"> * and prepare it for use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_config_tx_dma_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">txdma_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">txdma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">;</span>

	<span class="cm">/* Load the hardware with the start of the transmit descriptor ring. */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring_pa</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span>
	       <span class="o">&amp;</span><span class="n">txdma</span><span class="o">-&gt;</span><span class="n">pr_base_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring_pa</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">txdma</span><span class="o">-&gt;</span><span class="n">pr_base_lo</span><span class="p">);</span>

	<span class="cm">/* Initialise the transmit DMA engine */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">NUM_DESC_PER_RING_TX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdma</span><span class="o">-&gt;</span><span class="n">pr_num_des</span><span class="p">);</span>

	<span class="cm">/* Load the completion writeback physical address */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)((</span><span class="n">u64</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status_pa</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">txdma</span><span class="o">-&gt;</span><span class="n">dma_wb_base_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status_pa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdma</span><span class="o">-&gt;</span><span class="n">dma_wb_base_lo</span><span class="p">);</span>

	<span class="o">*</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdma</span><span class="o">-&gt;</span><span class="n">service_request</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_adapter_setup - Set the adapter up as per cassini+ documentation</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_adapter_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Configure the JAGCore */</span>
	<span class="n">et131x_configure_global_regs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et1310_config_mac_regs1</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Configure the MMC registers */</span>
	<span class="cm">/* All we need to do is initialize the Memory Control Register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ET_MMC_ENABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mmc</span><span class="p">.</span><span class="n">mmc_ctrl</span><span class="p">);</span>

	<span class="n">et1310_config_rxmac_regs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">et1310_config_txmac_regs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et131x_config_rx_dma_regs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">et131x_config_tx_dma_regs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et1310_config_macstat_regs</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et1310_phy_power_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">et131x_xcvr_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_soft_reset - Issue a soft reset to the hardware, complete for ET1310</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_soft_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable MAC Core */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xc00f0000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">cfg1</span><span class="p">);</span>

	<span class="cm">/* Set everything to a reset value */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x7F</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">sw_reset</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x000f0000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">cfg1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">cfg1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	et131x_enable_interrupts	-	enable interrupt</span>
<span class="cm"> *	@adapter: et131x device</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable the appropriate interrupts on the ET131x according to our</span>
<span class="cm"> *	configuration</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* Enable all global interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_TXONLY</span> <span class="o">||</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_BOTH</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">INT_MASK_ENABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">INT_MASK_ENABLE_NO_FLOW</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">int_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	et131x_disable_interrupts	-	interrupt disable</span>
<span class="cm"> *	@adapter: et131x device</span>
<span class="cm"> *</span>
<span class="cm"> *	Block all interrupts from the et131x device at the device itself</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable all global interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">INT_MASK_DISABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">int_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_tx_dma_disable - Stop of Tx_DMA on the ET1310</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_tx_dma_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Setup the tramsmit dma configuration register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ET_TXDMA_CSR_HALT</span><span class="o">|</span><span class="n">ET_TXDMA_SNGL_EPKT</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_enable_txrx - Enable tx/rx queues</span>
<span class="cm"> * @netdev: device to be enabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_enable_txrx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Enable the Tx and Rx DMA engines (if not already enabled) */</span>
	<span class="n">et131x_rx_dma_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">et131x_tx_dma_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Enable device interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_ADAPTER_INTERRUPT_IN_USE</span><span class="p">)</span>
		<span class="n">et131x_enable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* We&#39;re ready to move some data, so start the queue */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_disable_txrx - Disable tx/rx queues</span>
<span class="cm"> * @netdev: device to be disabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_disable_txrx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* First thing is to stop the queue */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Stop the Tx and Rx DMA engines */</span>
	<span class="n">et131x_rx_dma_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">et131x_tx_dma_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Disable device interrupts */</span>
	<span class="n">et131x_disable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_init_send - Initialize send data structures</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_init_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ct</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>

	<span class="cm">/* Setup some convenience pointers */</span>
	<span class="n">tx_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_ring</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tcb_qhead</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tcb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcb</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_TCB</span><span class="p">);</span>

	<span class="cm">/* Go through and set up each TCB */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ct</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">NUM_TCB</span><span class="p">;</span> <span class="n">tcb</span><span class="o">++</span><span class="p">)</span>
		<span class="cm">/* Set the link pointer in HW TCB to the next TCB in the</span>
<span class="cm">		 * chain</span>
<span class="cm">		 */</span>
		<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tcb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Set the  tail pointer */</span>
	<span class="n">tcb</span><span class="o">--</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tcb_qtail</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>
	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Curr send queue should now be empty */</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">send_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">send_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et1310_enable_phy_coma - called when network cable is unplugged</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * driver receive an phy status change interrupt while in D0 and check that</span>
<span class="cm"> * phy_status is down.</span>
<span class="cm"> *</span>
<span class="cm"> *          -- gate off JAGCore;</span>
<span class="cm"> *          -- set gigE PHY in Coma mode</span>
<span class="cm"> *          -- wake on phy_interrupt; Perform software reset JAGCore,</span>
<span class="cm"> *             re-initialize jagcore and gigE PHY</span>
<span class="cm"> *</span>
<span class="cm"> *      Add D0-ASPM-PhyLinkDown Support:</span>
<span class="cm"> *          -- while in D0, when there is a phy_interrupt indicating phy link</span>
<span class="cm"> *             down status, call the MPSetPhyComa routine to enter this active</span>
<span class="cm"> *             state power saving mode</span>
<span class="cm"> *          -- while in D0-ASPM-PhyLinkDown mode, when there is a phy_interrupt</span>
<span class="cm"> *       indicating linkup status, call the MPDisablePhyComa routine to</span>
<span class="cm"> *             restore JAGCore and gigE PHY</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_enable_phy_coma</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pmcsr</span><span class="p">;</span>

	<span class="n">pmcsr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>

	<span class="cm">/* Save the GbE PHY speed and duplex modes. Need to restore this</span>
<span class="cm">	 * when cable is plugged back in</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * TODO - when PM is re-enabled, check if we need to</span>
<span class="cm">	 * perform a similar task as this -</span>
<span class="cm">	 * adapter-&gt;pdown_speed = adapter-&gt;ai_force_speed;</span>
<span class="cm">	 * adapter-&gt;pdown_duplex = adapter-&gt;ai_force_duplex;</span>
<span class="cm">	 */</span>

	<span class="cm">/* Stop sending packets. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">send_hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">fMP_ADAPTER_LOWER_POWER</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">send_hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Wait for outstanding Receive packets */</span>

	<span class="n">et131x_disable_txrx</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Gate off JAGCore 3 clock domains */</span>
	<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET_PMCSR_INIT</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pmcsr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>

	<span class="cm">/* Program gigE PHY in to Coma mode */</span>
	<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">ET_PM_PHY_SW_COMA</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pmcsr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et1310_disable_phy_coma - Disable the Phy Coma Mode</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et1310_disable_phy_coma</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pmcsr</span><span class="p">;</span>

	<span class="n">pmcsr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>

	<span class="cm">/* Disable phy_sw_coma register and re-enable JAGCore clocks */</span>
	<span class="n">pmcsr</span> <span class="o">|=</span> <span class="n">ET_PMCSR_INIT</span><span class="p">;</span>
	<span class="n">pmcsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET_PM_PHY_SW_COMA</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pmcsr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>

	<span class="cm">/* Restore the GbE PHY speed and duplex modes;</span>
<span class="cm">	 * Reset JAGCore; re-configure and initialize JAGCore and gigE PHY</span>
<span class="cm">	 */</span>
	<span class="cm">/* TODO - when PM is re-enabled, check if we need to</span>
<span class="cm">	 * perform a similar task as this -</span>
<span class="cm">	 * adapter-&gt;ai_force_speed = adapter-&gt;pdown_speed;</span>
<span class="cm">	 * adapter-&gt;ai_force_duplex = adapter-&gt;pdown_duplex;</span>
<span class="cm">	 */</span>

	<span class="cm">/* Re-initialize the send structures */</span>
	<span class="n">et131x_init_send</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Bring the device back to the state it was during init prior to</span>
<span class="cm">	 * autonegotiation being complete.  This way, when we get the auto-neg</span>
<span class="cm">	 * complete interrupt, we can complete init by calling ConfigMacREGS2.</span>
<span class="cm">	 */</span>
	<span class="n">et131x_soft_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* setup et1310 as per the documentation ?? */</span>
	<span class="n">et131x_adapter_setup</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Allow Tx to restart */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">fMP_ADAPTER_LOWER_POWER</span><span class="p">;</span>

	<span class="n">et131x_enable_txrx</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">bump_free_buff_ring</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">free_buff_ring</span><span class="p">,</span> <span class="n">u32</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp_free_buff_ring</span> <span class="o">=</span> <span class="o">*</span><span class="n">free_buff_ring</span><span class="p">;</span>
	<span class="n">tmp_free_buff_ring</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* This works for all cases where limit &lt; 1024. The 1023 case</span>
<span class="cm">	   works because 1023++ is 1024 which means the if condition is not</span>
<span class="cm">	   taken but the carry of the bit into the wrap bit toggles the wrap</span>
<span class="cm">	   value correctly */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tmp_free_buff_ring</span> <span class="o">&amp;</span> <span class="n">ET_DMA10_MASK</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp_free_buff_ring</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET_DMA10_MASK</span><span class="p">;</span>
		<span class="n">tmp_free_buff_ring</span> <span class="o">^=</span> <span class="n">ET_DMA10_WRAP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* For the 1023 case */</span>
	<span class="n">tmp_free_buff_ring</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">ET_DMA10_MASK</span><span class="o">|</span><span class="n">ET_DMA10_WRAP</span><span class="p">);</span>
	<span class="o">*</span><span class="n">free_buff_ring</span> <span class="o">=</span> <span class="n">tmp_free_buff_ring</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tmp_free_buff_ring</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_align_allocated_memory - Align allocated memory on a given boundary</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> * @phys_addr: pointer to Physical address</span>
<span class="cm"> * @offset: pointer to the offset variable</span>
<span class="cm"> * @mask: correct mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_align_allocated_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="o">*</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">new_addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">phys_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_addr</span> <span class="o">!=</span> <span class="o">*</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Move to next aligned block */</span>
		<span class="n">new_addr</span> <span class="o">+=</span> <span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Return offset for adjusting virt addr */</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">new_addr</span> <span class="o">-</span> <span class="o">*</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="cm">/* Return new physical address */</span>
		<span class="o">*</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">new_addr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_rx_dma_memory_alloc</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and errno on failure (as defined in errno.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates Free buffer ring 1 for sure, free buffer ring 0 if required,</span>
<span class="cm"> * and the Packet Status Ring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_rx_dma_memory_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bufsize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pktstat_ringsize</span><span class="p">,</span> <span class="n">fbr_chunksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Setup some convenience pointers */</span>
	<span class="n">rx_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Alloc memory for the lookup table */</span>
<span class="cp">#ifdef USE_FBR0</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fbr_lookup</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fbr_lookup</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/* The first thing we will do is configure the sizes of the buffer</span>
<span class="cm">	 * rings. These will change based on jumbo packet support.  Larger</span>
<span class="cm">	 * jumbo packets increases the size of each entry in FBR0, and the</span>
<span class="cm">	 * number of entries in FBR0, while at the same time decreasing the</span>
<span class="cm">	 * number of entries in FBR1.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FBR1 holds &quot;large&quot; frames, FBR0 holds &quot;small&quot; frames.  If FBR1</span>
<span class="cm">	 * entries are huge in order to accommodate a &quot;jumbo&quot; frame, then it</span>
<span class="cm">	 * will have less entries.  Conversely, FBR1 will now be relied upon</span>
<span class="cm">	 * to carry more &quot;normal&quot; frames, thus it&#39;s entry size also increases</span>
<span class="cm">	 * and the number of entries goes up too (since it now carries</span>
<span class="cm">	 * &quot;small&quot; + &quot;regular&quot; packets.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In this scheme, we try to maintain 512 entries between the two</span>
<span class="cm">	 * rings. Also, FBR1 remains a constant size - when it&#39;s size doubles</span>
<span class="cm">	 * the number of entries halves.  FBR0 increases in size, however.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef USE_FBR0</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef USE_FBR0</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef USE_FBR0</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">768</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef USE_FBR0</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">psr_num_entries</span> <span class="o">=</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">+</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">psr_num_entries</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Allocate an area of memory for Free Buffer Ring 1 */</span>
	<span class="n">bufsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">)</span> <span class="o">+</span>
									<span class="mh">0xfff</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">bufsize</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_physaddr</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Cannot alloc memory for Free Buffer Ring 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save physical address</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: dma_alloc_coherent(), used above to alloc DMA regions,</span>
<span class="cm">	 * ALWAYS returns SAC (32-bit) addresses. If DAC (64-bit) addresses</span>
<span class="cm">	 * are ever returned, make sure the high part is retrieved here</span>
<span class="cm">	 * before storing the adjusted address.</span>
<span class="cm">	 */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_physaddr</span><span class="p">;</span>

	<span class="cm">/* Align Free Buffer Ring 1 on a 4K boundary */</span>
	<span class="n">et131x_align_allocated_memory</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mh">0x0FFF</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">+</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

<span class="cp">#ifdef USE_FBR0</span>
	<span class="cm">/* Allocate an area of memory for Free Buffer Ring 0 */</span>
	<span class="n">bufsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">)</span> <span class="o">+</span>
									<span class="mh">0xfff</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">bufsize</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_physaddr</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Cannot alloc memory for Free Buffer Ring 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save physical address</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: dma_alloc_coherent(), used above to alloc DMA regions,</span>
<span class="cm">	 * ALWAYS returns SAC (32-bit) addresses. If DAC (64-bit) addresses</span>
<span class="cm">	 * are ever returned, make sure the high part is retrieved here before</span>
<span class="cm">	 * storing the adjusted address.</span>
<span class="cm">	 */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_physaddr</span><span class="p">;</span>

	<span class="cm">/* Align Free Buffer Ring 0 on a 4K boundary */</span>
	<span class="n">et131x_align_allocated_memory</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">real_physaddr</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mh">0x0FFF</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">+</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">/</span> <span class="n">FBR_CHUNKS</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">fbr1_tmp_physaddr</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">fbr1_offset</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">fbr1_align</span><span class="p">;</span>

		<span class="cm">/* This code allocates an area of memory big enough for N</span>
<span class="cm">		 * free buffers + (buffer_size - 1) so that the buffers can</span>
<span class="cm">		 * be aligned on 4k boundaries.  If each buffer were aligned</span>
<span class="cm">		 * to a buffer_size boundary, the effect would be to double</span>
<span class="cm">		 * the size of FBR0.  By allocating N buffers at once, we</span>
<span class="cm">		 * reduce this overhead.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">)</span>
			<span class="n">fbr1_align</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fbr1_align</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">;</span>

		<span class="n">fbr_chunksize</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">FBR_CHUNKS</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">)</span> <span class="o">+</span> <span class="n">fbr1_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">fbr_chunksize</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_physaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				       <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Could not alloc memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* See NOTE in &quot;Save Physical Address&quot; comment above */</span>
		<span class="n">fbr1_tmp_physaddr</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_physaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">et131x_align_allocated_memory</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">fbr1_tmp_physaddr</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">fbr1_offset</span><span class="p">,</span> <span class="p">(</span><span class="n">fbr1_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">FBR_CHUNKS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">FBR_CHUNKS</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

			<span class="cm">/* Save the Virtual address of this index for quick</span>
<span class="cm">			 * access later</span>
<span class="cm">			 */</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">)</span> <span class="o">+</span> <span class="n">fbr1_offset</span><span class="p">;</span>

			<span class="cm">/* now store the physical address in the descriptor</span>
<span class="cm">			 * so the device can access it</span>
<span class="cm">			 */</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_high</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">fbr1_tmp_physaddr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_low</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">fbr1_tmp_physaddr</span><span class="p">;</span>

			<span class="n">fbr1_tmp_physaddr</span> <span class="o">+=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">;</span>

			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffer1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffer2</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef USE_FBR0</span>
	<span class="cm">/* Same for FBR0 (if in use) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">/</span> <span class="n">FBR_CHUNKS</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">fbr0_tmp_physaddr</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">fbr0_offset</span><span class="p">;</span>

		<span class="n">fbr_chunksize</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">FBR_CHUNKS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">fbr_chunksize</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_physaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				       <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Could not alloc memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* See NOTE in &quot;Save Physical Address&quot; comment above */</span>
		<span class="n">fbr0_tmp_physaddr</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_physaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">et131x_align_allocated_memory</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">fbr0_tmp_physaddr</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">fbr0_offset</span><span class="p">,</span>
					      <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">FBR_CHUNKS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">FBR_CHUNKS</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">)</span> <span class="o">+</span> <span class="n">fbr0_offset</span><span class="p">;</span>

			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_high</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">fbr0_tmp_physaddr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_low</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">fbr0_tmp_physaddr</span><span class="p">;</span>

			<span class="n">fbr0_tmp_physaddr</span> <span class="o">+=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">;</span>

			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffer1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffer2</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Allocate an area of memory for FIFO of Packet Status ring entries */</span>
	<span class="n">pktstat_ringsize</span> <span class="o">=</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pkt_stat_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">psr_num_entries</span><span class="p">;</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_virtaddr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">pktstat_ringsize</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_physaddr</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_virtaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Cannot alloc memory for Packet Status Ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Packet Status Ring %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_physaddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE : dma_alloc_coherent(), used above to alloc DMA regions,</span>
<span class="cm">	 * ALWAYS returns SAC (32-bit) addresses. If DAC (64-bit) addresses</span>
<span class="cm">	 * are ever returned, make sure the high part is retrieved here before</span>
<span class="cm">	 * storing the adjusted address.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Allocate an area of memory for writeback of status information */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_block</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_status_block</span><span class="p">),</span>
					    <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_bus</span><span class="p">,</span>
					    <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Cannot alloc memory for Status Block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">num_rfd</span> <span class="o">=</span> <span class="n">NIC_DEFAULT_NUM_RFD</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;PRS %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_bus</span><span class="p">);</span>

	<span class="cm">/* Recv</span>
<span class="cm">	 * kmem_cache_create initializes a lookaside list. After successful</span>
<span class="cm">	 * creation, nonpaged fixed-size blocks can be allocated from and</span>
<span class="cm">	 * freed to the lookaside list.</span>
<span class="cm">	 * RFDs will be allocated from this pool.</span>
<span class="cm">	 */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_lookaside</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfd</span><span class="p">),</span>
						   <span class="mi">0</span><span class="p">,</span>
						   <span class="n">SLAB_CACHE_DMA</span> <span class="o">|</span>
						   <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
						   <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">fMP_ADAPTER_RECV_LOOKASIDE</span><span class="p">;</span>

	<span class="cm">/* The RFDs are going to be put on lists later on, so initialize the</span>
<span class="cm">	 * lists now.</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_rx_dma_memory_free - Free all memory allocated within this module.</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_rx_dma_memory_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bufsize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pktstat_ringsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="n">rfd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Setup some convenience pointers */</span>
	<span class="n">rx_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Free RFDs and associated packet descriptors */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">num_ready_recv</span> <span class="o">!=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">num_rfd</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rfd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="p">)</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rfd</span><span class="p">,</span> <span class="n">list_node</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfd</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
		<span class="n">rfd</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">recv_lookaside</span><span class="p">,</span> <span class="n">rfd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free Free Buffer Ring 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First the packet memory */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span>
		     <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">/</span> <span class="n">FBR_CHUNKS</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">fbr1_align</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">)</span>
					<span class="n">fbr1_align</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">fbr1_align</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span><span class="p">;</span>

				<span class="n">bufsize</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">*</span> <span class="n">FBR_CHUNKS</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">fbr1_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

				<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">bufsize</span><span class="p">,</span>
					<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
					<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_physaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

				<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Now the FIFO itself */</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">-</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

		<span class="n">bufsize</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">)</span> <span class="o">+</span>
									<span class="mh">0xfff</span><span class="p">;</span>

		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span>
				    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">,</span>
				    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_physaddr</span><span class="p">);</span>

		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef USE_FBR0</span>
	<span class="cm">/* Now the same for Free Buffer Ring 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First the packet memory */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span>
		     <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">/</span> <span class="n">FBR_CHUNKS</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">bufsize</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffsize</span> <span class="o">*</span>
				     <span class="p">(</span><span class="n">FBR_CHUNKS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

				<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">bufsize</span><span class="p">,</span>
					<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
					<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_physaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

				<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mem_virtaddrs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Now the FIFO itself */</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">-</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

		<span class="n">bufsize</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">)</span> <span class="o">+</span>
									<span class="mh">0xfff</span><span class="p">;</span>

		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">bufsize</span><span class="p">,</span>
				  <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">,</span>
				  <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_physaddr</span><span class="p">);</span>

		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Free Packet Status Ring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_virtaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pktstat_ringsize</span> <span class="o">=</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pkt_stat_desc</span><span class="p">)</span> <span class="o">*</span>
		    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">psr_num_entries</span><span class="p">;</span>

		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pktstat_ringsize</span><span class="p">,</span>
				    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_virtaddr</span><span class="p">,</span>
				    <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_physaddr</span><span class="p">);</span>

		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ps_ring_virtaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free area of memory for the writeback of status information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rx_status_block</span><span class="p">),</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_block</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_bus</span><span class="p">);</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_status_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Destroy the lookaside (RFD) pool */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_ADAPTER_RECV_LOOKASIDE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_lookaside</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">fMP_ADAPTER_RECV_LOOKASIDE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free the FBR Lookup Table */</span>
<span class="cp">#ifdef USE_FBR0</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* Reset Counters */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">num_ready_recv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_init_recv - Initialize receive data structures.</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_init_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="n">rfd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rfdct</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">numrfd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Setup some convenience pointers */</span>
	<span class="n">rx_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Setup each RFD */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rfdct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rfdct</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">num_rfd</span><span class="p">;</span> <span class="n">rfdct</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfd</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_lookaside</span><span class="p">,</span>
						     <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				  <span class="s">&quot;Couldn&#39;t alloc RFD out of kmem_cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rfd</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Add this RFD to the recv_list */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfd</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_list</span><span class="p">);</span>

		<span class="cm">/* Increment both the available RFD&#39;s, and the total RFD&#39;s. */</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">num_ready_recv</span><span class="o">++</span><span class="p">;</span>
		<span class="n">numrfd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numrfd</span> <span class="o">&gt;</span> <span class="n">NIC_MIN_NUM_RFD</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">num_rfd</span> <span class="o">=</span> <span class="n">numrfd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">recv_lookaside</span><span class="p">,</span> <span class="n">rfd</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Allocation problems in et131x_init_recv</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_set_rx_dma_timer - Set the heartbeat timer according to line rate.</span>
<span class="cm"> * @adapter: pointer to our adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_set_rx_dma_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phydev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* For version B silicon, we do not use the RxDMA timer for 10 and 100</span>
<span class="cm">	 * Mbits/s line rates. We do not enable and RxDMA interrupt coalescing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_100</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_10</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">max_pkt_time</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">num_pkt_done</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * NICReturnRFD - Recycle a RFD and put it back onto the receive list</span>
<span class="cm"> * @adapter: pointer to our adapter</span>
<span class="cm"> * @rfd: pointer to the RFD</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nic_return_rfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="n">rfd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rx_ring</span> <span class="o">*</span><span class="n">rx_local</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rxdma_regs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">buff_index</span> <span class="o">=</span> <span class="n">rfd</span><span class="o">-&gt;</span><span class="n">bufferindex</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ring_index</span> <span class="o">=</span> <span class="n">rfd</span><span class="o">-&gt;</span><span class="n">ringindex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t use any of the OOB data besides status. Otherwise, we</span>
<span class="cm">	 * need to clean up OOB data</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span>
<span class="cp">#ifdef USE_FBR0</span>
	    <span class="p">(</span><span class="n">ring_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">buff_index</span> <span class="o">&lt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">)</span> <span class="o">||</span>
<span class="cp">#endif</span>
	    <span class="p">(</span><span class="n">ring_index</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">buff_index</span> <span class="o">&lt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fbr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ring_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fbr_desc</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span> <span class="o">*</span><span class="p">)</span>
					<span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">INDEX10</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">local_full</span><span class="p">);</span>

			<span class="cm">/* Handle the Free Buffer Ring advancement here. Write</span>
<span class="cm">			 * the PA / Buffer Index for the returned buffer into</span>
<span class="cm">			 * the oldest (next to be freed)FBR entry</span>
<span class="cm">			 */</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_high</span><span class="p">[</span><span class="n">buff_index</span><span class="p">];</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_low</span><span class="p">[</span><span class="n">buff_index</span><span class="p">];</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">buff_index</span><span class="p">;</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">bump_free_buff_ring</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">local_full</span><span class="p">,</span>
					<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr1_full_offset</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#ifdef USE_FBR0</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fbr_desc</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fbr_desc</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ring_virtaddr</span> <span class="o">+</span>
				    <span class="n">INDEX10</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">local_full</span><span class="p">);</span>

			<span class="cm">/* Handle the Free Buffer Ring advancement here. Write</span>
<span class="cm">			 * the PA / Buffer Index for the returned buffer into</span>
<span class="cm">			 * the oldest (next to be freed) FBR entry</span>
<span class="cm">			 */</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_high</span><span class="p">[</span><span class="n">buff_index</span><span class="p">];</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus_low</span><span class="p">[</span><span class="n">buff_index</span><span class="p">];</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">buff_index</span><span class="p">;</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">bump_free_buff_ring</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">local_full</span><span class="p">,</span>
					<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
			       <span class="o">&amp;</span><span class="n">rx_dma</span><span class="o">-&gt;</span><span class="n">fbr0_full_offset</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fbr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;%s illegal Buffer Index returned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The processing on this RFD is done, so put it back on the tail of</span>
<span class="cm">	 * our list</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfd</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">recv_list</span><span class="p">);</span>
	<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">num_ready_recv</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">num_ready_recv</span> <span class="o">&gt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">num_rfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nic_rx_pkts - Checks the hardware for available packets</span>
<span class="cm"> * @adapter: pointer to our adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Returns rfd, a pointer to our MPRFD.</span>
<span class="cm"> *</span>
<span class="cm"> * Checks the hardware for available packets, using completion ring</span>
<span class="cm"> * If packets are available, it gets an RFD from the recv_list, attaches</span>
<span class="cm"> * the packet to it, puts the RFD in the RecvPendList, and also returns</span>
<span class="cm"> * the pointer to the RFD.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="nf">nic_rx_pkts</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rx_ring</span> <span class="o">*</span><span class="n">rx_local</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rx_status_block</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pkt_stat_desc</span> <span class="o">*</span><span class="n">psr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="n">rfd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ring_index</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">buff_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word1</span><span class="p">;</span>

	<span class="cm">/* RX Status block is written by the DMA engine prior to every</span>
<span class="cm">	 * interrupt. It contains the next to be used entry in the Packet</span>
<span class="cm">	 * Status Ring, and also the two Free Buffer rings.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">rx_status_block</span><span class="p">;</span>
	<span class="n">word1</span> <span class="o">=</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">word1</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* Get the useful bits */</span>

	<span class="cm">/* Check the PSR and wrap bits do not match */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">word1</span> <span class="o">&amp;</span> <span class="mh">0x1FFF</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span> <span class="o">&amp;</span> <span class="mh">0x1FFF</span><span class="p">))</span>
		<span class="cm">/* Looks like this ring is not updated yet */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* The packet status ring indicates that data is available. */</span>
	<span class="n">psr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pkt_stat_desc</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">ps_ring_virtaddr</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">);</span>

	<span class="cm">/* Grab any information that is required once the PSR is</span>
<span class="cm">	 * advanced, since we can no longer rely on the memory being</span>
<span class="cm">	 * accurate</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">psr</span><span class="o">-&gt;</span><span class="n">word1</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="n">ring_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">psr</span><span class="o">-&gt;</span><span class="n">word1</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="n">buff_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">psr</span><span class="o">-&gt;</span><span class="n">word1</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span><span class="p">;</span>
	<span class="n">word0</span> <span class="o">=</span> <span class="n">psr</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">;</span>

	<span class="cm">/* Indicate that we have used this PSR entry. */</span>
	<span class="cm">/* FIXME wrap 12 */</span>
	<span class="n">add_12bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span>
	  <span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">psr_num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear psr full and toggle the wrap bit */</span>
		<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="mh">0xFFF</span><span class="p">;</span>
		<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span> <span class="o">^=</span> <span class="mh">0x1000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_full_offset</span><span class="p">);</span>

<span class="cp">#ifndef USE_FBR0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_index</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef USE_FBR0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_index</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ring_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		<span class="n">buff_index</span> <span class="o">&gt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ring_index</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
		<span class="n">buff_index</span> <span class="o">&gt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring_index</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">buff_index</span> <span class="o">&gt;</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="cm">/* Illegal buffer or ring index cannot be used by S/W*/</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;NICRxPkts PSR Entry %d indicates &quot;</span>
			  <span class="s">&quot;length of %d and/or bad bi(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">local_psr_full</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">,</span>
			  <span class="n">len</span><span class="p">,</span> <span class="n">buff_index</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get and fill the RFD. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rfd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">element</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">recv_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">rfd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="p">)</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfd</span><span class="p">,</span> <span class="n">list_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rfd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfd</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">num_ready_recv</span><span class="o">--</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rfd</span><span class="o">-&gt;</span><span class="n">bufferindex</span> <span class="o">=</span> <span class="n">buff_index</span><span class="p">;</span>
	<span class="n">rfd</span><span class="o">-&gt;</span><span class="n">ringindex</span> <span class="o">=</span> <span class="n">ring_index</span><span class="p">;</span>

	<span class="cm">/* In V1 silicon, there is a bug which screws up filtering of</span>
<span class="cm">	 * runt packets.  Therefore runt packet filtering is disabled</span>
<span class="cm">	 * in the MAC and the packets are dropped here.  They are</span>
<span class="cm">	 * also counted here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">NIC_MIN_PACKET_SIZE</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_other_errs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Determine if this is a multicast packet coming in */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">word0</span> <span class="o">&amp;</span> <span class="n">ALCATEL_MULTICAST_PKT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">word0</span> <span class="o">&amp;</span> <span class="n">ALCATEL_BROADCAST_PKT</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Promiscuous mode and Multicast mode are</span>
<span class="cm">			 * not mutually exclusive as was first</span>
<span class="cm">			 * thought.  I guess Promiscuous is just</span>
<span class="cm">			 * considered a super-set of the other</span>
<span class="cm">			 * filters. Generally filter is 0x2b when in</span>
<span class="cm">			 * promiscuous mode.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;</span>
					<span class="n">ET131X_PACKET_TYPE_MULTICAST</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;</span>
					<span class="n">ET131X_PACKET_TYPE_PROMISCUOUS</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;</span>
					<span class="n">ET131X_PACKET_TYPE_ALL_MULTICAST</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Note - ring_index for fbr[] array is reversed</span>
<span class="cm">				 * 1 for FBR0 etc</span>
<span class="cm">				 */</span>
				<span class="n">buf</span> <span class="o">=</span> <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[(</span><span class="n">ring_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)]</span><span class="o">-&gt;</span>
						<span class="n">virt</span><span class="p">[</span><span class="n">buff_index</span><span class="p">];</span>

				<span class="cm">/* Loop through our list to see if the</span>
<span class="cm">				 * destination address of this packet</span>
<span class="cm">				 * matches one in our list.</span>
<span class="cm">				 */</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_addr_count</span><span class="p">;</span>
				     <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
					    <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
					    <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
					    <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
					    <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
					    <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">])</span> <span class="p">{</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="cm">/* If our index is equal to the number</span>
<span class="cm">				 * of Multicast address we have, then</span>
<span class="cm">				 * this means we did not find this</span>
<span class="cm">				 * packet&#39;s matching address in our</span>
<span class="cm">				 * list.  Set the len to zero,</span>
<span class="cm">				 * so we free our RFD when we return</span>
<span class="cm">				 * from this function.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_addr_count</span><span class="p">)</span>
					<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast_pkts_rcvd</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">word0</span> <span class="o">&amp;</span> <span class="n">ALCATEL_BROADCAST_PKT</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">broadcast_pkts_rcvd</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* Not sure what this counter measures in</span>
<span class="cm">			 * promiscuous mode. Perhaps we should check</span>
<span class="cm">			 * the MAC address to see if it is directed</span>
<span class="cm">			 * to us in promiscuous mode.</span>
<span class="cm">			 */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unicast_pkts_rcvd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*rfd-&gt;len = len - 4; */</span>
		<span class="n">rfd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">rfd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				  <span class="s">&quot;Couldn&#39;t alloc an SKB for Rx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">rfd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note - ring_index for fbr[] array is reversed,</span>
<span class="cm">		 * 1 for FBR0 etc</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rfd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span>
		    <span class="n">rx_local</span><span class="o">-&gt;</span><span class="n">fbr</span><span class="p">[(</span><span class="n">ring_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">[</span><span class="n">buff_index</span><span class="p">],</span>
		    <span class="n">rfd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>

		<span class="n">netif_rx_ni</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rfd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nic_return_rfd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rfd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rfd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_handle_recv_interrupt - Interrupt handler for receive processing</span>
<span class="cm"> * @adapter: pointer to our adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Assumption, Rcv spinlock has been acquired.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_handle_recv_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfd</span> <span class="o">*</span><span class="n">rfd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Process up to available RFD&#39;s */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">NUM_PACKETS_HANDLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">recv_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">num_ready_recv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rfd</span> <span class="o">=</span> <span class="n">nic_rx_pkts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rfd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Do not receive any packets until a filter has been set.</span>
<span class="cm">		 * Do not receive any packets until we have link.</span>
<span class="cm">		 * If length is zero, return the RFD in order to advance the</span>
<span class="cm">		 * Free buffer ring.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">rfd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Increment the number of packets we received */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Set the status on the packet, either resources or success */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">num_ready_recv</span> <span class="o">&lt;</span> <span class="n">RFD_LOW_WATER_MARK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;RFD&#39;s are running out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">NUM_PACKETS_HANDLED</span> <span class="o">||</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">unfinished_receives</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PARM_TX_TIME_INT_DEF</span> <span class="o">*</span> <span class="n">NANO_IN_A_MICRO</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Watchdog timer will disable itself if appropriate. */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">unfinished_receives</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_tx_dma_memory_alloc</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and errno on failure (as defined in errno.h).</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates memory that will be visible both to the device and to the CPU.</span>
<span class="cm"> * The OS will pass us packets, pointers to which we will insert in the Tx</span>
<span class="cm"> * Descriptor queue. The device will read this queue to find the packets in</span>
<span class="cm"> * memory. The device will update the &quot;status&quot; in memory each time it xmits a</span>
<span class="cm"> * packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_tx_dma_memory_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">desc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for the TCB&#39;s (Transmit Control Block) */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_ring</span> <span class="o">=</span>
		<span class="n">kcalloc</span><span class="p">(</span><span class="n">NUM_TCB</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcb</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot alloc memory for TCBs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate enough memory for the Tx descriptor ring, and allocate</span>
<span class="cm">	 * some extra so that the ring can be aligned on a 4k boundary.</span>
<span class="cm">	 */</span>
	<span class="n">desc_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_DESC_PER_RING_TX</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4096</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_desc_ring</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">desc_size</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_desc_ring_pa</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Cannot alloc memory for Tx Ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save physical address</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: dma_alloc_coherent(), used above to alloc DMA regions,</span>
<span class="cm">	 * ALWAYS returns SAC (32-bit) addresses. If DAC (64-bit) addresses</span>
<span class="cm">	 * are ever returned, make sure the high part is retrieved here before</span>
<span class="cm">	 * storing the adjusted address.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Allocate memory for the Tx status block */</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_status</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
						    <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_status_pa</span><span class="p">,</span>
						    <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status_pa</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				  <span class="s">&quot;Cannot alloc memory for Tx status block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_tx_dma_memory_free - Free all memory allocated within this module</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and errno on failure (as defined in errno.h).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_tx_dma_memory_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">desc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Free memory relating to Tx rings here */</span>
		<span class="n">desc_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_DESC_PER_RING_TX</span><span class="p">)</span>
								<span class="o">+</span> <span class="mi">4096</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="n">desc_size</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring_pa</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free memory for the Tx status block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status_pa</span><span class="p">);</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_status</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Free the memory for the tcb structures */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_ring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nic_send_packet - NIC specific send handler for version B silicon.</span>
<span class="cm"> * @adapter: pointer to our adapter</span>
<span class="cm"> * @tcb: pointer to struct tcb</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nic_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="n">desc</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>	<span class="cm">/* 24 x 16 byte */</span>
	<span class="n">u32</span> <span class="n">frag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">thiscopy</span><span class="p">,</span> <span class="n">remainder</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nr_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frags</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>

	<span class="cm">/* Part of the optimizations of this send routine restrict us to</span>
<span class="cm">	 * sending 24 fragments at a pass.  In practice we should never see</span>
<span class="cm">	 * more than 5 fragments.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: The older version of this function (below) can handle any</span>
<span class="cm">	 * number of fragments. If needed, we can call this function,</span>
<span class="cm">	 * although it is less efficient.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_frags</span> <span class="o">&gt;</span> <span class="mi">23</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If there is something in this element, lets get a</span>
<span class="cm">		 * descriptor from the ring and get the necessary data</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If the fragments are smaller than a standard MTU,</span>
<span class="cm">			 * then map them to a single descriptor in the Tx</span>
<span class="cm">			 * Desc ring. However, if they&#39;re larger, as is</span>
<span class="cm">			 * possible with support for jumbo packets, then</span>
<span class="cm">			 * split them each across 2 descriptors.</span>
<span class="cm">			 *</span>
<span class="cm">			 * This will work until we determine why the hardware</span>
<span class="cm">			 * doesn&#39;t seem to like large fragments.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1514</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/* Low 16bits are length, high is vlan and</span>
<span class="cm">				   unused currently so zero */</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">len_vlan</span> <span class="o">=</span>
					<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>

				<span class="cm">/* NOTE: Here, the dma_addr_t returned from</span>
<span class="cm">				 * dma_map_single() is implicitly cast as a</span>
<span class="cm">				 * u32. Although dma_addr_t can be</span>
<span class="cm">				 * 64-bit, the address returned by</span>
<span class="cm">				 * dma_map_single() is always 32-bit</span>
<span class="cm">				 * addressable (as defined by the pci/dma</span>
<span class="cm">				 * subsystem)</span>
<span class="cm">				 */</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="o">++</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
				    <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
						   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span>
						   <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">len_vlan</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

				<span class="cm">/* NOTE: Here, the dma_addr_t returned from</span>
<span class="cm">				 * dma_map_single() is implicitly cast as a</span>
<span class="cm">				 * u32. Although dma_addr_t can be</span>
<span class="cm">				 * 64-bit, the address returned by</span>
<span class="cm">				 * dma_map_single() is always 32-bit</span>
<span class="cm">				 * addressable (as defined by the pci/dma</span>
<span class="cm">				 * subsystem)</span>
<span class="cm">				 */</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="o">++</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
				    <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						   <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
						     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
						   <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">len_vlan</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

				<span class="cm">/* NOTE: Here, the dma_addr_t returned from</span>
<span class="cm">				 * dma_map_single() is implicitly cast as a</span>
<span class="cm">				 * u32. Although dma_addr_t can be</span>
<span class="cm">				 * 64-bit, the address returned by</span>
<span class="cm">				 * dma_map_single() is always 32-bit</span>
<span class="cm">				 * addressable (as defined by the pci/dma</span>
<span class="cm">				 * subsystem)</span>
<span class="cm">				 */</span>
				<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="o">++</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
				    <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span>
						   <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
						     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
						   <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
						     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
						   <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="p">].</span><span class="n">len_vlan</span> <span class="o">=</span>
					<span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

			<span class="cm">/* NOTE: Here, the dma_addr_t returned from</span>
<span class="cm">			 * dma_map_page() is implicitly cast as a u32.</span>
<span class="cm">			 * Although dma_addr_t can be 64-bit, the address</span>
<span class="cm">			 * returned by dma_map_page() is always 32-bit</span>
<span class="cm">			 * addressable (as defined by the pci/dma subsystem)</span>
<span class="cm">			 */</span>
			<span class="n">desc</span><span class="p">[</span><span class="n">frag</span><span class="o">++</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
							<span class="mi">0</span><span class="p">,</span>
							<span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
							<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">since_irq</span> <span class="o">==</span> <span class="n">PARM_TX_NUM_BUFS_DEF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Last element &amp; Interrupt flag */</span>
			<span class="n">desc</span><span class="p">[</span><span class="n">frag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">since_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* Last element */</span>
			<span class="n">desc</span><span class="p">[</span><span class="n">frag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">desc</span><span class="p">[</span><span class="n">frag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">;</span>

	<span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* First element flag */</span>

	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index_start</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">;</span>
	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">stale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">send_hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">thiscopy</span> <span class="o">=</span> <span class="n">NUM_DESC_PER_RING_TX</span> <span class="o">-</span>
				<span class="n">INDEX10</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thiscopy</span> <span class="o">&gt;=</span> <span class="n">frag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remainder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">thiscopy</span> <span class="o">=</span> <span class="n">frag</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">remainder</span> <span class="o">=</span> <span class="n">frag</span> <span class="o">-</span> <span class="n">thiscopy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span> <span class="o">+</span>
	       <span class="n">INDEX10</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">),</span> <span class="n">desc</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">thiscopy</span><span class="p">);</span>

	<span class="n">add_10bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">,</span> <span class="n">thiscopy</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INDEX10</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		  <span class="n">INDEX10</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">NUM_DESC_PER_RING_TX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET_DMA10_MASK</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span> <span class="o">^=</span> <span class="n">ET_DMA10_WRAP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remainder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span><span class="p">,</span>
		       <span class="n">desc</span> <span class="o">+</span> <span class="n">thiscopy</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">remainder</span><span class="p">);</span>

		<span class="n">add_10bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">,</span> <span class="n">remainder</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INDEX10</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">)</span>
			<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">NUM_DESC_PER_RING_TX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">ET_DMA10_WRAP</span><span class="o">|</span><span class="p">(</span><span class="n">NUM_DESC_PER_RING_TX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_tail</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_tail</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">);</span>

	<span class="cm">/* Write the new write pointer back to the device. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_idx</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">service_request</span><span class="p">);</span>

	<span class="cm">/* For Gig only, we use Tx Interrupt coalescing.  Enable the software</span>
<span class="cm">	 * timer to wake us up if this packet isn&#39;t followed by N more.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PARM_TX_TIME_INT_DEF</span> <span class="o">*</span> <span class="n">NANO_IN_A_MICRO</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">send_hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_packet - Do the work to send a packet</span>
<span class="cm"> * @skb: the packet(s) to send</span>
<span class="cm"> * @adapter: a pointer to the device&#39;s private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 in almost all cases; non-zero value in extreme hard failure only.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumption: Send spinlock has been acquired</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">shbufva</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* All packets must have at least a MAC address and a protocol type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_HLEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Get a TCB for this packet */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qhead</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qhead</span> <span class="o">=</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qhead</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qtail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shbufva</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">shbufva</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">shbufva</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">shbufva</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">fMP_DEST_BROAD</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">shbufva</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span>  <span class="n">fMP_DEST_MULTI</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Call the NIC specific send handler. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">nic_send_packet</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tcb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qtail</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qtail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* Apparently ready Q is empty. */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qhead</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qtail</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span> <span class="o">&gt;</span> <span class="n">NUM_TCB</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_send_packets - This function is called by the OS to send packets</span>
<span class="cm"> * @skb: the packet(s) to send</span>
<span class="cm"> * @netdev:device on which to TX the above packet(s)</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 in almost all cases; non-zero value in extreme hard failure only</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_send_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Send these packets</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: The Linux Tx entry point is only given one packet at a time</span>
<span class="cm">	 * to Tx, so the PacketCount and it&#39;s array used makes no sense here</span>
<span class="cm">	 */</span>

	<span class="cm">/* TCB is not available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span> <span class="o">&gt;=</span> <span class="n">NUM_TCB</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* NOTE: If there&#39;s an error on send, no need to queue the</span>
<span class="cm">		 * packet under Linux; if we just send an error up to the</span>
<span class="cm">		 * netif layer, it will resend the skb to us.</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We need to see if the link is up; if it&#39;s not, make the</span>
<span class="cm">		 * netif layer think we&#39;re good and drop the packet</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_ADAPTER_FAIL_SEND_MASK</span><span class="p">)</span> <span class="o">||</span>
					<span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">send_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* On any other error, make netif think we&#39;re</span>
<span class="cm">				 * OK and drop the packet</span>
<span class="cm">				 */</span>
				<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_send_packet - Recycle a struct tcb</span>
<span class="cm"> * @adapter: pointer to our adapter</span>
<span class="cm"> * @tcb: pointer to struct tcb</span>
<span class="cm"> *</span>
<span class="cm"> * Complete the packet if necessary</span>
<span class="cm"> * Assumption - Send spinlock has been acquired</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_DEST_BROAD</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">broadcast_pkts_xmtd</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_DEST_MULTI</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast_pkts_xmtd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unicast_pkts_xmtd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Iterate through the TX descriptors on the ring</span>
<span class="cm">		 * corresponding to this packet and umap the fragments</span>
<span class="cm">		 * they point to</span>
<span class="cm">		 */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tx_desc</span> <span class="o">*</span><span class="p">)</span>
				    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span> <span class="o">+</span>
						<span class="n">INDEX10</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index_start</span><span class="p">));</span>

			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">desc</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">,</span>
					 <span class="n">desc</span><span class="o">-&gt;</span><span class="n">len_vlan</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

			<span class="n">add_10bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">INDEX10</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index_start</span><span class="p">)</span> <span class="o">&gt;=</span>
							<span class="n">NUM_DESC_PER_RING_TX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index_start</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET_DMA10_MASK</span><span class="p">;</span>
				<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index_start</span> <span class="o">^=</span> <span class="n">ET_DMA10_WRAP</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">desc</span> <span class="o">!=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tx_desc_ring</span> <span class="o">+</span>
				<span class="n">INDEX10</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)));</span>

		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tcb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcb</span><span class="p">));</span>

	<span class="cm">/* Add the TCB to the Ready Q */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qtail</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qtail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* Apparently ready Q is empty. */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qhead</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">tcb_qtail</span> <span class="o">=</span> <span class="n">tcb</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_free_busy_send_packets - Free and complete the stopped active sends</span>
<span class="cm"> * @adapter: pointer to our adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Assumption - Send spinlock has been acquired</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_free_busy_send_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Any packets being sent? Check the first TCB on the send list */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tcb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">freed</span> <span class="o">&lt;</span> <span class="n">NUM_TCB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
		<span class="n">free_send_packet</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tcb</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">freed</span> <span class="o">==</span> <span class="n">NUM_TCB</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_handle_send_interrupt - Interrupt handler for sending processing</span>
<span class="cm"> * @adapter: pointer to our adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Re-claim the send resources, complete sends and get more to send from</span>
<span class="cm"> * the send wait queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumption - Send spinlock has been acquired</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_handle_send_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">serviced</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">serviced</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">new_service_complete</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">INDEX10</span><span class="p">(</span><span class="n">serviced</span><span class="p">);</span>

	<span class="cm">/* Has the ring wrapped?  Process any descriptors that do not have</span>
<span class="cm">	 * the same &quot;wrap&quot; indicator as the current completion indicator</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tcb</span> <span class="o">&amp;&amp;</span>
	       <span class="p">((</span><span class="n">serviced</span> <span class="o">^</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ET_DMA10_WRAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">index</span> <span class="o">&lt;</span> <span class="n">INDEX10</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span> <span class="o">=</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">free_send_packet</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tcb</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Goto the next packet */</span>
		<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tcb</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="p">((</span><span class="n">serviced</span> <span class="o">^</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ET_DMA10_WRAP</span><span class="p">)</span>
	       <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&amp;</span> <span class="n">ET_DMA10_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span> <span class="o">=</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">free_send_packet</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tcb</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Goto the next packet */</span>
		<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wake up the queue when we hit a low-water mark */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span> <span class="o">&lt;=</span> <span class="n">NUM_TCB</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">phy_ethtool_gset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">phy_ethtool_sset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define ET131X_REGS_LEN 256</span>
	<span class="k">return</span> <span class="n">ET131X_REGS_LEN</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">regs_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">address_map</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">aregs</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">regs_buff</span> <span class="o">=</span> <span class="n">regs_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">regs_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">et131x_get_regs_len</span><span class="p">(</span><span class="n">netdev</span><span class="p">));</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="cm">/* PHY regs */</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_PHYSID1</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_PHYSID2</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_LPA</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_EXPANSION</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="cm">/* Autoneg next page transmit reg */</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="cm">/* Link partner next page reg */</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_CTRL1000</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_STAT1000</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">MII_ESTATUS</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INDEX_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_DATA_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_MPHY_CONTROL_REG</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_LOOPBACK_CONTROL</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_LOOPBACK_CONTROL</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_REGISTER_MGMT_CONTROL</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_CONFIG</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_PHY_CONTROL</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INTERRUPT_MASK</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INTERRUPT_STATUS</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_PHY_STATUS</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_LED_1</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_LED_2</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]);</span>

	<span class="cm">/* Global regs */</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">txq_start_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">txq_end_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">rxq_start_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">rxq_end_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">interrupt_status</span><span class="p">;</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">int_mask</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">int_alias_clr_en</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">int_status_alias</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">sw_reset</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">slv_timer</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">msi_config</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">loopback</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="cm">/* TXDMA regs */</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">pr_base_hi</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">pr_base_lo</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">pr_num_des</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">txq_wr_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">txq_wr_addr_ext</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">txq_rd_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">dma_wb_base_hi</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">dma_wb_base_lo</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">service_request</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">service_complete</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">cache_rd_index</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">cache_wr_index</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">tx_dma_error</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">desc_abort_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">payload_abort_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">writeback_abort_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">desc_timeout_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">payload_timeout_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">writeback_timeout_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">desc_error_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">payload_error_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">writeback_error_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">dropped_tlp_cnt</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">new_service_complete</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">ethernet_packet_cnt</span><span class="p">);</span>

	<span class="cm">/* RXDMA regs */</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">csr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">dma_wb_base_hi</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">dma_wb_base_lo</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">num_pkt_done</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">max_pkt_time</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">rxq_rd_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">rxq_rd_addr_ext</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">rxq_wr_addr</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_base_hi</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_base_lo</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_num_des</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_avail_offset</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_full_offset</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_access_index</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">psr_min_des</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr0_base_lo</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr0_base_hi</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr0_num_des</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr0_avail_offset</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr0_full_offset</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr0_rd_index</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr0_min_des</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr1_base_lo</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr1_base_hi</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr1_num_des</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr1_avail_offset</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr1_full_offset</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr1_rd_index</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aregs</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">.</span><span class="n">fbr1_min_des</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ET131X_DRVINFO_LEN 32 </span><span class="cm">/* value from ethtool.h */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">,</span> <span class="n">ET131X_DRVINFO_LEN</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRIVER_VERSION</span><span class="p">,</span> <span class="n">ET131X_DRVINFO_LEN</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span> <span class="n">ET131X_DRVINFO_LEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">et131x_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_settings</span>	<span class="o">=</span> <span class="n">et131x_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>	<span class="o">=</span> <span class="n">et131x_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>	<span class="o">=</span> <span class="n">et131x_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs_len</span>	<span class="o">=</span> <span class="n">et131x_get_regs_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs</span>	<span class="o">=</span> <span class="n">et131x_get_regs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">ethtool_op_get_link</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_set_ethtool_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SET_ETHTOOL_OPS</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">et131x_ethtool_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_hwaddr_init - set up the MAC Address on the ET1310</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_hwaddr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If have our default mac from init and no mac address from</span>
<span class="cm">	 * EEPROM then we need to generate the last octet and set it on the</span>
<span class="cm">	 * device</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to randomly generate the last octet so we</span>
<span class="cm">		 * decrease our chances of setting the mac address to</span>
<span class="cm">		 * same as another one of our cards in the system</span>
<span class="cm">		 */</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have the default value in the register we are</span>
<span class="cm">		 * working with so we need to copy the current</span>
<span class="cm">		 * address into the permanent address</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We do not have an override address, so set the</span>
<span class="cm">		 * current address to the permanent address and add</span>
<span class="cm">		 * it to the device</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
		       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_pci_init	 - initial PCI setup</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> * @pdev: our PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Perform the initial setup of PCI registers and if possible initialise</span>
<span class="cm"> * the MAC address. At this point the I/O registers have yet to be mapped</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_pci_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">max_payload</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">et131x_init_eeprom</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Missing PCIe capabilities</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Let&#39;s set up the PORT LOGIC Register.  First we need to know what</span>
<span class="cm">	 * the max_payload_size is</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_payload</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		    <span class="s">&quot;Could not read PCI config space for Max Payload Size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Program the Ack/Nak latency and replay timers */</span>
	<span class="n">max_payload</span> <span class="o">&amp;=</span> <span class="mh">0x07</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_payload</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">acknak</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mh">0xD0</span> <span class="p">};</span>
		<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">replay</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x1E0</span><span class="p">,</span> <span class="mh">0x2ED</span> <span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ET1310_PCI_ACK_NACK</span><span class="p">,</span>
					       <span class="n">acknak</span><span class="p">[</span><span class="n">max_payload</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Could not write PCI config space for ACK/NAK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ET1310_PCI_REPLAY</span><span class="p">,</span>
					       <span class="n">replay</span><span class="p">[</span><span class="n">max_payload</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Could not write PCI config space for Replay Timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* l0s and l1 latency timers.  We are using default values.</span>
<span class="cm">	 * Representing 001 for L0s and 010 for L1</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ET1310_PCI_L0L1LATENCY</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		  <span class="s">&quot;Could not write PCI config space for Latency Timers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Change the max read size to 2k */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Could not read PCI config space for Max read size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_EXP_DEVCTL_READRQ</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x04</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">ctl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		      <span class="s">&quot;Could not write PCI config space for Max read size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get MAC address from config space if an eeprom exists, otherwise</span>
<span class="cm">	 * the MAC address there will not be valid</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_eeprom</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">et131x_hwaddr_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ET1310_PCI_MAC_ADDRESS</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not read PCI config space for MAC address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rom_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_error_timer_handler</span>
<span class="cm"> * @data: timer-specific variable; here a pointer to our adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * The routine called when the error timer expires, to track the number of</span>
<span class="cm"> * recurring errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_error_timer_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">et1310_in_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Bring the device immediately out of coma, to</span>
<span class="cm">		 * prevent it from sleeping indefinitely, this</span>
<span class="cm">		 * mechanism could be improved! */</span>
		<span class="n">et1310_disable_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">et1310_update_macstat_host_counters</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">et1310_in_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* NOTE - This was originally a &#39;sync with</span>
<span class="cm">				 *  interrupt&#39;. How to do that under Linux?</span>
<span class="cm">				 */</span>
				<span class="n">et131x_enable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
				<span class="n">et1310_enable_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* This is a periodic timer, so reschedule */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">error_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span>
					  <span class="n">TX_ERROR_PERIOD</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_adapter_memory_alloc</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h).</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate all the memory blocks for send, receive and others.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_adapter_memory_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for the Tx Ring */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">et131x_tx_dma_memory_alloc</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;et131x_tx_dma_memory_alloc FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Receive buffer memory allocation */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">et131x_rx_dma_memory_alloc</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;et131x_rx_dma_memory_alloc FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">et131x_tx_dma_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init receive data structures */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">et131x_init_recv</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;et131x_init_recv FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">et131x_tx_dma_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">et131x_rx_dma_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_adapter_memory_free - Free all memory allocated for use by Tx &amp; Rx</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_adapter_memory_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Free DMA memory */</span>
	<span class="n">et131x_tx_dma_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">et131x_rx_dma_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_adjust_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span>  <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_10</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * NOTE - Is there a way to query this without</span>
<span class="cm">			 * TruePHY?</span>
<span class="cm">			 * &amp;&amp; TRU_QueryCoreType(adapter-&gt;hTruePhy, 0)==</span>
<span class="cm">			 * EMI_TRUEPHY_A13O) {</span>
<span class="cm">			 */</span>
			<span class="n">u16</span> <span class="n">register18</span><span class="p">;</span>

			<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_MPHY_CONTROL_REG</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">register18</span><span class="p">);</span>
			<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_MPHY_CONTROL_REG</span><span class="p">,</span>
					 <span class="n">register18</span> <span class="o">|</span> <span class="mh">0x4</span><span class="p">);</span>
			<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INDEX_REG</span><span class="p">,</span>
					 <span class="n">register18</span> <span class="o">|</span> <span class="mh">0x8402</span><span class="p">);</span>
			<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_DATA_REG</span><span class="p">,</span>
					 <span class="n">register18</span> <span class="o">|</span> <span class="mi">511</span><span class="p">);</span>
			<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_MPHY_CONTROL_REG</span><span class="p">,</span>
					 <span class="n">register18</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">et1310_config_flow_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span> <span class="o">&amp;&amp;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">&gt;</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">reg</span><span class="p">;</span>

			<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_CONFIG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET_PHY_CONFIG_TX_FIFO_DEPTH</span><span class="p">;</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="n">ET_PHY_CONFIG_FIFO_DEPTH_32</span><span class="p">;</span>
			<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_CONFIG</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">et131x_set_rx_dma_timer</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">et1310_config_mac_regs2</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span> <span class="o">&amp;&amp;</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check to see if we are in coma mode and if</span>
<span class="cm">		 * so, disable it because we will not be able</span>
<span class="cm">		 * to read PHY values until we are out.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">et1310_in_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
			<span class="n">et1310_disable_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;Link down - cable problem ?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_10</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* NOTE - Is there a way to query this without</span>
<span class="cm">				 * TruePHY?</span>
<span class="cm">				 * &amp;&amp; TRU_QueryCoreType(adapter-&gt;hTruePhy, 0) ==</span>
<span class="cm">				 * EMI_TRUEPHY_A13O)</span>
<span class="cm">				 */</span>
				<span class="n">u16</span> <span class="n">register18</span><span class="p">;</span>

				<span class="n">et131x_mii_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_MPHY_CONTROL_REG</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">register18</span><span class="p">);</span>
				<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_MPHY_CONTROL_REG</span><span class="p">,</span>
						 <span class="n">register18</span> <span class="o">|</span> <span class="mh">0x4</span><span class="p">);</span>
				<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_INDEX_REG</span><span class="p">,</span>
						 <span class="n">register18</span> <span class="o">|</span> <span class="mh">0x8402</span><span class="p">);</span>
				<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_DATA_REG</span><span class="p">,</span>
						 <span class="n">register18</span> <span class="o">|</span> <span class="mi">511</span><span class="p">);</span>
				<span class="n">et131x_mii_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PHY_MPHY_CONTROL_REG</span><span class="p">,</span>
						 <span class="n">register18</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Free the packets being actively sent &amp; stopped */</span>
			<span class="n">et131x_free_busy_send_packets</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

			<span class="cm">/* Re-initialize the send structures */</span>
			<span class="n">et131x_init_send</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Bring the device back to the state it was during</span>
<span class="cm">			 * init prior to autonegotiation being complete. This</span>
<span class="cm">			 * way, when we get the auto-neg complete interrupt,</span>
<span class="cm">			 * we can complete init by calling config_mac_regs2.</span>
<span class="cm">			 */</span>
			<span class="n">et131x_soft_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

			<span class="cm">/* Setup ET1310 as per the documentation */</span>
			<span class="n">et131x_adapter_setup</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

			<span class="cm">/* perform reset of tx/rx */</span>
			<span class="n">et131x_disable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">et131x_enable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

		<span class="n">phy_print_status</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_mii_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span>  <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">phydev</span> <span class="o">=</span> <span class="n">phy_find_first</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phydev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no PHY found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phydev</span> <span class="o">=</span> <span class="n">phy_connect</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">et131x_adjust_link</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PHY_INTERFACE_MODE_MII</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">phydev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not attach to PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">phydev</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">SUPPORTED_10baseT_Half</span>
				<span class="o">|</span> <span class="n">SUPPORTED_10baseT_Full</span>
				<span class="o">|</span> <span class="n">SUPPORTED_100baseT_Half</span>
				<span class="o">|</span> <span class="n">SUPPORTED_100baseT_Full</span>
				<span class="o">|</span> <span class="n">SUPPORTED_Autoneg</span>
				<span class="o">|</span> <span class="n">SUPPORTED_MII</span>
				<span class="o">|</span> <span class="n">SUPPORTED_TP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">ET131X_PCI_DEVICE_ID_FAST</span><span class="p">)</span>
		<span class="n">phydev</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">|=</span> <span class="n">SUPPORTED_1000baseT_Full</span><span class="p">;</span>

	<span class="n">phydev</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">supported</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span> <span class="o">=</span> <span class="n">phydev</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;attached PHY driver [%s] &quot;</span>
		 <span class="s">&quot;(mii_bus:phy_addr=%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_adapter_init</span>
<span class="cm"> * @adapter: pointer to the private adapter struct</span>
<span class="cm"> * @pdev: pointer to the PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the data structures for the et131x_adapter object and link</span>
<span class="cm"> * them together with the platform provided device structures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="nf">et131x_adapter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">default_mac</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x3d</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">};</span>

	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>

	<span class="cm">/* Allocate private adapter struct and copy in relevant information */</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_dev_get</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>

	<span class="cm">/* Initialize spinlocks here */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_ready_qlock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">send_hw_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rcv_pend_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fbr_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_lock</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">=</span> <span class="mi">1514</span><span class="p">;</span>	<span class="cm">/* 1514-9216 */</span>

	<span class="cm">/* Set the MAC address to a default */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">default_mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">adapter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_pci_remove</span>
<span class="cm"> * @pdev: a pointer to the device&#39;s pci_dev structure</span>
<span class="cm"> *</span>
<span class="cm"> * Registered in the pci_driver structure, this function is called when the</span>
<span class="cm"> * PCI subsystem detects that a PCI device which matches the information</span>
<span class="cm"> * contained in the pci_device_id table has been removed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">et131x_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">phy_disconnect</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>
	<span class="n">mdiobus_unregister</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>

	<span class="n">et131x_adapter_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_up - Bring up a device for use.</span>
<span class="cm"> * @netdev: device to be opened</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">et131x_enable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">phy_start</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_down - Bring down the device</span>
<span class="cm"> * @netdev: device to be brought down</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Save the timestamp for the TX watchdog, prevent a timeout */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">phy_stop</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>
	<span class="n">et131x_disable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">et131x_down</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">et131x_up</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SIMPLE_DEV_PM_OPS</span><span class="p">(</span><span class="n">et131x_pm_ops</span><span class="p">,</span> <span class="n">et131x_suspend</span><span class="p">,</span> <span class="n">et131x_resume</span><span class="p">);</span>
<span class="cp">#define ET131X_PM_OPS (&amp;et131x_pm_ops)</span>
<span class="cp">#else</span>
<span class="cp">#define ET131X_PM_OPS NULL</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_isr - The Interrupt Service Routine for the driver.</span>
<span class="cm"> * @irq: the IRQ on which the interrupt was received.</span>
<span class="cm"> * @dev_id: device-specific info (here a pointer to a net_device struct)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a value indicating if the interrupt was handled.</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">et131x_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">handled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* If the adapter is in low power state, then it should not</span>
<span class="cm">	 * recognize any interrupt</span>
<span class="cm">	 */</span>

	<span class="cm">/* Disable Device Interrupts */</span>
	<span class="n">et131x_disable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Get a copy of the value in the interrupt status register</span>
<span class="cm">	 * so we can process the interrupting section</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">int_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_TXONLY</span> <span class="o">||</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_BOTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INT_MASK_ENABLE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INT_MASK_ENABLE_NO_FLOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure this is our interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">et131x_enable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is our interrupt, so process accordingly */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_WATCHDOG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">stale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">|=</span> <span class="n">ET_INTR_TXDMA_ISR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">.</span><span class="n">unfinished_receives</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">|=</span> <span class="n">ET_INTR_RXDMA_XFR_DONE</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">watchdog_timer</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET_INTR_WATCHDOG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This interrupt has in some way been &quot;handled&quot; by</span>
<span class="cm">		 * the ISR. Either it was a spurious Rx interrupt, or</span>
<span class="cm">		 * it was a Tx interrupt that has been filtered by</span>
<span class="cm">		 * the ISR.</span>
<span class="cm">		 */</span>
		<span class="n">et131x_enable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to save the interrupt status value for use in our</span>
<span class="cm">	 * DPC. We will clear the software copy of that in that</span>
<span class="cm">	 * routine.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">interrupt_status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Schedule the ISR handler as a bottom-half task in the</span>
<span class="cm">	 * kernel&#39;s tq_immediate queue, and mark the queue for</span>
<span class="cm">	 * execution</span>
<span class="cm">	 */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_isr_handler - The ISR handler</span>
<span class="cm"> * @p_adapter, a pointer to the device&#39;s private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * scheduled to run in a deferred context by the ISR. This is where the ISR&#39;s</span>
<span class="cm"> * work actually gets done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_isr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">et131x_adapter</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">interrupt_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_map</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">iomem</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These first two are by far the most common.  Once handled, we clear</span>
<span class="cm">	 * their two bits in the status word.  If the word is now zero, we</span>
<span class="cm">	 * exit.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Handle all the completed Transmit interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_TXDMA_ISR</span><span class="p">)</span>
		<span class="n">et131x_handle_send_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Handle all the completed Receives interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_RXDMA_XFR_DONE</span><span class="p">)</span>
		<span class="n">et131x_handle_recv_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">&amp;=</span> <span class="mh">0xffffffd7</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Handle the TXDMA Error interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_TXDMA_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">txdma_err</span><span class="p">;</span>

			<span class="cm">/* Following read also clears the register (COR) */</span>
			<span class="n">txdma_err</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">.</span><span class="n">tx_dma_error</span><span class="p">);</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;TXDMA_ERR interrupt, error = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">txdma_err</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Handle Free Buffer Ring 0 and 1 Low interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span>
		    <span class="p">(</span><span class="n">ET_INTR_RXDMA_FB_R0_LOW</span> <span class="o">|</span> <span class="n">ET_INTR_RXDMA_FB_R1_LOW</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This indicates the number of unused buffers in</span>
<span class="cm">			 * RXDMA free buffer ring 0 is &lt;= the limit you</span>
<span class="cm">			 * programmed. Free buffer resources need to be</span>
<span class="cm">			 * returned.  Free buffers are consumed as packets</span>
<span class="cm">			 * are passed from the network to the host. The host</span>
<span class="cm">			 * becomes aware of the packets from the contents of</span>
<span class="cm">			 * the packet status ring. This ring is queried when</span>
<span class="cm">			 * the packet done interrupt occurs. Packets are then</span>
<span class="cm">			 * passed to the OS. When the OS is done with the</span>
<span class="cm">			 * packets the resources can be returned to the</span>
<span class="cm">			 * ET1310 for re-use. This interrupt is one method of</span>
<span class="cm">			 * returning resources.</span>
<span class="cm">			 */</span>

			<span class="cm">/* If the user has flow control on, then we will</span>
<span class="cm">			 * send a pause packet, otherwise just exit</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_TXONLY</span> <span class="o">||</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flowcontrol</span> <span class="o">==</span> <span class="n">FLOW_BOTH</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">pm_csr</span><span class="p">;</span>

				<span class="cm">/* Tell the device to send a pause packet via</span>
<span class="cm">				 * the back pressure register (bp req  and</span>
<span class="cm">				 * bp xon/xoff)</span>
<span class="cm">				 */</span>
				<span class="n">pm_csr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">et1310_in_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
					<span class="n">writel</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">txmac</span><span class="p">.</span><span class="n">bp_ctrl</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Handle Packet Status Ring Low Interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_RXDMA_STAT_LOW</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Same idea as with the two Free Buffer Rings.</span>
<span class="cm">			 * Packets going from the network to the host each</span>
<span class="cm">			 * consume a free buffer resource and a packet status</span>
<span class="cm">			 * resource.  These resoures are passed to the OS.</span>
<span class="cm">			 * When the OS is done with the resources, they need</span>
<span class="cm">			 * to be returned to the ET1310. This is one method</span>
<span class="cm">			 * of returning the resources.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>

		<span class="cm">/* Handle RXDMA Error Interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_RXDMA_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The rxdma_error interrupt is sent when a time-out</span>
<span class="cm">			 * on a request issued by the JAGCore has occurred or</span>
<span class="cm">			 * a completion is returned with an un-successful</span>
<span class="cm">			 * status.  In both cases the request is considered</span>
<span class="cm">			 * complete. The JAGCore will automatically re-try the</span>
<span class="cm">			 * request in question. Normally information on events</span>
<span class="cm">			 * like these are sent to the host using the &quot;Advanced</span>
<span class="cm">			 * Error Reporting&quot; capability. This interrupt is</span>
<span class="cm">			 * another way of getting similar information. The</span>
<span class="cm">			 * only thing required is to clear the interrupt by</span>
<span class="cm">			 * reading the ISR in the global resources. The</span>
<span class="cm">			 * JAGCore will do a re-try on the request.  Normally</span>
<span class="cm">			 * you should never see this interrupt. If you start</span>
<span class="cm">			 * to see this interrupt occurring frequently then</span>
<span class="cm">			 * something bad has occurred. A reset might be the</span>
<span class="cm">			 * thing to do.</span>
<span class="cm">			 */</span>
			<span class="cm">/* TRAP();*/</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;RxDMA_ERR interrupt, error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">txmac</span><span class="p">.</span><span class="n">tx_test</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* Handle the Wake on LAN Event */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_WOL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is a secondary interrupt for wake on LAN.</span>
<span class="cm">			 * The driver should never see this, if it does,</span>
<span class="cm">			 * something serious is wrong. We will TRAP the</span>
<span class="cm">			 * message when we are in DBG mode, otherwise we</span>
<span class="cm">			 * will ignore it.</span>
<span class="cm">			 */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WAKE_ON_LAN interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Let&#39;s move on to the TxMac */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_TXMAC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">err</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">txmac</span><span class="p">.</span><span class="n">err</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * When any of the errors occur and TXMAC generates</span>
<span class="cm">			 * an interrupt to report these errors, it usually</span>
<span class="cm">			 * means that TXMAC has detected an error in the data</span>
<span class="cm">			 * stream retrieved from the on-chip Tx Q. All of</span>
<span class="cm">			 * these errors are catastrophic and TXMAC won&#39;t be</span>
<span class="cm">			 * able to recover data when these errors occur.  In</span>
<span class="cm">			 * a nutshell, the whole Tx path will have to be reset</span>
<span class="cm">			 * and re-configured afterwards.</span>
<span class="cm">			 */</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;TXMAC interrupt, error 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">err</span><span class="p">);</span>

			<span class="cm">/* If we are debugging, we want to see this error,</span>
<span class="cm">			 * otherwise we just want the device to be reset and</span>
<span class="cm">			 * continue</span>
<span class="cm">			 */</span>
		<span class="p">}</span>

		<span class="cm">/* Handle RXMAC Interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_RXMAC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * These interrupts are catastrophic to the device,</span>
<span class="cm">			 * what we need to do is disable the interrupts and</span>
<span class="cm">			 * set the flag to cause us to reset so we can solve</span>
<span class="cm">			 * this issue.</span>
<span class="cm">			 */</span>
			<span class="cm">/* MP_SET_FLAG( adapter,</span>
<span class="cm">						fMP_ADAPTER_HARDWARE_ERROR); */</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;RXMAC interrupt, error 0x%08x.  Requesting reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">.</span><span class="n">err_reg</span><span class="p">));</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;Enable 0x%08x, Diag 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">.</span><span class="n">ctrl</span><span class="p">),</span>
				    <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">.</span><span class="n">rxq_diag</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we are debugging, we want to see this error,</span>
<span class="cm">			 * otherwise we just want the device to be reset and</span>
<span class="cm">			 * continue</span>
<span class="cm">			 */</span>
		<span class="p">}</span>

		<span class="cm">/* Handle MAC_STAT Interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_MAC_STAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This means at least one of the un-masked counters</span>
<span class="cm">			 * in the MAC_STAT block has rolled over.  Use this</span>
<span class="cm">			 * to maintain the top, software managed bits of the</span>
<span class="cm">			 * counter(s).</span>
<span class="cm">			 */</span>
			<span class="n">et1310_handle_macstat_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Handle SLV Timeout Interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ET_INTR_SLV_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This means a timeout has occurred on a read or</span>
<span class="cm">			 * write request to one of the JAGCore registers. The</span>
<span class="cm">			 * Global Resources block has terminated the request</span>
<span class="cm">			 * and on a read request, returned a &quot;fake&quot; value.</span>
<span class="cm">			 * The most likely reasons are: Bad Address or the</span>
<span class="cm">			 * addressed module is in a power-down state and</span>
<span class="cm">			 * can&#39;t respond.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">et131x_enable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_stats - Return the current device statistics.</span>
<span class="cm"> * @netdev: device whose stats are being queried</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">et131x_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ce_stats</span> <span class="o">*</span><span class="n">devstat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_length_errs</span> <span class="o">+</span>
			   <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_align_errs</span> <span class="o">+</span>
			   <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_crc_errs</span> <span class="o">+</span>
			   <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_code_violations</span> <span class="o">+</span>
			   <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_other_errs</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">tx_max_pkt_errs</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">multicast_pkts_rcvd</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">collisions</span> <span class="o">=</span> <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">tx_collisions</span><span class="p">;</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_length_errs</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_over_errors</span> <span class="o">=</span> <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_overflows</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">devstat</span><span class="o">-&gt;</span><span class="n">rx_crc_errs</span><span class="p">;</span>

	<span class="cm">/* NOTE: These stats don&#39;t have corresponding values in CE_STATS,</span>
<span class="cm">	 * so we&#39;re going to have to update these directly from within the</span>
<span class="cm">	 * TX/RX code</span>
<span class="cm">	 */</span>
	<span class="cm">/* stats-&gt;rx_bytes            = 20; devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;tx_bytes            = 20;  devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;rx_dropped          = devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;tx_dropped          = devstat-&gt;; */</span>

	<span class="cm">/*  NOTE: Not used, can&#39;t find analogous statistics */</span>
	<span class="cm">/* stats-&gt;rx_frame_errors     = devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;rx_fifo_errors      = devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;rx_missed_errors    = devstat-&gt;; */</span>

	<span class="cm">/* stats-&gt;tx_aborted_errors   = devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;tx_carrier_errors   = devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;tx_fifo_errors      = devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;tx_heartbeat_errors = devstat-&gt;; */</span>
	<span class="cm">/* stats-&gt;tx_window_errors    = devstat-&gt;; */</span>
	<span class="k">return</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_open - Open the device for use.</span>
<span class="cm"> * @netdev: device to be opened</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Start the timer to track NIC errors */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">error_timer</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">error_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">TX_ERROR_PERIOD</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">error_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">et131x_error_timer_handler</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">error_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">error_timer</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">et131x_isr</span><span class="p">,</span>
			     <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not register IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">fMP_ADAPTER_INTERRUPT_IN_USE</span><span class="p">;</span>

	<span class="n">et131x_up</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_close - Close the device</span>
<span class="cm"> * @netdev: device to be closed</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">et131x_down</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">fMP_ADAPTER_INTERRUPT_IN_USE</span><span class="p">;</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Stop the error timer */</span>
	<span class="k">return</span> <span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">error_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_ioctl - The I/O Control handler for the driver</span>
<span class="cm"> * @netdev: device on which the control request is being made</span>
<span class="cm"> * @reqbuf: a pointer to the IOCTL request buffer</span>
<span class="cm"> * @cmd: the IOCTL command code</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">reqbuf</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phy_mii_ioctl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">,</span> <span class="n">reqbuf</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_set_packet_filter - Configures the Rx Packet filtering on the device</span>
<span class="cm"> * @adapter: pointer to our private adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: lot of dups with MAC code</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_set_packet_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pf_ctrl</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">.</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">pf_ctrl</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">.</span><span class="n">pf_ctrl</span><span class="p">);</span>

	<span class="cm">/* Default to disabled packet filtering.  Enable it in the individual</span>
<span class="cm">	 * case statements that require the device to filter something</span>
<span class="cm">	 */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="mh">0x04</span><span class="p">;</span>

	<span class="cm">/* Set us to be in promiscuous mode so we receive everything, this</span>
<span class="cm">	 * is also true when we get a packet filter of 0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">ET131X_PACKET_TYPE_PROMISCUOUS</span><span class="p">)</span> <span class="o">||</span> <span class="n">filter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pf_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span>	<span class="cm">/* Clear filter bits */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set us up with Multicast packet filtering.  Three cases are</span>
<span class="cm">		 * possible - (1) we have a multi-cast list, (2) we receive ALL</span>
<span class="cm">		 * multicast entries or (3) we receive none.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">ET131X_PACKET_TYPE_ALL_MULTICAST</span><span class="p">)</span>
			<span class="n">pf_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Multicast filter bit */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">et1310_setup_device_for_multicast</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="n">pf_ctrl</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x04</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set us up with Unicast packet filtering */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">ET131X_PACKET_TYPE_DIRECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">et1310_setup_device_for_unicast</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="n">pf_ctrl</span> <span class="o">|=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x04</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set us up with Broadcast packet filtering */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">ET131X_PACKET_TYPE_BROADCAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pf_ctrl</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Broadcast filter bit */</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x04</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pf_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Setup the receive mac configuration registers - Packet</span>
<span class="cm">		 * Filter control + the enable / disable for packet filter</span>
<span class="cm">		 * in the control reg.</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">pf_ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">.</span><span class="n">pf_ctrl</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">rxmac</span><span class="p">.</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_multicast - The handler to configure multicasting on the interface</span>
<span class="cm"> * @netdev: a pointer to a net_device struct representing the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">packet_filter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Before we modify the platform-independent filter flags, store them</span>
<span class="cm">	 * locally. This allows us to determine if anything&#39;s changed and if</span>
<span class="cm">	 * we even need to bother the hardware</span>
<span class="cm">	 */</span>
	<span class="n">packet_filter</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span><span class="p">;</span>

	<span class="cm">/* Clear the &#39;multicast&#39; flag locally; because we only have a single</span>
<span class="cm">	 * flag to check multicast, and multiple multicast addresses can be</span>
<span class="cm">	 * set, this is the easiest way to determine if more than one</span>
<span class="cm">	 * multicast address is being set.</span>
<span class="cm">	 */</span>
	<span class="n">packet_filter</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET131X_PACKET_TYPE_MULTICAST</span><span class="p">;</span>

	<span class="cm">/* Check the net_device flags and set the device independent flags</span>
<span class="cm">	 * accordingly</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">|=</span> <span class="n">ET131X_PACKET_TYPE_PROMISCUOUS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET131X_PACKET_TYPE_PROMISCUOUS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">|=</span> <span class="n">ET131X_PACKET_TYPE_ALL_MULTICAST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">NIC_MAX_MCAST_LIST</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">|=</span> <span class="n">ET131X_PACKET_TYPE_ALL_MULTICAST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET131X_PACKET_TYPE_ALL_MULTICAST</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ET131X_PACKET_TYPE_MULTICAST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span> <span class="o">|=</span> <span class="n">ET131X_PACKET_TYPE_MULTICAST</span><span class="p">;</span>

	<span class="cm">/* Set values in the private adapter struct */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NIC_MAX_MCAST_LIST</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_list</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">multicast_addr_count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Are the new flags different from the previous ones? If not, then no</span>
<span class="cm">	 * action is required</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE - This block will always update the multicast_list with the</span>
<span class="cm">	 *        hardware, even if the addresses aren&#39;t the same.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet_filter</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">packet_filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Call the device&#39;s filter function */</span>
		<span class="n">et131x_set_packet_filter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_tx - The handler to tx a packet on the device</span>
<span class="cm"> * @skb: data to be Tx&#39;d</span>
<span class="cm"> * @netdev: device on which data is to be Tx&#39;d</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* stop the queue if it&#39;s getting full */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">used</span> <span class="o">&gt;=</span> <span class="n">NUM_TCB</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Save the timestamp for the TX timeout watchdog */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* Call the device-specific data Tx routine */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">et131x_send_packets</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Check status and manage the netif queue if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_tx_timeout - Timeout handler</span>
<span class="cm"> * @netdev: a pointer to a net_device struct representing the device</span>
<span class="cm"> *</span>
<span class="cm"> * The handler called when a Tx request times out. The timeout period is</span>
<span class="cm"> * specified by the &#39;tx_timeo&quot; element in the net_device structure (see</span>
<span class="cm"> * et131x_alloc_device() to see how this value is set).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">et131x_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* If the device is closed, ignore the timeout */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_ADAPTER_INTERRUPT_IN_USE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Any nonrecoverable hardware error?</span>
<span class="cm">	 * Checks adapter-&gt;flags for any failure in phy reading</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_ADAPTER_NON_RECOVER_ERROR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Hardware failure? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fMP_ADAPTER_HARDWARE_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hardware error - reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is send stuck? */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tcb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">.</span><span class="n">send_head</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">NIC_SEND_HANG_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span>
					       <span class="n">flags</span><span class="p">);</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Send stuck - reset.  tcb-&gt;WrIndex %x, flags 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
				<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* perform reset of tx/rx */</span>
			<span class="n">et131x_disable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">et131x_enable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tcb_send_qlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_change_mtu - The handler called to change the MTU for the device</span>
<span class="cm"> * @netdev: device whose MTU is to be changed</span>
<span class="cm"> * @new_mtu: the desired MTU</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Make sure the requested MTU is valid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">||</span> <span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="mi">9216</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">et131x_disable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">et131x_handle_send_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">et131x_handle_recv_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Set the new MTU */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="cm">/* Free Rx DMA memory */</span>
	<span class="n">et131x_adapter_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Set the config parameter for Jumbo Packet support */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">registry_jumbo_packet</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">et131x_soft_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Alloc and init Rx DMA memory */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">et131x_adapter_memory_alloc</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Change MTU failed; couldn&#39;t re-alloc DMA memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">et131x_init_send</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et131x_hwaddr_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="cm">/* Init the device with the new settings */</span>
	<span class="n">et131x_adapter_setup</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et131x_enable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_set_mac_addr - handler to change the MAC address for the device</span>
<span class="cm"> * @netdev: device whose MAC is to be changed</span>
<span class="cm"> * @new_mac: the desired MAC address</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> *</span>
<span class="cm"> * IMPLEMENTED BY : blux http://berndlux.de 22.01.2007 21:14</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">et131x_set_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">new_mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="n">new_mac</span><span class="p">;</span>

	<span class="cm">/* begin blux */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Make sure the requested MAC is valid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="n">et131x_disable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">et131x_handle_send_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">et131x_handle_recv_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Set the new MAC */</span>
	<span class="cm">/* netdev-&gt;set_mac_address  = &amp;new_mac; */</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">address</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Setting MAC address to %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* Free Rx DMA memory */</span>
	<span class="n">et131x_adapter_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et131x_soft_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Alloc and init Rx DMA memory */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">et131x_adapter_memory_alloc</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Change MAC failed; couldn&#39;t re-alloc DMA memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">et131x_init_send</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et131x_hwaddr_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Init the device with the new settings */</span>
	<span class="n">et131x_adapter_setup</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">et131x_enable_txrx</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">et131x_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">et131x_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">et131x_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">et131x_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">et131x_multicast</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">et131x_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">et131x_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">et131x_set_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">et131x_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">et131x_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_pci_setup - Perform device initialization</span>
<span class="cm"> * @pdev: a pointer to the device&#39;s pci_dev structure</span>
<span class="cm"> * @ent: this device&#39;s entry in the pci_device_id table</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Registered in the pci_driver structure, this function is called when the</span>
<span class="cm"> * PCI subsystem finds a new PCI device which matches the information</span>
<span class="cm"> * contained in the pci_device_id table. This routine is the equivalent to</span>
<span class="cm"> * a device insertion routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">et131x_pci_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">et131x_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_enable_device() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Perform some basic PCI checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t find PCI device&#39;s base address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_disable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get PCI resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_disable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Check the DMA addressing support of this device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Unable to obtain 64 bit DMA for consistent allocations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_release_res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			  <span class="s">&quot;Unable to obtain 32 bit DMA for consistent allocations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_release_res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No usable DMA addressing method</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_release_res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate netdev and private adapter structs */</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">et131x_adapter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t alloc netdev struct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_release_res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">ET131X_TX_TIMEOUT</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">et131x_netdev_ops</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">et131x_set_ethtool_ops</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">et131x_adapter_init</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">et131x_pci_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_dev</span><span class="p">;</span>

	<span class="cm">/* Map the bus-relative registers to system virtual memory */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot map device registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_free_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If Phy COMA mode was enabled when we went down, disable it here. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ET_PMCSR_INIT</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">.</span><span class="n">pm_csr</span><span class="p">);</span>

	<span class="cm">/* Issue a global reset to the et1310 */</span>
	<span class="n">et131x_soft_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Disable all interrupts (paranoid) */</span>
	<span class="n">et131x_disable_interrupts</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Allocate DMA memory */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">et131x_adapter_memory_alloc</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not alloc adapater memory (DMA)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init send data structures */</span>
	<span class="n">et131x_init_send</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Set up the task structure for the ISR&#39;s deferred handler */</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">et131x_isr_handler</span><span class="p">);</span>

	<span class="cm">/* Copy address into the net_device struct */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="cm">/* Init variable for counting how long we do not have link status */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_coma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">et1310_disable_phy_coma</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Setup the mii_bus struct */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span> <span class="o">=</span> <span class="n">mdiobus_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Alloc of mii_bus struct failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_mem_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;et131x_eth_mii&quot;</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">MII_BUS_ID_SIZE</span><span class="p">,</span> <span class="s">&quot;%x&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">et131x_mdio_read</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">et131x_mdio_write</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">=</span> <span class="n">et131x_mdio_reset</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">PHY_MAX_ADDR</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mii_bus irq allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_mdio_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">PHY_MAX_ADDR</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">PHY_POLL</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">mdiobus_register</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to register MII bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_mdio_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">et131x_mii_probe</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to probe MII bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_mdio_unregister</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup et1310 as per the documentation */</span>
	<span class="n">et131x_adapter_setup</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* We can enable interrupts now</span>
<span class="cm">	 *</span>
<span class="cm">	 *  NOTE - Because registration of interrupt handler is done in the</span>
<span class="cm">	 *         device&#39;s open(), defer enabling device interrupts to that</span>
<span class="cm">	 *         point</span>
<span class="cm">	 */</span>

	<span class="cm">/* Register the net_device struct with the Linux network layer */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;register_netdev() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_phy_disconnect</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register the net_device struct with the PCI subsystem. Save a copy</span>
<span class="cm">	 * of the PCI config space for this device now that the device has</span>
<span class="cm">	 * been initialized, just in case it needs to be quickly restored.</span>
<span class="cm">	 */</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">err_phy_disconnect:</span>
	<span class="n">phy_disconnect</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phydev</span><span class="p">);</span>
<span class="nl">err_mdio_unregister:</span>
	<span class="n">mdiobus_unregister</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
<span class="nl">err_mdio_free_irq:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="nl">err_mdio_free:</span>
	<span class="n">mdiobus_free</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mii_bus</span><span class="p">);</span>
<span class="nl">err_mem_free:</span>
	<span class="n">et131x_adapter_memory_free</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">err_free_dev:</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">err_release_res:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_disable:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">et131x_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">ATT</span><span class="p">,</span> <span class="n">ET131X_PCI_DEVICE_ID_GIG</span><span class="p">),</span> <span class="mi">0UL</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">ATT</span><span class="p">,</span> <span class="n">ET131X_PCI_DEVICE_ID_FAST</span><span class="p">),</span> <span class="mi">0UL</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">et131x_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">et131x_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">et131x_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">et131x_pci_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">et131x_pci_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="n">ET131X_PM_OPS</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_init_module - The &quot;main&quot; entry point called on driver initialization</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno on failure (as defined in errno.h)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">et131x_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">et131x_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * et131x_cleanup_module - The entry point called on driver cleanup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">et131x_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">et131x_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">et131x_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">et131x_cleanup_module</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
