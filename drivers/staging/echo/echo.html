<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › staging › echo › echo.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>echo.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SpanDSP - a series of DSP components for telephony</span>
<span class="cm"> *</span>
<span class="cm"> * echo.c - A line echo canceller.  This code is being developed</span>
<span class="cm"> *          against and partially complies with G168.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Steve Underwood &lt;steveu@coppice.org&gt;</span>
<span class="cm"> *         and David Rowe &lt;david_at_rowetel_dot_com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001, 2003 Steve Underwood, 2007 David Rowe</span>
<span class="cm"> *</span>
<span class="cm"> * Based on a bit from here, a bit from there, eye of toad, ear of</span>
<span class="cm"> * bat, 15 years of failed attempts by David and a few fried brain</span>
<span class="cm"> * cells.</span>
<span class="cm"> *</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*! \file */</span>

<span class="cm">/* Implementation Notes</span>
<span class="cm">   David Rowe</span>
<span class="cm">   April 2007</span>

<span class="cm">   This code started life as Steve&#39;s NLMS algorithm with a tap</span>
<span class="cm">   rotation algorithm to handle divergence during double talk.  I</span>
<span class="cm">   added a Geigel Double Talk Detector (DTD) [2] and performed some</span>
<span class="cm">   G168 tests.  However I had trouble meeting the G168 requirements,</span>
<span class="cm">   especially for double talk - there were always cases where my DTD</span>
<span class="cm">   failed, for example where near end speech was under the 6dB</span>
<span class="cm">   threshold required for declaring double talk.</span>

<span class="cm">   So I tried a two path algorithm [1], which has so far given better</span>
<span class="cm">   results.  The original tap rotation/Geigel algorithm is available</span>
<span class="cm">   in SVN http://svn.rowetel.com/software/oslec/tags/before_16bit.</span>
<span class="cm">   It&#39;s probably possible to make it work if some one wants to put some</span>
<span class="cm">   serious work into it.</span>

<span class="cm">   At present no special treatment is provided for tones, which</span>
<span class="cm">   generally cause NLMS algorithms to diverge.  Initial runs of a</span>
<span class="cm">   subset of the G168 tests for tones (e.g ./echo_test 6) show the</span>
<span class="cm">   current algorithm is passing OK, which is kind of surprising.  The</span>
<span class="cm">   full set of tests needs to be performed to confirm this result.</span>

<span class="cm">   One other interesting change is that I have managed to get the NLMS</span>
<span class="cm">   code to work with 16 bit coefficients, rather than the original 32</span>
<span class="cm">   bit coefficents.  This reduces the MIPs and storage required.</span>
<span class="cm">   I evaulated the 16 bit port using g168_tests.sh and listening tests</span>
<span class="cm">   on 4 real-world samples.</span>

<span class="cm">   I also attempted the implementation of a block based NLMS update</span>
<span class="cm">   [2] but although this passes g168_tests.sh it didn&#39;t converge well</span>
<span class="cm">   on the real-world samples.  I have no idea why, perhaps a scaling</span>
<span class="cm">   problem.  The block based code is also available in SVN</span>
<span class="cm">   http://svn.rowetel.com/software/oslec/tags/before_16bit.  If this</span>
<span class="cm">   code can be debugged, it will lead to further reduction in MIPS, as</span>
<span class="cm">   the block update code maps nicely onto DSP instruction sets (it&#39;s a</span>
<span class="cm">   dot product) compared to the current sample-by-sample update.</span>

<span class="cm">   Steve also has some nice notes on echo cancellers in echo.h</span>

<span class="cm">   References:</span>

<span class="cm">   [1] Ochiai, Areseki, and Ogihara, &quot;Echo Canceller with Two Echo</span>
<span class="cm">       Path Models&quot;, IEEE Transactions on communications, COM-25,</span>
<span class="cm">       No. 6, June</span>
<span class="cm">       1977.</span>
<span class="cm">       http://www.rowetel.com/images/echo/dual_path_paper.pdf</span>

<span class="cm">   [2] The classic, very useful paper that tells you how to</span>
<span class="cm">       actually build a real world echo canceller:</span>
<span class="cm">	 Messerschmitt, Hedberg, Cole, Haoui, Winship, &quot;Digital Voice</span>
<span class="cm">	 Echo Canceller with a TMS320020,</span>
<span class="cm">	 http://www.rowetel.com/images/echo/spra129.pdf</span>

<span class="cm">   [3] I have written a series of blog posts on this work, here is</span>
<span class="cm">       Part 1: http://www.rowetel.com/blog/?p=18</span>

<span class="cm">   [4] The source code http://svn.rowetel.com/software/oslec/</span>

<span class="cm">   [5] A nice reference on LMS filters:</span>
<span class="cm">	 http://en.wikipedia.org/wiki/Least_mean_squares_filter</span>

<span class="cm">   Credits:</span>

<span class="cm">   Thanks to Steve Underwood, Jean-Marc Valin, and Ramakrishnan</span>
<span class="cm">   Muthukrishnan for their suggestions and email discussions.  Thanks</span>
<span class="cm">   also to those people who collected echo samples for me such as</span>
<span class="cm">   Mark, Pawel, and Pavel.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;echo.h&quot;</span>

<span class="cp">#define MIN_TX_POWER_FOR_ADAPTION	64</span>
<span class="cp">#define MIN_RX_POWER_FOR_ADAPTION	64</span>
<span class="cp">#define DTD_HANGOVER			600	</span><span class="cm">/* 600 samples, or 75ms     */</span><span class="cp"></span>
<span class="cp">#define DC_LOG2BETA			3	</span><span class="cm">/* log2() of DC filter Beta */</span><span class="cp"></span>

<span class="cm">/* adapting coeffs using the traditional stochastic descent (N)LMS algorithm */</span>

<span class="cp">#ifdef __bfin__</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lms_adapt_bg</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clean</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exp</span><span class="p">;</span>
	<span class="kt">int16_t</span> <span class="o">*</span><span class="n">phist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="n">clean</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="n">clean</span> <span class="o">&gt;&gt;</span> <span class="o">-</span><span class="n">shift</span><span class="p">;</span>

	<span class="cm">/* Update the FIR taps */</span>

	<span class="n">offset2</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">curr_pos</span><span class="p">;</span>
	<span class="n">offset1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">-</span> <span class="n">offset2</span><span class="p">;</span>
	<span class="n">phist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">.</span><span class="n">history</span><span class="p">[</span><span class="n">offset2</span><span class="p">];</span>

	<span class="cm">/* st: and en: help us locate the assembler in echo.s */</span>

	<span class="cm">/* asm(&quot;st:&quot;); */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">offset2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="o">*</span><span class="n">phist</span><span class="o">++</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int16_t</span><span class="p">)</span> <span class="p">((</span><span class="n">exp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* asm(&quot;en:&quot;); */</span>

	<span class="cm">/* Note the asm for the inner loop above generated by Blackfin gcc</span>
<span class="cm">	   4.1.1 is pretty good (note even parallel instructions used):</span>

<span class="cm">	   R0 = W [P0++] (X);</span>
<span class="cm">	   R0 *= R2;</span>
<span class="cm">	   R0 = R0 + R3 (NS) ||</span>
<span class="cm">	   R1 = W [P1] (X) ||</span>
<span class="cm">	   nop;</span>
<span class="cm">	   R0 &gt;&gt;&gt;= 15;</span>
<span class="cm">	   R0 = R0 + R1;</span>
<span class="cm">	   W [P1++] = R0;</span>

<span class="cm">	   A block based update algorithm would be much faster but the</span>
<span class="cm">	   above can&#39;t be improved on much.  Every instruction saved in</span>
<span class="cm">	   the loop above is 2 MIPs/ch!  The for loop above is where the</span>
<span class="cm">	   Blackfin spends most of it&#39;s time - about 17 MIPs/ch measured</span>
<span class="cm">	   with speedtest.c with 256 taps (32ms).  Write-back and</span>
<span class="cm">	   Write-through cache gave about the same performance.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">   IDEAS for further optimisation of lms_adapt_bg():</span>

<span class="cm">   1/ The rounding is quite costly.  Could we keep as 32 bit coeffs</span>
<span class="cm">   then make filter pluck the MS 16-bits of the coeffs when filtering?</span>
<span class="cm">   However this would lower potential optimisation of filter, as I</span>
<span class="cm">   think the dual-MAC architecture requires packed 16 bit coeffs.</span>

<span class="cm">   2/ Block based update would be more efficient, as per comments above,</span>
<span class="cm">   could use dual MAC architecture.</span>

<span class="cm">   3/ Look for same sample Blackfin LMS code, see if we can get dual-MAC</span>
<span class="cm">   packing.</span>

<span class="cm">   4/ Execute the whole e/c in a block of say 20ms rather than sample</span>
<span class="cm">   by sample.  Processing a few samples every ms is inefficient.</span>
<span class="cm">*/</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lms_adapt_bg</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clean</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">offset1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="n">clean</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="n">clean</span> <span class="o">&gt;&gt;</span> <span class="o">-</span><span class="n">shift</span><span class="p">;</span>

	<span class="cm">/* Update the FIR taps */</span>

	<span class="n">offset2</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">curr_pos</span><span class="p">;</span>
	<span class="n">offset1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">-</span> <span class="n">offset2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">offset1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">.</span><span class="n">history</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">offset1</span><span class="p">]</span> <span class="o">*</span> <span class="n">factor</span><span class="p">);</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int16_t</span><span class="p">)</span> <span class="p">((</span><span class="n">exp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">.</span><span class="n">history</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">]</span> <span class="o">*</span> <span class="n">factor</span><span class="p">);</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int16_t</span><span class="p">)</span> <span class="p">((</span><span class="n">exp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">top_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">fls</span><span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span> <span class="n">bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="nf">oslec_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adaption_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ec</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">log2taps</span> <span class="o">=</span> <span class="n">top_bit</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">curr_pos</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">kcalloc</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int16_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">error_oom</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fir16_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">,</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">);</span>
	<span class="n">fir16_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">,</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">xvtx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">yvtx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">xvrx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">yvrx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_level</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">oslec_adaption_mode</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">adaption_mode</span><span class="p">);</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">snapshot</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int16_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">snapshot</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_oom</span><span class="p">;</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">cond_met</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Pstates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltxacc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrxacc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lcleanacc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bgacc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltx</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrx</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_2</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_upper</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_upper_acc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_upper</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ec</span><span class="p">;</span>

<span class="nl">error_oom:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ec</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">oslec_create</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">oslec_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">fir16_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">);</span>
	<span class="n">fir16_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">snapshot</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ec</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">oslec_free</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">oslec_adaption_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adaption_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">=</span> <span class="n">adaption_mode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">oslec_adaption_mode</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">oslec_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltxacc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrxacc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lcleanacc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bgacc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltx</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrx</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_2</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_upper</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_upper_acc</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_upper</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">;</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">nonupdate_dwell</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fir16_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">);</span>
	<span class="n">fir16_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">);</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">.</span><span class="n">curr_pos</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">.</span><span class="n">curr_pos</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int16_t</span><span class="p">));</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">curr_pos</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Pstates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">oslec_flush</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">oslec_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int16_t</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">oslec_snapshot</span><span class="p">);</span>

<span class="cm">/* Dual Path Echo Canceller */</span>

<span class="kt">int16_t</span> <span class="nf">oslec_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">tx</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">rx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int32_t</span> <span class="n">echo_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">clean_bg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Input scaling was found be required to prevent problems when tx</span>
<span class="cm">	 * starts clipping.  Another possible way to handle this would be the</span>
<span class="cm">	 * filter coefficent scaling.</span>
<span class="cm">	 */</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span><span class="p">;</span>
	<span class="n">tx</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rx</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Filter DC, 3dB point is 160Hz (I think), note 32 bit precision</span>
<span class="cm">	 * required otherwise values do not track down to 0. Zero at DC, Pole</span>
<span class="cm">	 * at (1-Beta) on real axis.  Some chip sets (like Si labs) don&#39;t</span>
<span class="cm">	 * need this, but something like a $10 X100P card does.  Any DC really</span>
<span class="cm">	 * slows down convergence.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: removes some low frequency from the signal, this reduces the</span>
<span class="cm">	 * speech quality when listening to samples through headphones but may</span>
<span class="cm">	 * not be obvious through a telephone handset.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that the 3dB frequency in radians is approx Beta, e.g. for Beta</span>
<span class="cm">	 * = 2^(-3) = 0.125, 3dB freq is 0.125 rads = 159Hz.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">&amp;</span> <span class="n">ECHO_CAN_USE_RX_HPF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure the gain of the HPF is 1.0. This can still</span>
<span class="cm">		 * saturate a little under impulse conditions, and it might</span>
<span class="cm">		 * roll to 32768 and need clipping on sustained peak level</span>
<span class="cm">		 * signals. However, the scale of such clipping is small, and</span>
<span class="cm">		 * the error due to any saturation should not markedly affect</span>
<span class="cm">		 * the downstream processing.</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_1</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_1</span> <span class="o">&gt;&gt;</span> <span class="n">DC_LOG2BETA</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_2</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * hard limit filter to prevent clipping.  Note that at this</span>
<span class="cm">		 * stage rx should be limited to +/- 16383 due to right shift</span>
<span class="cm">		 * above</span>
<span class="cm">		 */</span>
		<span class="n">tmp1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_1</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">&gt;</span> <span class="mi">16383</span><span class="p">)</span>
			<span class="n">tmp1</span> <span class="o">=</span> <span class="mi">16383</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">16383</span><span class="p">)</span>
			<span class="n">tmp1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">16383</span><span class="p">;</span>
		<span class="n">rx</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">rx_2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Block average of power in the filter states.  Used for</span>
<span class="cm">	   adaption power calculation. */</span>

	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">;</span>

		<span class="cm">/* efficient &quot;out with the old and in with the new&quot; algorithm so</span>
<span class="cm">		   we don&#39;t have to recalculate over the whole block of</span>
<span class="cm">		   samples. */</span>
		<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">;</span>
		<span class="n">old</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">.</span><span class="n">history</span><span class="p">[</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">.</span><span class="n">curr_pos</span><span class="p">]</span> <span class="o">*</span>
		    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">.</span><span class="n">history</span><span class="p">[</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">.</span><span class="n">curr_pos</span><span class="p">];</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Pstates</span> <span class="o">+=</span>
		    <span class="p">((</span><span class="n">new</span> <span class="o">-</span> <span class="n">old</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">log2taps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">log2taps</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Pstates</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Pstates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate short term average levels using simple single pole IIRs */</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltxacc</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="o">-</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltx</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltxacc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrxacc</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span> <span class="o">-</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrx</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrxacc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>

	<span class="cm">/* Foreground filter */</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">echo_value</span> <span class="o">=</span> <span class="n">fir16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state</span><span class="p">,</span> <span class="n">tx</span><span class="p">);</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">-</span> <span class="n">echo_value</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lcleanacc</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean</span><span class="p">)</span> <span class="o">-</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lcleanacc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>

	<span class="cm">/* Background filter */</span>

	<span class="n">echo_value</span> <span class="o">=</span> <span class="n">fir16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_state_bg</span><span class="p">,</span> <span class="n">tx</span><span class="p">);</span>
	<span class="n">clean_bg</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">-</span> <span class="n">echo_value</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bgacc</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">clean_bg</span><span class="p">)</span> <span class="o">-</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bg</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bg</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bgacc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>

	<span class="cm">/* Background Filter adaption */</span>

	<span class="cm">/* Almost always adap bg filter, just simple DT and energy</span>
<span class="cm">	   detection to minimise adaption in cases of strong double talk.</span>
<span class="cm">	   However this is not critical for the dual path algorithm.</span>
<span class="cm">	 */</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">nonupdate_dwell</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">P</span><span class="p">,</span> <span class="n">logP</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>

		<span class="cm">/* Determine:</span>

<span class="cm">		   f = Beta * clean_bg_rx/P ------ (1)</span>

<span class="cm">		   where P is the total power in the filter states.</span>

<span class="cm">		   The Boffins have shown that if we obey (1) we converge</span>
<span class="cm">		   quickly and avoid instability.</span>

<span class="cm">		   The correct factor f must be in Q30, as this is the fixed</span>
<span class="cm">		   point format required by the lms_adapt_bg() function,</span>
<span class="cm">		   therefore the scaled version of (1) is:</span>

<span class="cm">		   (2^30) * f  = (2^30) * Beta * clean_bg_rx/P</span>
<span class="cm">		   factor      = (2^30) * Beta * clean_bg_rx/P     ----- (2)</span>

<span class="cm">		   We have chosen Beta = 0.25 by experiment, so:</span>

<span class="cm">		   factor      = (2^30) * (2^-2) * clean_bg_rx/P</span>

<span class="cm">		   (30 - 2 - log2(P))</span>
<span class="cm">		   factor      = clean_bg_rx 2                     ----- (3)</span>

<span class="cm">		   To avoid a divide we approximate log2(P) as top_bit(P),</span>
<span class="cm">		   which returns the position of the highest non-zero bit in</span>
<span class="cm">		   P.  This approximation introduces an error as large as a</span>
<span class="cm">		   factor of 2, but the algorithm seems to handle it OK.</span>

<span class="cm">		   Come to think of it a divide may not be a big deal on a</span>
<span class="cm">		   modern DSP, so its probably worth checking out the cycles</span>
<span class="cm">		   for a divide versus a top_bit() implementation.</span>
<span class="cm">		 */</span>

		<span class="n">P</span> <span class="o">=</span> <span class="n">MIN_TX_POWER_FOR_ADAPTION</span> <span class="o">+</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Pstates</span><span class="p">;</span>
		<span class="n">logP</span> <span class="o">=</span> <span class="n">top_bit</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">+</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">log2taps</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">logP</span><span class="p">;</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">;</span>

		<span class="n">lms_adapt_bg</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">clean_bg</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* very simple DTD to make sure we dont try and adapt with strong</span>
<span class="cm">	   near end speech */</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">adapt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrx</span> <span class="o">&gt;</span> <span class="n">MIN_RX_POWER_FOR_ADAPTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lrx</span> <span class="o">&gt;</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltx</span><span class="p">))</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">nonupdate_dwell</span> <span class="o">=</span> <span class="n">DTD_HANGOVER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">nonupdate_dwell</span><span class="p">)</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">nonupdate_dwell</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Transfer logic */</span>

	<span class="cm">/* These conditions are from the dual path paper [1], I messed with</span>
<span class="cm">	   them a bit to improve performance. */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">&amp;</span> <span class="n">ECHO_CAN_USE_ADAPTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">nonupdate_dwell</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="cm">/* (ec-&gt;Lclean_bg &lt; 0.875*ec-&gt;Lclean) */</span>
	    <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bg</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="cm">/* (ec-&gt;Lclean_bg &lt; 0.125*ec-&gt;Ltx) */</span>
	    <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean_bg</span> <span class="o">&lt;</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltx</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">cond_met</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * BG filter has had better results for 6 consecutive</span>
<span class="cm">			 * samples</span>
<span class="cm">			 */</span>
			<span class="n">ec</span><span class="o">-&gt;</span><span class="n">adapt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">fir_taps16</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			       <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int16_t</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ec</span><span class="o">-&gt;</span><span class="n">cond_met</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">cond_met</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Non-Linear Processing */</span>

	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">&amp;</span> <span class="n">ECHO_CAN_USE_NLP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Non-linear processor - a fancy way to say &quot;zap small</span>
<span class="cm">		 * signals, to avoid residual echo due to (uLaw/ALaw)</span>
<span class="cm">		 * non-linearity in the channel.&quot;.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">((</span><span class="mi">16</span> <span class="o">*</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean</span> <span class="o">&lt;</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Ltx</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Our e/c has improved echo by at least 24 dB (each</span>
<span class="cm">			 * factor of 2 is 6dB, so 2*2*2*2=16 is the same as</span>
<span class="cm">			 * 6+6+6+6=24dB)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">&amp;</span> <span class="n">ECHO_CAN_USE_CNG</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_level</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Very elementary comfort noise generation.</span>
<span class="cm">				 * Just random numbers rolled off very vaguely</span>
<span class="cm">				 * Hoth-like.  DR: This noise doesn&#39;t sound</span>
<span class="cm">				 * quite right to me - I suspect there are some</span>
<span class="cm">				 * overflow issues in the filtering as it&#39;s too</span>
<span class="cm">				 * &quot;crackly&quot;.</span>
<span class="cm">				 * TODO: debug this, maybe just play noise at</span>
<span class="cm">				 * high level or look at spectrum.</span>
<span class="cm">				 */</span>

				<span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_rndnum</span> <span class="o">=</span>
				    <span class="mi">1664525U</span> <span class="o">*</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_rndnum</span> <span class="o">+</span> <span class="mi">1013904223U</span><span class="p">;</span>
				<span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_filter</span> <span class="o">=</span>
				    <span class="p">((</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_rndnum</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">-</span> <span class="mi">32768</span> <span class="o">+</span>
				     <span class="mi">5</span> <span class="o">*</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_filter</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
				<span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_filter</span> <span class="o">*</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">cng_level</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">&amp;</span> <span class="n">ECHO_CAN_USE_CLIP</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* This sounds much better than CNG */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">&gt;</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span><span class="p">)</span>
					<span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span><span class="p">)</span>
					<span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * just mute the residual, doesn&#39;t sound very</span>
<span class="cm">				 * good, used mainly in G168 tests</span>
<span class="cm">				 */</span>
				<span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Background noise estimator.  I tried a few</span>
<span class="cm">			 * algorithms here without much luck.  This very simple</span>
<span class="cm">			 * one seems to work best, we just average the level</span>
<span class="cm">			 * using a slow (1 sec time const) filter if the</span>
<span class="cm">			 * current level is less than a (experimentally</span>
<span class="cm">			 * derived) constant.  This means we dont include high</span>
<span class="cm">			 * level signals like near end speech.  When combined</span>
<span class="cm">			 * with CNG or especially CLIP seems to work OK.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lclean</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_acc</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean</span><span class="p">)</span> <span class="o">-</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span><span class="p">;</span>
				<span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn</span> <span class="o">=</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">Lbgn_acc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Roll around the taps buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">curr_pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">curr_pos</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">;</span>
	<span class="n">ec</span><span class="o">-&gt;</span><span class="n">curr_pos</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">&amp;</span> <span class="n">ECHO_CAN_DISABLE</span><span class="p">)</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">=</span> <span class="n">rx</span><span class="p">;</span>

	<span class="cm">/* Output scaled back up again to match input scaling */</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">int16_t</span><span class="p">)</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">clean_nlp</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">oslec_update</span><span class="p">);</span>

<span class="cm">/* This function is separated from the echo canceller is it is usually called</span>
<span class="cm">   as part of the tx process.  See rx HP (DC blocking) filter above, it&#39;s</span>
<span class="cm">   the same design.</span>

<span class="cm">   Some soft phones send speech signals with a lot of low frequency</span>
<span class="cm">   energy, e.g. down to 20Hz.  This can make the hybrid non-linear</span>
<span class="cm">   which causes the echo canceller to fall over.  This filter can help</span>
<span class="cm">   by removing any low frequency before it gets to the tx port of the</span>
<span class="cm">   hybrid.</span>

<span class="cm">   It can also help by removing and DC in the tx signal.  DC is bad</span>
<span class="cm">   for LMS algorithms.</span>

<span class="cm">   This is one of the classic DC removal filters, adjusted to provide</span>
<span class="cm">   sufficient bass rolloff to meet the above requirement to protect hybrids</span>
<span class="cm">   from things that upset them. The difference between successive samples</span>
<span class="cm">   produces a lousy HPF, and then a suitably placed pole flattens things out.</span>
<span class="cm">   The final result is a nicely rolled off bass end. The filtering is</span>
<span class="cm">   implemented with extended fractional precision, which noise shapes things,</span>
<span class="cm">   giving very clean DC removal.</span>
<span class="cm">*/</span>

<span class="kt">int16_t</span> <span class="nf">oslec_hpf_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">oslec_state</span> <span class="o">*</span><span class="n">ec</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">adaption_mode</span> <span class="o">&amp;</span> <span class="n">ECHO_CAN_USE_TX_HPF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tx</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure the gain of the HPF is 1.0. The first can still</span>
<span class="cm">		 * saturate a little under impulse conditions, and it might</span>
<span class="cm">		 * roll to 32768 and need clipping on sustained peak level</span>
<span class="cm">		 * signals. However, the scale of such clipping is small, and</span>
<span class="cm">		 * the error due to any saturation should not markedly affect</span>
<span class="cm">		 * the downstream processing.</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_1</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_1</span> <span class="o">&gt;&gt;</span> <span class="n">DC_LOG2BETA</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_2</span><span class="p">;</span>
		<span class="n">tmp1</span> <span class="o">=</span> <span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_1</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">&gt;</span> <span class="mi">32767</span><span class="p">)</span>
			<span class="n">tmp1</span> <span class="o">=</span> <span class="mi">32767</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">32767</span><span class="p">)</span>
			<span class="n">tmp1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">32767</span><span class="p">;</span>
		<span class="n">tx</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">tx_2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tx</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">oslec_hpf_tx</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Rowe&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Open Source Line Echo Canceller&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;0.3.0&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
