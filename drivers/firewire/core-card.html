<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › firewire › core-card.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>core-card.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2005-2007  Kristian Hoegsberg &lt;krh@bitplanet.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/crc-itu-t.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/firewire.h&gt;</span>
<span class="cp">#include &lt;linux/firewire-constants.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;core.h&quot;</span>

<span class="cp">#define define_fw_printk_level(func, kern_level)		\</span>
<span class="cp">void func(const struct fw_card *card, const char *fmt, ...)	\</span>
<span class="cp">{								\</span>
<span class="cp">	struct va_format vaf;					\</span>
<span class="cp">	va_list args;						\</span>
<span class="cp">								\</span>
<span class="cp">	va_start(args, fmt);					\</span>
<span class="cp">	vaf.fmt = fmt;						\</span>
<span class="cp">	vaf.va = &amp;args;						\</span>
<span class="cp">	printk(kern_level KBUILD_MODNAME &quot; %s: %pV&quot;,		\</span>
<span class="cp">	       dev_name(card-&gt;device), &amp;vaf);			\</span>
<span class="cp">	va_end(args);						\</span>
<span class="cp">}</span>
<span class="n">define_fw_printk_level</span><span class="p">(</span><span class="n">fw_err</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">);</span>
<span class="n">define_fw_printk_level</span><span class="p">(</span><span class="n">fw_notice</span><span class="p">,</span> <span class="n">KERN_NOTICE</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">fw_compute_block_crc</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">crc</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc_itu_t</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">length</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">block</span> <span class="o">|=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">card_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">card_list</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">descriptor_list</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">descriptor_count</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="n">tmp_config_rom</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="cm">/* ROM header, bus info block, root dir header, capabilities = 7 quadlets */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">config_rom_length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#define BIB_CRC(v)		((v) &lt;&lt;  0)</span>
<span class="cp">#define BIB_CRC_LENGTH(v)	((v) &lt;&lt; 16)</span>
<span class="cp">#define BIB_INFO_LENGTH(v)	((v) &lt;&lt; 24)</span>
<span class="cp">#define BIB_BUS_NAME		0x31333934 </span><span class="cm">/* &quot;1394&quot; */</span><span class="cp"></span>
<span class="cp">#define BIB_LINK_SPEED(v)	((v) &lt;&lt;  0)</span>
<span class="cp">#define BIB_GENERATION(v)	((v) &lt;&lt;  4)</span>
<span class="cp">#define BIB_MAX_ROM(v)		((v) &lt;&lt;  8)</span>
<span class="cp">#define BIB_MAX_RECEIVE(v)	((v) &lt;&lt; 12)</span>
<span class="cp">#define BIB_CYC_CLK_ACC(v)	((v) &lt;&lt; 16)</span>
<span class="cp">#define BIB_PMC			((1) &lt;&lt; 27)</span>
<span class="cp">#define BIB_BMC			((1) &lt;&lt; 28)</span>
<span class="cp">#define BIB_ISC			((1) &lt;&lt; 29)</span>
<span class="cp">#define BIB_CMC			((1) &lt;&lt; 30)</span>
<span class="cp">#define BIB_IRMC		((1) &lt;&lt; 31)</span>
<span class="cp">#define NODE_CAPABILITIES	0x0c0083c0 </span><span class="cm">/* per IEEE 1394 clause 8.3.2.6.5.2 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * IEEE-1394 specifies a default SPLIT_TIMEOUT value of 800 cycles (100 ms),</span>
<span class="cm"> * but we have to make it longer because there are many devices whose firmware</span>
<span class="cm"> * is just too slow for that.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_SPLIT_TIMEOUT	(2 * 8000)</span>

<span class="cp">#define CANON_OUI		0x000085</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">generate_config_rom</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">config_rom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize contents of config rom buffer.  On the OHCI</span>
<span class="cm">	 * controller, block reads to the config rom accesses the host</span>
<span class="cm">	 * memory, but quadlet read access the hardware bus info block</span>
<span class="cm">	 * registers.  That&#39;s just crack, but it means we should make</span>
<span class="cm">	 * sure the contents of bus info block in host memory matches</span>
<span class="cm">	 * the version stored in the OHCI registers.</span>
<span class="cm">	 */</span>

	<span class="n">config_rom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
		<span class="n">BIB_CRC_LENGTH</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIB_INFO_LENGTH</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIB_CRC</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">config_rom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">BIB_BUS_NAME</span><span class="p">);</span>
	<span class="n">config_rom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
		<span class="n">BIB_LINK_SPEED</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">BIB_GENERATION</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">config_rom_generation</span><span class="o">++</span> <span class="o">%</span> <span class="mi">14</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">BIB_MAX_ROM</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">BIB_MAX_RECEIVE</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">max_receive</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">BIB_BMC</span> <span class="o">|</span> <span class="n">BIB_ISC</span> <span class="o">|</span> <span class="n">BIB_CMC</span> <span class="o">|</span> <span class="n">BIB_IRMC</span><span class="p">);</span>
	<span class="n">config_rom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">guid</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">config_rom</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">);</span>

	<span class="cm">/* Generate root directory. */</span>
	<span class="n">config_rom</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NODE_CAPABILITIES</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">descriptor_count</span><span class="p">;</span>

	<span class="cm">/* Generate root directory entries for descriptors. */</span>
	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descriptor_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">immediate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">config_rom</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">immediate</span><span class="p">);</span>
		<span class="n">config_rom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">|</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">+=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update root directory length. */</span>
	<span class="n">config_rom</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* End of root directory, now copy in descriptors. */</span>
	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descriptor_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">config_rom</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate CRCs for all blocks in the config rom.  This</span>
<span class="cm">	 * assumes that CRC length and info length are identical for</span>
<span class="cm">	 * the bus info block, which is always the case for this</span>
<span class="cm">	 * implementation. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">fw_compute_block_crc</span><span class="p">(</span><span class="n">config_rom</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">config_rom_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_config_roms</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span> <span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">generate_config_rom</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">tmp_config_rom</span><span class="p">);</span>
		<span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">set_config_rom</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">tmp_config_rom</span><span class="p">,</span>
					     <span class="n">config_rom_length</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">required_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* descriptor + entry into root dir + optional immediate entry */</span>
	<span class="k">return</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">immediate</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fw_core_add_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check descriptor is valid; the length of all blocks in the</span>
<span class="cm">	 * descriptor has to add up to exactly the length of the</span>
<span class="cm">	 * block.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config_rom_length</span> <span class="o">+</span> <span class="n">required_space</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descriptor_list</span><span class="p">);</span>
		<span class="n">config_rom_length</span> <span class="o">+=</span> <span class="n">required_space</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">descriptor_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">immediate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">descriptor_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">update_config_roms</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fw_core_add_descriptor</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">fw_core_remove_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">config_rom_length</span> <span class="o">-=</span> <span class="n">required_space</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">descriptor_count</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">immediate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">descriptor_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">update_config_roms</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fw_core_remove_descriptor</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">bool</span> <span class="n">short_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">short_reset</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">short_reset</span> <span class="o">?</span> <span class="n">PHY_BUS_SHORT_RESET</span> <span class="o">:</span> <span class="n">PHY_BUS_RESET</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_phy_reg</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fw_schedule_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">bool</span> <span class="n">delayed</span><span class="p">,</span> <span class="n">bool</span> <span class="n">short_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t try hard to sort out requests of long vs. short resets. */</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">br_short</span> <span class="o">=</span> <span class="n">short_reset</span><span class="p">;</span>

	<span class="cm">/* Use an arbitrary short delay to combine multiple reset requests. */</span>
	<span class="n">fw_card_get</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">fw_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">br_work</span><span class="p">,</span>
				<span class="n">delayed</span> <span class="o">?</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">fw_card_put</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fw_schedule_bus_reset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">br_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_card</span><span class="p">,</span> <span class="n">br_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="cm">/* Delay for 2s after last reset per IEEE 1394 clause 8.2.1. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">reset_jiffies</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_before64</span><span class="p">(</span><span class="n">get_jiffies_64</span><span class="p">(),</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">reset_jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">fw_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">br_work</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span>
			<span class="n">fw_card_put</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fw_send_phy_config</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">FW_PHY_CONFIG_NO_NODE_ID</span><span class="p">,</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">,</span>
			   <span class="n">FW_PHY_CONFIG_CURRENT_GAP_COUNT</span><span class="p">);</span>
	<span class="n">reset_bus</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">br_short</span><span class="p">);</span>
	<span class="n">fw_card_put</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">allocate_broadcast_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">int</span> <span class="n">generation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">broadcast_channel_allocated</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fw_iso_resource_manage</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bandwidth</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">!=</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fw_notice</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;failed to allocate broadcast channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">card</span><span class="o">-&gt;</span><span class="n">broadcast_channel_allocated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device_for_each_child</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">generation</span><span class="p">,</span>
			      <span class="n">fw_device_set_broadcast_channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">gap_count_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">63</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">40</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">fw_schedule_bm_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fw_card_get</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_work</span><span class="p">,</span> <span class="n">delay</span><span class="p">))</span>
		<span class="n">fw_card_put</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_card</span><span class="p">,</span> <span class="n">bm_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fw_device</span> <span class="o">*</span><span class="n">root_device</span><span class="p">,</span> <span class="o">*</span><span class="n">irm_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_node</span> <span class="o">*</span><span class="n">root_node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">root_id</span><span class="p">,</span> <span class="n">new_root_id</span><span class="p">,</span> <span class="n">irm_id</span><span class="p">,</span> <span class="n">bm_id</span><span class="p">,</span> <span class="n">local_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gap_count</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">grace</span><span class="p">,</span> <span class="n">rcode</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">do_reset</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">root_device_is_running</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">root_device_is_cmc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">irm_is_1394_1995_only</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">keep_this_irm</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">transaction_data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">local_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put_card</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">generation</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>

	<span class="n">root_node</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">root_node</span><span class="p">;</span>
	<span class="n">fw_node_get</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
	<span class="n">root_device</span> <span class="o">=</span> <span class="n">root_node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">root_device_is_running</span> <span class="o">=</span> <span class="n">root_device</span> <span class="o">&amp;&amp;</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_device</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="n">FW_DEVICE_RUNNING</span><span class="p">;</span>
	<span class="n">root_device_is_cmc</span> <span class="o">=</span> <span class="n">root_device</span> <span class="o">&amp;&amp;</span> <span class="n">root_device</span><span class="o">-&gt;</span><span class="n">cmc</span><span class="p">;</span>

	<span class="n">irm_device</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">irm_node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">irm_is_1394_1995_only</span> <span class="o">=</span> <span class="n">irm_device</span> <span class="o">&amp;&amp;</span> <span class="n">irm_device</span><span class="o">-&gt;</span><span class="n">config_rom</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">irm_device</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x000000f0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Canon MV5i works unreliably if it is not root node. */</span>
	<span class="n">keep_this_irm</span> <span class="o">=</span> <span class="n">irm_device</span> <span class="o">&amp;&amp;</span> <span class="n">irm_device</span><span class="o">-&gt;</span><span class="n">config_rom</span> <span class="o">&amp;&amp;</span>
			<span class="n">irm_device</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">CANON_OUI</span><span class="p">;</span>

	<span class="n">root_id</span>  <span class="o">=</span> <span class="n">root_node</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">;</span>
	<span class="n">irm_id</span>   <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">irm_node</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">;</span>
	<span class="n">local_id</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">local_node</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">;</span>

	<span class="n">grace</span> <span class="o">=</span> <span class="n">time_after64</span><span class="p">(</span><span class="n">get_jiffies_64</span><span class="p">(),</span>
			     <span class="n">card</span><span class="o">-&gt;</span><span class="n">reset_jiffies</span> <span class="o">+</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">is_next_generation</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_generation</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_abdicate</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_generation</span> <span class="o">!=</span> <span class="n">generation</span> <span class="o">&amp;&amp;</span> <span class="n">grace</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This first step is to figure out who is IRM and</span>
<span class="cm">		 * then try to become bus manager.  If the IRM is not</span>
<span class="cm">		 * well defined (e.g. does not have an active link</span>
<span class="cm">		 * layer or does not responds to our lock request, we</span>
<span class="cm">		 * will have to do a little vigilante bus management.</span>
<span class="cm">		 * In that case, we do a goto into the gap count logic</span>
<span class="cm">		 * so that when we do the reset, we still optimize the</span>
<span class="cm">		 * gap count.  That could well save a reset in the</span>
<span class="cm">		 * next generation.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">irm_node</span><span class="o">-&gt;</span><span class="n">link_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_root_id</span> <span class="o">=</span> <span class="n">local_id</span><span class="p">;</span>
			<span class="n">fw_notice</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;%s, making local node (%02x) root</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="s">&quot;IRM has link off&quot;</span><span class="p">,</span> <span class="n">new_root_id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">pick_me</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irm_is_1394_1995_only</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">keep_this_irm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_root_id</span> <span class="o">=</span> <span class="n">local_id</span><span class="p">;</span>
			<span class="n">fw_notice</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;%s, making local node (%02x) root</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="s">&quot;IRM is not 1394a compliant&quot;</span><span class="p">,</span> <span class="n">new_root_id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">pick_me</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">transaction_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mh">0x3f</span><span class="p">);</span>
		<span class="n">transaction_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">local_id</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">rcode</span> <span class="o">=</span> <span class="n">fw_run_transaction</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">TCODE_LOCK_COMPARE_SWAP</span><span class="p">,</span>
				<span class="n">irm_id</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">SCODE_100</span><span class="p">,</span>
				<span class="n">CSR_REGISTER_BASE</span> <span class="o">+</span> <span class="n">CSR_BUS_MANAGER_ID</span><span class="p">,</span>
				<span class="n">transaction_data</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rcode</span> <span class="o">==</span> <span class="n">RCODE_GENERATION</span><span class="p">)</span>
			<span class="cm">/* Another bus reset, BM work has been rescheduled. */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">bm_id</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">transaction_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcode</span> <span class="o">==</span> <span class="n">RCODE_COMPLETE</span> <span class="o">&amp;&amp;</span> <span class="n">generation</span> <span class="o">==</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span>
			<span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_node_id</span> <span class="o">=</span>
			    <span class="n">bm_id</span> <span class="o">==</span> <span class="mh">0x3f</span> <span class="o">?</span> <span class="n">local_id</span> <span class="o">:</span> <span class="mh">0xffc0</span> <span class="o">|</span> <span class="n">bm_id</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rcode</span> <span class="o">==</span> <span class="n">RCODE_COMPLETE</span> <span class="o">&amp;&amp;</span> <span class="n">bm_id</span> <span class="o">!=</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Somebody else is BM.  Only act as IRM. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">local_id</span> <span class="o">==</span> <span class="n">irm_id</span><span class="p">)</span>
				<span class="n">allocate_broadcast_channel</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">generation</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rcode</span> <span class="o">==</span> <span class="n">RCODE_SEND_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We have been unable to send the lock request due to</span>
<span class="cm">			 * some local problem.  Let&#39;s try again later and hope</span>
<span class="cm">			 * that the problem has gone away by then.</span>
<span class="cm">			 */</span>
			<span class="n">fw_schedule_bm_work</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rcode</span> <span class="o">!=</span> <span class="n">RCODE_COMPLETE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">keep_this_irm</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The lock request failed, maybe the IRM</span>
<span class="cm">			 * isn&#39;t really IRM capable after all. Let&#39;s</span>
<span class="cm">			 * do a bus reset and pick the local node as</span>
<span class="cm">			 * root, and thus, IRM.</span>
<span class="cm">			 */</span>
			<span class="n">new_root_id</span> <span class="o">=</span> <span class="n">local_id</span><span class="p">;</span>
			<span class="n">fw_notice</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;BM lock failed (%s), making local node (%02x) root</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">fw_rcode_string</span><span class="p">(</span><span class="n">rcode</span><span class="p">),</span> <span class="n">new_root_id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">pick_me</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_generation</span> <span class="o">!=</span> <span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We weren&#39;t BM in the last generation, and the last</span>
<span class="cm">		 * bus reset is less than 125ms ago.  Reschedule this job.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">fw_schedule_bm_work</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re bus manager for this generation, so next step is to</span>
<span class="cm">	 * make sure we have an active cycle master and do gap count</span>
<span class="cm">	 * optimization.</span>
<span class="cm">	 */</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_generation</span> <span class="o">=</span> <span class="n">generation</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_device</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Either link_on is false, or we failed to read the</span>
<span class="cm">		 * config rom.  In either case, pick another root.</span>
<span class="cm">		 */</span>
		<span class="n">new_root_id</span> <span class="o">=</span> <span class="n">local_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_device_is_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we haven&#39;t probed this device yet, bail out now</span>
<span class="cm">		 * and let&#39;s try again once that&#39;s done.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root_device_is_cmc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We will send out a force root packet for this</span>
<span class="cm">		 * node as part of the gap count optimization.</span>
<span class="cm">		 */</span>
		<span class="n">new_root_id</span> <span class="o">=</span> <span class="n">root_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Current root has an active link layer and we</span>
<span class="cm">		 * successfully read the config rom, but it&#39;s not</span>
<span class="cm">		 * cycle master capable.</span>
<span class="cm">		 */</span>
		<span class="n">new_root_id</span> <span class="o">=</span> <span class="n">local_id</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">pick_me:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pick a gap count from 1394a table E-1.  The table doesn&#39;t cover</span>
<span class="cm">	 * the typically much larger 1394b beta repeater delays though.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">beta_repeaters_present</span> <span class="o">&amp;&amp;</span>
	    <span class="n">root_node</span><span class="o">-&gt;</span><span class="n">max_hops</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">gap_count_table</span><span class="p">))</span>
		<span class="n">gap_count</span> <span class="o">=</span> <span class="n">gap_count_table</span><span class="p">[</span><span class="n">root_node</span><span class="o">-&gt;</span><span class="n">max_hops</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">gap_count</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, figure out if we should do a reset or not.  If we have</span>
<span class="cm">	 * done less than 5 resets with the same physical topology and we</span>
<span class="cm">	 * have either a new root or a new gap count setting, let&#39;s do it.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">gap_count</span> <span class="o">!=</span> <span class="n">gap_count</span> <span class="o">||</span> <span class="n">new_root_id</span> <span class="o">!=</span> <span class="n">root_id</span><span class="p">))</span>
		<span class="n">do_reset</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fw_notice</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;phy config: new root=%x, gap_count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">new_root_id</span><span class="p">,</span> <span class="n">gap_count</span><span class="p">);</span>
		<span class="n">fw_send_phy_config</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">new_root_id</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">gap_count</span><span class="p">);</span>
		<span class="n">reset_bus</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="cm">/* Will allocate broadcast channel after the reset. */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_device_is_cmc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure that the cycle master sends cycle start packets.</span>
<span class="cm">		 */</span>
		<span class="n">transaction_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">CSR_STATE_BIT_CMSTR</span><span class="p">);</span>
		<span class="n">rcode</span> <span class="o">=</span> <span class="n">fw_run_transaction</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">TCODE_WRITE_QUADLET_REQUEST</span><span class="p">,</span>
				<span class="n">root_id</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">SCODE_100</span><span class="p">,</span>
				<span class="n">CSR_REGISTER_BASE</span> <span class="o">+</span> <span class="n">CSR_STATE_SET</span><span class="p">,</span>
				<span class="n">transaction_data</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcode</span> <span class="o">==</span> <span class="n">RCODE_GENERATION</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local_id</span> <span class="o">==</span> <span class="n">irm_id</span><span class="p">)</span>
		<span class="n">allocate_broadcast_channel</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">generation</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">fw_node_put</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
 <span class="nl">out_put_card:</span>
	<span class="n">fw_card_put</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fw_card_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">fw_card_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">card</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">current_tlabel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">tlabel_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">split_timeout_hi</span> <span class="o">=</span> <span class="n">DEFAULT_SPLIT_TIMEOUT</span> <span class="o">/</span> <span class="mi">8000</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">split_timeout_lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">DEFAULT_SPLIT_TIMEOUT</span> <span class="o">%</span> <span class="mi">8000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">split_timeout_cycles</span> <span class="o">=</span> <span class="n">DEFAULT_SPLIT_TIMEOUT</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">split_timeout_jiffies</span> <span class="o">=</span>
			<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">DEFAULT_SPLIT_TIMEOUT</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">broadcast_channel</span> <span class="o">=</span> <span class="n">BROADCAST_CHANNEL_INITIAL</span><span class="p">;</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">transaction_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">phy_receiver_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">card</span><span class="o">-&gt;</span><span class="n">local_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">br_work</span><span class="p">,</span> <span class="n">br_work</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">bm_work</span><span class="p">,</span> <span class="n">bm_work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fw_card_initialize</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">fw_card_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">max_receive</span><span class="p">,</span> <span class="n">u32</span> <span class="n">link_speed</span><span class="p">,</span> <span class="n">u64</span> <span class="n">guid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">card</span><span class="o">-&gt;</span><span class="n">max_receive</span> <span class="o">=</span> <span class="n">max_receive</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="n">link_speed</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">guid</span> <span class="o">=</span> <span class="n">guid</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>

	<span class="n">generate_config_rom</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">tmp_config_rom</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">tmp_config_rom</span><span class="p">,</span> <span class="n">config_rom_length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card_list</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fw_card_add</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The next few functions implement a dummy driver that is used once a card</span>
<span class="cm"> * driver shuts down an fw_card.  This allows the driver to cleanly unload,</span>
<span class="cm"> * as all IO to the card will be handled (and failed) by the dummy driver</span>
<span class="cm"> * instead of calling into the module.  Only functions for iso context</span>
<span class="cm"> * shutdown still need to be provided by the card driver.</span>
<span class="cm"> *</span>
<span class="cm"> * .read/write_csr() should never be called anymore after the dummy driver</span>
<span class="cm"> * was bound since they are only used within request handler context.</span>
<span class="cm"> * .set_config_rom() is never called since the card is taken out of card_list</span>
<span class="cm"> * before switching to the dummy driver.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">int</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_update_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">clear_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dummy_send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">RCODE_CANCELLED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dummy_send_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">RCODE_CANCELLED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_cancel_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_enable_phys_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">node_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">generation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="nf">dummy_allocate_iso_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">header_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_start_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			   <span class="n">s32</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sync</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_set_iso_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_queue_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_iso_packet</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fw_iso_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dummy_flush_queue_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_flush_iso_completions</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_card_driver</span> <span class="n">dummy_driver_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_phy_reg</span>		<span class="o">=</span> <span class="n">dummy_read_phy_reg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_phy_reg</span>		<span class="o">=</span> <span class="n">dummy_update_phy_reg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_request</span>		<span class="o">=</span> <span class="n">dummy_send_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_response</span>		<span class="o">=</span> <span class="n">dummy_send_response</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cancel_packet</span>		<span class="o">=</span> <span class="n">dummy_cancel_packet</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_phys_dma</span>	<span class="o">=</span> <span class="n">dummy_enable_phys_dma</span><span class="p">,</span>
	<span class="p">.</span><span class="n">allocate_iso_context</span>	<span class="o">=</span> <span class="n">dummy_allocate_iso_context</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_iso</span>		<span class="o">=</span> <span class="n">dummy_start_iso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_iso_channels</span>	<span class="o">=</span> <span class="n">dummy_set_iso_channels</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queue_iso</span>		<span class="o">=</span> <span class="n">dummy_queue_iso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_queue_iso</span>	<span class="o">=</span> <span class="n">dummy_flush_queue_iso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_iso_completions</span>	<span class="o">=</span> <span class="n">dummy_flush_iso_completions</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">fw_card_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_card</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fw_card_release</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">fw_core_remove_card</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_card_driver</span> <span class="n">dummy_driver</span> <span class="o">=</span> <span class="n">dummy_driver_template</span><span class="p">;</span>

	<span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">update_phy_reg</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
				     <span class="n">PHY_LINK_ACTIVE</span> <span class="o">|</span> <span class="n">PHY_CONTENDER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">fw_schedule_bus_reset</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card_mutex</span><span class="p">);</span>

	<span class="cm">/* Switch off most of the card driver interface. */</span>
	<span class="n">dummy_driver</span><span class="p">.</span><span class="n">free_iso_context</span>	<span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">free_iso_context</span><span class="p">;</span>
	<span class="n">dummy_driver</span><span class="p">.</span><span class="n">stop_iso</span>		<span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">stop_iso</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_driver</span><span class="p">;</span>

	<span class="n">fw_destroy_nodes</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>

	<span class="cm">/* Wait for all users, especially device workqueue jobs, to finish. */</span>
	<span class="n">fw_card_put</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">transaction_list</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fw_core_remove_card</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
