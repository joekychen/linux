<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › firewire › ohci.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ohci.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for OHCI 1394 controllers</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003-2006 Kristian Hoegsberg &lt;krh@bitplanet.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/firewire.h&gt;</span>
<span class="cp">#include &lt;linux/firewire-constants.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci_ids.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cp">#ifdef CONFIG_PPC_PMAC</span>
<span class="cp">#include &lt;asm/pmac_feature.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;core.h&quot;</span>
<span class="cp">#include &quot;ohci.h&quot;</span>

<span class="cp">#define DESCRIPTOR_OUTPUT_MORE		0</span>
<span class="cp">#define DESCRIPTOR_OUTPUT_LAST		(1 &lt;&lt; 12)</span>
<span class="cp">#define DESCRIPTOR_INPUT_MORE		(2 &lt;&lt; 12)</span>
<span class="cp">#define DESCRIPTOR_INPUT_LAST		(3 &lt;&lt; 12)</span>
<span class="cp">#define DESCRIPTOR_STATUS		(1 &lt;&lt; 11)</span>
<span class="cp">#define DESCRIPTOR_KEY_IMMEDIATE	(2 &lt;&lt; 8)</span>
<span class="cp">#define DESCRIPTOR_PING			(1 &lt;&lt; 7)</span>
<span class="cp">#define DESCRIPTOR_YY			(1 &lt;&lt; 6)</span>
<span class="cp">#define DESCRIPTOR_NO_IRQ		(0 &lt;&lt; 4)</span>
<span class="cp">#define DESCRIPTOR_IRQ_ERROR		(1 &lt;&lt; 4)</span>
<span class="cp">#define DESCRIPTOR_IRQ_ALWAYS		(3 &lt;&lt; 4)</span>
<span class="cp">#define DESCRIPTOR_BRANCH_ALWAYS	(3 &lt;&lt; 2)</span>
<span class="cp">#define DESCRIPTOR_WAIT			(3 &lt;&lt; 0)</span>

<span class="k">struct</span> <span class="n">descriptor</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">req_count</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">control</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">data_address</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">branch_address</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">res_count</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">transfer_status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

<span class="cp">#define CONTROL_SET(regs)	(regs)</span>
<span class="cp">#define CONTROL_CLEAR(regs)	((regs) + 4)</span>
<span class="cp">#define COMMAND_PTR(regs)	((regs) + 12)</span>
<span class="cp">#define CONTEXT_MATCH(regs)	((regs) + 16)</span>

<span class="cp">#define AR_BUFFER_SIZE	(32*1024)</span>
<span class="cp">#define AR_BUFFERS_MIN	DIV_ROUND_UP(AR_BUFFER_SIZE, PAGE_SIZE)</span>
<span class="cm">/* we need at least two pages for proper list management */</span>
<span class="cp">#define AR_BUFFERS	(AR_BUFFERS_MIN &gt;= 2 ? AR_BUFFERS_MIN : 2)</span>

<span class="cp">#define MAX_ASYNC_PAYLOAD	4096</span>
<span class="cp">#define MAX_AR_PACKET_SIZE	(16 + MAX_ASYNC_PAYLOAD + 4)</span>
<span class="cp">#define AR_WRAPAROUND_PAGES	DIV_ROUND_UP(MAX_AR_PACKET_SIZE, PAGE_SIZE)</span>

<span class="k">struct</span> <span class="n">ar_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">AR_BUFFERS</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">descriptors</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">descriptors_bus</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_buffer_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">context</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">descriptor_callback_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A buffer that contains a block of DMA-able coherent memory used for</span>
<span class="cm"> * storing a portion of a DMA descriptor program.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">buffer_bus</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">used</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_allocation</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">current_bus</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">running</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">flushing</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List of page-sized buffers for storing DMA descriptors.</span>
<span class="cm">	 * Head of list contains buffers in use and tail of list contains</span>
<span class="cm">	 * free buffers.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">buffer_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pointer to a buffer inside buffer_list that contains the tail</span>
<span class="cm">	 * end of the current DMA program.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="o">*</span><span class="n">buffer_tail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The descriptor containing the branch address of the first</span>
<span class="cm">	 * descriptor that has not yet been filled by the device.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The last descriptor in the DMA program.  It contains the branch</span>
<span class="cm">	 * address that must be updated upon appending a new descriptor.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">descriptor_callback_t</span> <span class="n">callback</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IT_HEADER_SY(v)          ((v) &lt;&lt;  0)</span>
<span class="cp">#define IT_HEADER_TCODE(v)       ((v) &lt;&lt;  4)</span>
<span class="cp">#define IT_HEADER_CHANNEL(v)     ((v) &lt;&lt;  8)</span>
<span class="cp">#define IT_HEADER_TAG(v)         ((v) &lt;&lt; 14)</span>
<span class="cp">#define IT_HEADER_SPEED(v)       ((v) &lt;&lt; 16)</span>
<span class="cp">#define IT_HEADER_DATA_LENGTH(v) ((v) &lt;&lt; 16)</span>

<span class="k">struct</span> <span class="n">iso_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">context</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flushing_completions</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mc_buffer_bus</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mc_completed</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">last_timestamp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sync</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define CONFIG_ROM_SIZE 1024</span>

<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_card</span> <span class="n">card</span><span class="p">;</span>

	<span class="n">__iomem</span> <span class="kt">char</span> <span class="o">*</span><span class="n">registers</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">generation</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">request_generation</span><span class="p">;</span>	<span class="cm">/* for timestamping incoming requests */</span>
	<span class="kt">unsigned</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pri_req_max</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bus_time</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_root</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">csr_state_setclear_abdicate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_ir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_it</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Spinlock for accessing fw_ohci data.  Never call out of</span>
<span class="cm">	 * this driver with this lock held.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">phy_reg_mutex</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">misc_buffer</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">misc_buffer_bus</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ar_context</span> <span class="n">ar_request_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ar_context</span> <span class="n">ar_response_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">at_request_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="n">at_response_ctx</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">it_context_support</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">it_context_mask</span><span class="p">;</span>     <span class="cm">/* unoccupied IT contexts */</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">it_context_list</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ir_context_channels</span><span class="p">;</span> <span class="cm">/* unoccupied channels */</span>
	<span class="n">u32</span> <span class="n">ir_context_support</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ir_context_mask</span><span class="p">;</span>     <span class="cm">/* unoccupied IR contexts */</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ir_context_list</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mc_channels</span><span class="p">;</span> <span class="cm">/* channels in use by the multichannel IR context */</span>
	<span class="n">bool</span> <span class="n">mc_allocated</span><span class="p">;</span>

	<span class="n">__be32</span>    <span class="o">*</span><span class="n">config_rom</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">config_rom_bus</span><span class="p">;</span>
	<span class="n">__be32</span>    <span class="o">*</span><span class="n">next_config_rom</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">next_config_rom_bus</span><span class="p">;</span>
	<span class="n">__be32</span>     <span class="n">next_header</span><span class="p">;</span>

	<span class="n">__le32</span>    <span class="o">*</span><span class="n">self_id_cpu</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">self_id_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">bus_reset_work</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">self_id_buffer</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="nf">fw_ohci</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_ohci</span><span class="p">,</span> <span class="n">card</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define IT_CONTEXT_CYCLE_MATCH_ENABLE	0x80000000</span>
<span class="cp">#define IR_CONTEXT_BUFFER_FILL		0x80000000</span>
<span class="cp">#define IR_CONTEXT_ISOCH_HEADER		0x40000000</span>
<span class="cp">#define IR_CONTEXT_CYCLE_MATCH_ENABLE	0x20000000</span>
<span class="cp">#define IR_CONTEXT_MULTI_CHANNEL_MODE	0x10000000</span>
<span class="cp">#define IR_CONTEXT_DUAL_BUFFER_MODE	0x08000000</span>

<span class="cp">#define CONTEXT_RUN	0x8000</span>
<span class="cp">#define CONTEXT_WAKE	0x1000</span>
<span class="cp">#define CONTEXT_DEAD	0x0800</span>
<span class="cp">#define CONTEXT_ACTIVE	0x0400</span>

<span class="cp">#define OHCI1394_MAX_AT_REQ_RETRIES	0xf</span>
<span class="cp">#define OHCI1394_MAX_AT_RESP_RETRIES	0x2</span>
<span class="cp">#define OHCI1394_MAX_PHYS_RESP_RETRIES	0x8</span>

<span class="cp">#define OHCI1394_REGISTER_SIZE		0x800</span>
<span class="cp">#define OHCI1394_PCI_HCI_Control	0x40</span>
<span class="cp">#define SELF_ID_BUF_SIZE		0x800</span>
<span class="cp">#define OHCI_TCODE_PHY_PACKET		0x0e</span>
<span class="cp">#define OHCI_VERSION_1_1		0x010010</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">ohci_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">;</span>

<span class="cp">#define PCI_DEVICE_ID_AGERE_FW643	0x5901</span>
<span class="cp">#define PCI_DEVICE_ID_CREATIVE_SB1394	0x4001</span>
<span class="cp">#define PCI_DEVICE_ID_JMICRON_JMB38X_FW	0x2380</span>
<span class="cp">#define PCI_DEVICE_ID_TI_TSB12LV22	0x8009</span>
<span class="cp">#define PCI_DEVICE_ID_TI_TSB12LV26	0x8020</span>
<span class="cp">#define PCI_DEVICE_ID_TI_TSB82AA2	0x8025</span>
<span class="cp">#define PCI_VENDOR_ID_PINNACLE_SYSTEMS	0x11bd</span>

<span class="cp">#define QUIRK_CYCLE_TIMER		1</span>
<span class="cp">#define QUIRK_RESET_PACKET		2</span>
<span class="cp">#define QUIRK_BE_HEADERS		4</span>
<span class="cp">#define QUIRK_NO_1394A			8</span>
<span class="cp">#define QUIRK_NO_MSI			16</span>
<span class="cp">#define QUIRK_TI_SLLZ059		32</span>

<span class="cm">/* In case of multiple matches in ohci_quirks[], only the first one is used. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ohci_quirks</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_CYCLE_TIMER</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_APPLE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_APPLE_UNI_N_FW</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_BE_HEADERS</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_ATT</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AGERE_FW643</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
		<span class="n">QUIRK_NO_MSI</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_CREATIVE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CREATIVE_SB1394</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_RESET_PACKET</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB38X_FW</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_NO_MSI</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_NEC</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_CYCLE_TIMER</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_O2</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_NO_MSI</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_RICOH</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_CYCLE_TIMER</span> <span class="o">|</span> <span class="n">QUIRK_NO_MSI</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TI_TSB12LV22</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_CYCLE_TIMER</span> <span class="o">|</span> <span class="n">QUIRK_RESET_PACKET</span> <span class="o">|</span> <span class="n">QUIRK_NO_1394A</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TI_TSB12LV26</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_RESET_PACKET</span> <span class="o">|</span> <span class="n">QUIRK_TI_SLLZ059</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TI_TSB82AA2</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_RESET_PACKET</span> <span class="o">|</span> <span class="n">QUIRK_TI_SLLZ059</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_RESET_PACKET</span><span class="p">},</span>

	<span class="p">{</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">QUIRK_CYCLE_TIMER</span> <span class="o">|</span> <span class="n">QUIRK_NO_MSI</span><span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* This overrides anything that was found in ohci_quirks[]. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">param_quirks</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">quirks</span><span class="p">,</span> <span class="n">param_quirks</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">quirks</span><span class="p">,</span> <span class="s">&quot;Chip quirks (default = 0&quot;</span>
	<span class="s">&quot;, nonatomic cycle timer = &quot;</span>	<span class="n">__stringify</span><span class="p">(</span><span class="n">QUIRK_CYCLE_TIMER</span><span class="p">)</span>
	<span class="s">&quot;, reset packet generation = &quot;</span>	<span class="n">__stringify</span><span class="p">(</span><span class="n">QUIRK_RESET_PACKET</span><span class="p">)</span>
	<span class="s">&quot;, AR/selfID endianess = &quot;</span>	<span class="n">__stringify</span><span class="p">(</span><span class="n">QUIRK_BE_HEADERS</span><span class="p">)</span>
	<span class="s">&quot;, no 1394a enhancements = &quot;</span>	<span class="n">__stringify</span><span class="p">(</span><span class="n">QUIRK_NO_1394A</span><span class="p">)</span>
	<span class="s">&quot;, disable MSI = &quot;</span>		<span class="n">__stringify</span><span class="p">(</span><span class="n">QUIRK_NO_MSI</span><span class="p">)</span>
	<span class="s">&quot;, TI SLLZ059 erratum = &quot;</span>	<span class="n">__stringify</span><span class="p">(</span><span class="n">QUIRK_TI_SLLZ059</span><span class="p">)</span>
	<span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="cp">#define OHCI_PARAM_DEBUG_AT_AR		1</span>
<span class="cp">#define OHCI_PARAM_DEBUG_SELFIDS	2</span>
<span class="cp">#define OHCI_PARAM_DEBUG_IRQS		4</span>
<span class="cp">#define OHCI_PARAM_DEBUG_BUSRESETS	8 </span><span class="cm">/* only effective before chip init */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">param_debug</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">param_debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Verbose logging (default = 0&quot;</span>
	<span class="s">&quot;, AT/AR events = &quot;</span>	<span class="n">__stringify</span><span class="p">(</span><span class="n">OHCI_PARAM_DEBUG_AT_AR</span><span class="p">)</span>
	<span class="s">&quot;, self-IDs = &quot;</span>		<span class="n">__stringify</span><span class="p">(</span><span class="n">OHCI_PARAM_DEBUG_SELFIDS</span><span class="p">)</span>
	<span class="s">&quot;, IRQs = &quot;</span>		<span class="n">__stringify</span><span class="p">(</span><span class="n">OHCI_PARAM_DEBUG_IRQS</span><span class="p">)</span>
	<span class="s">&quot;, busReset events = &quot;</span>	<span class="n">__stringify</span><span class="p">(</span><span class="n">OHCI_PARAM_DEBUG_BUSRESETS</span><span class="p">)</span>
	<span class="s">&quot;, or a combination, or all = -1)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">log_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">param_debug</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="n">OHCI_PARAM_DEBUG_IRQS</span> <span class="o">|</span> <span class="n">OHCI_PARAM_DEBUG_BUSRESETS</span><span class="p">))))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">param_debug</span> <span class="o">&amp;</span> <span class="n">OHCI_PARAM_DEBUG_IRQS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_busReset</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
	    <span class="s">&quot;IRQ %08x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">evt</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_selfIDComplete</span>	<span class="o">?</span> <span class="s">&quot; selfID&quot;</span>		<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_RQPkt</span>		<span class="o">?</span> <span class="s">&quot; AR_req&quot;</span>		<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_RSPkt</span>		<span class="o">?</span> <span class="s">&quot; AR_resp&quot;</span>		<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_reqTxComplete</span>	<span class="o">?</span> <span class="s">&quot; AT_req&quot;</span>		<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_respTxComplete</span>	<span class="o">?</span> <span class="s">&quot; AT_resp&quot;</span>		<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_isochRx</span>		<span class="o">?</span> <span class="s">&quot; IR&quot;</span>			<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_isochTx</span>		<span class="o">?</span> <span class="s">&quot; IT&quot;</span>			<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_postedWriteErr</span>	<span class="o">?</span> <span class="s">&quot; postedWriteErr&quot;</span>	<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_cycleTooLong</span>		<span class="o">?</span> <span class="s">&quot; cycleTooLong&quot;</span>	<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_cycle64Seconds</span>	<span class="o">?</span> <span class="s">&quot; cycle64Seconds&quot;</span>	<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_cycleInconsistent</span>	<span class="o">?</span> <span class="s">&quot; cycleInconsistent&quot;</span>	<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_regAccessFail</span>	<span class="o">?</span> <span class="s">&quot; regAccessFail&quot;</span>	<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_unrecoverableError</span>	<span class="o">?</span> <span class="s">&quot; unrecoverableError&quot;</span>	<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="n">OHCI1394_busReset</span>		<span class="o">?</span> <span class="s">&quot; busReset&quot;</span>		<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	    <span class="n">evt</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">OHCI1394_selfIDComplete</span> <span class="o">|</span> <span class="n">OHCI1394_RQPkt</span> <span class="o">|</span>
		    <span class="n">OHCI1394_RSPkt</span> <span class="o">|</span> <span class="n">OHCI1394_reqTxComplete</span> <span class="o">|</span>
		    <span class="n">OHCI1394_respTxComplete</span> <span class="o">|</span> <span class="n">OHCI1394_isochRx</span> <span class="o">|</span>
		    <span class="n">OHCI1394_isochTx</span> <span class="o">|</span> <span class="n">OHCI1394_postedWriteErr</span> <span class="o">|</span>
		    <span class="n">OHCI1394_cycleTooLong</span> <span class="o">|</span> <span class="n">OHCI1394_cycle64Seconds</span> <span class="o">|</span>
		    <span class="n">OHCI1394_cycleInconsistent</span> <span class="o">|</span>
		    <span class="n">OHCI1394_regAccessFail</span> <span class="o">|</span> <span class="n">OHCI1394_busReset</span><span class="p">)</span>
						<span class="o">?</span> <span class="s">&quot; ?&quot;</span>			<span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">speed</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;S100&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;S200&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;S400&quot;</span><span class="p">,</span>    <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;beta&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">power</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;+0W&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;+15W&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;+30W&quot;</span><span class="p">,</span>    <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;+45W&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-3W&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot; ?W&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-3..-6W&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-3..-10W&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">port</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="sc">&#39;p&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="nf">_p</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port</span><span class="p">[</span><span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">log_selfids</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">generation</span><span class="p">,</span> <span class="kt">int</span> <span class="n">self_id_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">param_debug</span> <span class="o">&amp;</span> <span class="n">OHCI_PARAM_DEBUG_SELFIDS</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
		   <span class="s">&quot;%d selfIDs, generation %d, local node ID %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self_id_count</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">;</span> <span class="n">self_id_count</span><span class="o">--</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">s</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			    <span class="s">&quot;selfID 0: %08x, phy %d [%c%c%c] &quot;</span>
			    <span class="s">&quot;%s gc=%d %s %s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">,</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
			    <span class="n">speed</span><span class="p">[</span><span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">],</span> <span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">,</span>
			    <span class="n">power</span><span class="p">[</span><span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">],</span> <span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;L&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			    <span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;c&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span> <span class="o">&amp;</span> <span class="mi">2</span> <span class="o">?</span> <span class="s">&quot;i&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			    <span class="s">&quot;selfID n: %08x, phy %d [%c%c%c%c%c%c%c%c]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">,</span>
			    <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
			    <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>  <span class="mi">8</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>  <span class="mi">6</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>  <span class="mi">4</span><span class="p">),</span> <span class="n">_p</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>  <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">evts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mh">0x00</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_no_status&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0x01</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x02</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_long_packet&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0x03</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_missing_ack&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x04</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_underrun&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0x05</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_overrun&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x06</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_descriptor_read&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0x07</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_data_read&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x08</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_data_write&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0x09</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_bus_reset&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x0a</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_timeout&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x0b</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_tcode_err&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x0c</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x0d</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x0e</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_unknown&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x0f</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;evt_flushed&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x11</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_complete&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x12</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_pending &quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0x13</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x14</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_busy_X&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x15</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_busy_A&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_busy_B&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x17</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x18</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x19</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x1a</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x1b</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_tardy&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x1c</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x1d</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_data_error&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x1e</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ack_type_error&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0x1f</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x20</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;pending/cancelled&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tcodes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mh">0x0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;QW req&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;BW req&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;W resp&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x4</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;QR req&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x5</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;BR req&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;QR resp&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;BR resp&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0x8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;cycle start&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0x9</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Lk req&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0xa</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;async stream packet&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0xb</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Lk resp&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0xc</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>		<span class="p">[</span><span class="mh">0xd</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="mh">0xe</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;link internal&quot;</span><span class="p">,</span>	<span class="p">[</span><span class="mh">0xf</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;-reserved-&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">log_ar_at_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="kt">int</span> <span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tcode</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">specific</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">param_debug</span> <span class="o">&amp;</span> <span class="n">OHCI_PARAM_DEBUG_AT_AR</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">evt</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">evts</span><span class="p">)))</span>
			<span class="n">evt</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span> <span class="o">==</span> <span class="n">OHCI1394_evt_bus_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;A%c evt_bus_reset, generation %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dir</span><span class="p">,</span> <span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0</span>: <span class="k">case</span> <span class="mh">0x6</span>: <span class="k">case</span> <span class="mh">0x8</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">specific</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">specific</span><span class="p">),</span> <span class="s">&quot; = %08x&quot;</span><span class="p">,</span>
			 <span class="n">be32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__be32</span><span class="p">)</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x1</span>: <span class="k">case</span> <span class="mh">0x5</span>: <span class="k">case</span> <span class="mh">0x7</span>: <span class="k">case</span> <span class="mh">0x9</span>: <span class="k">case</span> <span class="mh">0xb</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">specific</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">specific</span><span class="p">),</span> <span class="s">&quot; %x,%x&quot;</span><span class="p">,</span>
			 <span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">specific</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0xa</span>:
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;A%c %s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dir</span><span class="p">,</span> <span class="n">evts</span><span class="p">[</span><span class="n">evt</span><span class="p">],</span> <span class="n">tcodes</span><span class="p">[</span><span class="n">tcode</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xe</span>:
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;A%c %s, PHY %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dir</span><span class="p">,</span> <span class="n">evts</span><span class="p">[</span><span class="n">evt</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0</span>: <span class="k">case</span> <span class="mh">0x1</span>: <span class="k">case</span> <span class="mh">0x4</span>: <span class="k">case</span> <span class="mh">0x5</span>: <span class="k">case</span> <span class="mh">0x9</span>:
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;A%c spd %x tl %02x, &quot;</span>
			   <span class="s">&quot;%04x -&gt; %04x, %s, &quot;</span>
			   <span class="s">&quot;%s, %04x%08x%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dir</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">,</span>
			   <span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">evts</span><span class="p">[</span><span class="n">evt</span><span class="p">],</span>
			   <span class="n">tcodes</span><span class="p">[</span><span class="n">tcode</span><span class="p">],</span> <span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">specific</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;A%c spd %x tl %02x, &quot;</span>
			   <span class="s">&quot;%04x -&gt; %04x, %s, &quot;</span>
			   <span class="s">&quot;%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dir</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">,</span>
			   <span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">evts</span><span class="p">[</span><span class="n">evt</span><span class="p">],</span>
			   <span class="n">tcodes</span><span class="p">[</span><span class="n">tcode</span><span class="p">],</span> <span class="n">specific</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reg_write</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">registers</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">reg_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">registers</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_writes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Do a dummy read to flush writes. */</span>
	<span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_Version</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Beware!  read_phy_reg(), write_phy_reg(), update_phy_reg(), and</span>
<span class="cm"> * read_paged_phy_reg() require the caller to hold ohci-&gt;phy_reg_mutex.</span>
<span class="cm"> * In other words, only use ohci_read_phy_reg() and ohci_update_phy_reg()</span>
<span class="cm"> * directly.  Exceptions are intrinsically serialized contexts like pci_probe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyControl</span><span class="p">,</span> <span class="n">OHCI1394_PhyControl_Read</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyControl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!~</span><span class="n">val</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span> <span class="cm">/* Card was ejected. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">OHCI1394_PhyControl_ReadDone</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">OHCI1394_PhyControl_ReadData</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try a few times without waiting.  Sleeping is necessary</span>
<span class="cm">		 * only when the link/PHY interface is busy.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;failed to read phy reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_phy_reg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyControl</span><span class="p">,</span>
		  <span class="n">OHCI1394_PhyControl_Write</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyControl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!~</span><span class="n">val</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span> <span class="cm">/* Card was ejected. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">OHCI1394_PhyControl_WritePending</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;failed to write phy reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">clear_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The interrupt status bits are cleared by writing a one bit.</span>
<span class="cm">	 * Avoid clearing them unless explicitly requested in set_bits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">clear_bits</span> <span class="o">|=</span> <span class="n">PHY_INT_STATUS_BITS</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">write_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">clear_bits</span><span class="p">)</span> <span class="o">|</span> <span class="n">set_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_paged_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">PHY_PAGE_SELECT</span><span class="p">,</span> <span class="n">page</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">read_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">phy_reg_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">read_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">phy_reg_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_update_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">clear_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">phy_reg_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">clear_bits</span><span class="p">,</span> <span class="n">set_bits</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">phy_reg_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dma_addr_t</span> <span class="nf">ar_buffer_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page_private</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ar_context_link_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">branch_address</span>  <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="mh">0xf</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">res_count</span>       <span class="o">=</span>  <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">transfer_status</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>

	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* finish init of new descriptors before branch_address update */</span>
	<span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_buffer_index</span><span class="p">];</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">branch_address</span>  <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_buffer_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_SET</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">CONTEXT_WAKE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ar_context_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">vm_unmap_ram</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">AR_BUFFERS</span> <span class="o">+</span> <span class="n">AR_WRAPAROUND_PAGES</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR_BUFFERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
				       <span class="n">ar_buffer_bus</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
				       <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ar_context_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">error_msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_CLEAR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">CONTEXT_RUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_CLEAR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">CONTEXT_RUN</span><span class="p">);</span>
		<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

		<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;AR error: %s; DMA stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">error_msg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME: restart? */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ar_next_buffer_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">AR_BUFFERS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ar_prev_buffer_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">AR_BUFFERS</span><span class="p">)</span> <span class="o">%</span> <span class="n">AR_BUFFERS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ar_first_buffer_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ar_next_buffer_index</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_buffer_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We search for the buffer that contains the last AR packet DMA data written</span>
<span class="cm"> * by the controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ar_search_last_active_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buffer_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">next_i</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_buffer_index</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">res_count</span><span class="p">,</span> <span class="n">next_res_count</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">ar_first_buffer_index</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">res_count</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">res_count</span><span class="p">);</span>

	<span class="cm">/* A buffer that is not yet completely filled must be the last one. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">res_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Peek at the next descriptor. */</span>
		<span class="n">next_i</span> <span class="o">=</span> <span class="n">ar_next_buffer_index</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read descriptors in order */</span>
		<span class="n">next_res_count</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">next_i</span><span class="p">].</span><span class="n">res_count</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the next descriptor is still empty, we must stop at this</span>
<span class="cm">		 * descriptor.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_res_count</span> <span class="o">==</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The exception is when the DMA data for one packet is</span>
<span class="cm">			 * split over three buffers; in this case, the middle</span>
<span class="cm">			 * buffer&#39;s descriptor might be never updated by the</span>
<span class="cm">			 * controller and look still empty, and we have to peek</span>
<span class="cm">			 * at the third one.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">MAX_AR_PACKET_SIZE</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next_i</span> <span class="o">=</span> <span class="n">ar_next_buffer_index</span><span class="p">(</span><span class="n">next_i</span><span class="p">);</span>
				<span class="n">rmb</span><span class="p">();</span>
				<span class="n">next_res_count</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span>
					<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">next_i</span><span class="p">].</span><span class="n">res_count</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">next_res_count</span> <span class="o">!=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">next_buffer_is_active</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">next_buffer_is_active:</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">next_i</span><span class="p">;</span>
		<span class="n">res_count</span> <span class="o">=</span> <span class="n">next_res_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read res_count before the DMA data */</span>

	<span class="o">*</span><span class="n">buffer_offset</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">res_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer_offset</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">buffer_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ar_context_abort</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">&quot;corrupted descriptor&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ar_sync_buffers_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end_buffer_index</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end_buffer_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">ar_first_buffer_index</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">end_buffer_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					<span class="n">ar_buffer_bus</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
					<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ar_next_buffer_index</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_buffer_offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					<span class="n">ar_buffer_bus</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
					<span class="n">end_buffer_offset</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_PPC_PMAC) &amp;&amp; defined(CONFIG_PPC32)</span>
<span class="cp">#define cond_le32_to_cpu(v) \</span>
<span class="cp">	(ohci-&gt;quirks &amp; QUIRK_BE_HEADERS ? (__force __u32)(v) : le32_to_cpu(v))</span>
<span class="cp">#else</span>
<span class="cp">#define cond_le32_to_cpu(v) le32_to_cpu(v)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__le32</span> <span class="o">*</span><span class="nf">handle_ar_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_packet</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">tcode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">evt</span><span class="p">;</span>

	<span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="n">tcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">tcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCODE_WRITE_QUADLET_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_READ_QUADLET_RESPONSE</span>:
		<span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__u32</span><span class="p">)</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">p</span><span class="p">.</span><span class="n">header_length</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">p</span><span class="p">.</span><span class="n">payload_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCODE_READ_BLOCK_REQUEST</span> :
		<span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">p</span><span class="p">.</span><span class="n">header_length</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">p</span><span class="p">.</span><span class="n">payload_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCODE_WRITE_BLOCK_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_READ_BLOCK_RESPONSE</span>:
	<span class="k">case</span> <span class="n">TCODE_LOCK_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_LOCK_RESPONSE</span>:
		<span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">p</span><span class="p">.</span><span class="n">header_length</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">p</span><span class="p">.</span><span class="n">payload_length</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">payload_length</span> <span class="o">&gt;</span> <span class="n">MAX_ASYNC_PAYLOAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ar_context_abort</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">&quot;invalid packet length&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCODE_WRITE_RESPONSE</span>:
	<span class="k">case</span> <span class="n">TCODE_READ_QUADLET_REQUEST</span>:
	<span class="k">case</span> <span class="n">OHCI_TCODE_PHY_PACKET</span>:
		<span class="n">p</span><span class="p">.</span><span class="n">header_length</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">p</span><span class="p">.</span><span class="n">payload_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ar_context_abort</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">&quot;invalid tcode&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">header_length</span><span class="p">;</span>

	<span class="cm">/* FIXME: What to do about evt_* errors? */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">header_length</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">payload_length</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">length</span><span class="p">]);</span>
	<span class="n">evt</span>    <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="n">p</span><span class="p">.</span><span class="n">ack</span>        <span class="o">=</span> <span class="n">evt</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">p</span><span class="p">.</span><span class="n">speed</span>      <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">p</span><span class="p">.</span><span class="n">timestamp</span>  <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">p</span><span class="p">.</span><span class="n">generation</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">request_generation</span><span class="p">;</span>

	<span class="n">log_ar_at_event</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">speed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="n">evt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Several controllers, notably from NEC and VIA, forget to</span>
<span class="cm">	 * write ack_complete status at PHY packet reception.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span> <span class="o">==</span> <span class="n">OHCI1394_evt_no_status</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">OHCI1394_phy_tcode</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span>
		<span class="n">p</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="n">ACK_COMPLETE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The OHCI bus reset handler synthesizes a PHY packet with</span>
<span class="cm">	 * the new generation number when a bus reset happens (see</span>
<span class="cm">	 * section 8.4.2.3).  This helps us determine when a request</span>
<span class="cm">	 * was received and make sure we send the response in the same</span>
<span class="cm">	 * generation.  We only need this for requests; for responses</span>
<span class="cm">	 * we use the unique tlabel for finding the matching</span>
<span class="cm">	 * request.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Alas some chips sometimes emit bus reset packets with a</span>
<span class="cm">	 * wrong generation.  We set the correct generation for these</span>
<span class="cm">	 * at a slightly incorrect time (in bus_reset_work).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span> <span class="o">==</span> <span class="n">OHCI1394_evt_bus_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">QUIRK_RESET_PACKET</span><span class="p">))</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">request_generation</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_request_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fw_core_handle_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fw_core_handle_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">handle_ar_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">handle_ar_packet</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ar_recycle_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">ar_first_buffer_index</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">end_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					   <span class="n">ar_buffer_bus</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
					   <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">ar_context_link_page</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ar_next_buffer_index</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ar_context_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end_buffer_index</span><span class="p">,</span> <span class="n">end_buffer_offset</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">end_buffer_index</span> <span class="o">=</span> <span class="n">ar_search_last_active_buffer</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">end_buffer_offset</span><span class="p">);</span>
	<span class="n">ar_sync_buffers_for_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">end_buffer_index</span><span class="p">,</span> <span class="n">end_buffer_offset</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">end_buffer_index</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="n">end_buffer_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_buffer_index</span> <span class="o">&lt;</span> <span class="n">ar_first_buffer_index</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The filled part of the overall buffer wraps around; handle</span>
<span class="cm">		 * all packets up to the buffer end here.  If the last packet</span>
<span class="cm">		 * wraps around, its tail will be visible after the buffer end</span>
<span class="cm">		 * because the buffer start pages are mapped there again.</span>
<span class="cm">		 */</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buffer_end</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">AR_BUFFERS</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">handle_ar_packets</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">buffer_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">buffer_end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="cm">/* adjust p to point back into the actual buffer */</span>
		<span class="n">p</span> <span class="o">-=</span> <span class="n">AR_BUFFERS</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">handle_ar_packets</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="n">ar_context_abort</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">&quot;inconsistent descriptor&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">ar_recycle_buffers</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">end_buffer_index</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ar_context_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">descriptors_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">AR_BUFFERS</span> <span class="o">+</span> <span class="n">AR_WRAPAROUND_PAGES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span>        <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span>        <span class="o">=</span> <span class="n">ohci</span><span class="p">;</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">ar_context_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR_BUFFERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_of_memory</span><span class="p">;</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_of_memory</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_page_private</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dma_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR_BUFFERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>              <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR_WRAPAROUND_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">AR_BUFFERS</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">vm_map_ram</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">AR_BUFFERS</span> <span class="o">+</span> <span class="n">AR_WRAPAROUND_PAGES</span><span class="p">,</span>
				 <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_of_memory</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors</span>     <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer</span>     <span class="o">+</span> <span class="n">descriptors_offset</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors_bus</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer_bus</span> <span class="o">+</span> <span class="n">descriptors_offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR_BUFFERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">req_count</span>      <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span>        <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_INPUT_MORE</span> <span class="o">|</span>
						<span class="n">DESCRIPTOR_STATUS</span> <span class="o">|</span>
						<span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">data_address</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ar_buffer_bus</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">branch_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors_bus</span> <span class="o">+</span>
			<span class="n">ar_next_buffer_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">descriptor</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_of_memory:</span>
	<span class="n">ar_context_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ar_context_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">ar_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AR_BUFFERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ar_context_link_page</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">,</span> <span class="n">COMMAND_PTR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">descriptors_bus</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_SET</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">CONTEXT_RUN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="nf">find_branch_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le16</span> <span class="n">branch</span><span class="p">;</span>

	<span class="n">branch</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">);</span>

	<span class="cm">/* figure out which descriptor the branch address goes in */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">branch</span> <span class="o">==</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">d</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">d</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">context_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">descriptor_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">branch_address</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="o">*</span><span class="n">old_desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">branch_address</span><span class="p">);</span>
		<span class="n">z</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">address</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">current_bus</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>

		<span class="cm">/* If the branch address points to a buffer outside of the</span>
<span class="cm">		 * current buffer, advance to the next buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_bus</span> <span class="o">||</span>
				<span class="n">address</span> <span class="o">&gt;=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_bus</span> <span class="o">+</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">descriptor_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">address</span> <span class="o">-</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_bus</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">find_branch_descriptor</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">last</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">old_desc</span> <span class="o">!=</span> <span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we&#39;ve advanced to the next buffer, move the</span>
<span class="cm">			 * previous buffer to the free list. */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
			<span class="n">old_desc</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new buffer and add it to the list of free buffers for this</span>
<span class="cm"> * context.  Must be called with ohci-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">context_add_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">bus_addr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 16MB of descriptors should be far more than enough for any DMA</span>
<span class="cm">	 * program.  This will catch run-away userspace or DoS attacks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">total_allocation</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">bus_addr</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_bus</span> <span class="o">=</span> <span class="n">bus_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">total_allocation</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">context_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">regs</span><span class="p">,</span> <span class="n">descriptor_callback_t</span> <span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">ohci</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">total_allocation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_add_buffer</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">descriptor_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">context_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We put a dummy descriptor in the buffer that has a NULL</span>
<span class="cm">	 * branch address and looks like it&#39;s been sent.  That way we</span>
<span class="cm">	 * have a descriptor to append DMA programs to.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_OUTPUT_LAST</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">transfer_status</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8011</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">context_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_bus</span> <span class="o">-</span>
			<span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Must be called with ohci-&gt;lock held */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="nf">context_get_descriptors</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">z</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">d_bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">-</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No room for the descriptor in this buffer, so advance to the</span>
<span class="cm">		 * next one. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If there is no free buffer next in the list,</span>
<span class="cm">			 * allocate one. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">context_add_buffer</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">descriptor_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">));</span>
	<span class="o">*</span><span class="n">d_bus</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_bus</span> <span class="o">+</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">context_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">COMMAND_PTR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span>
		  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">branch_address</span><span class="p">));</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_CLEAR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_SET</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">CONTEXT_RUN</span> <span class="o">|</span> <span class="n">extra</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">context_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">d_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor_buffer</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">buffer_tail</span><span class="p">;</span>

	<span class="n">d_bus</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer_bus</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">+=</span> <span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">extra</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>

	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* finish init of new descriptors before branch_address update */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">branch_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">d_bus</span> <span class="o">|</span> <span class="n">z</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">find_branch_descriptor</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">context_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_CLEAR</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">CONTEXT_RUN</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_SET</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">CONTEXT_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;DMA context still active (0x%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">driver_data</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">inline_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This function apppends a packet to the DMA queue for transmission.</span>
<span class="cm"> * Must always be called with the ochi-&gt;lock held to ensure proper</span>
<span class="cm"> * generation handling and locking around packet queue manipulation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">at_context_queue_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">d_bus</span><span class="p">,</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">payload_bus</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">z</span><span class="p">,</span> <span class="n">tcode</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">context_get_descriptors</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_SEND_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">control</span>   <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_KEY_IMMEDIATE</span><span class="p">);</span>
	<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">res_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The DMA format for asyncronous link packets is different</span>
<span class="cm">	 * from the IEEE1394 layout, so shift the fields around</span>
<span class="cm">	 * accordingly.</span>
<span class="cm">	 */</span>

	<span class="n">tcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">tcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCODE_WRITE_QUADLET_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_WRITE_BLOCK_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_WRITE_RESPONSE</span>:
	<span class="k">case</span> <span class="n">TCODE_READ_QUADLET_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_READ_BLOCK_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_READ_QUADLET_RESPONSE</span>:
	<span class="k">case</span> <span class="n">TCODE_READ_BLOCK_RESPONSE</span>:
	<span class="k">case</span> <span class="n">TCODE_LOCK_REQUEST</span>:
	<span class="k">case</span> <span class="n">TCODE_LOCK_RESPONSE</span>:
		<span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
		<span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">));</span>
		<span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TCODE_IS_BLOCK_PACKET</span><span class="p">(</span><span class="n">tcode</span><span class="p">))</span>
			<span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">req_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCODE_LINK_INTERNAL</span>:
		<span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">OHCI1394_phy_tcode</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
		<span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">req_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_ping_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
			<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_PING</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCODE_STREAM_DATA</span>:
		<span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
		<span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">);</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">req_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* BUG(); */</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_SEND_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">descriptor</span><span class="p">));</span>
	<span class="n">driver_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">driver_data</span><span class="o">-&gt;</span><span class="n">packet</span> <span class="o">=</span> <span class="n">packet</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">driver_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">driver_data</span><span class="o">-&gt;</span><span class="n">inline_data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">payload_bus</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
						     <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span>
						     <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">,</span>
						     <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">payload_bus</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_SEND_ERROR</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_bus</span>	<span class="o">=</span> <span class="n">payload_bus</span><span class="p">;</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_mapped</span>	<span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">driver_data</span><span class="o">-&gt;</span><span class="n">inline_data</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span>
			       <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">);</span>
			<span class="n">payload_bus</span> <span class="o">=</span> <span class="n">d_bus</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">req_count</span>    <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">);</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">data_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">payload_bus</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">z</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">last</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_OUTPUT_LAST</span> <span class="o">|</span>
				     <span class="n">DESCRIPTOR_IRQ_ALWAYS</span> <span class="o">|</span>
				     <span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">);</span>

	<span class="cm">/* FIXME: Document how the locking works. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_mapped</span><span class="p">)</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">payload_bus</span><span class="p">,</span>
					 <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_GENERATION</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">context_append</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">z</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_SET</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">CONTEXT_WAKE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">context_run</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">at_context_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flushing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">context_tasklet</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flushing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_at_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">evt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">transfer_status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">flushing</span><span class="p">)</span>
		<span class="cm">/* This descriptor isn&#39;t done yet, stop iteration. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">driver_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">packet</span> <span class="o">=</span> <span class="n">driver_data</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="cm">/* This packet was cancelled, just continue. */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_mapped</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_bus</span><span class="p">,</span>
				 <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="n">evt</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">transfer_status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">res_count</span><span class="p">);</span>

	<span class="n">log_ar_at_event</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span> <span class="n">evt</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">evt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OHCI1394_evt_timeout</span>:
		<span class="cm">/* Async response transmit timed out. */</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_CANCELLED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">OHCI1394_evt_flushed</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The packet was flushed should give same error as</span>
<span class="cm">		 * when we try to use a stale generation count.</span>
<span class="cm">		 */</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_GENERATION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">OHCI1394_evt_missing_ack</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">flushing</span><span class="p">)</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_GENERATION</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Using a valid (current) generation count, but the</span>
<span class="cm">			 * node is not on the bus or not sending acks.</span>
<span class="cm">			 */</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_NO_ACK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACK_COMPLETE</span> <span class="o">+</span> <span class="mh">0x10</span>:
	<span class="k">case</span> <span class="n">ACK_PENDING</span> <span class="o">+</span> <span class="mh">0x10</span>:
	<span class="k">case</span> <span class="n">ACK_BUSY_X</span> <span class="o">+</span> <span class="mh">0x10</span>:
	<span class="k">case</span> <span class="n">ACK_BUSY_A</span> <span class="o">+</span> <span class="mh">0x10</span>:
	<span class="k">case</span> <span class="n">ACK_BUSY_B</span> <span class="o">+</span> <span class="mh">0x10</span>:
	<span class="k">case</span> <span class="n">ACK_DATA_ERROR</span> <span class="o">+</span> <span class="mh">0x10</span>:
	<span class="k">case</span> <span class="n">ACK_TYPE_ERROR</span> <span class="o">+</span> <span class="mh">0x10</span>:
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">evt</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">OHCI1394_evt_no_status</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">flushing</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_GENERATION</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fall through */</span>

	<span class="nl">default:</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_SEND_ERROR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define HEADER_GET_DESTINATION(q)	(((q) &gt;&gt; 16) &amp; 0xffff)</span>
<span class="cp">#define HEADER_GET_TCODE(q)		(((q) &gt;&gt; 4) &amp; 0x0f)</span>
<span class="cp">#define HEADER_GET_OFFSET_HIGH(q)	(((q) &gt;&gt; 0) &amp; 0xffff)</span>
<span class="cp">#define HEADER_GET_DATA_LENGTH(q)	(((q) &gt;&gt; 16) &amp; 0xffff)</span>
<span class="cp">#define HEADER_GET_EXTENDED_TCODE(q)	(((q) &gt;&gt; 0) &amp; 0xffff)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_local_rom</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span> <span class="n">u32</span> <span class="n">csr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_packet</span> <span class="n">response</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tcode</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">tcode</span> <span class="o">=</span> <span class="n">HEADER_GET_TCODE</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCODE_IS_BLOCK_PACKET</span><span class="p">(</span><span class="n">tcode</span><span class="p">))</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">HEADER_GET_DATA_LENGTH</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">csr</span> <span class="o">-</span> <span class="n">CSR_CONFIG_ROM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fw_fill_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">response</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span>
				 <span class="n">RCODE_ADDRESS_ERROR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TCODE_IS_READ_REQUEST</span><span class="p">(</span><span class="n">tcode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fw_fill_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">response</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span>
				 <span class="n">RCODE_TYPE_ERROR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fw_fill_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">response</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span> <span class="n">RCODE_COMPLETE</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fw_core_handle_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">response</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_local_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span> <span class="n">u32</span> <span class="n">csr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_packet</span> <span class="n">response</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tcode</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ext_tcode</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">try</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="n">lock_old</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lock_arg</span><span class="p">,</span> <span class="n">lock_data</span><span class="p">;</span>

	<span class="n">tcode</span> <span class="o">=</span> <span class="n">HEADER_GET_TCODE</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">HEADER_GET_DATA_LENGTH</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">;</span>
	<span class="n">ext_tcode</span> <span class="o">=</span> <span class="n">HEADER_GET_EXTENDED_TCODE</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcode</span> <span class="o">==</span> <span class="n">TCODE_LOCK_REQUEST</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ext_tcode</span> <span class="o">==</span> <span class="n">EXTCODE_COMPARE_SWAP</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_arg</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">lock_data</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">payload</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcode</span> <span class="o">==</span> <span class="n">TCODE_READ_QUADLET_REQUEST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lock_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fw_fill_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">response</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span>
				 <span class="n">RCODE_TYPE_ERROR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr</span> <span class="o">-</span> <span class="n">CSR_BUS_MANAGER_ID</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_CSRData</span><span class="p">,</span> <span class="n">lock_data</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_CSRCompareData</span><span class="p">,</span> <span class="n">lock_arg</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_CSRControl</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">try</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">try</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">try</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_CSRControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_old</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span>
							<span class="n">OHCI1394_CSRData</span><span class="p">));</span>
			<span class="n">fw_fill_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">response</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span>
					 <span class="n">RCODE_COMPLETE</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">lock_old</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lock_old</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;swap not done (CSR lock timeout)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">fw_fill_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">response</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span> <span class="n">RCODE_BUSY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">fw_core_handle_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">response</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_local_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">csr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">ACK_PENDING</span><span class="p">;</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
		 <span class="n">HEADER_GET_OFFSET_HIGH</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">csr</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">CSR_REGISTER_BASE</span><span class="p">;</span>

	<span class="cm">/* Handle config rom reads. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csr</span> <span class="o">&gt;=</span> <span class="n">CSR_CONFIG_ROM</span> <span class="o">&amp;&amp;</span> <span class="n">csr</span> <span class="o">&lt;</span> <span class="n">CSR_CONFIG_ROM_END</span><span class="p">)</span>
		<span class="n">handle_local_rom</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">switch</span> <span class="p">(</span><span class="n">csr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CSR_BUS_MANAGER_ID</span>:
	<span class="k">case</span> <span class="n">CSR_BANDWIDTH_AVAILABLE</span>:
	<span class="k">case</span> <span class="n">CSR_CHANNELS_AVAILABLE_HI</span>:
	<span class="k">case</span> <span class="n">CSR_CHANNELS_AVAILABLE_LO</span>:
		<span class="n">handle_local_lock</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">)</span>
			<span class="n">fw_core_handle_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">fw_core_handle_response</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">ACK_COMPLETE</span><span class="p">;</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">at_context_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HEADER_GET_DESTINATION</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">==</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">handle_local_request</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">at_context_queue_packet</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">detect_dead_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctl</span><span class="p">;</span>

	<span class="n">ctl</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_SET</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">CONTEXT_DEAD</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			<span class="s">&quot;DMA context %s has stopped, error code: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">name</span><span class="p">,</span> <span class="n">evts</span><span class="p">[</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_dead_contexts</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">detect_dead_context</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;ATReq&quot;</span><span class="p">,</span> <span class="n">OHCI1394_AsReqTrContextBase</span><span class="p">);</span>
	<span class="n">detect_dead_context</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;ATRsp&quot;</span><span class="p">,</span> <span class="n">OHCI1394_AsRspTrContextBase</span><span class="p">);</span>
	<span class="n">detect_dead_context</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;ARReq&quot;</span><span class="p">,</span> <span class="n">OHCI1394_AsReqRcvContextBase</span><span class="p">);</span>
	<span class="n">detect_dead_context</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="s">&quot;ARRsp&quot;</span><span class="p">,</span> <span class="n">OHCI1394_AsRspRcvContextBase</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_support</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;IT%u&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">detect_dead_context</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitContextBase</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_support</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;IR%u&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">detect_dead_context</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">OHCI1394_IsoRcvContextBase</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/* TODO: maybe try to flush and restart the dead contexts */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">cycle_timer_ticks</span><span class="p">(</span><span class="n">u32</span> <span class="n">cycle_timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ticks</span><span class="p">;</span>

	<span class="n">ticks</span> <span class="o">=</span> <span class="n">cycle_timer</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
	<span class="n">ticks</span> <span class="o">+=</span> <span class="mi">3072</span> <span class="o">*</span> <span class="p">((</span><span class="n">cycle_timer</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1fff</span><span class="p">);</span>
	<span class="n">ticks</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">3072</span> <span class="o">*</span> <span class="mi">8000</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cycle_timer</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ticks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some controllers exhibit one or more of the following bugs when updating the</span>
<span class="cm"> * iso cycle timer register:</span>
<span class="cm"> *  - When the lowest six bits are wrapping around to zero, a read that happens</span>
<span class="cm"> *    at the same time will return garbage in the lowest ten bits.</span>
<span class="cm"> *  - When the cycleOffset field wraps around to zero, the cycleCount field is</span>
<span class="cm"> *    not incremented for about 60 ns.</span>
<span class="cm"> *  - Occasionally, the entire register reads zero.</span>
<span class="cm"> *</span>
<span class="cm"> * To catch these, we read the register three times and ensure that the</span>
<span class="cm"> * difference between each two consecutive reads is approximately the same, i.e.</span>
<span class="cm"> * less than twice the other.  Furthermore, any negative difference indicates an</span>
<span class="cm"> * error.  (A PCI read should take at least 20 ticks of the 24.576 MHz timer to</span>
<span class="cm"> * execute, so we have enough precision to compute the ratio of the differences.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_cycle_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">diff01</span><span class="p">,</span> <span class="n">diff12</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">c2</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsochronousCycleTimer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">QUIRK_CYCLE_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span><span class="p">;</span>
		<span class="n">c2</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsochronousCycleTimer</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">c0</span> <span class="o">=</span> <span class="n">c1</span><span class="p">;</span>
			<span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span><span class="p">;</span>
			<span class="n">c2</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsochronousCycleTimer</span><span class="p">);</span>
			<span class="n">t0</span> <span class="o">=</span> <span class="n">cycle_timer_ticks</span><span class="p">(</span><span class="n">c0</span><span class="p">);</span>
			<span class="n">t1</span> <span class="o">=</span> <span class="n">cycle_timer_ticks</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span>
			<span class="n">t2</span> <span class="o">=</span> <span class="n">cycle_timer_ticks</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span>
			<span class="n">diff01</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">;</span>
			<span class="n">diff12</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">diff01</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">diff12</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
			  <span class="n">diff01</span> <span class="o">/</span> <span class="n">diff12</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">diff12</span> <span class="o">/</span> <span class="n">diff01</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
			 <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">c2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function has to be called at least every 64 seconds.  The bus_time</span>
<span class="cm"> * field stores not only the upper 25 bits of the BUS_TIME register but also</span>
<span class="cm"> * the most significant bit of the cycle timer in bit 6 so that we can detect</span>
<span class="cm"> * changes in this bit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">update_bus_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cycle_time_seconds</span> <span class="o">=</span> <span class="n">get_cycle_time</span><span class="p">(</span><span class="n">ohci</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_time</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">cycle_time_seconds</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">))</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_time</span> <span class="o">+=</span> <span class="mh">0x40</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_time</span> <span class="o">|</span> <span class="n">cycle_time_seconds</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_status_for_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">phy_reg_mutex</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">write_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">port_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">read_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">phy_reg_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x06</span>:
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* is child node (connected to parent node) */</span>
	<span class="k">case</span> <span class="mh">0x0e</span>:
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* is parent node (connected to child node) */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* not connected */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_self_id_pos</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">self_id</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">self_id_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self_id_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self_id</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self_id</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TI TSB82AA2B and TSB12LV26 do not receive the selfID of a locally</span>
<span class="cm"> * attached TSB41BA3D phy; see http://www.ti.com/litv/pdf/sllz059.</span>
<span class="cm"> * Construct the selfID from phy register contents.</span>
<span class="cm"> * FIXME:  How to determine the selfID.i flag?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_and_insert_self_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">self_id_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="cm">/* link active 1, speed 3, bridge 0, contender 1, more packets 0 */</span>
	<span class="n">u32</span> <span class="n">self_id</span> <span class="o">=</span> <span class="mh">0x8040c800</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_NodeID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">OHCI1394_NodeID_idValid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;node ID not valid, new bus reset in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">self_id</span> <span class="o">|=</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span> <span class="cm">/* phy ID */</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">ohci_read_phy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">self_id</span> <span class="o">|=</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span> <span class="cm">/* power class */</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">ohci_read_phy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">self_id</span> <span class="o">|=</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span> <span class="cm">/* gap count */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">get_status_for_port</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">self_id</span> <span class="o">|=</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">6</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">get_self_id_pos</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">self_id</span><span class="p">,</span> <span class="n">self_id_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
			<span class="o">&amp;</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">]),</span>
			<span class="p">(</span><span class="n">self_id_count</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">));</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_id</span><span class="p">;</span>
		<span class="n">self_id_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">self_id_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bus_reset_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_ohci</span><span class="p">,</span> <span class="n">bus_reset_work</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">self_id_count</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">new_generation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">free_rom</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">free_rom_bus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_new_root</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_NodeID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">OHCI1394_NodeID_idValid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;node ID not valid, new bus reset in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">OHCI1394_NodeID_nodeNumber</span><span class="p">)</span> <span class="o">==</span> <span class="mi">63</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;malconfigured bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">OHCI1394_NodeID_busNumber</span> <span class="o">|</span>
			       <span class="n">OHCI1394_NodeID_nodeNumber</span><span class="p">);</span>

	<span class="n">is_new_root</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">OHCI1394_NodeID_root</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">is_root</span> <span class="o">&amp;&amp;</span> <span class="n">is_new_root</span><span class="p">))</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_LinkControlSet</span><span class="p">,</span>
			  <span class="n">OHCI1394_LinkControl_cycleMaster</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">is_root</span> <span class="o">=</span> <span class="n">is_new_root</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_SelfIDCount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">OHCI1394_SelfIDCount_selfIDError</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;inconsistent self IDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The count in the SelfIDCount register is the number of</span>
<span class="cm">	 * bytes in the self ID receive buffer.  Since we also receive</span>
<span class="cm">	 * the inverted quadlets and a header quadlet, we shift one</span>
<span class="cm">	 * bit extra to get the actual number of self IDs.</span>
<span class="cm">	 */</span>
	<span class="n">self_id_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self_id_count</span> <span class="o">&gt;</span> <span class="mi">252</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;inconsistent self IDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">generation</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_cpu</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">rmb</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">self_id_count</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">~</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_cpu</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the invalid data looks like a cycle start packet,</span>
<span class="cm">			 * it&#39;s likely to be the result of the cycle master</span>
<span class="cm">			 * having a wrong gap count.  In this case, the self IDs</span>
<span class="cm">			 * so far are valid and should be processed so that the</span>
<span class="cm">			 * bus manager can then correct the gap count.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
							<span class="o">==</span> <span class="mh">0xffff008f</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					   <span class="s">&quot;ignoring spurious self IDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">self_id_count</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					   <span class="s">&quot;inconsistent self IDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cond_le32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">QUIRK_TI_SLLZ059</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self_id_count</span> <span class="o">=</span> <span class="n">find_and_insert_self_id</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">self_id_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self_id_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
				   <span class="s">&quot;could not construct local self ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self_id_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;inconsistent self IDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rmb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the consistency of the self IDs we just read.  The</span>
<span class="cm">	 * problem we face is that a new bus reset can start while we</span>
<span class="cm">	 * read out the self IDs from the DMA buffer. If this happens,</span>
<span class="cm">	 * the DMA buffer will be overwritten with new self IDs and we</span>
<span class="cm">	 * will read out inconsistent data.  The OHCI specification</span>
<span class="cm">	 * (section 11.2) recommends a technique similar to</span>
<span class="cm">	 * linux/seqlock.h, where we remember the generation of the</span>
<span class="cm">	 * self IDs in the buffer before reading them out and compare</span>
<span class="cm">	 * it to the current generation after reading them out.  If</span>
<span class="cm">	 * the two generations match we know we have a consistent set</span>
<span class="cm">	 * of self IDs.</span>
<span class="cm">	 */</span>

	<span class="n">new_generation</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_SelfIDCount</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_generation</span> <span class="o">!=</span> <span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
			   <span class="s">&quot;new bus reset, discarding self ids</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: Document how the locking works. */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* prevent AT packet queueing */</span>
	<span class="n">context_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">);</span>
	<span class="n">context_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per OHCI 1.2 draft, clause 7.2.3.3, hardware may leave unsent</span>
<span class="cm">	 * packets in the AT queues and software needs to drain them.</span>
<span class="cm">	 * Some OHCI 1.1 controllers (JMicron) apparently require this too.</span>
<span class="cm">	 */</span>
	<span class="n">at_context_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">);</span>
	<span class="n">at_context_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">generation</span><span class="p">;</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntEventClear</span><span class="p">,</span> <span class="n">OHCI1394_busReset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">QUIRK_RESET_PACKET</span><span class="p">)</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">request_generation</span> <span class="o">=</span> <span class="n">generation</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This next bit is unrelated to the AT context stuff but we</span>
<span class="cm">	 * have to do it under the spinlock also.  If a new config rom</span>
<span class="cm">	 * was set up before this reset, the old one is now no longer</span>
<span class="cm">	 * in use and we can free it. Update the config rom pointers</span>
<span class="cm">	 * to point to the current config rom and clear the</span>
<span class="cm">	 * next_config_rom pointer so a new update can take place.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">!=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_rom</span>      <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">;</span>
			<span class="n">free_rom_bus</span>  <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom_bus</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span>      <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom_bus</span>  <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Restore config_rom image and manually update</span>
<span class="cm">		 * config_rom registers.  Writing the header quadlet</span>
<span class="cm">		 * will indicate that the config rom is ready, so we</span>
<span class="cm">		 * do that last.</span>
<span class="cm">		 */</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_BusOptions</span><span class="p">,</span>
			  <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_header</span><span class="p">;</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_ConfigROMhdr</span><span class="p">,</span>
			  <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_header</span><span class="p">));</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FIREWIRE_OHCI_REMOTE_DMA</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyReqFilterHiSet</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyReqFilterLoSet</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_rom</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">,</span>
				  <span class="n">free_rom</span><span class="p">,</span> <span class="n">free_rom_bus</span><span class="p">);</span>

	<span class="n">log_selfids</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">self_id_count</span><span class="p">);</span>

	<span class="n">fw_core_handle_bus_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span>
				 <span class="n">self_id_count</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_buffer</span><span class="p">,</span>
				 <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">csr_state_setclear_abdicate</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">csr_state_setclear_abdicate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">event</span><span class="p">,</span> <span class="n">iso_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntEventClear</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span> <span class="o">||</span> <span class="o">!~</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * busReset and postedWriteErr must not be cleared yet</span>
<span class="cm">	 * (OHCI 1.1 clauses 7.2.3.2 and 13.2.8.1)</span>
<span class="cm">	 */</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntEventClear</span><span class="p">,</span>
		  <span class="n">event</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">OHCI1394_busReset</span> <span class="o">|</span> <span class="n">OHCI1394_postedWriteErr</span><span class="p">));</span>
	<span class="n">log_irqs</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_selfIDComplete</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">fw_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_reset_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_RQPkt</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_request_ctx</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_RSPkt</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_response_ctx</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_reqTxComplete</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_respTxComplete</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_isochRx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iso_event</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntEventClear</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntEventClear</span><span class="p">,</span> <span class="n">iso_event</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">iso_event</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">iso_event</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tasklet_schedule</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">context</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
			<span class="n">iso_event</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_isochTx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iso_event</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntEventClear</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntEventClear</span><span class="p">,</span> <span class="n">iso_event</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">iso_event</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">iso_event</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tasklet_schedule</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">context</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>
			<span class="n">iso_event</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_regAccessFail</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;register access failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_postedWriteErr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PostedWriteAddressHi</span><span class="p">);</span>
		<span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PostedWriteAddressLo</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntEventClear</span><span class="p">,</span>
			  <span class="n">OHCI1394_postedWriteErr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;PCI posted write error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_cycleTooLong</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
				   <span class="s">&quot;isochronous cycle too long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_LinkControlSet</span><span class="p">,</span>
			  <span class="n">OHCI1394_LinkControl_cycleMaster</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_cycleInconsistent</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to clear this event bit in order to make</span>
<span class="cm">		 * cycleMatch isochronous I/O work.  In theory we should</span>
<span class="cm">		 * stop active cycleMatch iso contexts now and restart</span>
<span class="cm">		 * them at least two cycles later.  (FIXME?)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
				   <span class="s">&quot;isochronous cycle inconsistent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_unrecoverableError</span><span class="p">))</span>
		<span class="n">handle_dead_contexts</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">OHCI1394_cycle64Seconds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">update_bus_time</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">software_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlSet</span><span class="p">,</span> <span class="n">OHCI1394_HCControl_softReset</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlSet</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!~</span><span class="n">val</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span> <span class="cm">/* Card was ejected. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">OHCI1394_HCControl_softReset</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_config_rom</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">[</span><span class="n">length</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configure_1394a_enhancements</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">enable_1394a</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">clear</span><span class="p">,</span> <span class="n">set</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* Check if the driver should configure link and PHY. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlSet</span><span class="p">)</span> <span class="o">&amp;</span>
	      <span class="n">OHCI1394_HCControl_programPhyEnable</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Paranoia: check whether the PHY supports 1394a, too. */</span>
	<span class="n">enable_1394a</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">read_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">PHY_EXTENDED_REGISTERS</span><span class="p">)</span> <span class="o">==</span> <span class="n">PHY_EXTENDED_REGISTERS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">read_paged_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">enable_1394a</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">QUIRK_NO_1394A</span><span class="p">)</span>
		<span class="n">enable_1394a</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Configure PHY and link consistently. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_1394a</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">PHY_ENABLE_ACCEL</span> <span class="o">|</span> <span class="n">PHY_ENABLE_MULTI</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clear</span> <span class="o">=</span> <span class="n">PHY_ENABLE_ACCEL</span> <span class="o">|</span> <span class="n">PHY_ENABLE_MULTI</span><span class="p">;</span>
		<span class="n">set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">clear</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_1394a</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">OHCI1394_HCControlSet</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">OHCI1394_HCControlClear</span><span class="p">;</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">OHCI1394_HCControl_aPhyEnhanceEnable</span><span class="p">);</span>

	<span class="cm">/* Clean up: configuration has been taken care of. */</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlClear</span><span class="p">,</span>
		  <span class="n">OHCI1394_HCControl_programPhyEnable</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">probe_tsb41ba3d</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TI vendor ID = 0x080028, TSB41BA3D product ID = 0x833005 (sic) */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">read_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">PHY_EXTENDED_REGISTERS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PHY_EXTENDED_REGISTERS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">read_paged_phy_reg</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">!=</span> <span class="n">id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">config_rom</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">lps</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">irqs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">software_reset</span><span class="p">(</span><span class="n">ohci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;failed to reset ohci card</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now enable LPS, which we need in order to start accessing</span>
<span class="cm">	 * most of the registers.  In fact, on some cards (ALI M5251),</span>
<span class="cm">	 * accessing registers in the SClk domain without LPS enabled</span>
<span class="cm">	 * will lock up the machine.  Wait 50msec to make sure we have</span>
<span class="cm">	 * full link enabled.  However, with some cards (well, at least</span>
<span class="cm">	 * a JMicron PCIe card), we have to try again sometimes.</span>
<span class="cm">	 */</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlSet</span><span class="p">,</span>
		  <span class="n">OHCI1394_HCControl_LPS</span> <span class="o">|</span>
		  <span class="n">OHCI1394_HCControl_postedWriteEnable</span><span class="p">);</span>
	<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">lps</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">lps</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlSet</span><span class="p">)</span> <span class="o">&amp;</span>
		      <span class="n">OHCI1394_HCControl_LPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;failed to set Link Power Status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">QUIRK_TI_SLLZ059</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">probe_tsb41ba3d</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;local TSB41BA3D phy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QUIRK_TI_SLLZ059</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlClear</span><span class="p">,</span>
		  <span class="n">OHCI1394_HCControl_noByteSwapData</span><span class="p">);</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_SelfIDBuffer</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_bus</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_LinkControlSet</span><span class="p">,</span>
		  <span class="n">OHCI1394_LinkControl_cycleTimerEnable</span> <span class="o">|</span>
		  <span class="n">OHCI1394_LinkControl_cycleMaster</span><span class="p">);</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_ATRetries</span><span class="p">,</span>
		  <span class="n">OHCI1394_MAX_AT_REQ_RETRIES</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">OHCI1394_MAX_AT_RESP_RETRIES</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="n">OHCI1394_MAX_PHYS_RESP_RETRIES</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		  <span class="p">(</span><span class="mi">200</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>

	<span class="n">seconds</span> <span class="o">=</span> <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">get_seconds</span><span class="p">());</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsochronousCycleTimer</span><span class="p">,</span> <span class="n">seconds</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_time</span> <span class="o">=</span> <span class="n">seconds</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3f</span><span class="p">;</span>

	<span class="n">version</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_Version</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ff00ff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="n">OHCI_VERSION_1_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_InitialChannelsAvailableHi</span><span class="p">,</span>
			  <span class="mh">0xfffffffe</span><span class="p">);</span>
		<span class="n">card</span><span class="o">-&gt;</span><span class="n">broadcast_channel_auto_allocated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get implemented bits of the priority arbitration request counter. */</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_FairnessControl</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">pri_req_max</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_FairnessControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_FairnessControl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">priority_budget_implemented</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">pri_req_max</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyUpperBound</span><span class="p">,</span> <span class="mh">0x00010000</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntEventClear</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntMaskClear</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">configure_1394a_enhancements</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Activate link_on bit and contender bit in our self ID packets.*/</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ohci_update_phy_reg</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PHY_LINK_ACTIVE</span> <span class="o">|</span> <span class="n">PHY_CONTENDER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the link is not yet enabled, the atomic config rom</span>
<span class="cm">	 * update mechanism described below in ohci_set_config_rom()</span>
<span class="cm">	 * is not active.  We have to update ConfigRomHeader and</span>
<span class="cm">	 * BusOptions manually, and the write to ConfigROMmap takes</span>
<span class="cm">	 * effect immediately.  We tie this to the enabling of the</span>
<span class="cm">	 * link, so we have a valid config rom before enabling - the</span>
<span class="cm">	 * OHCI requires that ConfigROMhdr and BusOptions have valid</span>
<span class="cm">	 * values before enabling.</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, when the ConfigROMmap is written, some controllers</span>
<span class="cm">	 * always read back quadlets 0 and 2 from the config rom to</span>
<span class="cm">	 * the ConfigRomHeader and BusOptions registers on bus reset.</span>
<span class="cm">	 * They shouldn&#39;t do that in this initial case where the link</span>
<span class="cm">	 * isn&#39;t enabled.  This means we have to use the same</span>
<span class="cm">	 * workaround here, setting the bus header to 0 and then write</span>
<span class="cm">	 * the right values in the bus reset tasklet.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config_rom</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">=</span>
			<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span><span class="p">,</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">copy_config_rom</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">,</span> <span class="n">config_rom</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In the suspend case, config_rom is NULL, which</span>
<span class="cm">		 * means that we just reuse the old config rom.</span>
<span class="cm">		 */</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom_bus</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_header</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_ConfigROMhdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_BusOptions</span><span class="p">,</span>
		  <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_ConfigROMmap</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span><span class="p">);</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_AsReqFilterHiSet</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">QUIRK_NO_MSI</span><span class="p">))</span>
		<span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">,</span>
			<span class="n">pci_dev_msi_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">ohci_driver_name</span><span class="p">,</span> <span class="n">ohci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;failed to allocate interrupt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">config_rom</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">,</span>
					  <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">,</span>
					  <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span><span class="p">);</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">irqs</span> <span class="o">=</span>	<span class="n">OHCI1394_reqTxComplete</span> <span class="o">|</span> <span class="n">OHCI1394_respTxComplete</span> <span class="o">|</span>
		<span class="n">OHCI1394_RQPkt</span> <span class="o">|</span> <span class="n">OHCI1394_RSPkt</span> <span class="o">|</span>
		<span class="n">OHCI1394_isochTx</span> <span class="o">|</span> <span class="n">OHCI1394_isochRx</span> <span class="o">|</span>
		<span class="n">OHCI1394_postedWriteErr</span> <span class="o">|</span>
		<span class="n">OHCI1394_selfIDComplete</span> <span class="o">|</span>
		<span class="n">OHCI1394_regAccessFail</span> <span class="o">|</span>
		<span class="n">OHCI1394_cycle64Seconds</span> <span class="o">|</span>
		<span class="n">OHCI1394_cycleInconsistent</span> <span class="o">|</span>
		<span class="n">OHCI1394_unrecoverableError</span> <span class="o">|</span>
		<span class="n">OHCI1394_cycleTooLong</span> <span class="o">|</span>
		<span class="n">OHCI1394_masterIntEnable</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param_debug</span> <span class="o">&amp;</span> <span class="n">OHCI_PARAM_DEBUG_BUSRESETS</span><span class="p">)</span>
		<span class="n">irqs</span> <span class="o">|=</span> <span class="n">OHCI1394_busReset</span><span class="p">;</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntMaskSet</span><span class="p">,</span> <span class="n">irqs</span><span class="p">);</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_HCControlSet</span><span class="p">,</span>
		  <span class="n">OHCI1394_HCControl_linkEnable</span> <span class="o">|</span>
		  <span class="n">OHCI1394_HCControl_BIBimageValid</span><span class="p">);</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_LinkControlSet</span><span class="p">,</span>
		  <span class="n">OHCI1394_LinkControl_rcvSelfID</span> <span class="o">|</span>
		  <span class="n">OHCI1394_LinkControl_rcvPhyPkt</span><span class="p">);</span>

	<span class="n">ar_context_run</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_request_ctx</span><span class="p">);</span>
	<span class="n">ar_context_run</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_response_ctx</span><span class="p">);</span>

	<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="cm">/* We are ready to go, reset bus to finish initialization. */</span>
	<span class="n">fw_schedule_bus_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_set_config_rom</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">config_rom</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">next_config_rom</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">next_config_rom_bus</span><span class="p">);</span>

	<span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the OHCI controller is enabled, the config rom update</span>
<span class="cm">	 * mechanism is a bit tricky, but easy enough to use.  See</span>
<span class="cm">	 * section 5.5.6 in the OHCI specification.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The OHCI controller caches the new config rom address in a</span>
<span class="cm">	 * shadow register (ConfigROMmapNext) and needs a bus reset</span>
<span class="cm">	 * for the changes to take place.  When the bus reset is</span>
<span class="cm">	 * detected, the controller loads the new values for the</span>
<span class="cm">	 * ConfigRomHeader and BusOptions registers from the specified</span>
<span class="cm">	 * config rom and loads ConfigROMmap from the ConfigROMmapNext</span>
<span class="cm">	 * shadow register. All automatically and atomically.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Now, there&#39;s a twist to this story.  The automatic load of</span>
<span class="cm">	 * ConfigRomHeader and BusOptions doesn&#39;t honor the</span>
<span class="cm">	 * noByteSwapData bit, so with a be32 config rom, the</span>
<span class="cm">	 * controller will load be32 values in to these registers</span>
<span class="cm">	 * during the atomic update, even on litte endian</span>
<span class="cm">	 * architectures.  The workaround we use is to put a 0 in the</span>
<span class="cm">	 * header quadlet; 0 is endian agnostic and means that the</span>
<span class="cm">	 * config rom isn&#39;t ready yet.  In the bus reset tasklet we</span>
<span class="cm">	 * then set up the real values for the two registers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We use ohci-&gt;lock to avoid racing with the code that sets</span>
<span class="cm">	 * ohci-&gt;next_config_rom to NULL (see bus_reset_work).</span>
<span class="cm">	 */</span>

	<span class="n">next_config_rom</span> <span class="o">=</span>
		<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">next_config_rom_bus</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_config_rom</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is not an already pending config_rom update,</span>
<span class="cm">	 * push our new allocation into the ohci-&gt;next_config_rom</span>
<span class="cm">	 * and then mark the local variable as null so that we</span>
<span class="cm">	 * won&#39;t deallocate the new buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * OTOH, if there is a pending config_rom update, just</span>
<span class="cm">	 * use that buffer with the new config_rom data, and</span>
<span class="cm">	 * let this routine free the unused DMA allocation.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">=</span> <span class="n">next_config_rom</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span> <span class="o">=</span> <span class="n">next_config_rom_bus</span><span class="p">;</span>
		<span class="n">next_config_rom</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">copy_config_rom</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">,</span> <span class="n">config_rom</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_header</span> <span class="o">=</span> <span class="n">config_rom</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_ConfigROMmap</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* If we didn&#39;t use the DMA allocation, delete it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_config_rom</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">,</span>
				  <span class="n">next_config_rom</span><span class="p">,</span> <span class="n">next_config_rom_bus</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now initiate a bus reset to have the changes take</span>
<span class="cm">	 * effect. We clean up the old config rom memory and DMA</span>
<span class="cm">	 * mappings in the bus reset tasklet, since the OHCI</span>
<span class="cm">	 * controller could need to access it before the bus reset</span>
<span class="cm">	 * takes effect.</span>
<span class="cm">	 */</span>

	<span class="n">fw_schedule_bus_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>

	<span class="n">at_context_transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_send_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>

	<span class="n">at_context_transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_cancel_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_mapped</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_bus</span><span class="p">,</span>
				 <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="n">log_ar_at_event</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
	<span class="n">driver_data</span><span class="o">-&gt;</span><span class="n">packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="n">RCODE_CANCELLED</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_enable_phys_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">node_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">generation</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FIREWIRE_OHCI_REMOTE_DMA</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME:  Make sure this bitmask is cleared when we clear the busReset</span>
<span class="cm">	 * interrupt bit.  Clear physReqResourceAllBuses on bus reset.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note, if the node ID contains a non-local bus ID, physical DMA is</span>
<span class="cm">	 * enabled for _all_ nodes on remote buses.</span>
<span class="cm">	 */</span>

	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_id</span> <span class="o">&amp;</span> <span class="mh">0xffc0</span><span class="p">)</span> <span class="o">==</span> <span class="n">LOCAL_BUS</span> <span class="o">?</span> <span class="n">node_id</span> <span class="o">&amp;</span> <span class="mh">0x3f</span> <span class="o">:</span> <span class="mi">63</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyReqFilterLoSet</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_PhyReqFilterHiSet</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">32</span><span class="p">));</span>

	<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FIREWIRE_OHCI_REMOTE_DMA */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">ohci_read_csr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csr_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">csr_offset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CSR_STATE_CLEAR</span>:
	<span class="k">case</span> <span class="n">CSR_STATE_SET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">is_root</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_LinkControlSet</span><span class="p">)</span> <span class="o">&amp;</span>
		     <span class="n">OHCI1394_LinkControl_cycleMaster</span><span class="p">))</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">CSR_STATE_BIT_CMSTR</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">csr_state_setclear_abdicate</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">|=</span> <span class="n">CSR_STATE_BIT_ABDICATE</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_NODE_IDS</span>:
		<span class="k">return</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_NodeID</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_CYCLE_TIME</span>:
		<span class="k">return</span> <span class="n">get_cycle_time</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">CSR_BUS_TIME</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We might be called just after the cycle timer has wrapped</span>
<span class="cm">		 * around but just before the cycle64Seconds handler, so we</span>
<span class="cm">		 * better check here, too, if the bus time needs to be updated.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">update_bus_time</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_BUSY_TIMEOUT</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_ATRetries</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ffff00f</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_PRIORITY_BUDGET</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_FairnessControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">pri_req_max</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_write_csr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="kt">int</span> <span class="n">csr_offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">csr_offset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CSR_STATE_CLEAR</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">CSR_STATE_BIT_CMSTR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">is_root</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_LinkControlClear</span><span class="p">,</span>
				  <span class="n">OHCI1394_LinkControl_cycleMaster</span><span class="p">);</span>
			<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">CSR_STATE_BIT_ABDICATE</span><span class="p">)</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">csr_state_setclear_abdicate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_STATE_SET</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">CSR_STATE_BIT_CMSTR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">is_root</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_LinkControlSet</span><span class="p">,</span>
				  <span class="n">OHCI1394_LinkControl_cycleMaster</span><span class="p">);</span>
			<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">CSR_STATE_BIT_ABDICATE</span><span class="p">)</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">csr_state_setclear_abdicate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_NODE_IDS</span>:
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_NodeID</span><span class="p">,</span> <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_CYCLE_TIME</span>:
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsochronousCycleTimer</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntEventSet</span><span class="p">,</span>
			  <span class="n">OHCI1394_cycleInconsistent</span><span class="p">);</span>
		<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_BUS_TIME</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_time</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x7f</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_BUSY_TIMEOUT</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x0ffff000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_ATRetries</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CSR_PRIORITY_BUDGET</span>:
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_FairnessControl</span><span class="p">,</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
		<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_iso_completions</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">callback</span><span class="p">.</span><span class="n">sc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_timestamp</span><span class="p">,</span>
			      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span>
			      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">callback_data</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_iso_headers</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dma_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">ctx_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">flush_iso_completions</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">ctx_hdr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_timestamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">((</span><span class="n">__force</span> <span class="n">__le32</span><span class="p">)</span><span class="n">dma_hdr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The two iso header quadlets are byteswapped to little</span>
<span class="cm">	 * endian by the controller, but we want to present them</span>
<span class="cm">	 * as big endian for consistency with the bus endianness.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctx_hdr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">dma_hdr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="cm">/* iso packet header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">ctx_hdr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">swab32</span><span class="p">(</span><span class="n">dma_hdr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="cm">/* timestamp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_hdr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dma_hdr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">+=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_ir_packet_per_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buffer_dma</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pd</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="n">pd</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="n">pd</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">transfer_status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
		<span class="cm">/* Descriptor(s) not done yet, stop iteration */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">d</span><span class="o">++</span><span class="p">;</span>
		<span class="n">buffer_dma</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">data_address</span><span class="p">);</span>
		<span class="n">dma_sync_single_range_for_cpu</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					      <span class="n">buffer_dma</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
					      <span class="n">buffer_dma</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span>
					      <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">req_count</span><span class="p">),</span>
					      <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">copy_iso_headers</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_IRQ_ALWAYS</span><span class="p">))</span>
		<span class="n">flush_iso_completions</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* d == last because each descriptor block is only a single descriptor. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_ir_buffer_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req_count</span><span class="p">,</span> <span class="n">res_count</span><span class="p">,</span> <span class="n">completed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buffer_dma</span><span class="p">;</span>

	<span class="n">req_count</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">req_count</span><span class="p">);</span>
	<span class="n">res_count</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">res_count</span><span class="p">));</span>
	<span class="n">completed</span> <span class="o">=</span> <span class="n">req_count</span> <span class="o">-</span> <span class="n">res_count</span><span class="p">;</span>
	<span class="n">buffer_dma</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">data_address</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">completed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_buffer_bus</span> <span class="o">=</span> <span class="n">buffer_dma</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_completed</span> <span class="o">=</span> <span class="n">completed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Descriptor(s) not done yet, stop iteration */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dma_sync_single_range_for_cpu</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
				      <span class="n">buffer_dma</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
				      <span class="n">buffer_dma</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span>
				      <span class="n">completed</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_IRQ_ALWAYS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">callback</span><span class="p">.</span><span class="n">mc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
				      <span class="n">buffer_dma</span> <span class="o">+</span> <span class="n">completed</span><span class="p">,</span>
				      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">callback_data</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_ir_buffer_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_sync_single_range_for_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
				      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_buffer_bus</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
				      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_buffer_bus</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span>
				      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_completed</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">callback</span><span class="p">.</span><span class="n">mc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
			      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_buffer_bus</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_completed</span><span class="p">,</span>
			      <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">callback_data</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sync_it_packet_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le16</span> <span class="n">control</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">buffer_dma</span><span class="p">;</span>

	<span class="cm">/* only packets beginning with OUTPUT_MORE* have data buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* skip over the OUTPUT_MORE_IMMEDIATE descriptor */</span>
	<span class="n">pd</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the packet has a header, the first OUTPUT_MORE/LAST descriptor&#39;s</span>
<span class="cm">	 * data buffer is in the context program&#39;s coherent page and must not</span>
<span class="cm">	 * be synced.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">data_address</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">current_bus</span>          <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">pd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">buffer_dma</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">data_address</span><span class="p">);</span>
		<span class="n">dma_sync_single_range_for_cpu</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					      <span class="n">buffer_dma</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
					      <span class="n">buffer_dma</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span>
					      <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">req_count</span><span class="p">),</span>
					      <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">;</span>
		<span class="n">pd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_it_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">ctx_hdr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pd</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="n">pd</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="n">pd</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">transfer_status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
		<span class="cm">/* Descriptor(s) not done yet, stop iteration */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sync_it_packet_for_cpu</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">flush_iso_completions</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">ctx_hdr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_timestamp</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">res_count</span><span class="p">);</span>
	<span class="cm">/* Present this value as big-endian to match the receive code */</span>
	<span class="o">*</span><span class="n">ctx_hdr</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">((</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">transfer_status</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">res_count</span><span class="p">));</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_IRQ_ALWAYS</span><span class="p">))</span>
		<span class="n">flush_iso_completions</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_multichannel_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">,</span> <span class="n">u64</span> <span class="n">channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">channels</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">channels</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IRMultiChanMaskHiClear</span><span class="p">,</span> <span class="o">~</span><span class="n">hi</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IRMultiChanMaskLoClear</span><span class="p">,</span> <span class="o">~</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IRMultiChanMaskHiSet</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IRMultiChanMaskLoSet</span><span class="p">,</span> <span class="n">lo</span><span class="p">);</span>
	<span class="n">mmiowb</span><span class="p">();</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_channels</span> <span class="o">=</span> <span class="n">channels</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="nf">ohci_allocate_iso_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">header_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">descriptor_callback_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">channels</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_TRANSMIT</span>:
		<span class="n">mask</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_mask</span><span class="p">;</span>
		<span class="n">callback</span> <span class="o">=</span> <span class="n">handle_it_packet</span><span class="p">;</span>
		<span class="n">index</span>    <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">regs</span> <span class="o">=</span> <span class="n">OHCI1394_IsoXmitContextBase</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
			<span class="n">ctx</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE</span>:
		<span class="n">channels</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_channels</span><span class="p">;</span>
		<span class="n">mask</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_mask</span><span class="p">;</span>
		<span class="n">callback</span> <span class="o">=</span> <span class="n">handle_ir_packet_per_buffer</span><span class="p">;</span>
		<span class="n">index</span>    <span class="o">=</span> <span class="o">*</span><span class="n">channels</span> <span class="o">&amp;</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span> <span class="o">?</span> <span class="n">ffs</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">channels</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="p">);</span>
			<span class="o">*</span><span class="n">mask</span>     <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">regs</span> <span class="o">=</span> <span class="n">OHCI1394_IsoRcvContextBase</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
			<span class="n">ctx</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:
		<span class="n">mask</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_mask</span><span class="p">;</span>
		<span class="n">callback</span> <span class="o">=</span> <span class="n">handle_ir_buffer_fill</span><span class="p">;</span>
		<span class="n">index</span>    <span class="o">=</span> <span class="o">!</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_allocated</span> <span class="o">?</span> <span class="n">ffs</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_allocated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="o">*</span><span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">regs</span> <span class="o">=</span> <span class="n">OHCI1394_IsoRcvContextBase</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
			<span class="n">ctx</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">));</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">ohci</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_with_header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_multichannel_mask</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

 <span class="nl">out_with_header:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE</span>:
		<span class="o">*</span><span class="n">channels</span> <span class="o">|=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_allocated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_start_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			  <span class="n">s32</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sync</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ohci</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">control</span> <span class="o">=</span> <span class="n">IR_CONTEXT_ISOCH_HEADER</span><span class="p">,</span> <span class="n">match</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* the controller cannot start without any queued packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">branch_address</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_TRANSMIT</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">;</span>
		<span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cycle</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">match</span> <span class="o">=</span> <span class="n">IT_CONTEXT_CYCLE_MATCH_ENABLE</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">cycle</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntEventClear</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntMaskSet</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">context_run</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">match</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:
		<span class="n">control</span> <span class="o">|=</span> <span class="n">IR_CONTEXT_BUFFER_FILL</span><span class="o">|</span><span class="n">IR_CONTEXT_MULTI_CHANNEL_MODE</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">;</span>
		<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">tags</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">sync</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">channel</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cycle</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">match</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cycle</span> <span class="o">&amp;</span> <span class="mh">0x07fff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>
			<span class="n">control</span> <span class="o">|=</span> <span class="n">IR_CONTEXT_CYCLE_MATCH_ENABLE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntEventClear</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntMaskSet</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTEXT_MATCH</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">regs</span><span class="p">),</span> <span class="n">match</span><span class="p">);</span>
		<span class="n">context_run</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="n">sync</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tags</span> <span class="o">=</span> <span class="n">tags</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_stop_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_TRANSMIT</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">;</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntMaskClear</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE</span>:
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">;</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntMaskClear</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">context_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_free_iso_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">ohci_stop_iso</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="n">context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_TRANSMIT</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_channels</span> <span class="o">|=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_channels</span> <span class="o">|=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_channels</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_channels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_allocated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_set_iso_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">fw_ohci</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Don&#39;t allow multichannel to grab other contexts&#39; channels. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_channels</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">mc_channels</span> <span class="o">&amp;</span> <span class="o">*</span><span class="n">channels</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">channels</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_channels</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_multichannel_mask</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="o">*</span><span class="n">channels</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_resume_iso_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_ir</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">running</span><span class="p">)</span>
			<span class="n">ohci_start_iso</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_it</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">running</span><span class="p">)</span>
			<span class="n">ohci_start_iso</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_iso_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">fw_iso_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">fw_iso_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_iso_packet</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">d_bus</span><span class="p">,</span> <span class="n">page_bus</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">z</span><span class="p">,</span> <span class="n">header_z</span><span class="p">,</span> <span class="n">payload_z</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">payload_index</span><span class="p">,</span> <span class="n">payload_end_index</span><span class="p">,</span> <span class="n">next_page_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">end_page</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">packet</span><span class="p">;</span>
	<span class="n">payload_index</span> <span class="o">=</span> <span class="n">payload</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span>
		<span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">z</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">z</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Determine the first page the payload isn&#39;t contained in. */</span>
	<span class="n">end_page</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">payload_index</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">payload_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">payload_z</span> <span class="o">=</span> <span class="n">end_page</span> <span class="o">-</span> <span class="p">(</span><span class="n">payload_index</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">payload_z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">z</span> <span class="o">+=</span> <span class="n">payload_z</span><span class="p">;</span>

	<span class="cm">/* Get header size in number of descriptors. */</span>
	<span class="n">header_z</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">));</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">context_get_descriptors</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">header_z</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">control</span>   <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_KEY_IMMEDIATE</span><span class="p">);</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">req_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Link the skip address to this descriptor itself.  This causes</span>
<span class="cm">		 * a context to skip a cycle whenever lost cycles or FIFO</span>
<span class="cm">		 * overruns occur, without dropping the data.  The application</span>
<span class="cm">		 * should then decide whether this is an error condition or not.</span>
<span class="cm">		 * FIXME:  Make the context&#39;s cycle-lost behaviour configurable?</span>
<span class="cm">		 */</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">branch_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">d_bus</span> <span class="o">|</span> <span class="n">z</span><span class="p">);</span>

		<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">IT_HEADER_SY</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sy</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">IT_HEADER_TAG</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">IT_HEADER_TCODE</span><span class="p">(</span><span class="n">TCODE_STREAM_DATA</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">IT_HEADER_CHANNEL</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">channel</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">IT_HEADER_SPEED</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">speed</span><span class="p">));</span>
		<span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">IT_HEADER_DATA_LENGTH</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">+</span>
							  <span class="n">p</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">req_count</span>    <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">);</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">data_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">d_bus</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">z</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="n">payload_z</span><span class="p">;</span>
	<span class="n">payload_end_index</span> <span class="o">=</span> <span class="n">payload_index</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">payload_z</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span>               <span class="o">=</span> <span class="n">payload_index</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">offset</span>             <span class="o">=</span> <span class="n">payload_index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">next_page_index</span>    <span class="o">=</span> <span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">length</span>             <span class="o">=</span>
			<span class="n">min</span><span class="p">(</span><span class="n">next_page_index</span><span class="p">,</span> <span class="n">payload_end_index</span><span class="p">)</span> <span class="o">-</span> <span class="n">payload_index</span><span class="p">;</span>
		<span class="n">pd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">req_count</span>    <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>

		<span class="n">page_bus</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page</span><span class="p">]);</span>
		<span class="n">pd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">page_bus</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

		<span class="n">dma_sync_single_range_for_device</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
						 <span class="n">page_bus</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
						 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

		<span class="n">payload_index</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">)</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">DESCRIPTOR_IRQ_ALWAYS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">DESCRIPTOR_NO_IRQ</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">d</span> <span class="o">:</span> <span class="n">d</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">last</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_OUTPUT_LAST</span> <span class="o">|</span>
				     <span class="n">DESCRIPTOR_STATUS</span> <span class="o">|</span>
				     <span class="n">DESCRIPTOR_BRANCH_ALWAYS</span> <span class="o">|</span>
				     <span class="n">irq</span><span class="p">);</span>

	<span class="n">context_append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">header_z</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_iso_packet_per_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">fw_iso_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">fw_iso_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">d_bus</span><span class="p">,</span> <span class="n">page_bus</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">z</span><span class="p">,</span> <span class="n">header_z</span><span class="p">,</span> <span class="n">rest</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">packet_count</span><span class="p">,</span> <span class="n">header_size</span><span class="p">,</span> <span class="n">payload_per_buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The OHCI controller puts the isochronous header and trailer in the</span>
<span class="cm">	 * buffer, so we need at least 8 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">packet_count</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">/</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span><span class="p">;</span>
	<span class="n">header_size</span>  <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">header_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* Get header size in number of descriptors. */</span>
	<span class="n">header_z</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">header_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">));</span>
	<span class="n">page</span>     <span class="o">=</span> <span class="n">payload</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">offset</span>   <span class="o">=</span> <span class="n">payload</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">payload_per_buffer</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span> <span class="o">/</span> <span class="n">packet_count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packet_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* d points to the header descriptor */</span>
		<span class="n">z</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">payload_per_buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">context_get_descriptors</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span>
				<span class="n">z</span> <span class="o">+</span> <span class="n">header_z</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_bus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span>      <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_STATUS</span> <span class="o">|</span>
					      <span class="n">DESCRIPTOR_INPUT_MORE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_WAIT</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">req_count</span>    <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">header_size</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">res_count</span>    <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">req_count</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">transfer_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">data_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">d_bus</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)));</span>

		<span class="n">rest</span> <span class="o">=</span> <span class="n">payload_per_buffer</span><span class="p">;</span>
		<span class="n">pd</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pd</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_STATUS</span> <span class="o">|</span>
						  <span class="n">DESCRIPTOR_INPUT_MORE</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">rest</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
				<span class="n">length</span> <span class="o">=</span> <span class="n">rest</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">length</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">req_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">res_count</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">req_count</span><span class="p">;</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">transfer_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">page_bus</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page</span><span class="p">]);</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">data_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">page_bus</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

			<span class="n">dma_sync_single_range_for_device</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">page_bus</span><span class="p">,</span>
							 <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
							 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

			<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
			<span class="n">rest</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_STATUS</span> <span class="o">|</span>
					  <span class="n">DESCRIPTOR_INPUT_LAST</span> <span class="o">|</span>
					  <span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">interrupt</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">packet_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_IRQ_ALWAYS</span><span class="p">);</span>

		<span class="n">context_append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">header_z</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_iso_buffer_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">fw_iso_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">fw_iso_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">descriptor</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">d_bus</span><span class="p">,</span> <span class="n">page_bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">page</span>   <span class="o">=</span> <span class="n">payload</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">payload</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">rest</span>   <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_length</span><span class="p">;</span>

	<span class="cm">/* We need one descriptor for each page in the buffer. */</span>
	<span class="n">z</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">rest</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">rest</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">page</span> <span class="o">+</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">context_get_descriptors</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_bus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_INPUT_MORE</span> <span class="o">|</span>
					 <span class="n">DESCRIPTOR_BRANCH_ALWAYS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_WAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">interrupt</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DESCRIPTOR_IRQ_ALWAYS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">rest</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">rest</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">req_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">res_count</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">req_count</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">transfer_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">page_bus</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page</span><span class="p">]);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">data_address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">page_bus</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

		<span class="n">dma_sync_single_range_for_device</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
						 <span class="n">page_bus</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

		<span class="n">rest</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">page</span><span class="o">++</span><span class="p">;</span>

		<span class="n">context_append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_queue_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">fw_iso_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">fw_iso_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_TRANSMIT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">queue_iso_transmit</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">queue_iso_packet_per_buffer</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">queue_iso_buffer_fill</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ohci_flush_queue_iso</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ohci</span><span class="p">,</span> <span class="n">CONTROL_SET</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="n">CONTEXT_WAKE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ohci_flush_iso_completions</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_iso_context</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iso_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iso_context</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tasklet_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit_lock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flushing_completions</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">context_tasklet</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_TRANSMIT</span>:
		<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">flush_iso_completions</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mc_completed</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">flush_ir_buffer_fill</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">clear_bit_unlock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flushing_completions</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">tasklet_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fw_card_driver</span> <span class="n">ohci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>			<span class="o">=</span> <span class="n">ohci_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_phy_reg</span>		<span class="o">=</span> <span class="n">ohci_read_phy_reg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_phy_reg</span>		<span class="o">=</span> <span class="n">ohci_update_phy_reg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_config_rom</span>		<span class="o">=</span> <span class="n">ohci_set_config_rom</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_request</span>		<span class="o">=</span> <span class="n">ohci_send_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_response</span>		<span class="o">=</span> <span class="n">ohci_send_response</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cancel_packet</span>		<span class="o">=</span> <span class="n">ohci_cancel_packet</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_phys_dma</span>	<span class="o">=</span> <span class="n">ohci_enable_phys_dma</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_csr</span>		<span class="o">=</span> <span class="n">ohci_read_csr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_csr</span>		<span class="o">=</span> <span class="n">ohci_write_csr</span><span class="p">,</span>

	<span class="p">.</span><span class="n">allocate_iso_context</span>	<span class="o">=</span> <span class="n">ohci_allocate_iso_context</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_iso_context</span>	<span class="o">=</span> <span class="n">ohci_free_iso_context</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_iso_channels</span>	<span class="o">=</span> <span class="n">ohci_set_iso_channels</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queue_iso</span>		<span class="o">=</span> <span class="n">ohci_queue_iso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_queue_iso</span>	<span class="o">=</span> <span class="n">ohci_flush_queue_iso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_iso_completions</span>	<span class="o">=</span> <span class="n">ohci_flush_iso_completions</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_iso</span>		<span class="o">=</span> <span class="n">ohci_start_iso</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_iso</span>		<span class="o">=</span> <span class="n">ohci_stop_iso</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PPC_PMAC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmac_ohci_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">machine_is</span><span class="p">(</span><span class="n">powermac</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ofn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_1394_CABLE_POWER</span><span class="p">,</span> <span class="n">ofn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_1394_ENABLE</span><span class="p">,</span> <span class="n">ofn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmac_ohci_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">machine_is</span><span class="p">(</span><span class="n">powermac</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ofn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_1394_ENABLE</span><span class="p">,</span> <span class="n">ofn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_1394_CABLE_POWER</span><span class="p">,</span> <span class="n">ofn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmac_ohci_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmac_ohci_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_PMAC */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bus_options</span><span class="p">,</span> <span class="n">max_receive</span><span class="p">,</span> <span class="n">link_speed</span><span class="p">,</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_PINNACLE_SYSTEMS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pinnacle MovieBoard is not yet supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ohci</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ohci</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fw_card_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohci_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pmac_ohci_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to enable OHCI hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">OHCI1394_PCI_HCI_Control</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ohci</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">phy_reg_mutex</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_reset_work</span><span class="p">,</span> <span class="n">bus_reset_work</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ohci_driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MMIO resource unavailable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_disable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">registers</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">OHCI1394_REGISTER_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">registers</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to remap registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_iomem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ohci_quirks</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ohci_quirks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ohci_quirks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">device</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">PCI_ANY_ID</span> <span class="o">||</span>
		     <span class="n">ohci_quirks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">device</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ohci_quirks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">revision</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">PCI_ANY_ID</span> <span class="o">||</span>
		     <span class="n">ohci_quirks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">=</span> <span class="n">ohci_quirks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param_quirks</span><span class="p">)</span>
		<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">=</span> <span class="n">param_quirks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because dma_alloc_coherent() allocates at least one page,</span>
<span class="cm">	 * we save space by using a common buffer for the AR request/</span>
<span class="cm">	 * response descriptors and the self IDs buffer.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">AR_BUFFERS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">descriptor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SELF_ID_BUF_SIZE</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
					       <span class="n">PAGE_SIZE</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer_bus</span><span class="p">,</span>
					       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ar_context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_request_ctx</span><span class="p">,</span> <span class="n">ohci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">OHCI1394_AsReqRcvContextControlSet</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_misc_buf</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ar_context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_response_ctx</span><span class="p">,</span> <span class="n">ohci</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span>
			      <span class="n">OHCI1394_AsRspRcvContextControlSet</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_arreq_ctx</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">,</span> <span class="n">ohci</span><span class="p">,</span>
			   <span class="n">OHCI1394_AsReqTrContextControlSet</span><span class="p">,</span> <span class="n">handle_at_packet</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_arrsp_ctx</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">context_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">,</span> <span class="n">ohci</span><span class="p">,</span>
			   <span class="n">OHCI1394_AsRspTrContextControlSet</span><span class="p">,</span> <span class="n">handle_at_packet</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_atreq_ctx</span><span class="p">;</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntMaskSet</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_channels</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_support</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntMaskSet</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoRecvIntMaskClear</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_mask</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_support</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_ir</span> <span class="o">=</span> <span class="n">hweight32</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_mask</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span><span class="p">)</span> <span class="o">*</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_ir</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntMaskSet</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_support</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntMaskSet</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IsoXmitIntMaskClear</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_mask</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_support</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_it</span> <span class="o">=</span> <span class="n">hweight32</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_mask</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iso_context</span><span class="p">)</span> <span class="o">*</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_it</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_contexts</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_cpu</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer</span>     <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">ohci</span><span class="o">-&gt;</span><span class="n">self_id_bus</span> <span class="o">=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer_bus</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

	<span class="n">bus_options</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_BusOptions</span><span class="p">);</span>
	<span class="n">max_receive</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus_options</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">link_speed</span> <span class="o">=</span> <span class="n">bus_options</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">guid</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_GUIDHi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_GUIDLo</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fw_card_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">max_receive</span><span class="p">,</span> <span class="n">link_speed</span><span class="p">,</span> <span class="n">guid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_contexts</span><span class="p">;</span>

	<span class="n">version</span> <span class="o">=</span> <span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_Version</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ff00ff</span><span class="p">;</span>
	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		  <span class="s">&quot;added OHCI v%x.%x device as card %d, &quot;</span>
		  <span class="s">&quot;%d IR + %d IT contexts, quirks 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">version</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">index</span><span class="p">,</span>
		  <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_ir</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">n_it</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail_contexts:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">);</span>
	<span class="n">context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">);</span>
 <span class="nl">fail_atreq_ctx:</span>
	<span class="n">context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">);</span>
 <span class="nl">fail_arrsp_ctx:</span>
	<span class="n">ar_context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_response_ctx</span><span class="p">);</span>
 <span class="nl">fail_arreq_ctx:</span>
	<span class="n">ar_context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_request_ctx</span><span class="p">);</span>
 <span class="nl">fail_misc_buf:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			  <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer_bus</span><span class="p">);</span>
 <span class="nl">fail_iounmap:</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">registers</span><span class="p">);</span>
 <span class="nl">fail_iomem:</span>
	<span class="n">pci_release_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
 <span class="nl">fail_disable:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">fail_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">pmac_ohci_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span><span class="p">;</span>

	<span class="n">ohci</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_IntMaskClear</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">flush_writes</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">bus_reset_work</span><span class="p">);</span>
	<span class="n">fw_core_remove_card</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Fail all pending packets here, now that the upper</span>
<span class="cm">	 * layers can&#39;t queue any more.</span>
<span class="cm">	 */</span>

	<span class="n">software_reset</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ohci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">&amp;&amp;</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span> <span class="o">!=</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">,</span>
				  <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">next_config_rom_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">CONFIG_ROM_SIZE</span><span class="p">,</span>
				  <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">config_rom_bus</span><span class="p">);</span>
	<span class="n">ar_context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_request_ctx</span><span class="p">);</span>
	<span class="n">ar_context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ar_response_ctx</span><span class="p">);</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			  <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">misc_buffer_bus</span><span class="p">);</span>
	<span class="n">context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_request_ctx</span><span class="p">);</span>
	<span class="n">context_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">at_response_ctx</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">it_context_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">ir_context_list</span><span class="p">);</span>
	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ohci</span><span class="o">-&gt;</span><span class="n">registers</span><span class="p">);</span>
	<span class="n">pci_release_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">pmac_ohci_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;removed fw-ohci device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">software_reset</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ohci</span><span class="p">);</span>
	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_save_state failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_set_power_state failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">pmac_ohci_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_ohci</span> <span class="o">*</span><span class="n">ohci</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pmac_ohci_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_enable_device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Some systems don&#39;t setup GUID register on resume from ram  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_GUIDLo</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">reg_read</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_GUIDHi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_GUIDLo</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">guid</span><span class="p">);</span>
		<span class="n">reg_write</span><span class="p">(</span><span class="n">ohci</span><span class="p">,</span> <span class="n">OHCI1394_GUIDHi</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">.</span><span class="n">guid</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ohci_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ohci</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ohci_resume_iso_dma</span><span class="p">(</span><span class="n">ohci</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">pci_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE_CLASS</span><span class="p">(</span><span class="n">PCI_CLASS_SERIAL_FIREWIRE_OHCI</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">fw_ohci_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">ohci_driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">pci_remove</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">pci_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">pci_suspend</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="n">module_pci_driver</span><span class="p">(</span><span class="n">fw_ohci_pci_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Kristian Hoegsberg &lt;krh@bitplanet.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for PCI OHCI IEEE1394 controllers&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* Provide a module alias so root-on-sbp2 initrds don&#39;t break. */</span>
<span class="cp">#ifndef CONFIG_IEEE1394_OHCI1394_MODULE</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;ohci1394&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
