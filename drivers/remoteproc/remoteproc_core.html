<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › remoteproc › remoteproc_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>remoteproc_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Remote Processor Framework</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright (C) 2011 Google, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Ohad Ben-Cohen &lt;ohad@wizery.com&gt;</span>
<span class="cm"> * Brian Swetland &lt;swetland@google.com&gt;</span>
<span class="cm"> * Mark Grosen &lt;mgrosen@ti.com&gt;</span>
<span class="cm"> * Fernando Guzman Lugo &lt;fernando.lugo@ti.com&gt;</span>
<span class="cm"> * Suman Anna &lt;s-anna@ti.com&gt;</span>
<span class="cm"> * Robert Tivy &lt;rtivy@ti.com&gt;</span>
<span class="cm"> * Armando Uribe De Leon &lt;x0095078@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt)    &quot;%s: &quot; fmt, __func__</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/remoteproc.h&gt;</span>
<span class="cp">#include &lt;linux/iommu.h&gt;</span>
<span class="cp">#include &lt;linux/klist.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_ids.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_ring.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;remoteproc_internal.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">klist_rproc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">klist_rproc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * klist of the available remote processors.</span>
<span class="cm"> *</span>
<span class="cm"> * We need this in order to support name-based lookups (needed by the</span>
<span class="cm"> * rproc_get_by_name()).</span>
<span class="cm"> *</span>
<span class="cm"> * That said, we don&#39;t use rproc_get_by_name() at this point.</span>
<span class="cm"> * The use cases that do require its existence should be</span>
<span class="cm"> * scrutinized, and hopefully migrated to rproc_boot() using device-based</span>
<span class="cm"> * binding.</span>
<span class="cm"> *</span>
<span class="cm"> * If/when this materializes, we could drop the klist (and the by_name</span>
<span class="cm"> * API).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_KLIST</span><span class="p">(</span><span class="n">rprocs</span><span class="p">,</span> <span class="n">klist_rproc_get</span><span class="p">,</span> <span class="n">klist_rproc_put</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rproc_handle_resources_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rproc_handle_resource_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is the IOMMU fault handler we register with the IOMMU API</span>
<span class="cm"> * (when relevant; not all remote processors access memory through</span>
<span class="cm"> * an IOMMU).</span>
<span class="cm"> *</span>
<span class="cm"> * IOMMU core will invoke this handler whenever the remote processor</span>
<span class="cm"> * will try to access an unmapped device address.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently this is mostly a stub, but it will be later used to trigger</span>
<span class="cm"> * the recovery of the remote processor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rproc_iommu_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu fault: da 0x%lx flags 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let the iommu core know we&#39;re not really handling this fault;</span>
<span class="cm">	 * we just plan to use this as a recovery trigger.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rproc_enable_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We currently use iommu_present() to decide if an IOMMU</span>
<span class="cm">	 * setup is needed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This works for simple cases, but will easily fail with</span>
<span class="cm">	 * platforms that do have an IOMMU, but not for this specific</span>
<span class="cm">	 * rproc.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This will be easily solved by introducing hw capabilities</span>
<span class="cm">	 * that will be set by the remoteproc driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_present</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">iommu_domain_alloc</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t alloc iommu domain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iommu_set_fault_handler</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">rproc_iommu_fault</span><span class="p">,</span> <span class="n">rproc</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_attach_device</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t attach iommu device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_domain</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_domain:</span>
	<span class="n">iommu_domain_free</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rproc_disable_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">iommu_detach_device</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">iommu_domain_free</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some remote processors will ask us to allocate them physically contiguous</span>
<span class="cm"> * memory regions (which we call &quot;carveouts&quot;), and map them to specific</span>
<span class="cm"> * device addresses (which are hardcoded in the firmware).</span>
<span class="cm"> *</span>
<span class="cm"> * They may then ask us to copy objects into specific device addresses (e.g.</span>
<span class="cm"> * code/data sections) or expose us certain symbols in other device address</span>
<span class="cm"> * (e.g. their trace buffer).</span>
<span class="cm"> *</span>
<span class="cm"> * This function is an internal helper with which we can go over the allocated</span>
<span class="cm"> * carveouts and translate specific device address to kernel virtual addresses</span>
<span class="cm"> * so we can access the referenced memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: phys_to_virt(iommu_iova_to_phys(rproc-&gt;domain, da)) will work too,</span>
<span class="cm"> * but only on kernel direct mapped RAM memory. Instead, we&#39;re just using</span>
<span class="cm"> * here the output of the DMA API, which should be more correct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">rproc_da_to_va</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="n">u64</span> <span class="n">da</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc_mem_entry</span> <span class="o">*</span><span class="n">carveout</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">carveout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">carveouts</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">da</span> <span class="o">-</span> <span class="n">carveout</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">;</span>

		<span class="cm">/* try next carveout if da is too small */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* try next carveout if da is too large */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">carveout</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ptr</span> <span class="o">=</span> <span class="n">carveout</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_load_segments() - load firmware segments to memory</span>
<span class="cm"> * @rproc: remote processor which will be booted using these fw segments</span>
<span class="cm"> * @elf_data: the content of the ELF firmware image</span>
<span class="cm"> * @len: firmware size (in bytes)</span>
<span class="cm"> *</span>
<span class="cm"> * This function loads the firmware segments to memory, where the remote</span>
<span class="cm"> * processor expects them.</span>
<span class="cm"> *</span>
<span class="cm"> * Some remote processors will expect their code and data to be placed</span>
<span class="cm"> * in specific device addresses, and can&#39;t have them dynamically assigned.</span>
<span class="cm"> *</span>
<span class="cm"> * We currently support only those kind of remote processors, and expect</span>
<span class="cm"> * the program header&#39;s paddr member to contain those addresses. We then go</span>
<span class="cm"> * through the physically contiguous &quot;carveout&quot; memory regions which we</span>
<span class="cm"> * allocated (and mapped) earlier on behalf of the remote processor,</span>
<span class="cm"> * and &quot;translate&quot; device address to kernel addresses, so we can copy the</span>
<span class="cm"> * segments where they are expected.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently we only support remote processors that required carveout</span>
<span class="cm"> * allocations and got them mapped onto their iommus. Some processors</span>
<span class="cm"> * might be different: they might not have iommus, and would prefer to</span>
<span class="cm"> * directly allocate memory for every segment/resource. This is not yet</span>
<span class="cm"> * supported, though.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rproc_load_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">elf_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="n">ehdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf32_phdr</span> <span class="o">*</span><span class="n">phdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">elf_data</span><span class="p">;</span>
	<span class="n">phdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf32_phdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">elf_data</span> <span class="o">+</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>

	<span class="cm">/* go through the available ELF segments */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">phdr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">da</span> <span class="o">=</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">memsz</span> <span class="o">=</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">filesz</span> <span class="o">=</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">!=</span> <span class="n">PT_LOAD</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;phdr: type %d da 0x%x memsz 0x%x filesz 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">memsz</span><span class="p">,</span> <span class="n">filesz</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">filesz</span> <span class="o">&gt;</span> <span class="n">memsz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad phdr filesz 0x%x memsz 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">filesz</span><span class="p">,</span> <span class="n">memsz</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">filesz</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;truncated fw: need 0x%x avail 0x%zx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">offset</span> <span class="o">+</span> <span class="n">filesz</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* grab the kernel address for this device address */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">rproc_da_to_va</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">memsz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad phdr da 0x%x mem 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">memsz</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* put the segment where the remote processor expects it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">elf_data</span> <span class="o">+</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">,</span> <span class="n">filesz</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Zero out remaining memory for this segment.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This isn&#39;t strictly required since dma_alloc_coherent already</span>
<span class="cm">		 * did this for us. albeit harmless, we may consider removing</span>
<span class="cm">		 * this.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memsz</span> <span class="o">&gt;</span> <span class="n">filesz</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">filesz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">memsz</span> <span class="o">-</span> <span class="n">filesz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__rproc_handle_vring</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="n">rvdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_rsc_vdev</span> <span class="o">*</span><span class="n">rsc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">rproc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_rsc_vdev_vring</span> <span class="o">*</span><span class="n">vring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rsc</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">notifyid</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vdev rsc: vring%d: da %x, qsz %d, align %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">vring</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">vring</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">vring</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">);</span>

	<span class="cm">/* make sure reserved bytes are zeroes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vring</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vring rsc has non zero reserved bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* verify queue size and vring alignment are sane */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vring</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">||</span> <span class="o">!</span><span class="n">vring</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid qsz (%d) or alignment (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">vring</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">vring</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* actual size of vring (in bytes) */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">vring_size</span><span class="p">(</span><span class="n">vring</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">vring</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">notifyids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;idr_pre_get failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate non-cacheable memory for the vring. In the future</span>
<span class="cm">	 * this call will also configure the IOMMU for us</span>
<span class="cm">	 */</span>
	<span class="n">va</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">va</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dma_alloc_coherent failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* assign an rproc-wide unique index for this vring */</span>
	<span class="cm">/* TODO: assign a notifyid for rvdev updates as well */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">notifyids</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">notifyid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;idr_get_new failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* let the rproc know the da and notifyid of this vring */</span>
	<span class="cm">/* TODO: expose this to remote processor */</span>
	<span class="n">vring</span><span class="o">-&gt;</span><span class="n">da</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">vring</span><span class="o">-&gt;</span><span class="n">notifyid</span> <span class="o">=</span> <span class="n">notifyid</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vring%d: va %p dma %x size %x idr %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span>
					<span class="n">dma</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">notifyid</span><span class="p">);</span>

	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">vring</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">align</span> <span class="o">=</span> <span class="n">vring</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">;</span>
	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">va</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">notifyid</span> <span class="o">=</span> <span class="n">notifyid</span><span class="p">;</span>
	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rvdev</span> <span class="o">=</span> <span class="n">rvdev</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__rproc_free_vrings</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="n">rvdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">rproc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rproc_vring</span> <span class="o">*</span><span class="n">rvring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">vring_size</span><span class="p">(</span><span class="n">rvring</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">rvring</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">));</span>

		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rvring</span><span class="o">-&gt;</span><span class="n">va</span><span class="p">,</span> <span class="n">rvring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">notifyids</span><span class="p">,</span> <span class="n">rvring</span><span class="o">-&gt;</span><span class="n">notifyid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_handle_vdev() - handle a vdev fw resource</span>
<span class="cm"> * @rproc: the remote processor</span>
<span class="cm"> * @rsc: the vring resource descriptor</span>
<span class="cm"> * @avail: size of available data (for sanity checking the image)</span>
<span class="cm"> *</span>
<span class="cm"> * This resource entry requests the host to statically register a virtio</span>
<span class="cm"> * device (vdev), and setup everything needed to support it. It contains</span>
<span class="cm"> * everything needed to make it possible: the virtio device id, virtio</span>
<span class="cm"> * device features, vrings information, virtio config space, etc...</span>
<span class="cm"> *</span>
<span class="cm"> * Before registering the vdev, the vrings are allocated from non-cacheable</span>
<span class="cm"> * physically contiguous memory. Currently we only support two vrings per</span>
<span class="cm"> * remote processor (temporary limitation). We might also want to consider</span>
<span class="cm"> * doing the vring allocation only later when -&gt;find_vqs() is invoked, and</span>
<span class="cm"> * then release them upon -&gt;del_vqs().</span>
<span class="cm"> *</span>
<span class="cm"> * Note: @da is currently not really handled correctly: we dynamically</span>
<span class="cm"> * allocate it using the DMA API, ignoring requested hard coded addresses,</span>
<span class="cm"> * and we don&#39;t take care of any required IOMMU programming. This is all</span>
<span class="cm"> * going to be taken care of when the generic iommu-based DMA API will be</span>
<span class="cm"> * merged. Meanwhile, statically-addressed iommu-based firmware images should</span>
<span class="cm"> * use RSC_DEVMEM resource entries to map their required @da to the physical</span>
<span class="cm"> * address of their base CMA region (ouch, hacky!).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, or an appropriate error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rproc_handle_vdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_rsc_vdev</span> <span class="o">*</span><span class="n">rsc</span><span class="p">,</span>
								<span class="kt">int</span> <span class="n">avail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="n">rvdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* make sure resource isn&#39;t truncated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rsc</span><span class="p">)</span> <span class="o">+</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">num_of_vrings</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fw_rsc_vdev_vring</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">config_len</span> <span class="o">&gt;</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vdev rsc is truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure reserved bytes are zeroes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsc</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vdev rsc has non zero reserved bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vdev rsc: id %d, dfeatures %x, cfg len %d, %d vrings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">rsc</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">dfeatures</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">config_len</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">num_of_vrings</span><span class="p">);</span>

	<span class="cm">/* we currently support only two vrings per rvdev */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsc</span><span class="o">-&gt;</span><span class="n">num_of_vrings</span> <span class="o">&gt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;too many vrings: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">num_of_vrings</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rvdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc_vdev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rvdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">rproc</span><span class="p">;</span>

	<span class="cm">/* allocate the vrings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">num_of_vrings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__rproc_handle_vring</span><span class="p">(</span><span class="n">rvdev</span><span class="p">,</span> <span class="n">rsc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_vrings</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remember the device features */</span>
	<span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">dfeatures</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">dfeatures</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">rvdevs</span><span class="p">);</span>

	<span class="cm">/* it is now safe to add the virtio device */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_add_virtio_dev</span><span class="p">(</span><span class="n">rvdev</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_vrings</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_vrings:</span>
	<span class="n">__rproc_free_vrings</span><span class="p">(</span><span class="n">rvdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rvdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_handle_trace() - handle a shared trace buffer resource</span>
<span class="cm"> * @rproc: the remote processor</span>
<span class="cm"> * @rsc: the trace resource descriptor</span>
<span class="cm"> * @avail: size of available data (for sanity checking the image)</span>
<span class="cm"> *</span>
<span class="cm"> * In case the remote processor dumps trace logs into memory,</span>
<span class="cm"> * export it via debugfs.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently, the &#39;da&#39; member of @rsc should contain the device address</span>
<span class="cm"> * where the remote processor is dumping the traces. Later we could also</span>
<span class="cm"> * support dynamically allocating this address using the generic</span>
<span class="cm"> * DMA API (but currently there isn&#39;t a use case for that).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, or an appropriate error code otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rproc_handle_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_rsc_trace</span> <span class="o">*</span><span class="n">rsc</span><span class="p">,</span>
								<span class="kt">int</span> <span class="n">avail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc_mem_entry</span> <span class="o">*</span><span class="n">trace</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rsc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;trace rsc is truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure reserved bytes are zeroes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsc</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;trace rsc has non zero reserved bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* what&#39;s the kernel address of this resource ? */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">rproc_da_to_va</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;erroneous trace resource entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">trace</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;kzalloc trace failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set the trace buffer dma properties */</span>
	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* make sure snprintf always null terminates, even if truncating */</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;trace%d&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">num_traces</span><span class="p">);</span>

	<span class="cm">/* create the debugfs entry */</span>
	<span class="n">trace</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">rproc_create_trace_file</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rproc</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">trace</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">traces</span><span class="p">);</span>

	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">num_traces</span><span class="o">++</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s added: va %p, da 0x%x, len 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
						<span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_handle_devmem() - handle devmem resource entry</span>
<span class="cm"> * @rproc: remote processor handle</span>
<span class="cm"> * @rsc: the devmem resource entry</span>
<span class="cm"> * @avail: size of available data (for sanity checking the image)</span>
<span class="cm"> *</span>
<span class="cm"> * Remote processors commonly need to access certain on-chip peripherals.</span>
<span class="cm"> *</span>
<span class="cm"> * Some of these remote processors access memory via an iommu device,</span>
<span class="cm"> * and might require us to configure their iommu before they can access</span>
<span class="cm"> * the on-chip peripherals they need.</span>
<span class="cm"> *</span>
<span class="cm"> * This resource entry is a request to map such a peripheral device.</span>
<span class="cm"> *</span>
<span class="cm"> * These devmem entries will contain the physical address of the device in</span>
<span class="cm"> * the &#39;pa&#39; member. If a specific device address is expected, then &#39;da&#39; will</span>
<span class="cm"> * contain it (currently this is the only use case supported). &#39;len&#39; will</span>
<span class="cm"> * contain the size of the physical region we need to map.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently we just &quot;trust&quot; those devmem entries to contain valid physical</span>
<span class="cm"> * addresses, but this is going to change: we want the implementations to</span>
<span class="cm"> * tell us ranges of physical addresses the firmware is allowed to request,</span>
<span class="cm"> * and not allow firmwares to request access to physical addresses that</span>
<span class="cm"> * are outside those ranges.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rproc_handle_devmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="o">*</span><span class="n">rsc</span><span class="p">,</span>
								<span class="kt">int</span> <span class="n">avail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc_mem_entry</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* no point in handling this resource without a valid iommu domain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rsc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;devmem rsc is truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure reserved bytes are zeroes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsc</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;devmem rsc has non zero reserved bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mapping</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;kzalloc mapping failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_map</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">pa</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to map devmem: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ll need this info later when we&#39;ll want to unmap everything</span>
<span class="cm">	 * (e.g. on shutdown).</span>
<span class="cm">	 *</span>
<span class="cm">	 * We can&#39;t trust the remote processor not to change the resource</span>
<span class="cm">	 * table, so we must maintain this info independently.</span>
<span class="cm">	 */</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">da</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">mappings</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mapped devmem pa 0x%x, da 0x%x, len 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rsc</span><span class="o">-&gt;</span><span class="n">pa</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_handle_carveout() - handle phys contig memory allocation requests</span>
<span class="cm"> * @rproc: rproc handle</span>
<span class="cm"> * @rsc: the resource entry</span>
<span class="cm"> * @avail: size of available data (for image validation)</span>
<span class="cm"> *</span>
<span class="cm"> * This function will handle firmware requests for allocation of physically</span>
<span class="cm"> * contiguous memory regions.</span>
<span class="cm"> *</span>
<span class="cm"> * These request entries should come first in the firmware&#39;s resource table,</span>
<span class="cm"> * as other firmware entries might request placing other data objects inside</span>
<span class="cm"> * these memory regions (e.g. data/code segments, trace resource entries, ...).</span>
<span class="cm"> *</span>
<span class="cm"> * Allocating memory this way helps utilizing the reserved physical memory</span>
<span class="cm"> * (e.g. CMA) more efficiently, and also minimizes the number of TLB entries</span>
<span class="cm"> * needed to map it (in case @rproc is using an IOMMU). Reducing the TLB</span>
<span class="cm"> * pressure is important; it may have a substantial impact on performance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rproc_handle_carveout</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fw_rsc_carveout</span> <span class="o">*</span><span class="n">rsc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc_mem_entry</span> <span class="o">*</span><span class="n">carveout</span><span class="p">,</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rsc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;carveout rsc is truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure reserved bytes are zeroes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsc</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;carveout rsc has non zero reserved bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;carveout rsc: da %x, pa %x, len %x, flags %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">pa</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mapping</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;kzalloc mapping failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">carveout</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">carveout</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">carveout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;kzalloc carveout failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_mapping</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">va</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">va</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to dma alloc carveout: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_carv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;carveout va %p, dma %x, len 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, this is non-standard.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Sometimes we can&#39;t rely on the generic iommu-based DMA API</span>
<span class="cm">	 * to dynamically allocate the device address and then set the IOMMU</span>
<span class="cm">	 * tables accordingly, because some remote processors might</span>
<span class="cm">	 * _require_ us to use hard coded device addresses that their</span>
<span class="cm">	 * firmware was compiled with.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In this case, we must use the IOMMU API directly and map</span>
<span class="cm">	 * the memory to the device address as expected by the remote</span>
<span class="cm">	 * processor.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Obviously such remote processor devices should not be configured</span>
<span class="cm">	 * to use the iommu-based DMA API: we expect &#39;dma&#39; to contain the</span>
<span class="cm">	 * physical address in this case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_map</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
								<span class="n">rsc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu_map failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">dma_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ll need this info later when we&#39;ll want to unmap</span>
<span class="cm">		 * everything (e.g. on shutdown).</span>
<span class="cm">		 *</span>
<span class="cm">		 * We can&#39;t trust the remote processor not to change the</span>
<span class="cm">		 * resource table, so we must maintain this info independently.</span>
<span class="cm">		 */</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">da</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">;</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">mappings</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;carveout mapped 0x%x to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some remote processors might need to know the pa</span>
<span class="cm">		 * even though they are behind an IOMMU. E.g., OMAP4&#39;s</span>
<span class="cm">		 * remote M3 processor needs this so it can control</span>
<span class="cm">		 * on-chip hardware accelerators that are not behind</span>
<span class="cm">		 * the IOMMU, and therefor must know the pa.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Generally we don&#39;t want to expose physical addresses</span>
<span class="cm">		 * if we don&#39;t have to (remote processors are generally</span>
<span class="cm">		 * _not_ trusted), so we might want to do this only for</span>
<span class="cm">		 * remote processor that _must_ have this (e.g. OMAP4&#39;s</span>
<span class="cm">		 * dual M3 subsystem).</span>
<span class="cm">		 */</span>
		<span class="n">rsc</span><span class="o">-&gt;</span><span class="n">pa</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">carveout</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
	<span class="n">carveout</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">carveout</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">carveout</span><span class="o">-&gt;</span><span class="n">da</span> <span class="o">=</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">carveout</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">carveouts</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">dma_free:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rsc</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
<span class="nl">free_carv:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">carveout</span><span class="p">);</span>
<span class="nl">free_mapping:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A lookup table for resource handlers. The indices are defined in</span>
<span class="cm"> * enum fw_resource_type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">rproc_handle_resource_t</span> <span class="n">rproc_handle_rsc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">RSC_CARVEOUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rproc_handle_resource_t</span><span class="p">)</span><span class="n">rproc_handle_carveout</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RSC_DEVMEM</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rproc_handle_resource_t</span><span class="p">)</span><span class="n">rproc_handle_devmem</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RSC_TRACE</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rproc_handle_resource_t</span><span class="p">)</span><span class="n">rproc_handle_trace</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RSC_VDEV</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="cm">/* VDEVs were handled upon registrarion */</span>
<span class="p">};</span>

<span class="cm">/* handle firmware resource entries before booting the remote processor */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rproc_handle_boot_rsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">rproc_handle_resource_t</span> <span class="n">handler</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">fw_rsc_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">table</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">);</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">rsc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">);</span>

		<span class="cm">/* make sure table isn&#39;t truncated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rsc table is truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rsc: type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">RSC_LAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported resource %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">handler</span> <span class="o">=</span> <span class="n">rproc_handle_rsc</span><span class="p">[</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handler</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">rsc</span><span class="p">,</span> <span class="n">avail</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* handle firmware resource entries while registering the remote processor */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rproc_handle_virtio_rsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">fw_rsc_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">table</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">fw_rsc_vdev</span> <span class="o">*</span><span class="n">vrsc</span><span class="p">;</span>

		<span class="cm">/* make sure table isn&#39;t truncated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rsc table is truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: rsc type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">RSC_VDEV</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">vrsc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fw_rsc_vdev</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_handle_vdev</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">vrsc</span><span class="p">,</span> <span class="n">avail</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_find_rsc_table() - find the resource table</span>
<span class="cm"> * @rproc: the rproc handle</span>
<span class="cm"> * @elf_data: the content of the ELF firmware image</span>
<span class="cm"> * @len: firmware size (in bytes)</span>
<span class="cm"> * @tablesz: place holder for providing back the table size</span>
<span class="cm"> *</span>
<span class="cm"> * This function finds the resource table inside the remote processor&#39;s</span>
<span class="cm"> * firmware. It is used both upon the registration of @rproc (in order</span>
<span class="cm"> * to look for and register the supported virito devices), and when the</span>
<span class="cm"> * @rproc is booted.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the pointer to the resource table if it is found, and write its</span>
<span class="cm"> * size into @tablesz. If a valid table isn&#39;t found, NULL is returned</span>
<span class="cm"> * (and @tablesz isn&#39;t set).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span>
<span class="nf">rproc_find_rsc_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">elf_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
							<span class="kt">int</span> <span class="o">*</span><span class="n">tablesz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="n">ehdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf32_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">elf_data</span><span class="p">;</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf32_shdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">elf_data</span> <span class="o">+</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span><span class="p">);</span>
	<span class="n">name_table</span> <span class="o">=</span> <span class="n">elf_data</span> <span class="o">+</span> <span class="n">shdr</span><span class="p">[</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>

	<span class="cm">/* look for the resource table and handle it */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">shdr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name_table</span> <span class="o">+</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">,</span> <span class="s">&quot;.resource_table&quot;</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span><span class="p">)(</span><span class="n">elf_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

		<span class="cm">/* make sure we have the entire table */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resource table truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* make sure table has at least the header */</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource_table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;header-less resource table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we don&#39;t support any version beyond the first */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">ver</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported fw ver: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">ver</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* make sure reserved bytes are zeroes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;non zero reserved bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* make sure the offsets array isn&#39;t truncated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource_table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resource table incomplete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">tablesz</span> <span class="o">=</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_resource_cleanup() - clean up and free all acquired resources</span>
<span class="cm"> * @rproc: rproc handle</span>
<span class="cm"> *</span>
<span class="cm"> * This function will free all resources acquired for @rproc, and it</span>
<span class="cm"> * is called whenever @rproc either shuts down or fails to boot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rproc_resource_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc_mem_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* clean up debugfs trace entries */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">traces</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rproc_remove_trace_file</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">);</span>
		<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">num_traces</span><span class="o">--</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clean up carveout allocations */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">carveouts</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">va</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clean up iommu mapping entries */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">mappings</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">unmapped</span><span class="p">;</span>

		<span class="n">unmapped</span> <span class="o">=</span> <span class="n">iommu_unmap</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unmapped</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* nothing much to do besides complaining */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to unmap %u/%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
								<span class="n">unmapped</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* make sure this fw image is sane */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rproc_fw_sanity_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="n">ehdr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">class</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to load %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf32_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Image is too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* We only support ELF32 at this point */</span>
	<span class="n">class</span> <span class="o">=</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_CLASS</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">!=</span> <span class="n">ELFCLASS32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unsupported class: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">class</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We assume the firmware has the same endianess as the host */</span>
<span class="cp"># ifdef __LITTLE_ENDIAN</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_DATA</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFDATA2LSB</span><span class="p">)</span> <span class="p">{</span>
<span class="cp"># else </span><span class="cm">/* BIG ENDIAN */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_DATA</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFDATA2MSB</span><span class="p">)</span> <span class="p">{</span>
<span class="cp"># endif</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unsupported firmware endianess</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf32_shdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Image is too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Image is corrupted (bad magic)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No loadable segments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span> <span class="o">&gt;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Firmware size is too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * take a firmware and boot a remote processor with it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rproc_fw_boot</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="n">ehdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">tablesz</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_fw_sanity_check</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf32_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Booting fw image %s, size %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if enabling an IOMMU isn&#39;t relevant for this rproc, this is</span>
<span class="cm">	 * just a nop</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_enable_iommu</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t enable iommu: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ELF entry point is the rproc&#39;s boot addr (though this is not</span>
<span class="cm">	 * a configurable property of all remote processors: some will always</span>
<span class="cm">	 * boot at a specific hardcoded address).</span>
<span class="cm">	 */</span>
	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">bootaddr</span> <span class="o">=</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">;</span>

	<span class="cm">/* look for the resource table */</span>
	<span class="n">table</span> <span class="o">=</span> <span class="n">rproc_find_rsc_table</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tablesz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* handle fw resources which are required to boot rproc */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_handle_boot_rsc</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">tablesz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to process resources: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* load the ELF segments to memory */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_load_segments</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to load program segments: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* power up the remote processor */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t start rproc %s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RPROC_RUNNING</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;remote processor %s is now up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">clean_up:</span>
	<span class="n">rproc_resource_cleanup</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
	<span class="n">rproc_disable_iommu</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * take a firmware and look for virtio devices to register.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this function is called asynchronously upon registration of the</span>
<span class="cm"> * remote processor (so we must wait until it completes before we try</span>
<span class="cm"> * to unregister the device. one other option is just to use kref here,</span>
<span class="cm"> * that might be cleaner).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rproc_fw_config_virtio</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">tablesz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rproc_fw_sanity_check</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">fw</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* look for the resource table */</span>
	<span class="n">table</span> <span class="o">=</span> <span class="n">rproc_find_rsc_table</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tablesz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* look for virtio devices and register them */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_handle_virtio_rsc</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">tablesz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="cm">/* allow rproc_unregister() contexts, if any, to proceed */</span>
	<span class="n">complete_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware_loading_complete</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_boot() - boot a remote processor</span>
<span class="cm"> * @rproc: handle of a remote processor</span>
<span class="cm"> *</span>
<span class="cm"> * Boot a remote processor (i.e. load its firmware, power it on, ...).</span>
<span class="cm"> *</span>
<span class="cm"> * If the remote processor is already powered on, this function immediately</span>
<span class="cm"> * returns (successfully).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, and an appropriate error value otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rproc_boot</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">firmware_p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rproc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;invalid rproc handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t lock rproc %s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* loading a firmware is required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no firmware to load</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* prevent underlying implementation from being removed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: can&#39;t get owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* skip the boot process if rproc is already powered up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;powering up %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* load firmware */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">firmware_p</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_firmware failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">downref_rproc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_fw_boot</span><span class="p">(</span><span class="n">rproc</span><span class="p">,</span> <span class="n">firmware_p</span><span class="p">);</span>

	<span class="n">release_firmware</span><span class="p">(</span><span class="n">firmware_p</span><span class="p">);</span>

<span class="nl">downref_rproc:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">unlock_mutex:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_boot</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_shutdown() - power off the remote processor</span>
<span class="cm"> * @rproc: the remote processor</span>
<span class="cm"> *</span>
<span class="cm"> * Power off a remote processor (previously booted with rproc_boot()).</span>
<span class="cm"> *</span>
<span class="cm"> * In case @rproc is still being used by an additional user(s), then</span>
<span class="cm"> * this function will just decrement the power refcount and exit,</span>
<span class="cm"> * without really powering off the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Every call to rproc_boot() must (eventually) be accompanied by a call</span>
<span class="cm"> * to rproc_shutdown(). Calling rproc_shutdown() redundantly is a bug.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * - we&#39;re not decrementing the rproc&#39;s refcount, only the power refcount.</span>
<span class="cm"> *   which means that the @rproc handle stays valid even after rproc_shutdown()</span>
<span class="cm"> *   returns, and users can still use it with a subsequent rproc_boot(), if</span>
<span class="cm"> *   needed.</span>
<span class="cm"> * - don&#39;t call rproc_shutdown() to unroll rproc_get_by_name(), exactly</span>
<span class="cm"> *   because rproc_shutdown() _does not_ decrement the refcount of @rproc.</span>
<span class="cm"> *   To decrement the refcount of @rproc, use rproc_put() (but _only_ if</span>
<span class="cm"> *   you acquired @rproc using rproc_get_by_name()).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rproc_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t lock rproc %s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if the remote proc is still needed, bail out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* power off the remote processor */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t stop rproc: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clean up all acquired resources */</span>
	<span class="n">rproc_resource_cleanup</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>

	<span class="n">rproc_disable_iommu</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>

	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RPROC_OFFLINE</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stopped remote processor %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_shutdown</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_release() - completely deletes the existence of a remote processor</span>
<span class="cm"> * @kref: the rproc&#39;s kref</span>
<span class="cm"> *</span>
<span class="cm"> * This function should _never_ be called directly.</span>
<span class="cm"> *</span>
<span class="cm"> * The only reasonable location to use it is as an argument when kref_put&#39;ing</span>
<span class="cm"> * @rproc&#39;s refcount.</span>
<span class="cm"> *</span>
<span class="cm"> * This way it will be called when no one holds a valid pointer to this @rproc</span>
<span class="cm"> * anymore (and obviously after it is removed from the rprocs klist).</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this function is not static because rproc_vdev_release() needs it when</span>
<span class="cm"> * it decrements @rproc&#39;s refcount.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rproc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rproc</span><span class="p">,</span> <span class="n">refcount</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="n">rvdev</span><span class="p">,</span> <span class="o">*</span><span class="n">rvtmp</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;removing %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">rproc_delete_debug_dir</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>

	<span class="cm">/* clean up remote vdev entries */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rvdev</span><span class="p">,</span> <span class="n">rvtmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">rvdevs</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__rproc_free_vrings</span><span class="p">(</span><span class="n">rvdev</span><span class="p">,</span> <span class="n">RVDEV_NUM_VRINGS</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point no one holds a reference to rproc anymore,</span>
<span class="cm">	 * so we can directly unroll rproc_alloc()</span>
<span class="cm">	 */</span>
	<span class="n">rproc_free</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* will be called when an rproc is added to the rprocs klist */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">klist_rproc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rproc</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* will be called when an rproc is removed from the rprocs klist */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">klist_rproc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rproc</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">rproc_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">next_rproc</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">klist_next</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rproc</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_get_by_name() - find a remote processor by name and boot it</span>
<span class="cm"> * @name: name of the remote processor</span>
<span class="cm"> *</span>
<span class="cm"> * Finds an rproc handle using the remote processor&#39;s name, and then</span>
<span class="cm"> * boot it. If it&#39;s already powered on, then just immediately return</span>
<span class="cm"> * (successfully).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the rproc handle on success, and NULL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function increments the remote processor&#39;s refcount, so always</span>
<span class="cm"> * use rproc_put() to decrement it back once rproc isn&#39;t needed anymore.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: currently this function (and its counterpart rproc_put()) are not</span>
<span class="cm"> * being used. We need to scrutinize the use cases</span>
<span class="cm"> * that still need them, and see if we can migrate them to use the non</span>
<span class="cm"> * name-based boot/shutdown interface.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc_get_by_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist_iter</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* find the remote processor, and upref its refcount */</span>
	<span class="n">klist_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rprocs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">rproc</span> <span class="o">=</span> <span class="n">next_rproc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

	<span class="cm">/* can&#39;t find this rproc ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rproc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;can&#39;t find remote processor %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rproc_boot</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">rproc_release</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rproc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_get_by_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_put() - decrement the refcount of a remote processor, and shut it down</span>
<span class="cm"> * @rproc: the remote processor</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to shutdown @rproc, and it then decrements its</span>
<span class="cm"> * refcount.</span>
<span class="cm"> *</span>
<span class="cm"> * After this function returns, @rproc may _not_ be used anymore, and its</span>
<span class="cm"> * handle should be considered invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called _iff_ the @rproc handle was grabbed by</span>
<span class="cm"> * calling rproc_get_by_name().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rproc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* try to power off the remote processor */</span>
	<span class="n">rproc_shutdown</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>

	<span class="cm">/* downref rproc&#39;s refcount */</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">rproc_release</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_put</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_register() - register a remote processor</span>
<span class="cm"> * @rproc: the remote processor handle to register</span>
<span class="cm"> *</span>
<span class="cm"> * Registers @rproc with the remoteproc framework, after it has been</span>
<span class="cm"> * allocated with rproc_alloc().</span>
<span class="cm"> *</span>
<span class="cm"> * This is called by the platform-specific rproc implementation, whenever</span>
<span class="cm"> * a new remote processor device is probed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error code otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this function initiates an asynchronous firmware loading</span>
<span class="cm"> * context, which will look for virtio devices supported by the rproc&#39;s</span>
<span class="cm"> * firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * If found, those virtio devices will be created and added, so as a result</span>
<span class="cm"> * of registering this remote processor, additional virtio drivers might be</span>
<span class="cm"> * probed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rproc_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* expose to rproc_get_by_name users */</span>
	<span class="n">klist_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rprocs</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s is available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Note: remoteproc is still under development and considered experimental.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;THE BINARY FORMAT IS NOT YET FINALIZED, and backward compatibility isn&#39;t yet guaranteed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* create debugfs entries */</span>
	<span class="n">rproc_create_debug_dir</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>

	<span class="cm">/* rproc_unregister() calls must wait until async loader completes */</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware_loading_complete</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must retrieve early virtio configuration info from</span>
<span class="cm">	 * the firmware (e.g. whether to register a virtio device,</span>
<span class="cm">	 * what virtio features does it support, ...).</span>
<span class="cm">	 *</span>
<span class="cm">	 * We&#39;re initiating an asynchronous firmware loading, so we can</span>
<span class="cm">	 * be built-in kernel code, without hanging the boot process.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_firmware_nowait</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="n">FW_ACTION_HOTPLUG</span><span class="p">,</span>
					<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
					<span class="n">rproc</span><span class="p">,</span> <span class="n">rproc_fw_config_virtio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_firmware_nowait failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">complete_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware_loading_complete</span><span class="p">);</span>
		<span class="n">klist_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_alloc() - allocate a remote processor handle</span>
<span class="cm"> * @dev: the underlying device</span>
<span class="cm"> * @name: name of this remote processor</span>
<span class="cm"> * @ops: platform-specific handlers (mainly start/stop)</span>
<span class="cm"> * @firmware: name of firmware file to load</span>
<span class="cm"> * @len: length of private data needed by the rproc driver (in bytes)</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a new remote processor handle, but does not register</span>
<span class="cm"> * it yet.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be used by rproc implementations during initialization</span>
<span class="cm"> * of the remote processor.</span>
<span class="cm"> *</span>
<span class="cm"> * After creating an rproc handle using this function, and when ready,</span>
<span class="cm"> * implementations should then call rproc_register() to complete</span>
<span class="cm"> * the registration of the remote processor.</span>
<span class="cm"> *</span>
<span class="cm"> * On success the new rproc is returned, and on failure, NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: _never_ directly deallocate @rproc, even if it was not registered</span>
<span class="cm"> * yet. Instead, if you just need to unroll rproc_alloc(), use rproc_free().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">rproc_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">firmware</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rproc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rproc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: kzalloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware</span> <span class="o">=</span> <span class="n">firmware</span><span class="p">;</span>
	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">notifyids</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">carveouts</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">mappings</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">traces</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">rvdevs</span><span class="p">);</span>

	<span class="n">rproc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RPROC_OFFLINE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rproc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_free() - free an rproc handle that was allocated by rproc_alloc</span>
<span class="cm"> * @rproc: the remote processor handle</span>
<span class="cm"> *</span>
<span class="cm"> * This function should _only_ be used if @rproc was only allocated,</span>
<span class="cm"> * but not registered yet.</span>
<span class="cm"> *</span>
<span class="cm"> * If @rproc was already successfully registered (by calling rproc_register()),</span>
<span class="cm"> * then use rproc_unregister() instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rproc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">idr_remove_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">notifyids</span><span class="p">);</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">notifyids</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rproc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rproc_unregister() - unregister a remote processor</span>
<span class="cm"> * @rproc: rproc handle to unregister</span>
<span class="cm"> *</span>
<span class="cm"> * Unregisters a remote processor, and decrements its refcount.</span>
<span class="cm"> * If its refcount drops to zero, then @rproc will be freed. If not,</span>
<span class="cm"> * it will be freed later once the last reference is dropped.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called when the platform specific rproc</span>
<span class="cm"> * implementation decides to remove the rproc device. it should</span>
<span class="cm"> * _only_ be called if a previous invocation of rproc_register()</span>
<span class="cm"> * has completed successfully.</span>
<span class="cm"> *</span>
<span class="cm"> * After rproc_unregister() returns, @rproc is _not_ valid anymore and</span>
<span class="cm"> * it shouldn&#39;t be used. More specifically, don&#39;t call rproc_free()</span>
<span class="cm"> * or try to directly free @rproc after rproc_unregister() returns;</span>
<span class="cm"> * none of these are needed, and calling them is a bug.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and -EINVAL if @rproc isn&#39;t valid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rproc_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="n">rvdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rproc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* if rproc is just being registered, wait */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">firmware_loading_complete</span><span class="p">);</span>

	<span class="cm">/* clean up remote vdev entries */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rvdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">rvdevs</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">rproc_remove_virtio_dev</span><span class="p">(</span><span class="n">rvdev</span><span class="p">);</span>

	<span class="cm">/* the rproc is downref&#39;ed as soon as it&#39;s removed from the klist */</span>
	<span class="n">klist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* the rproc will only be released after its refcount drops to zero */</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rproc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">rproc_release</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rproc_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">remoteproc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rproc_init_debugfs</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">remoteproc_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">remoteproc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rproc_exit_debugfs</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">remoteproc_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Generic Remote Processor Framework&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
