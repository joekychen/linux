<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › sbus › char › envctrl.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>envctrl.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* envctrl.c: Temperature and Fan monitoring on Machines providing it.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)</span>
<span class="cm"> * Copyright (C) 2000  Vinh Truong    (vinh.truong@eng.sun.com)</span>
<span class="cm"> * VT - The implementation is to support Sun Microelectronics (SME) platform</span>
<span class="cm"> *      environment monitoring.  SME platforms use pcf8584 as the i2c bus </span>
<span class="cm"> *      controller to access pcf8591 (8-bit A/D and D/A converter) and </span>
<span class="cm"> *      pcf8571 (256 x 8-bit static low-voltage RAM with I2C-bus interface).</span>
<span class="cm"> *      At board level, it follows SME Firmware I2C Specification. Reference:</span>
<span class="cm"> * 	http://www-eu2.semiconductors.com/pip/PCF8584P</span>
<span class="cm"> * 	http://www-eu2.semiconductors.com/pip/PCF8574AP</span>
<span class="cm"> * 	http://www-eu2.semiconductors.com/pip/PCF8591P</span>
<span class="cm"> *</span>
<span class="cm"> * EB - Added support for CP1500 Global Address and PS/Voltage monitoring.</span>
<span class="cm"> * 		Eric Brower &lt;ebrower@usa.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * DB - Audit every copy_to_user in envctrl_read.</span>
<span class="cm"> *              Daniele Bellucci &lt;bellucda@tiscali.it&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/envctrl.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#define DRIVER_NAME	&quot;envctrl&quot;</span>
<span class="cp">#define PFX		DRIVER_NAME &quot;: &quot;</span>

<span class="cp">#define ENVCTRL_MINOR	162</span>

<span class="cp">#define PCF8584_ADDRESS	0x55</span>

<span class="cp">#define CONTROL_PIN	0x80</span>
<span class="cp">#define CONTROL_ES0	0x40</span>
<span class="cp">#define CONTROL_ES1	0x20</span>
<span class="cp">#define CONTROL_ES2	0x10</span>
<span class="cp">#define CONTROL_ENI	0x08</span>
<span class="cp">#define CONTROL_STA	0x04</span>
<span class="cp">#define CONTROL_STO	0x02</span>
<span class="cp">#define CONTROL_ACK	0x01</span>

<span class="cp">#define STATUS_PIN	0x80</span>
<span class="cp">#define STATUS_STS	0x20</span>
<span class="cp">#define STATUS_BER	0x10</span>
<span class="cp">#define STATUS_LRB	0x08</span>
<span class="cp">#define STATUS_AD0	0x08</span>
<span class="cp">#define STATUS_AAB	0x04</span>
<span class="cp">#define STATUS_LAB	0x02</span>
<span class="cp">#define STATUS_BB	0x01</span>

<span class="cm">/*</span>
<span class="cm"> * CLK Mode Register.</span>
<span class="cm"> */</span>
<span class="cp">#define BUS_CLK_90	0x00</span>
<span class="cp">#define BUS_CLK_45	0x01</span>
<span class="cp">#define BUS_CLK_11	0x02</span>
<span class="cp">#define BUS_CLK_1_5	0x03</span>

<span class="cp">#define CLK_3		0x00</span>
<span class="cp">#define CLK_4_43	0x10</span>
<span class="cp">#define CLK_6		0x14</span>
<span class="cp">#define CLK_8		0x18</span>
<span class="cp">#define CLK_12		0x1c</span>

<span class="cp">#define OBD_SEND_START	0xc5    </span><span class="cm">/* value to generate I2c_bus START condition */</span><span class="cp"></span>
<span class="cp">#define OBD_SEND_STOP 	0xc3    </span><span class="cm">/* value to generate I2c_bus STOP condition */</span><span class="cp"></span>

<span class="cm">/* Monitor type of i2c child device.</span>
<span class="cm"> * Firmware definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define PCF8584_MAX_CHANNELS            8</span>
<span class="cp">#define PCF8584_GLOBALADDR_TYPE			6  </span><span class="cm">/* global address monitor */</span><span class="cp"></span>
<span class="cp">#define PCF8584_FANSTAT_TYPE            3  </span><span class="cm">/* fan status monitor */</span><span class="cp"></span>
<span class="cp">#define PCF8584_VOLTAGE_TYPE            2  </span><span class="cm">/* voltage monitor    */</span><span class="cp"></span>
<span class="cp">#define PCF8584_TEMP_TYPE	        	1  </span><span class="cm">/* temperature monitor*/</span><span class="cp"></span>

<span class="cm">/* Monitor type of i2c child device.</span>
<span class="cm"> * Driver definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define ENVCTRL_NOMON				0</span>
<span class="cp">#define ENVCTRL_CPUTEMP_MON			1    </span><span class="cm">/* cpu temperature monitor */</span><span class="cp"></span>
<span class="cp">#define ENVCTRL_CPUVOLTAGE_MON	  	2    </span><span class="cm">/* voltage monitor         */</span><span class="cp"></span>
<span class="cp">#define ENVCTRL_FANSTAT_MON  		3    </span><span class="cm">/* fan status monitor      */</span><span class="cp"></span>
<span class="cp">#define ENVCTRL_ETHERTEMP_MON		4    </span><span class="cm">/* ethernet temperature */</span><span class="cp"></span>
					     <span class="cm">/* monitor                     */</span>
<span class="cp">#define ENVCTRL_VOLTAGESTAT_MON	  	5    </span><span class="cm">/* voltage status monitor  */</span><span class="cp"></span>
<span class="cp">#define ENVCTRL_MTHRBDTEMP_MON		6    </span><span class="cm">/* motherboard temperature */</span><span class="cp"></span>
<span class="cp">#define ENVCTRL_SCSITEMP_MON		7    </span><span class="cm">/* scsi temperature */</span><span class="cp"></span>
<span class="cp">#define ENVCTRL_GLOBALADDR_MON		8    </span><span class="cm">/* global address */</span><span class="cp"></span>

<span class="cm">/* Child device type.</span>
<span class="cm"> * Driver definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define I2C_ADC				0    </span><span class="cm">/* pcf8591 */</span><span class="cp"></span>
<span class="cp">#define I2C_GPIO			1    </span><span class="cm">/* pcf8571 */</span><span class="cp"></span>

<span class="cm">/* Data read from child device may need to decode</span>
<span class="cm"> * through a data table and a scale.</span>
<span class="cm"> * Translation type as defined by firmware.</span>
<span class="cm"> */</span>
<span class="cp">#define ENVCTRL_TRANSLATE_NO		0</span>
<span class="cp">#define ENVCTRL_TRANSLATE_PARTIAL	1</span>
<span class="cp">#define ENVCTRL_TRANSLATE_COMBINED	2</span>
<span class="cp">#define ENVCTRL_TRANSLATE_FULL		3     </span><span class="cm">/* table[data] */</span><span class="cp"></span>
<span class="cp">#define ENVCTRL_TRANSLATE_SCALE		4     </span><span class="cm">/* table[data]/scale */</span><span class="cp"></span>

<span class="cm">/* Driver miscellaneous definitions. */</span>
<span class="cp">#define ENVCTRL_MAX_CPU			4</span>
<span class="cp">#define CHANNEL_DESC_SZ			256</span>

<span class="cm">/* Mask values for combined GlobalAddress/PowerStatus node */</span>
<span class="cp">#define ENVCTRL_GLOBALADDR_ADDR_MASK 	0x1F</span>
<span class="cp">#define ENVCTRL_GLOBALADDR_PSTAT_MASK	0x60</span>

<span class="cm">/* Node 0x70 ignored on CompactPCI CP1400/1500 platforms </span>
<span class="cm"> * (see envctrl_init_i2c_child)</span>
<span class="cm"> */</span>
<span class="cp">#define ENVCTRL_CPCI_IGNORED_NODE		0x70</span>

<span class="cp">#define PCF8584_DATA	0x00</span>
<span class="cp">#define PCF8584_CSR	0x01</span>

<span class="cm">/* Each child device can be monitored by up to PCF8584_MAX_CHANNELS.</span>
<span class="cm"> * Property of a port or channel as defined by the firmware.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pcf8584_channel</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chnl_no</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">io_direction</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">last</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Each child device may have one or more tables of bytes to help decode</span>
<span class="cm"> * data. Table property as defined by the firmware.</span>
<span class="cm"> */</span> 
<span class="k">struct</span> <span class="n">pcf8584_tblprop</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scale</span><span class="p">;</span>  
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span> <span class="cm">/* offset from the beginning of the table */</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* i2c child */</span>
<span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="p">{</span>
	<span class="cm">/* Either ADC or GPIO. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">i2ctype</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>    
        <span class="k">struct</span> <span class="n">pcf8584_channel</span> <span class="n">chnl_array</span><span class="p">[</span><span class="n">PCF8584_MAX_CHANNELS</span><span class="p">];</span>

	<span class="cm">/* Channel info. */</span> 
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_chnls</span><span class="p">;</span>	<span class="cm">/* Number of monitor channels. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fan_mask</span><span class="p">;</span>		<span class="cm">/* Byte mask for fan status channels. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">voltage_mask</span><span class="p">;</span>	<span class="cm">/* Byte mask for voltage status channels. */</span>
        <span class="k">struct</span> <span class="n">pcf8584_tblprop</span> <span class="n">tblprop_array</span><span class="p">[</span><span class="n">PCF8584_MAX_CHANNELS</span><span class="p">];</span>

	<span class="cm">/* Properties of all monitor channels. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_tbls</span><span class="p">;</span>	<span class="cm">/* Number of monitor tables. */</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">tables</span><span class="p">;</span>			<span class="cm">/* Pointer to table(s). */</span>
	<span class="kt">char</span> <span class="n">chnls_desc</span><span class="p">[</span><span class="n">CHANNEL_DESC_SZ</span><span class="p">];</span> <span class="cm">/* Channel description. */</span>
	<span class="kt">char</span> <span class="n">mon_type</span><span class="p">[</span><span class="n">PCF8584_MAX_CHANNELS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">i2c</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="n">i2c_childlist</span><span class="p">[</span><span class="n">ENVCTRL_MAX_CPU</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chnls_mask</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x80</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">warning_temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shutdown_temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">read_cpu</span><span class="p">;</span>

<span class="cm">/* Forward declarations. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>

<span class="cm">/* Function Description: Test the PIN bit (Pending Interrupt Not) </span>
<span class="cm"> * 			 to test when serial transmission is completed .</span>
<span class="cm"> * Return : None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envtrl_i2c_test_pin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">STATUS_PIN</span><span class="p">))</span> 
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> 

	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Pin status will not clear.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Test busy bit.</span>
<span class="cm"> * Return : None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_i2c_test_bb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Busy bit 0 means busy. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">STATUS_BB</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> 

	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Busy bit will not clear.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Send the address for a read access.</span>
<span class="cm"> * Return : 0 if not acknowledged, otherwise acknowledged.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">envctrl_i2c_read_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">envctrl_i2c_test_bb</span><span class="p">();</span>

	<span class="cm">/* Load address. */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>

	<span class="n">envctrl_i2c_test_bb</span><span class="p">();</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">OBD_SEND_START</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>

	<span class="cm">/* Wait for PIN. */</span>
	<span class="n">envtrl_i2c_test_pin</span><span class="p">();</span>

	<span class="cm">/* CSR 0 means acknowledged. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">STATUS_LRB</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">OBD_SEND_STOP</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Send the address for write mode.  </span>
<span class="cm"> * Return : None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_i2c_write_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">envctrl_i2c_test_bb</span><span class="p">();</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>

	<span class="cm">/* Generate Start condition. */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">OBD_SEND_START</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read 1 byte of data from addr </span>
<span class="cm"> *			 set by envctrl_i2c_read_addr() </span>
<span class="cm"> * Return : Data from address set by envctrl_i2c_read_addr().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">envctrl_i2c_read_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">envtrl_i2c_test_pin</span><span class="p">();</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">CONTROL_ES0</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>  <span class="cm">/* Send neg ack. */</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Instruct the device which port to read data from.  </span>
<span class="cm"> * Return : None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_i2c_write_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">envtrl_i2c_test_pin</span><span class="p">();</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Generate Stop condition after last byte is sent.</span>
<span class="cm"> * Return : None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_i2c_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">envtrl_i2c_test_pin</span><span class="p">();</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">OBD_SEND_STOP</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read adc device.</span>
<span class="cm"> * Return : Data at address and port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">envctrl_i2c_read_8591</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Send address. */</span>
	<span class="n">envctrl_i2c_write_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* Setup port to read. */</span>
	<span class="n">envctrl_i2c_write_data</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">envctrl_i2c_stop</span><span class="p">();</span>

	<span class="cm">/* Read port. */</span>
	<span class="n">envctrl_i2c_read_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* Do a single byte read and send stop. */</span>
	<span class="n">envctrl_i2c_read_data</span><span class="p">();</span>
	<span class="n">envctrl_i2c_stop</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read gpio device.</span>
<span class="cm"> * Return : Data at address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">envctrl_i2c_read_8574</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rd</span><span class="p">;</span>

	<span class="n">envctrl_i2c_read_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/* Do a single byte read and send stop. */</span>
	<span class="n">rd</span> <span class="o">=</span> <span class="n">envctrl_i2c_read_data</span><span class="p">();</span>
	<span class="n">envctrl_i2c_stop</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Decode data read from an adc device using firmware</span>
<span class="cm"> *                       table.</span>
<span class="cm"> * Return: Number of read bytes. Data is stored in bufdata in ascii format.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">envctrl_i2c_data_translate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">translate_type</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">scale</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bufdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">translate_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ENVCTRL_TRANSLATE_NO</span>:
		<span class="cm">/* No decode necessary. */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bufdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_TRANSLATE_FULL</span>:
		<span class="cm">/* Decode this way: data = table[data]. */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bufdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">[</span><span class="n">data</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_TRANSLATE_SCALE</span>:
		<span class="cm">/* Decode this way: data = table[data]/scale */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">bufdata</span><span class="p">,</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">tbl</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">scale</span><span class="p">));</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">bufdata</span><span class="p">);</span>
		<span class="n">bufdata</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bufdata</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">bufdata</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read cpu-related data such as cpu temperature, voltage.</span>
<span class="cm"> * Return: Number of read bytes. Data is stored in bufdata in ascii format.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">envctrl_read_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="n">mon_type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bufdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Find the right monitor type and channel. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCF8584_MAX_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">mon_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">j</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Read data from address and port. */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">envctrl_i2c_read_8591</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">chnl_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chnl_no</span><span class="p">);</span>

	<span class="cm">/* Find decoding table. */</span>
	<span class="n">tbl</span> <span class="o">=</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tables</span> <span class="o">+</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">envctrl_i2c_data_translate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">,</span>
					  <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scale</span><span class="p">,</span>
					  <span class="n">tbl</span><span class="p">,</span> <span class="n">bufdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read noncpu-related data such as motherboard </span>
<span class="cm"> *                       temperature.</span>
<span class="cm"> * Return: Number of read bytes. Data is stored in bufdata in ascii format.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">envctrl_read_noncpu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">mon_type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bufdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tbl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCF8584_MAX_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">mon_type</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">PCF8584_MAX_CHANNELS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Read data from address and port. */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">envctrl_i2c_read_8591</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">chnl_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chnl_no</span><span class="p">);</span>

	<span class="cm">/* Find decoding table. */</span>
	<span class="n">tbl</span> <span class="o">=</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tables</span> <span class="o">+</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">envctrl_i2c_data_translate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">,</span>
					  <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scale</span><span class="p">,</span>
					  <span class="n">tbl</span><span class="p">,</span> <span class="n">bufdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read fan status.</span>
<span class="cm"> * Return : Always 1 byte. Status stored in bufdata.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">envctrl_i2c_fan_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">bufdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">fan_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">fan_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All bits are on. All fans are functioning. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ENVCTRL_ALL_FANS_GOOD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No bits are on. No fans are functioning. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ENVCTRL_ALL_FANS_BAD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Go through all channels, mark &#39;on&#39; the matched bits.</span>
<span class="cm">		 * Notice that fan_mask may have discontiguous bits but</span>
<span class="cm">		 * return mask are always contiguous. For example if we</span>
<span class="cm">		 * monitor 4 fans at channels 0,1,2,4, the return mask</span>
<span class="cm">		 * should be 00010000 if only fan at channel 4 is working.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCF8584_MAX_CHANNELS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">fan_mask</span> <span class="o">&amp;</span> <span class="n">chnls_mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">chnls_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">tmp</span><span class="p">))</span>
					<span class="n">ret</span> <span class="o">|=</span> <span class="n">chnls_mask</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

				<span class="n">j</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bufdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read global addressing line.</span>
<span class="cm"> * Return : Always 1 byte. Status stored in bufdata.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">envctrl_i2c_globaladdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">bufdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Translatation table is not necessary, as global</span>
<span class="cm">	 * addr is the integer value of the GA# bits.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: MSB is documented as zero, but I see it as &#39;1&#39; always....</span>
<span class="cm">	 *</span>
<span class="cm">	 * -----------------------------------------------</span>
<span class="cm">	 * | 0 | FAL | DEG | GA4 | GA3 | GA2 | GA1 | GA0 |</span>
<span class="cm">	 * -----------------------------------------------</span>
<span class="cm">	 * GA0 - GA4	integer value of Global Address (backplane slot#)</span>
<span class="cm">	 * DEG			0 = cPCI Power supply output is starting to degrade</span>
<span class="cm">	 * 				1 = cPCI Power supply output is OK</span>
<span class="cm">	 * FAL			0 = cPCI Power supply has failed</span>
<span class="cm">	 * 				1 = cPCI Power supply output is OK</span>
<span class="cm">	 */</span>
	<span class="n">bufdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">ENVCTRL_GLOBALADDR_ADDR_MASK</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read standard voltage and power supply status.</span>
<span class="cm"> * Return : Always 1 byte. Status stored in bufdata.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">envctrl_i2c_voltage_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">,</span>
						<span class="kt">char</span> <span class="o">*</span><span class="n">bufdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">voltage_mask</span><span class="p">;</span>

	<span class="cm">/* Two channels are used to monitor voltage and power supply. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">voltage_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All bits are on. Voltage and power supply are okay. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ENVCTRL_VOLTAGE_POWERSUPPLY_GOOD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All bits are off. Voltage and power supply are bad */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ENVCTRL_VOLTAGE_POWERSUPPLY_BAD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Either voltage or power supply has problem. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCF8584_MAX_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">voltage_mask</span> <span class="o">&amp;</span> <span class="n">chnls_mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">j</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* Break out when there is a mismatch. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">chnls_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">tmp</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span> 
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Make a wish that hardware will always use the</span>
<span class="cm">		 * first channel for voltage and the second for</span>
<span class="cm">		 * power supply.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ENVCTRL_VOLTAGE_BAD</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ENVCTRL_POWERSUPPLY_BAD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bufdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Read a byte from /dev/envctrl. Mapped to user read().</span>
<span class="cm"> * Return: Number of read bytes. 0 for error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">envctrl_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Get the type of read as decided in ioctl() call.</span>
<span class="cm">	 * Find the appropriate i2c child.</span>
<span class="cm">	 * Get the data and put back to the user buffer.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ENVCTRL_RD_WARNING_TEMPERATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">warning_temperature</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">warning_temperature</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_SHUTDOWN_TEMPERATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">shutdown_temperature</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">shutdown_temperature</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_MTHRBD_TEMPERATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_MTHRBDTEMP_MON</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_read_noncpu_info</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span> <span class="n">ENVCTRL_MTHRBDTEMP_MON</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_CPU_TEMPERATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_CPUTEMP_MON</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_read_cpu_info</span><span class="p">(</span><span class="n">read_cpu</span><span class="p">,</span> <span class="n">pchild</span><span class="p">,</span> <span class="n">ENVCTRL_CPUTEMP_MON</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

		<span class="cm">/* Reset cpu to the default cpu0. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_CPU_VOLTAGE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_CPUVOLTAGE_MON</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_read_cpu_info</span><span class="p">(</span><span class="n">read_cpu</span><span class="p">,</span> <span class="n">pchild</span><span class="p">,</span> <span class="n">ENVCTRL_CPUVOLTAGE_MON</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

		<span class="cm">/* Reset cpu to the default cpu0. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_SCSI_TEMPERATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_SCSITEMP_MON</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_read_noncpu_info</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span> <span class="n">ENVCTRL_SCSITEMP_MON</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_ETHERNET_TEMPERATURE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_ETHERTEMP_MON</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_read_noncpu_info</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span> <span class="n">ENVCTRL_ETHERTEMP_MON</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_FAN_STATUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_FANSTAT_MON</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">envctrl_i2c_read_8574</span><span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_i2c_fan_status</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	
	<span class="k">case</span> <span class="n">ENVCTRL_RD_GLOBALADDRESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_GLOBALADDR_MON</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">envctrl_i2c_read_8574</span><span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_i2c_globaladdr</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_VOLTAGE_STATUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_VOLTAGESTAT_MON</span><span class="p">)))</span>
			<span class="cm">/* If voltage monitor not present, check for CPCI equivalent */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pchild</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_GLOBALADDR_MON</span><span class="p">)))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">envctrl_i2c_read_8574</span><span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">envctrl_i2c_voltage_status</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="p">};</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Command what to read.  Mapped to user ioctl().</span>
<span class="cm"> * Return: Gives 0 for implemented commands, -EINVAL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span>
<span class="nf">envctrl_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">infobuf</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ENVCTRL_RD_WARNING_TEMPERATURE</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_SHUTDOWN_TEMPERATURE</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_MTHRBD_TEMPERATURE</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_FAN_STATUS</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_VOLTAGE_STATUS</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_ETHERNET_TEMPERATURE</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_SCSI_TEMPERATURE</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_GLOBALADDRESS</span>:
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ENVCTRL_RD_CPU_TEMPERATURE</span>:
	<span class="k">case</span> <span class="n">ENVCTRL_RD_CPU_VOLTAGE</span>:
		<span class="cm">/* Check to see if application passes in any cpu number,</span>
<span class="cm">		 * the default is cpu0.</span>
<span class="cm">		 */</span>
		<span class="n">infobuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">infobuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">read_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="n">get_user</span><span class="p">(</span><span class="n">read_cpu</span><span class="p">,</span> <span class="n">infobuf</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Save the command for use when reading. */</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: open device. Mapped to user open().</span>
<span class="cm"> * Return: Always 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">envctrl_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Open device. Mapped to user close().</span>
<span class="cm"> * Return: Always 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">envctrl_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">envctrl_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>		<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>			<span class="n">envctrl_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span>	<span class="n">envctrl_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span>		<span class="n">envctrl_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>			<span class="n">envctrl_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>		<span class="n">envctrl_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>		<span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>	

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">envctrl_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ENVCTRL_MINOR</span><span class="p">,</span>
	<span class="s">&quot;envctrl&quot;</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">envctrl_fops</span>
<span class="p">};</span>

<span class="cm">/* Function Description: Set monitor type based on firmware description.</span>
<span class="cm"> * Return: None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_set_mon</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chnl_desc</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">chnl_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Firmware only has temperature type.  It does not distinguish</span>
<span class="cm">	 * different kinds of temperatures.  We use channel description</span>
<span class="cm">	 * to disinguish them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,cpu&quot;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,cpu0&quot;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,cpu1&quot;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,cpu2&quot;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,cpu3&quot;</span><span class="p">)))</span>
		<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">chnl_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_CPUTEMP_MON</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;vddcore,cpu0&quot;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;vddcore,cpu1&quot;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;vddcore,cpu2&quot;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;vddcore,cpu3&quot;</span><span class="p">)))</span>
		<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">chnl_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_CPUVOLTAGE_MON</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,motherboard&quot;</span><span class="p">)))</span>
		<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">chnl_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_MTHRBDTEMP_MON</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,scsi&quot;</span><span class="p">)))</span>
		<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">chnl_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_SCSITEMP_MON</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chnl_desc</span><span class="p">,</span><span class="s">&quot;temp,ethernet&quot;</span><span class="p">)))</span>
		<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">chnl_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_ETHERTEMP_MON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Initialize monitor channel with channel desc,</span>
<span class="cm"> *                       decoding tables, monitor type, optional properties.</span>
<span class="cm"> * Return: None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_init_adc</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pval</span><span class="p">;</span>

	<span class="cm">/* Firmware describe channels into a stream separated by a &#39;\0&#39;. */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;channels-description&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">envctrl_set_mon</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get optional properties. */</span>
	<span class="n">pval</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;warning-temp&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pval</span><span class="p">)</span>
		<span class="n">warning_temperature</span> <span class="o">=</span> <span class="o">*</span><span class="n">pval</span><span class="p">;</span>

	<span class="n">pval</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;shutdown-temp&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pval</span><span class="p">)</span>
		<span class="n">shutdown_temperature</span> <span class="o">=</span> <span class="o">*</span><span class="n">pval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Initialize child device monitoring fan status.</span>
<span class="cm"> * Return: None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_init_fanstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Go through all channels and set up the mask. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">fan_mask</span> <span class="o">|=</span> <span class="n">chnls_mask</span><span class="p">[(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">chnl_array</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">chnl_no</span><span class="p">];</span>

	<span class="cm">/* We only need to know if this child has fan status monitored.</span>
<span class="cm">	 * We don&#39;t care which channels since we have the mask already.</span>
<span class="cm">	 */</span>
	<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_FANSTAT_MON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Initialize child device for global addressing line.</span>
<span class="cm"> * Return: None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_init_globaladdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Voltage/PowerSupply monitoring is piggybacked </span>
<span class="cm">	 * with Global Address on CompactPCI.  See comments</span>
<span class="cm">	 * within envctrl_i2c_globaladdr for bit assignments.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The mask is created here by assigning mask bits to each</span>
<span class="cm">	 * bit position that represents PCF8584_VOLTAGE_TYPE data.</span>
<span class="cm">	 * Channel numbers are not consecutive within the globaladdr</span>
<span class="cm">	 * node (why?), so we use the actual counter value as chnls_mask</span>
<span class="cm">	 * index instead of the chnl_array[x].chnl_no value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: This loop could be replaced with a constant representing</span>
<span class="cm">	 * a mask of bits 5&amp;6 (ENVCTRL_GLOBALADDR_PSTAT_MASK).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PCF8584_VOLTAGE_TYPE</span> <span class="o">==</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">chnl_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">voltage_mask</span> <span class="o">|=</span> <span class="n">chnls_mask</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We only need to know if this child has global addressing </span>
<span class="cm">	 * line monitored.  We don&#39;t care which channels since we know </span>
<span class="cm">	 * the mask already (ENVCTRL_GLOBALADDR_ADDR_MASK).</span>
<span class="cm">	 */</span>
	<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_GLOBALADDR_MON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize child device monitoring voltage status. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_init_voltage_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Go through all channels and set up the mask. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">voltage_mask</span> <span class="o">|=</span> <span class="n">chnls_mask</span><span class="p">[(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">chnl_array</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">chnl_no</span><span class="p">];</span>

	<span class="cm">/* We only need to know if this child has voltage status monitored.</span>
<span class="cm">	 * We don&#39;t care which channels since we have the mask already.</span>
<span class="cm">	 */</span>
	<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_VOLTAGESTAT_MON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Initialize i2c child device.</span>
<span class="cm"> * Return: None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_init_i2c_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">pchild</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tbls_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pval</span><span class="p">;</span>

	<span class="cm">/* Get device address. */</span>
	<span class="n">pval</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Get tables property.  Read firmware temperature tables. */</span>
	<span class="n">pval</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;translation&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pval</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_tbls</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcf8584_tblprop</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_tbls</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">+</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tbls_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tbls_size</span> <span class="o">=</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">+</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tblprop_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

                <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tables</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">tbls_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tables</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Failed to allocate table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pval</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;tables&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pval</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Failed to get table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">tables</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* SPARCengine ASM Reference Manual (ref. SMI doc 805-7581-04)</span>
<span class="cm">	 * sections 2.5, 3.5, 4.5 state node 0x70 for CP1400/1500 is</span>
<span class="cm">	 * &quot;For Factory Use Only.&quot;</span>
<span class="cm">	 *</span>
<span class="cm">	 * We ignore the node on these platforms by assigning the</span>
<span class="cm">	 * &#39;NULL&#39; monitor type.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ENVCTRL_CPCI_IGNORED_NODE</span> <span class="o">==</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">root_node</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">root_node</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">root_node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;SUNW,UltraSPARC-IIi-cEngine&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">PCF8584_MAX_CHANNELS</span><span class="p">;</span> <span class="o">++</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">mon_type</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENVCTRL_NOMON</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Get the monitor channels. */</span>
	<span class="n">pval</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;channels-in-use&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">chnl_array</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcf8584_channel</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">chnl_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PCF8584_TEMP_TYPE</span>:
			<span class="n">envctrl_init_adc</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PCF8584_GLOBALADDR_TYPE</span>:
			<span class="n">envctrl_init_globaladdr</span><span class="p">(</span><span class="n">pchild</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PCF8584_FANSTAT_TYPE</span>:
			<span class="n">envctrl_init_fanstat</span><span class="p">(</span><span class="n">pchild</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PCF8584_VOLTAGE_TYPE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">pchild</span><span class="o">-&gt;</span><span class="n">i2ctype</span> <span class="o">==</span> <span class="n">I2C_ADC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">envctrl_init_adc</span><span class="p">(</span><span class="n">pchild</span><span class="p">,</span><span class="n">dp</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">envctrl_init_voltage_status</span><span class="p">(</span><span class="n">pchild</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">pchild</span><span class="o">-&gt;</span><span class="n">total_chnls</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Function Description: Search the child device list for a device.</span>
<span class="cm"> * Return : The i2c child if found. NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="nf">envctrl_get_i2c_child</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mon_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ENVCTRL_MAX_CPU</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">PCF8584_MAX_CHANNELS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i2c_childlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mon_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">mon_type</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">i2c_childlist</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">envctrl_do_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">inprog</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inprog</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">inprog</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;kenvctrld: WARNING: Shutting down the system now.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">orderly_poweroff</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;kenvctrld: WARNING: system shutdown failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> 
		<span class="n">inprog</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* unlikely to succeed, but we could try again */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kenvctrld_task</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kenvctrld</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">poll_interval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">whichcpu</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tempbuf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">i2c_child_t</span> <span class="o">*</span><span class="n">cputemp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">cputemp</span> <span class="o">=</span> <span class="n">envctrl_get_i2c_child</span><span class="p">(</span><span class="n">ENVCTRL_CPUTEMP_MON</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>  <span class="n">PFX</span>
		       <span class="s">&quot;kenvctrld unable to monitor CPU temp-- exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">poll_interval</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="cm">/* TODO env_mon_interval */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;%s starting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="n">poll_interval</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
		
		<span class="k">for</span> <span class="p">(</span><span class="n">whichcpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">whichcpu</span> <span class="o">&lt;</span> <span class="n">ENVCTRL_MAX_CPU</span><span class="p">;</span> <span class="o">++</span><span class="n">whichcpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">envctrl_read_cpu_info</span><span class="p">(</span><span class="n">whichcpu</span><span class="p">,</span> <span class="n">cputemp</span><span class="p">,</span>
						      <span class="n">ENVCTRL_CPUTEMP_MON</span><span class="p">,</span>
						      <span class="n">tempbuf</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tempbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">shutdown_temperature</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> 
						<span class="s">&quot;%s: WARNING: CPU%i temperature %i C meets or exceeds &quot;</span>\
						<span class="s">&quot;shutdown threshold %i C</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
						<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">whichcpu</span><span class="p">,</span> 
						<span class="n">tempbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shutdown_temperature</span><span class="p">);</span>
					<span class="n">envctrl_do_shutdown</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;%s exiting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">envctrl_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2c</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">i2c</span> <span class="o">=</span> <span class="n">of_ioremap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;gpio&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">i2ctype</span> <span class="o">=</span> <span class="n">I2C_GPIO</span><span class="p">;</span>
			<span class="n">envctrl_init_i2c_child</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;adc&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">i2ctype</span> <span class="o">=</span> <span class="n">I2C_ADC</span><span class="p">;</span>
			<span class="n">envctrl_init_i2c_child</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]));</span>
		<span class="p">}</span>

		<span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set device address. */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">CONTROL_PIN</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">PCF8584_ADDRESS</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>

	<span class="cm">/* Set system clock and SCL frequencies. */</span> 
	<span class="n">writeb</span><span class="p">(</span><span class="n">CONTROL_PIN</span> <span class="o">|</span> <span class="n">CONTROL_ES1</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">CLK_4_43</span> <span class="o">|</span> <span class="n">BUS_CLK_90</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_DATA</span><span class="p">);</span>

	<span class="cm">/* Enable serial interface. */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">CONTROL_PIN</span> <span class="o">|</span> <span class="n">CONTROL_ES0</span> <span class="o">|</span> <span class="n">CONTROL_ACK</span><span class="p">,</span> <span class="n">i2c</span> <span class="o">+</span> <span class="n">PCF8584_CSR</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

	<span class="cm">/* Register the device as a minor miscellaneous device. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">envctrl_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Unable to get misc minor %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">envctrl_dev</span><span class="p">.</span><span class="n">minor</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Note above traversal routine post-incremented &#39;i&#39; to accommodate </span>
<span class="cm">	 * a next child device, so we decrement before reverse-traversal of</span>
<span class="cm">	 * child devices.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Initialized &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">index</span><span class="p">;</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[%s 0x%lx]%s&quot;</span><span class="p">,</span> 
			<span class="p">(</span><span class="n">I2C_ADC</span> <span class="o">==</span> <span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">i2ctype</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;adc&quot;</span> <span class="o">:</span> 
			<span class="p">((</span><span class="n">I2C_GPIO</span> <span class="o">==</span> <span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">i2ctype</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;gpio&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">),</span> 
			<span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kenvctrld_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">kenvctrld</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;kenvctrld&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kenvctrld_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kenvctrld_task</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_deregister</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_deregister:</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">envctrl_dev</span><span class="p">);</span>
<span class="nl">out_iounmap:</span>
	<span class="n">of_iounmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i2c</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ENVCTRL_MAX_CPU</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">tables</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">envctrl_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">kenvctrld_task</span><span class="p">);</span>

	<span class="n">of_iounmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i2c</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">envctrl_dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ENVCTRL_MAX_CPU</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">i2c_childlist</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">tables</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">envctrl_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;i2c&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;i2cpcf,8584&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">envctrl_match</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">envctrl_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">envctrl_match</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">envctrl_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">envctrl_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">envctrl_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
