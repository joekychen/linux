<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › xen › events.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>events.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Xen event channels</span>
<span class="cm"> *</span>
<span class="cm"> * Xen models interrupts with abstract event channels.  Because each</span>
<span class="cm"> * domain gets 1024 event channels, but NR_IRQ is not that large, we</span>
<span class="cm"> * must dynamically map irqs&lt;-&gt;event channels.  The event channels</span>
<span class="cm"> * interface with the rest of the kernel by defining a xen interrupt</span>
<span class="cm"> * chip.  When an event is received, it is mapped to an irq and sent</span>
<span class="cm"> * through the normal interrupt processing path.</span>
<span class="cm"> *</span>
<span class="cm"> * There are four kinds of events which can be mapped to an event</span>
<span class="cm"> * channel:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Inter-domain notifications.  This includes all the virtual</span>
<span class="cm"> *    device events, since they&#39;re driven by front-ends in another domain</span>
<span class="cm"> *    (typically dom0).</span>
<span class="cm"> * 2. VIRQs, typically used for timers.  These are per-cpu events.</span>
<span class="cm"> * 3. IPIs.</span>
<span class="cm"> * 4. PIRQs - Hardware interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * Jeremy Fitzhardinge &lt;jeremy@xensource.com&gt;, XenSource Inc, 2007</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/irqnr.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>

<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/idle.h&gt;</span>
<span class="cp">#include &lt;asm/io_apic.h&gt;</span>
<span class="cp">#include &lt;asm/sync_bitops.h&gt;</span>
<span class="cp">#include &lt;asm/xen/page.h&gt;</span>
<span class="cp">#include &lt;asm/xen/pci.h&gt;</span>
<span class="cp">#include &lt;asm/xen/hypercall.h&gt;</span>
<span class="cp">#include &lt;asm/xen/hypervisor.h&gt;</span>

<span class="cp">#include &lt;xen/xen.h&gt;</span>
<span class="cp">#include &lt;xen/hvm.h&gt;</span>
<span class="cp">#include &lt;xen/xen-ops.h&gt;</span>
<span class="cp">#include &lt;xen/events.h&gt;</span>
<span class="cp">#include &lt;xen/interface/xen.h&gt;</span>
<span class="cp">#include &lt;xen/interface/event_channel.h&gt;</span>
<span class="cp">#include &lt;xen/interface/hvm/hvm_op.h&gt;</span>
<span class="cp">#include &lt;xen/interface/hvm/params.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This lock protects updates to the following mapping and reference-count</span>
<span class="cm"> * arrays. The lock does not need to be acquired to read the mapping tables.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">xen_irq_list_head</span><span class="p">);</span>

<span class="cm">/* IRQ &lt;-&gt; VIRQ mapping. */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span> <span class="p">[</span><span class="n">NR_VIRQS</span><span class="p">],</span> <span class="n">virq_to_irq</span><span class="p">)</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">NR_VIRQS</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>

<span class="cm">/* IRQ &lt;-&gt; IPI mapping */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span> <span class="p">[</span><span class="n">XEN_NR_IPIS</span><span class="p">],</span> <span class="n">ipi_to_irq</span><span class="p">)</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">XEN_NR_IPIS</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>

<span class="cm">/* Interrupt types. */</span>
<span class="k">enum</span> <span class="n">xen_irq_type</span> <span class="p">{</span>
	<span class="n">IRQT_UNBOUND</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IRQT_PIRQ</span><span class="p">,</span>
	<span class="n">IRQT_VIRQ</span><span class="p">,</span>
	<span class="n">IRQT_IPI</span><span class="p">,</span>
	<span class="n">IRQT_EVTCHN</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Packed IRQ information:</span>
<span class="cm"> * type - enum xen_irq_type</span>
<span class="cm"> * event channel - irq-&gt;event channel mapping</span>
<span class="cm"> * cpu - cpu this event channel is bound to</span>
<span class="cm"> * index - type-specific information:</span>
<span class="cm"> *    PIRQ - vector, with MSB being &quot;needs EIO&quot;, or physical IRQ of the HVM</span>
<span class="cm"> *           guest, or GSI (real passthrough IRQ) of the device.</span>
<span class="cm"> *    VIRQ - virq number</span>
<span class="cm"> *    IPI - IPI vector</span>
<span class="cm"> *    EVTCHN -</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irq_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">refcnt</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xen_irq_type</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* type */</span>
	<span class="kt">unsigned</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">evtchn</span><span class="p">;</span>	<span class="cm">/* event channel */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cpu</span><span class="p">;</span>	<span class="cm">/* cpu bound */</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">virq</span><span class="p">;</span>
		<span class="k">enum</span> <span class="n">ipi_vector</span> <span class="n">ipi</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pirq</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">gsi</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vector</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">domid</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">pirq</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define PIRQ_NEEDS_EOI	(1 &lt;&lt; 0)</span>
<span class="cp">#define PIRQ_SHAREABLE	(1 &lt;&lt; 1)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="o">*</span><span class="n">evtchn_to_irq</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pirq_eoi_map</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pirq_needs_eoi</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">[</span><span class="n">NR_EVENT_CHANNELS</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">],</span>
		      <span class="n">cpu_evtchn_mask</span><span class="p">);</span>

<span class="cm">/* Xen will never allocate port zero for any purpose. */</span>
<span class="cp">#define VALID_EVTCHN(chn)	((chn) != 0)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">xen_dynamic_chip</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">xen_percpu_chip</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">xen_pirq_chip</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">enable_dynirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">disable_dynirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* Get info for IRQ */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="nf">info_for_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_get_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Constructors for packed IRQ information. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_irq_info_common_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="n">irq</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">xen_irq_type</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">evtchn</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_UNBOUND</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_irq_info_evtchn_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">evtchn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">xen_irq_info_common_init</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">IRQT_EVTCHN</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_irq_info_ipi_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">cpu</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="n">irq</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">evtchn</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">ipi_vector</span> <span class="n">ipi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">xen_irq_info_common_init</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">IRQT_IPI</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ipi</span> <span class="o">=</span> <span class="n">ipi</span><span class="p">;</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_to_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">ipi</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_irq_info_virq_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">cpu</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">irq</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">evtchn</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">virq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">xen_irq_info_common_init</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">IRQT_VIRQ</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">virq</span> <span class="o">=</span> <span class="n">virq</span><span class="p">;</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">virq_to_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">virq</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_irq_info_pirq_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">evtchn</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pirq</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">gsi</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vector</span><span class="p">,</span>
				   <span class="kt">uint16_t</span> <span class="n">domid</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">xen_irq_info_common_init</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">IRQT_PIRQ</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">pirq</span> <span class="o">=</span> <span class="n">pirq</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">gsi</span> <span class="o">=</span> <span class="n">gsi</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">domid</span> <span class="o">=</span> <span class="n">domid</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Accessors for packed IRQ information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">evtchn_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">nr_irqs</span><span class="p">,</span> <span class="s">&quot;Invalid irq %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">evtchn</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="nf">irq_from_evtchn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evtchn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">irq_from_evtchn</span><span class="p">);</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">ipi_vector</span> <span class="nf">ipi_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_IPI</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ipi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">virq_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_VIRQ</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">virq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">pirq_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">pirq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">xen_irq_type</span> <span class="nf">type_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">cpu_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpu_from_evtchn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evtchn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cpu_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pirq_check_eoi_map</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">pirq_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">),</span> <span class="n">pirq_eoi_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pirq_needs_eoi_flag</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PIRQ_NEEDS_EOI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">active_evtchns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">sh</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_evtchn_mask</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bind_evtchn_to_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">chn</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">affinity</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">chn</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_evtchn_mask</span><span class="p">,</span> <span class="n">cpu_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">chn</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_evtchn_mask</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_evtchn_cpu_bindings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/* By default all event channels notify CPU#0. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_irq_list_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">affinity</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_evtchn_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
		       <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">~</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_evtchn_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_evtchn</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="n">sync_clear_bit</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_evtchn</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="n">sync_set_bit</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_evtchn</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sync_test_bit</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * notify_remote_via_irq - send event to remote end of event channel via irq</span>
<span class="cm"> * @irq: irq of event channel to send event to</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike notify_remote_via_evtchn(), this is safe to use across</span>
<span class="cm"> * save/restore. Notifications on a broken connection are silently</span>
<span class="cm"> * dropped.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">notify_remote_via_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">notify_remote_via_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">notify_remote_via_irq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_evtchn</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="n">sync_set_bit</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmask_evtchn</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="cm">/* Slow path (hypercall) if this is a non-local port. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu_from_evtchn</span><span class="p">(</span><span class="n">port</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">evtchn_unmask</span> <span class="n">unmask</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span> <span class="p">};</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_unmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unmask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vcpu_info</span> <span class="o">*</span><span class="n">vcpu_info</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">xen_vcpu</span><span class="p">);</span>

		<span class="n">sync_clear_bit</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The following is basically the equivalent of</span>
<span class="cm">		 * &#39;hw_resend_irq&#39;. Just like a real IO-APIC we &#39;lose</span>
<span class="cm">		 * the interrupt edge&#39; if the channel is masked.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sync_test_bit</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">sync_test_and_set_bit</span><span class="p">(</span><span class="n">port</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">vcpu_info</span><span class="o">-&gt;</span><span class="n">evtchn_pending_sel</span><span class="p">))</span>
			<span class="n">vcpu_info</span><span class="o">-&gt;</span><span class="n">evtchn_upcall_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_irq_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* By default all event channels notify CPU#0. */</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">affinity</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unable to allocate metadata for IRQ%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">IRQT_UNBOUND</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">irq_set_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_irq_list_head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">xen_allocate_irq_dynamic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
	<span class="cm">/*</span>
<span class="cm">	 * For an HVM guest or domain 0 which see &quot;real&quot; (emulated or</span>
<span class="cm">	 * actual respectively) GSIs we allocate dynamic IRQs</span>
<span class="cm">	 * e.g. those corresponding to event channels or MSIs</span>
<span class="cm">	 * etc. from the range above those &quot;real&quot; GSIs to avoid</span>
<span class="cm">	 * collisions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_initial_domain</span><span class="p">()</span> <span class="o">||</span> <span class="n">xen_hvm_domain</span><span class="p">())</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">get_nr_irqs_gsi</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">irq_alloc_desc_from</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xen_irq_init</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">xen_allocate_irq_gsi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A PV guest has no concept of a GSI (since it has no ACPI</span>
<span class="cm">	 * nor access to/knowledge of the physical APICs). Therefore</span>
<span class="cm">	 * all IRQs are dynamically allocated from the entire IRQ</span>
<span class="cm">	 * space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_pv_domain</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xen_initial_domain</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">xen_allocate_irq_dynamic</span><span class="p">();</span>

	<span class="cm">/* Legacy IRQ descriptors are already allocated by the arch. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsi</span> <span class="o">&lt;</span> <span class="n">NR_IRQS_LEGACY</span><span class="p">)</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">gsi</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">irq_alloc_desc_at</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">xen_irq_init</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_free_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">irq_get_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">irq_set_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Legacy IRQ descriptors are managed by the arch. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="n">NR_IRQS_LEGACY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">irq_free_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pirq_query_unmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">physdev_irq_status_query</span> <span class="n">irq_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">);</span>

	<span class="n">irq_status</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pirq_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_irq_status_query</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_status</span><span class="p">))</span>
		<span class="n">irq_status</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PIRQ_NEEDS_EOI</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XENIRQSTAT_needs_eoi</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PIRQ_NEEDS_EOI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">probing_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">eoi_pirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">physdev_eoi</span> <span class="n">eoi</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pirq_from_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irq_move_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">clear_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pirq_needs_eoi</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_eoi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eoi</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_ack_pirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_dynirq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">eoi_pirq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__startup_pirq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_pirq</span> <span class="n">bind_pirq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bind_pirq</span><span class="p">.</span><span class="n">pirq</span> <span class="o">=</span> <span class="n">pirq_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="cm">/* NB. We are happy to share unless we are probing. */</span>
	<span class="n">bind_pirq</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PIRQ_SHAREABLE</span> <span class="o">?</span>
					<span class="n">BIND_PIRQ__WILL_SHARE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_pirq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bind_pirq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">probing_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Failed to obtain physical IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">evtchn</span> <span class="o">=</span> <span class="n">bind_pirq</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>

	<span class="n">pirq_query_unmask</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">unmask_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
	<span class="n">eoi_pirq</span><span class="p">(</span><span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">irq</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">startup_pirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__startup_pirq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shutdown_pirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_close</span> <span class="n">close</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mask_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>

	<span class="n">close</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">evtchn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_close</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">close</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">evtchn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_pirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">startup_pirq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_pirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_dynirq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xen_irq_from_gsi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_irq_list_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">gsi</span> <span class="o">==</span> <span class="n">gsi</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_irq_from_gsi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Do not make any assumptions regarding the relationship between the</span>
<span class="cm"> * IRQ number returned here and the Xen pirq argument.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: We don&#39;t assign an event channel until the irq actually started</span>
<span class="cm"> * up.  Return an existing irq if we&#39;ve already got one for the gsi.</span>
<span class="cm"> *</span>
<span class="cm"> * Shareable implies level triggered, not shareable implies edge</span>
<span class="cm"> * triggered here.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xen_bind_pirq_gsi_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gsi</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="n">pirq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shareable</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">physdev_irq</span> <span class="n">irq_op</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">xen_irq_from_gsi</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;xen_map_pirq_gsi: returning irq %d for gsi %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">irq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">xen_allocate_irq_gsi</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">irq_op</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">irq_op</span><span class="p">.</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Only the privileged domain can do this. For non-priv, the pcifront</span>
<span class="cm">	 * driver provides a PCI bus that does the call to do exactly</span>
<span class="cm">	 * this in the priv domain. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_initial_domain</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_alloc_irq_vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_op</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xen_free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xen_irq_info_pirq_init</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pirq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">,</span> <span class="n">irq_op</span><span class="p">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">,</span>
			       <span class="n">shareable</span> <span class="o">?</span> <span class="n">PIRQ_SHAREABLE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">pirq_query_unmask</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="cm">/* We try to use the handler with the appropriate semantic for the</span>
<span class="cm">	 * type of interrupt: if the interrupt is an edge triggered</span>
<span class="cm">	 * interrupt we use handle_edge_irq.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On the other hand if the interrupt is level triggered we use</span>
<span class="cm">	 * handle_fasteoi_irq like the native code does for this kind of</span>
<span class="cm">	 * interrupts.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Depending on the Xen version, pirq_needs_eoi might return true</span>
<span class="cm">	 * not only for level triggered interrupts but for edge triggered</span>
<span class="cm">	 * interrupts too. In any case Xen always honors the eoi mechanism,</span>
<span class="cm">	 * not injecting any more pirqs of the same kind if the first one</span>
<span class="cm">	 * hasn&#39;t received an eoi yet. Therefore using the fasteoi handler</span>
<span class="cm">	 * is the right choice either way.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shareable</span><span class="p">)</span>
		<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_pirq_chip</span><span class="p">,</span>
				<span class="n">handle_fasteoi_irq</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_pirq_chip</span><span class="p">,</span>
				<span class="n">handle_edge_irq</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI_MSI</span>
<span class="kt">int</span> <span class="nf">xen_allocate_pirq_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msi_desc</span> <span class="o">*</span><span class="n">msidesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">physdev_get_free_pirq</span> <span class="n">op_get_free_pirq</span><span class="p">;</span>

	<span class="n">op_get_free_pirq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MAP_PIRQ_TYPE_MSI</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_get_free_pirq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op_get_free_pirq</span><span class="p">);</span>

	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">,</span>
		  <span class="s">&quot;hypervisor does not support the PHYSDEVOP_get_free_pirq interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">op_get_free_pirq</span><span class="p">.</span><span class="n">pirq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xen_bind_pirq_msi_to_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msi_desc</span> <span class="o">*</span><span class="n">msidesc</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">pirq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">domid_t</span> <span class="n">domid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">xen_allocate_irq_dynamic</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_pirq_chip</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span>
			<span class="n">name</span><span class="p">);</span>

	<span class="n">xen_irq_info_pirq_init</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pirq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">domid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irq_set_msi_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">msidesc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_irq</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="nl">error_irq:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>
	<span class="n">xen_free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">xen_destroy_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">physdev_unmap_pirq</span> <span class="n">unmap_irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xen_initial_domain</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">unmap_irq</span><span class="p">.</span><span class="n">pirq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">pirq</span><span class="p">;</span>
		<span class="n">unmap_irq</span><span class="p">.</span><span class="n">domid</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">domid</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_unmap_pirq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unmap_irq</span><span class="p">);</span>
		<span class="cm">/* If another domain quits without making the pci_disable_msix</span>
<span class="cm">		 * call, the Xen hypervisor takes care of freeing the PIRQs</span>
<span class="cm">		 * (free_domain_pirqs).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESRCH</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">domid</span> <span class="o">!=</span> <span class="n">DOMID_SELF</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;domain %d does not have %d anymore</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">domid</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">pirq</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;unmap irq failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xen_free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xen_irq_from_pirq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pirq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_irq_list_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">pirq</span> <span class="o">==</span> <span class="n">pirq</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">xen_pirq_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pirq_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_pirq_from_irq</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bind_evtchn_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evtchn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">xen_allocate_irq_dynamic</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_dynamic_chip</span><span class="p">,</span>
					      <span class="n">handle_edge_irq</span><span class="p">,</span> <span class="s">&quot;event&quot;</span><span class="p">);</span>

		<span class="n">xen_irq_info_evtchn_init</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_EVTCHN</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bind_evtchn_to_irq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bind_ipi_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ipi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_ipi</span> <span class="n">bind_ipi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">evtchn</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_to_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">ipi</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">xen_allocate_irq_dynamic</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_percpu_chip</span><span class="p">,</span>
					      <span class="n">handle_percpu_irq</span><span class="p">,</span> <span class="s">&quot;ipi&quot;</span><span class="p">);</span>

		<span class="n">bind_ipi</span><span class="p">.</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_ipi</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">bind_ipi</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">evtchn</span> <span class="o">=</span> <span class="n">bind_ipi</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>

		<span class="n">xen_irq_info_ipi_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="n">ipi</span><span class="p">);</span>

		<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_IPI</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bind_interdomain_evtchn_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remote_domain</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remote_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_interdomain</span> <span class="n">bind_interdomain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">bind_interdomain</span><span class="p">.</span><span class="n">remote_dom</span>  <span class="o">=</span> <span class="n">remote_domain</span><span class="p">;</span>
	<span class="n">bind_interdomain</span><span class="p">.</span><span class="n">remote_port</span> <span class="o">=</span> <span class="n">remote_port</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_interdomain</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">bind_interdomain</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="o">:</span> <span class="n">bind_evtchn_to_irq</span><span class="p">(</span><span class="n">bind_interdomain</span><span class="p">.</span><span class="n">local_port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_virq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;=</span> <span class="n">NR_EVENT_CHANNELS</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span><span class="p">.</span><span class="n">dom</span> <span class="o">=</span> <span class="n">DOMID_SELF</span><span class="p">;</span>
		<span class="n">status</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">EVTCHNSTAT_virq</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">virq</span> <span class="o">==</span> <span class="n">virq</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">.</span><span class="n">vcpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bind_virq_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_virq</span> <span class="n">bind_virq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">evtchn</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">virq_to_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">virq</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">xen_allocate_irq_dynamic</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_percpu_chip</span><span class="p">,</span>
					      <span class="n">handle_percpu_irq</span><span class="p">,</span> <span class="s">&quot;virq&quot;</span><span class="p">);</span>

		<span class="n">bind_virq</span><span class="p">.</span><span class="n">virq</span> <span class="o">=</span> <span class="n">virq</span><span class="p">;</span>
		<span class="n">bind_virq</span><span class="p">.</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_virq</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">bind_virq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">evtchn</span> <span class="o">=</span> <span class="n">bind_virq</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">find_virq</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">evtchn</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xen_irq_info_virq_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="n">virq</span><span class="p">);</span>

		<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_VIRQ</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unbind_from_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_close</span> <span class="n">close</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">irq_get_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">close</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">evtchn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_close</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">close</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IRQT_VIRQ</span>:
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">virq_to_irq</span><span class="p">,</span> <span class="n">cpu_from_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
				<span class="p">[</span><span class="n">virq_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IRQT_IPI</span>:
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_to_irq</span><span class="p">,</span> <span class="n">cpu_from_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
				<span class="p">[</span><span class="n">ipi_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Closed ports are implicitly re-bound to VCPU0. */</span>
		<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">IRQT_UNBOUND</span><span class="p">);</span>

	<span class="n">xen_free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bind_evtchn_to_irqhandler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evtchn</span><span class="p">,</span>
			      <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">bind_evtchn_to_irq</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">,</span> <span class="n">devname</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unbind_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bind_evtchn_to_irqhandler</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bind_interdomain_evtchn_to_irqhandler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remote_domain</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remote_port</span><span class="p">,</span>
					  <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">bind_interdomain_evtchn_to_irq</span><span class="p">(</span><span class="n">remote_domain</span><span class="p">,</span> <span class="n">remote_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">,</span> <span class="n">devname</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unbind_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bind_interdomain_evtchn_to_irqhandler</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bind_virq_to_irqhandler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			    <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">bind_virq_to_irq</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">,</span> <span class="n">devname</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unbind_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bind_virq_to_irqhandler</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bind_ipi_to_irqhandler</span><span class="p">(</span><span class="k">enum</span> <span class="n">ipi_vector</span> <span class="n">ipi</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			   <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">bind_ipi_to_irq</span><span class="p">(</span><span class="n">ipi</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">irqflags</span> <span class="o">|=</span> <span class="n">IRQF_NO_SUSPEND</span> <span class="o">|</span> <span class="n">IRQF_FORCE_RESUME</span> <span class="o">|</span> <span class="n">IRQF_EARLY_RESUME</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">,</span> <span class="n">devname</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unbind_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unbind_from_irqhandler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="n">unbind_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unbind_from_irqhandler</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">evtchn_make_refcounted</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evtchn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">irq_get_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">evtchn_make_refcounted</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">evtchn_get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evtchn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">evtchn</span> <span class="o">&gt;=</span> <span class="n">NR_EVENT_CHANNELS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">irq_get_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">evtchn_get</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">evtchn_put</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evtchn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">unbind_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">evtchn_put</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">xen_send_IPI_one</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ipi_vector</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_to_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">notify_remote_via_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">xen_debug_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cpu_evtchn</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_evtchn_mask</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">debug_lock</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vcpu_info</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">debug_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">vcpu %d</span><span class="se">\n</span><span class="s">  &quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pending</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">xen_vcpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">pending</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_irq_regs</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="o">?</span> <span class="n">xen_irqs_disabled</span><span class="p">(</span><span class="n">get_irq_regs</span><span class="p">())</span>
			<span class="o">:</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">evtchn_upcall_mask</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d: masked=%d pending=%d event_sel %0*lx</span><span class="se">\n</span><span class="s">  &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
		       <span class="n">pending</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">evtchn_upcall_pending</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">evtchn_pending_sel</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span>
		       <span class="n">v</span><span class="o">-&gt;</span><span class="n">evtchn_pending_sel</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">xen_vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">pending:</span><span class="se">\n</span><span class="s">   &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%0*lx%s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
		       <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
		       <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">global mask:</span><span class="se">\n</span><span class="s">   &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%0*lx%s&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span>
		       <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
		       <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">globally unmasked:</span><span class="se">\n</span><span class="s">   &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%0*lx%s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span>
		       <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
		       <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">local cpu%d mask:</span><span class="se">\n</span><span class="s">   &quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">NR_EVENT_CHANNELS</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%0*lx%s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cpu_evtchn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span>
		       <span class="n">cpu_evtchn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
		       <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">locally unmasked:</span><span class="se">\n</span><span class="s">   &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="o">&amp;</span> <span class="n">cpu_evtchn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%0*lx%s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span>
		       <span class="n">pending</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">pending list:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_EVENT_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sync_test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">word_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  %d: event %d -&gt; irq %d%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cpu_from_evtchn</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span>
			       <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			       <span class="n">sync_test_bit</span><span class="p">(</span><span class="n">word_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">evtchn_pending_sel</span><span class="p">)</span>
					     <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; l2-clear&quot;</span><span class="p">,</span>
			       <span class="o">!</span><span class="n">sync_test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">)</span>
					     <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; globally-masked&quot;</span><span class="p">,</span>
			       <span class="n">sync_test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_evtchn</span><span class="p">)</span>
					     <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; locally-masked&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">debug_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">xed_nesting_count</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">current_word_idx</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">current_bit_idx</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Mask out the i least significant bits of w</span>
<span class="cm"> */</span>
<span class="cp">#define MASK_LSBS(w, i) (w &amp; ((~0UL) &lt;&lt; i))</span>

<span class="cm">/*</span>
<span class="cm"> * Search the CPUs pending events bitmasks.  For each one found, map</span>
<span class="cm"> * the event number to an irq, and feed it into do_IRQ() for</span>
<span class="cm"> * handling.</span>
<span class="cm"> *</span>
<span class="cm"> * Xen uses a two-level bitmap to speed searching.  The first level is</span>
<span class="cm"> * a bitset of words which contain pending event bits.  The second</span>
<span class="cm"> * level is a bitset of pending events themselves.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__xen_evtchn_do_upcall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_word_idx</span><span class="p">,</span> <span class="n">start_bit_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">word_idx</span><span class="p">,</span> <span class="n">bit_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_info</span> <span class="o">*</span><span class="n">vcpu_info</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">xen_vcpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_words</span><span class="p">;</span>

		<span class="n">vcpu_info</span><span class="o">-&gt;</span><span class="n">evtchn_upcall_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_inc_return</span><span class="p">(</span><span class="n">xed_nesting_count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_X86 </span><span class="cm">/* No need for a barrier -- XCHG is a barrier on x86. */</span><span class="cp"></span>
		<span class="cm">/* Clear master flag /before/ clearing selector flag. */</span>
		<span class="n">wmb</span><span class="p">();</span>
<span class="cp">#endif</span>
		<span class="n">pending_words</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu_info</span><span class="o">-&gt;</span><span class="n">evtchn_pending_sel</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">start_word_idx</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_word_idx</span><span class="p">);</span>
		<span class="n">start_bit_idx</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_bit_idx</span><span class="p">);</span>

		<span class="n">word_idx</span> <span class="o">=</span> <span class="n">start_word_idx</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pending_words</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_bits</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">words</span><span class="p">;</span>

			<span class="n">words</span> <span class="o">=</span> <span class="n">MASK_LSBS</span><span class="p">(</span><span class="n">pending_words</span><span class="p">,</span> <span class="n">word_idx</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we masked out all events, wrap to beginning.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">word_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">bit_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">word_idx</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">words</span><span class="p">);</span>

			<span class="n">pending_bits</span> <span class="o">=</span> <span class="n">active_evtchns</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">word_idx</span><span class="p">);</span>
			<span class="n">bit_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* usually scan entire word from start */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">word_idx</span> <span class="o">==</span> <span class="n">start_word_idx</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We scan the starting word in two parts */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="cm">/* 1st time: start in the middle */</span>
					<span class="n">bit_idx</span> <span class="o">=</span> <span class="n">start_bit_idx</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="cm">/* 2nd time: mask bits done already */</span>
					<span class="n">bit_idx</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">start_bit_idx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">do</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

				<span class="n">bits</span> <span class="o">=</span> <span class="n">MASK_LSBS</span><span class="p">(</span><span class="n">pending_bits</span><span class="p">,</span> <span class="n">bit_idx</span><span class="p">);</span>

				<span class="cm">/* If we masked out all events, move on. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="n">bit_idx</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>

				<span class="cm">/* Process port. */</span>
				<span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="n">word_idx</span> <span class="o">*</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">+</span> <span class="n">bit_idx</span><span class="p">;</span>
				<span class="n">irq</span> <span class="o">=</span> <span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span>
						<span class="n">generic_handle_irq_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">bit_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>

				<span class="cm">/* Next caller starts at last processed + 1 */</span>
				<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_word_idx</span><span class="p">,</span>
						 <span class="n">bit_idx</span> <span class="o">?</span> <span class="n">word_idx</span> <span class="o">:</span>
						 <span class="p">(</span><span class="n">word_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
				<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_bit_idx</span><span class="p">,</span> <span class="n">bit_idx</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bit_idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/* Scan start_l1i twice; all others once. */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">word_idx</span> <span class="o">!=</span> <span class="n">start_word_idx</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">pending_words</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">word_idx</span><span class="p">);</span>

			<span class="n">word_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">word_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">xed_nesting_count</span><span class="p">);</span>
		<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">xed_nesting_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">vcpu_info</span><span class="o">-&gt;</span><span class="n">evtchn_upcall_pending</span><span class="p">);</span>

<span class="nl">out:</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xen_evtchn_do_upcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">old_regs</span> <span class="o">=</span> <span class="n">set_irq_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">exit_idle</span><span class="p">();</span>
	<span class="n">irq_enter</span><span class="p">();</span>

	<span class="n">__xen_evtchn_do_upcall</span><span class="p">();</span>

	<span class="n">irq_exit</span><span class="p">();</span>
	<span class="n">set_irq_regs</span><span class="p">(</span><span class="n">old_regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xen_hvm_evtchn_do_upcall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__xen_evtchn_do_upcall</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_hvm_evtchn_do_upcall</span><span class="p">);</span>

<span class="cm">/* Rebind a new event channel to an existing irq. */</span>
<span class="kt">void</span> <span class="nf">rebind_evtchn_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">evtchn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* Make sure the irq is masked, since the new event channel</span>
<span class="cm">	   will also be masked. */</span>
	<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="cm">/* After resume the irq&lt;-&gt;evtchn mappings are all cleared out */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Expect irq to have been bound before,</span>
<span class="cm">	   so there should be a proper type */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">IRQT_UNBOUND</span><span class="p">);</span>

	<span class="n">xen_irq_info_evtchn_init</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mapping_update_lock</span><span class="p">);</span>

	<span class="cm">/* new event channels are always bound to cpu 0 */</span>
	<span class="n">irq_set_affinity</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="cm">/* Unmask the event channel. */</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Rebind an evtchn so that it gets delivered to a specific cpu */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rebind_irq_to_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">tcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_vcpu</span> <span class="n">bind_vcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Events delivered via platform PCI interrupts are always</span>
<span class="cm">	 * routed to vcpu 0 and hence cannot be rebound.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_hvm_domain</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xen_have_vector_callback</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Send future instances of this interrupt to other vcpu. */</span>
	<span class="n">bind_vcpu</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">evtchn</span><span class="p">;</span>
	<span class="n">bind_vcpu</span><span class="p">.</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">tcpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this fails, it usually just indicates that we&#39;re dealing with a</span>
<span class="cm">	 * virq or IPI channel, which don&#39;t actually need to be rebound. Ignore</span>
<span class="cm">	 * it, but don&#39;t do the xenlinux-level rebind in that case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bind_vcpu</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">tcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_affinity_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">tcpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rebind_irq_to_cpu</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">tcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">resend_irq_on_evtchn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">masked</span><span class="p">,</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">masked</span> <span class="o">=</span> <span class="n">sync_test_and_set_bit</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">);</span>
	<span class="n">sync_set_bit</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">masked</span><span class="p">)</span>
		<span class="n">unmask_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_dynirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">unmask_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_dynirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">mask_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ack_dynirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">irq_move_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">clear_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_ack_dynirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_dynirq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">ack_dynirq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">retrigger_dynirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shared_info</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">HYPERVISOR_shared_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">masked</span><span class="p">;</span>

		<span class="n">masked</span> <span class="o">=</span> <span class="n">sync_test_and_set_bit</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_mask</span><span class="p">);</span>
		<span class="n">sync_set_bit</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">evtchn_pending</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">masked</span><span class="p">)</span>
			<span class="n">unmask_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_pirqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pirq</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">physdev_map_pirq</span> <span class="n">map_irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_irq_list_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQT_PIRQ</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pirq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">pirq</span><span class="p">;</span>
		<span class="n">gsi</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">gsi</span><span class="p">;</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

		<span class="cm">/* save/restore of PT devices doesn&#39;t work, so at this point the</span>
<span class="cm">		 * only devices present are GSI based emulated devices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsi</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">map_irq</span><span class="p">.</span><span class="n">domid</span> <span class="o">=</span> <span class="n">DOMID_SELF</span><span class="p">;</span>
		<span class="n">map_irq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MAP_PIRQ_TYPE_GSI</span><span class="p">;</span>
		<span class="n">map_irq</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">gsi</span><span class="p">;</span>
		<span class="n">map_irq</span><span class="p">.</span><span class="n">pirq</span> <span class="o">=</span> <span class="n">pirq</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_map_pirq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;xen map irq failed gsi=%d irq=%d pirq=%d rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">pirq</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">xen_free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;xen: --&gt; irq=%d, pirq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">map_irq</span><span class="p">.</span><span class="n">pirq</span><span class="p">);</span>

		<span class="n">__startup_pirq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_cpu_virqs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_virq</span> <span class="n">bind_virq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">virq</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">virq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">virq</span> <span class="o">&lt;</span> <span class="n">NR_VIRQS</span><span class="p">;</span> <span class="n">virq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">irq</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">virq_to_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">virq</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">virq_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">virq</span><span class="p">);</span>

		<span class="cm">/* Get a new binding from Xen. */</span>
		<span class="n">bind_virq</span><span class="p">.</span><span class="n">virq</span> <span class="o">=</span> <span class="n">virq</span><span class="p">;</span>
		<span class="n">bind_virq</span><span class="p">.</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_virq</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">bind_virq</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">evtchn</span> <span class="o">=</span> <span class="n">bind_virq</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>

		<span class="cm">/* Record the new mapping. */</span>
		<span class="n">xen_irq_info_virq_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="n">virq</span><span class="p">);</span>
		<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_cpu_ipis</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_ipi</span> <span class="n">bind_ipi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ipi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ipi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ipi</span> <span class="o">&lt;</span> <span class="n">XEN_NR_IPIS</span><span class="p">;</span> <span class="n">ipi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">irq</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_to_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">ipi</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ipi_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ipi</span><span class="p">);</span>

		<span class="cm">/* Get a new binding from Xen. */</span>
		<span class="n">bind_ipi</span><span class="p">.</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_ipi</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">bind_ipi</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">evtchn</span> <span class="o">=</span> <span class="n">bind_ipi</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>

		<span class="cm">/* Record the new mapping. */</span>
		<span class="n">xen_irq_info_ipi_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">,</span> <span class="n">ipi</span><span class="p">);</span>
		<span class="n">bind_evtchn_to_cpu</span><span class="p">(</span><span class="n">evtchn</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Clear an irq&#39;s pending state, in preparation for polling on it */</span>
<span class="kt">void</span> <span class="nf">xen_clear_irq_pending</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">clear_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">xen_clear_irq_pending</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">xen_set_irq_pending</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">set_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">xen_test_irq_pending</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">test_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Poll waiting for an irq to become pending with timeout.  In the usual case,</span>
<span class="cm"> * the irq will be disabled so it won&#39;t deliver an interrupt. */</span>
<span class="kt">void</span> <span class="nf">xen_poll_irq_timeout</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">evtchn_port_t</span> <span class="n">evtchn</span> <span class="o">=</span> <span class="n">evtchn_from_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_EVTCHN</span><span class="p">(</span><span class="n">evtchn</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sched_poll</span> <span class="n">poll</span><span class="p">;</span>

		<span class="n">poll</span><span class="p">.</span><span class="n">nr_ports</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">poll</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="n">set_xen_guest_handle</span><span class="p">(</span><span class="n">poll</span><span class="p">.</span><span class="n">ports</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">evtchn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_sched_op</span><span class="p">(</span><span class="n">SCHEDOP_poll</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">xen_poll_irq_timeout</span><span class="p">);</span>
<span class="cm">/* Poll waiting for an irq to become pending.  In the usual case, the</span>
<span class="cm"> * irq will be disabled so it won&#39;t deliver an interrupt. */</span>
<span class="kt">void</span> <span class="nf">xen_poll_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_poll_irq_timeout</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* no timeout */</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check whether the IRQ line is shared with other guests. */</span>
<span class="kt">int</span> <span class="nf">xen_test_irq_shared</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">info_for_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">physdev_irq_status_query</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pirq</span><span class="p">.</span><span class="n">pirq</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_irq_status_query</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_status</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">irq_status</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XENIRQSTAT_shared</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_test_irq_shared</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">xen_irq_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">evtchn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">init_evtchn_cpu_bindings</span><span class="p">();</span>

	<span class="cm">/* New event-channel space is not &#39;live&#39; yet. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">evtchn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">evtchn</span> <span class="o">&lt;</span> <span class="n">NR_EVENT_CHANNELS</span><span class="p">;</span> <span class="n">evtchn</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mask_evtchn</span><span class="p">(</span><span class="n">evtchn</span><span class="p">);</span>

	<span class="cm">/* No IRQ &lt;-&gt; event-channel mappings. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xen_irq_list_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">evtchn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* zap event-channel binding */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">evtchn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">evtchn</span> <span class="o">&lt;</span> <span class="n">NR_EVENT_CHANNELS</span><span class="p">;</span> <span class="n">evtchn</span><span class="o">++</span><span class="p">)</span>
		<span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">evtchn</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">restore_cpu_virqs</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">restore_cpu_ipis</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">restore_pirqs</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">xen_dynamic_chip</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;xen-dyn&quot;</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_disable</span>		<span class="o">=</span> <span class="n">disable_dynirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">disable_dynirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">enable_dynirq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">ack_dynirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask_ack</span>		<span class="o">=</span> <span class="n">mask_ack_dynirq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">set_affinity_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_retrigger</span>		<span class="o">=</span> <span class="n">retrigger_dynirq</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">xen_pirq_chip</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;xen-pirq&quot;</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_startup</span>		<span class="o">=</span> <span class="n">startup_pirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_shutdown</span>		<span class="o">=</span> <span class="n">shutdown_pirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_enable</span>		<span class="o">=</span> <span class="n">enable_pirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_disable</span>		<span class="o">=</span> <span class="n">disable_pirq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">disable_dynirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">enable_dynirq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">eoi_pirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_eoi</span>		<span class="o">=</span> <span class="n">eoi_pirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask_ack</span>		<span class="o">=</span> <span class="n">mask_ack_pirq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">set_affinity_irq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_retrigger</span>		<span class="o">=</span> <span class="n">retrigger_dynirq</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">xen_percpu_chip</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;xen-percpu&quot;</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_disable</span>		<span class="o">=</span> <span class="n">disable_dynirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">disable_dynirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">enable_dynirq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">ack_dynirq</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">xen_set_callback_via</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">via</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xen_hvm_param</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">a</span><span class="p">.</span><span class="n">domid</span> <span class="o">=</span> <span class="n">DOMID_SELF</span><span class="p">;</span>
	<span class="n">a</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">HVM_PARAM_CALLBACK_IRQ</span><span class="p">;</span>
	<span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">via</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">HYPERVISOR_hvm_op</span><span class="p">(</span><span class="n">HVMOP_set_param</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_set_callback_via</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_XEN_PVHVM</span>
<span class="cm">/* Vector callbacks are better than PCI interrupts to receive event</span>
<span class="cm"> * channel notifications because we can receive vector callbacks on any</span>
<span class="cm"> * vcpu and we don&#39;t need PCI support or APIC interactions. */</span>
<span class="kt">void</span> <span class="nf">xen_callback_vector</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">callback_via</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_have_vector_callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">callback_via</span> <span class="o">=</span> <span class="n">HVM_CALLBACK_VECTOR</span><span class="p">(</span><span class="n">XEN_HVM_EVTCHN_CALLBACK</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">xen_set_callback_via</span><span class="p">(</span><span class="n">callback_via</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Request for Xen HVM callback vector&quot;</span>
					<span class="s">&quot; failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xen_have_vector_callback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Xen HVM callback vector for event delivery is &quot;</span>
				<span class="s">&quot;enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* in the restore case the vector has already been allocated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XEN_HVM_EVTCHN_CALLBACK</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">))</span>
			<span class="n">alloc_intr_gate</span><span class="p">(</span><span class="n">XEN_HVM_EVTCHN_CALLBACK</span><span class="p">,</span> <span class="n">xen_hvm_callback_vector</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="nf">xen_callback_vector</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_init_IRQ</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">evtchn_to_irq</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">NR_EVENT_CHANNELS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">evtchn_to_irq</span><span class="p">),</span>
				    <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">evtchn_to_irq</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_EVENT_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">evtchn_to_irq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">init_evtchn_cpu_bindings</span><span class="p">();</span>

	<span class="cm">/* No event channels are &#39;live&#39; right now. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_EVENT_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mask_evtchn</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="n">pirq_needs_eoi</span> <span class="o">=</span> <span class="n">pirq_needs_eoi_flag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xen_hvm_domain</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">xen_callback_vector</span><span class="p">();</span>
		<span class="n">native_init_IRQ</span><span class="p">();</span>
		<span class="cm">/* pci_xen_hvm_init must be called after native_init_IRQ so that</span>
<span class="cm">		 * __acpi_register_gsi can point at the right function */</span>
		<span class="n">pci_xen_hvm_init</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">physdev_pirq_eoi_gmfn</span> <span class="n">eoi_gmfn</span><span class="p">;</span>

		<span class="n">irq_ctx_init</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xen_initial_domain</span><span class="p">())</span>
			<span class="n">pci_xen_initial_domain</span><span class="p">();</span>

		<span class="n">pirq_eoi_map</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">);</span>
		<span class="n">eoi_gmfn</span><span class="p">.</span><span class="n">gmfn</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">pirq_eoi_map</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_physdev_op</span><span class="p">(</span><span class="n">PHYSDEVOP_pirq_eoi_gmfn_v2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eoi_gmfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pirq_eoi_map</span><span class="p">);</span>
			<span class="n">pirq_eoi_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pirq_needs_eoi</span> <span class="o">=</span> <span class="n">pirq_check_eoi_map</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
