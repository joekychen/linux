<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › xen › xen-selfballoon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xen-selfballoon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * Xen selfballoon driver (and optional frontswap self-shrinking driver)</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009-2011, Dan Magenheimer, Oracle Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * This code complements the cleancache and frontswap patchsets to optimize</span>
<span class="cm"> * support for Xen Transcendent Memory (&quot;tmem&quot;).  The policy it implements</span>
<span class="cm"> * is rudimentary and will likely improve over time, but it does work well</span>
<span class="cm"> * enough today.</span>
<span class="cm"> *</span>
<span class="cm"> * Two functionalities are implemented here which both use &quot;control theory&quot;</span>
<span class="cm"> * (feedback) to optimize memory utilization. In a virtualized environment</span>
<span class="cm"> * such as Xen, RAM is often a scarce resource and we would like to ensure</span>
<span class="cm"> * that each of a possibly large number of virtual machines is using RAM</span>
<span class="cm"> * efficiently, i.e. using as little as possible when under light load</span>
<span class="cm"> * and obtaining as much as possible when memory demands are high.</span>
<span class="cm"> * Since RAM needs vary highly dynamically and sometimes dramatically,</span>
<span class="cm"> * &quot;hysteresis&quot; is used, that is, memory target is determined not just</span>
<span class="cm"> * on current data but also on past data stored in the system.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Selfballooning&quot; creates memory pressure by managing the Xen balloon</span>
<span class="cm"> * driver to decrease and increase available kernel memory, driven</span>
<span class="cm"> * largely by the target value of &quot;Committed_AS&quot; (see /proc/meminfo).</span>
<span class="cm"> * Since Committed_AS does not account for clean mapped pages (i.e. pages</span>
<span class="cm"> * in RAM that are identical to pages on disk), selfballooning has the</span>
<span class="cm"> * affect of pushing less frequently used clean pagecache pages out of</span>
<span class="cm"> * kernel RAM and, presumably using cleancache, into Xen tmem where</span>
<span class="cm"> * Xen can more efficiently optimize RAM utilization for such pages.</span>
<span class="cm"> *</span>
<span class="cm"> * When kernel memory demand unexpectedly increases faster than Xen, via</span>
<span class="cm"> * the selfballoon driver, is able to (or chooses to) provide usable RAM,</span>
<span class="cm"> * the kernel may invoke swapping.  In most cases, frontswap is able</span>
<span class="cm"> * to absorb this swapping into Xen tmem.  However, due to the fact</span>
<span class="cm"> * that the kernel swap subsystem assumes swapping occurs to a disk,</span>
<span class="cm"> * swapped pages may sit on the disk for a very long time; even if</span>
<span class="cm"> * the kernel knows the page will never be used again.  This is because</span>
<span class="cm"> * the disk space costs very little and can be overwritten when</span>
<span class="cm"> * necessary.  When such stale pages are in frontswap, however, they</span>
<span class="cm"> * are taking up valuable real estate.  &quot;Frontswap selfshrinking&quot; works</span>
<span class="cm"> * to resolve this:  When frontswap activity is otherwise stable</span>
<span class="cm"> * and the guest kernel is not under memory pressure, the &quot;frontswap</span>
<span class="cm"> * selfshrinking&quot; accounts for this by providing pressure to remove some</span>
<span class="cm"> * pages from frontswap and return them to kernel memory.</span>
<span class="cm"> *</span>
<span class="cm"> * For both &quot;selfballooning&quot; and &quot;frontswap-selfshrinking&quot;, a worker</span>
<span class="cm"> * thread is used and sysfs tunables are provided to adjust the frequency</span>
<span class="cm"> * and rate of adjustments to achieve the goal, as well as to disable one</span>
<span class="cm"> * or both functions independently.</span>
<span class="cm"> *</span>
<span class="cm"> * While some argue that this functionality can and should be implemented</span>
<span class="cm"> * in userspace, it has been observed that bad things happen (e.g. OOMs).</span>
<span class="cm"> *</span>
<span class="cm"> * System configuration note: Selfballooning should not be enabled on</span>
<span class="cm"> * systems without a sufficiently large swap device configured; for best</span>
<span class="cm"> * results, it is recommended that total swap be increased by the size</span>
<span class="cm"> * of the guest memory.  Also, while technically not required to be</span>
<span class="cm"> * configured, it is highly recommended that frontswap also be configured</span>
<span class="cm"> * and enabled when selfballooning is running.  So, selfballooning</span>
<span class="cm"> * is disabled by default if frontswap is not configured and can only</span>
<span class="cm"> * be enabled with the &quot;selfballooning&quot; kernel boot option; similarly</span>
<span class="cm"> * selfballooning is enabled by default if frontswap is configured and</span>
<span class="cm"> * can be disabled with the &quot;noselfballooning&quot; kernel boot option.  Finally,</span>
<span class="cm"> * when frontswap is configured, frontswap-selfshrinking can be disabled</span>
<span class="cm"> * with the &quot;noselfshrink&quot; kernel boot option.</span>
<span class="cm"> *</span>
<span class="cm"> * Selfballooning is disallowed in domain0 and force-disabled.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;xen/balloon.h&gt;</span>
<span class="cp">#include &lt;xen/tmem.h&gt;</span>
<span class="cp">#include &lt;xen/xen.h&gt;</span>

<span class="cm">/* Enable/disable with sysfs. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xen_selfballooning_enabled</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Controls rate at which memory target (this iteration) approaches</span>
<span class="cm"> * ultimate goal when memory need is increasing (up-hysteresis) or</span>
<span class="cm"> * decreasing (down-hysteresis). Higher values of hysteresis cause</span>
<span class="cm"> * slower increases/decreases. The default values for the various</span>
<span class="cm"> * parameters were deemed reasonable by experimentation, may be</span>
<span class="cm"> * workload-dependent, and can all be adjusted via sysfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selfballoon_downhysteresis</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selfballoon_uphysteresis</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* In HZ, controls frequency of worker invocation. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selfballoon_interval</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Minimum usable RAM in MB for selfballooning target for balloon.</span>
<span class="cm"> * If non-zero, it is added to totalreserve_pages and self-ballooning</span>
<span class="cm"> * will not balloon below the sum.  If zero, a piecewise linear function</span>
<span class="cm"> * is calculated as a minimum and added to totalreserve_pages.  Note that</span>
<span class="cm"> * setting this value indiscriminately may cause OOMs and crashes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selfballoon_min_usable_mb</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Amount of RAM in MB to add to the target number of pages.</span>
<span class="cm"> * Can be used to reserve some more room for caches and the like.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selfballoon_reserved_mb</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">selfballoon_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">selfballoon_worker</span><span class="p">,</span> <span class="n">selfballoon_process</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
<span class="cp">#include &lt;linux/frontswap.h&gt;</span>

<span class="cm">/* Enable/disable with sysfs. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">frontswap_selfshrinking</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Enable/disable with kernel boot option. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">use_frontswap_selfshrink</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The default values for the following parameters were deemed reasonable</span>
<span class="cm"> * by experimentation, may be workload-dependent, and can all be</span>
<span class="cm"> * adjusted via sysfs.</span>
<span class="cm"> */</span>

<span class="cm">/* Control rate for frontswap shrinking. Higher hysteresis is slower. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frontswap_hysteresis</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Number of selfballoon worker invocations to wait before observing that</span>
<span class="cm"> * frontswap selfshrinking should commence. Note that selfshrinking does</span>
<span class="cm"> * not use a separate worker thread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frontswap_inertia</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="cm">/* Countdown to next invocation of frontswap_shrink() */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">frontswap_inertia_counter</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Invoked by the selfballoon worker thread, uses current number of pages</span>
<span class="cm"> * in frontswap (frontswap_curr_pages()), previous status, and control</span>
<span class="cm"> * values (hysteresis and inertia) to determine if frontswap should be</span>
<span class="cm"> * shrunk and what the new frontswap size should be.  Note that</span>
<span class="cm"> * frontswap_shrink is essentially a partial swapoff that immediately</span>
<span class="cm"> * transfers pages from the &quot;swap device&quot; (frontswap) back into kernel</span>
<span class="cm"> * RAM; despite the name, frontswap &quot;shrinking&quot; is very different from</span>
<span class="cm"> * the &quot;shrinker&quot; interface used by the kernel MM subsystem to reclaim</span>
<span class="cm"> * memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">frontswap_selfshrink</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur_frontswap_pages</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_frontswap_pages</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tgt_frontswap_pages</span><span class="p">;</span>

	<span class="n">last_frontswap_pages</span> <span class="o">=</span> <span class="n">cur_frontswap_pages</span><span class="p">;</span>
	<span class="n">cur_frontswap_pages</span> <span class="o">=</span> <span class="n">frontswap_curr_pages</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur_frontswap_pages</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">cur_frontswap_pages</span> <span class="o">&gt;</span> <span class="n">last_frontswap_pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">frontswap_inertia_counter</span> <span class="o">=</span> <span class="n">frontswap_inertia</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_inertia_counter</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">frontswap_inertia_counter</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_frontswap_pages</span> <span class="o">&lt;=</span> <span class="n">frontswap_hysteresis</span><span class="p">)</span>
		<span class="n">tgt_frontswap_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tgt_frontswap_pages</span> <span class="o">=</span> <span class="n">cur_frontswap_pages</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">cur_frontswap_pages</span> <span class="o">/</span> <span class="n">frontswap_hysteresis</span><span class="p">);</span>
	<span class="n">frontswap_shrink</span><span class="p">(</span><span class="n">tgt_frontswap_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xen_nofrontswap_selfshrink_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">use_frontswap_selfshrink</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noselfshrink&quot;</span><span class="p">,</span> <span class="n">xen_nofrontswap_selfshrink_setup</span><span class="p">);</span>

<span class="cm">/* Disable with kernel boot option. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">use_selfballooning</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xen_noselfballooning_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">use_selfballooning</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noselfballooning&quot;</span><span class="p">,</span> <span class="n">xen_noselfballooning_setup</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_FRONTSWAP */</span><span class="cp"></span>
<span class="cm">/* Enable with kernel boot option. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">use_selfballooning</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xen_selfballooning_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">use_selfballooning</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;selfballooning&quot;</span><span class="p">,</span> <span class="n">xen_selfballooning_setup</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FRONTSWAP */</span><span class="cp"></span>

<span class="cp">#define MB2PAGES(mb)	((mb) &lt;&lt; (20 - PAGE_SHIFT))</span>

<span class="cm">/*</span>
<span class="cm"> * Use current balloon size, the goal (vm_committed_as), and hysteresis</span>
<span class="cm"> * parameters to set a new target balloon size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">selfballoon_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur_pages</span><span class="p">,</span> <span class="n">goal_pages</span><span class="p">,</span> <span class="n">tgt_pages</span><span class="p">,</span> <span class="n">floor_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">useful_pages</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">reset_timer</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xen_selfballooning_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_pages</span> <span class="o">=</span> <span class="n">totalram_pages</span><span class="p">;</span>
		<span class="n">tgt_pages</span> <span class="o">=</span> <span class="n">cur_pages</span><span class="p">;</span> <span class="cm">/* default is no change */</span>
		<span class="n">goal_pages</span> <span class="o">=</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_committed_as</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">totalreserve_pages</span> <span class="o">+</span>
				<span class="n">MB2PAGES</span><span class="p">(</span><span class="n">selfballoon_reserved_mb</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
		<span class="cm">/* allow space for frontswap pages to be repatriated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_selfshrinking</span> <span class="o">&amp;&amp;</span> <span class="n">frontswap_enabled</span><span class="p">)</span>
			<span class="n">goal_pages</span> <span class="o">+=</span> <span class="n">frontswap_curr_pages</span><span class="p">();</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_pages</span> <span class="o">&gt;</span> <span class="n">goal_pages</span><span class="p">)</span>
			<span class="n">tgt_pages</span> <span class="o">=</span> <span class="n">cur_pages</span> <span class="o">-</span>
				<span class="p">((</span><span class="n">cur_pages</span> <span class="o">-</span> <span class="n">goal_pages</span><span class="p">)</span> <span class="o">/</span>
				  <span class="n">selfballoon_downhysteresis</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur_pages</span> <span class="o">&lt;</span> <span class="n">goal_pages</span><span class="p">)</span>
			<span class="n">tgt_pages</span> <span class="o">=</span> <span class="n">cur_pages</span> <span class="o">+</span>
				<span class="p">((</span><span class="n">goal_pages</span> <span class="o">-</span> <span class="n">cur_pages</span><span class="p">)</span> <span class="o">/</span>
				  <span class="n">selfballoon_uphysteresis</span><span class="p">);</span>
		<span class="cm">/* else if cur_pages == goal_pages, no change */</span>
		<span class="n">useful_pages</span> <span class="o">=</span> <span class="n">max_pfn</span> <span class="o">-</span> <span class="n">totalreserve_pages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">selfballoon_min_usable_mb</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">floor_pages</span> <span class="o">=</span> <span class="n">totalreserve_pages</span> <span class="o">+</span>
					<span class="n">MB2PAGES</span><span class="p">(</span><span class="n">selfballoon_min_usable_mb</span><span class="p">);</span>
		<span class="cm">/* piecewise linear function ending in ~3% slope */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">useful_pages</span> <span class="o">&lt;</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
			<span class="n">floor_pages</span> <span class="o">=</span> <span class="n">max_pfn</span><span class="p">;</span> <span class="cm">/* not worth ballooning */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">useful_pages</span> <span class="o">&lt;</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
			<span class="n">floor_pages</span> <span class="o">=</span> <span class="n">totalreserve_pages</span> <span class="o">+</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">+</span>
					<span class="p">((</span><span class="n">useful_pages</span> <span class="o">-</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">useful_pages</span> <span class="o">&lt;</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">512</span><span class="p">))</span>
			<span class="n">floor_pages</span> <span class="o">=</span> <span class="n">totalreserve_pages</span> <span class="o">+</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span> <span class="o">+</span>
					<span class="p">((</span><span class="n">useful_pages</span> <span class="o">-</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">else</span> <span class="cm">/* useful_pages &gt;= MB2PAGES(512) */</span>
			<span class="n">floor_pages</span> <span class="o">=</span> <span class="n">totalreserve_pages</span> <span class="o">+</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span> <span class="o">+</span>
					<span class="p">((</span><span class="n">useful_pages</span> <span class="o">-</span> <span class="n">MB2PAGES</span><span class="p">(</span><span class="mi">99</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tgt_pages</span> <span class="o">&lt;</span> <span class="n">floor_pages</span><span class="p">)</span>
			<span class="n">tgt_pages</span> <span class="o">=</span> <span class="n">floor_pages</span><span class="p">;</span>
		<span class="n">balloon_set_new_target</span><span class="p">(</span><span class="n">tgt_pages</span> <span class="o">+</span>
			<span class="n">balloon_stats</span><span class="p">.</span><span class="n">current_pages</span> <span class="o">-</span> <span class="n">totalram_pages</span><span class="p">);</span>
		<span class="n">reset_timer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_selfshrinking</span> <span class="o">&amp;&amp;</span> <span class="n">frontswap_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frontswap_selfshrink</span><span class="p">();</span>
		<span class="n">reset_timer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset_timer</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selfballoon_worker</span><span class="p">,</span>
			<span class="n">selfballoon_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>

<span class="cp">#define SELFBALLOON_SHOW(name, format, args...)				\</span>
<span class="cp">	static ssize_t show_##name(struct device *dev,	\</span>
<span class="cp">					  struct device_attribute *attr, \</span>
<span class="cp">					  char *buf) \</span>
<span class="cp">	{ \</span>
<span class="cp">		return sprintf(buf, format, ##args); \</span>
<span class="cp">	}</span>

<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">selfballooning</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xen_selfballooning_enabled</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_selfballooning</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">was_enabled</span> <span class="o">=</span> <span class="n">xen_selfballooning_enabled</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">xen_selfballooning_enabled</span> <span class="o">=</span> <span class="o">!!</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">xen_selfballooning_enabled</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selfballoon_worker</span><span class="p">,</span>
			<span class="n">selfballoon_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">selfballooning</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_selfballooning</span><span class="p">,</span> <span class="n">store_selfballooning</span><span class="p">);</span>

<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">selfballoon_interval</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">selfballoon_interval</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_selfballoon_interval</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">selfballoon_interval</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">selfballoon_interval</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_selfballoon_interval</span><span class="p">,</span> <span class="n">store_selfballoon_interval</span><span class="p">);</span>

<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">selfballoon_downhys</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">selfballoon_downhysteresis</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_selfballoon_downhys</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">selfballoon_downhysteresis</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">selfballoon_downhysteresis</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_selfballoon_downhys</span><span class="p">,</span> <span class="n">store_selfballoon_downhys</span><span class="p">);</span>


<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">selfballoon_uphys</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">selfballoon_uphysteresis</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_selfballoon_uphys</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">selfballoon_uphysteresis</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">selfballoon_uphysteresis</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_selfballoon_uphys</span><span class="p">,</span> <span class="n">store_selfballoon_uphys</span><span class="p">);</span>

<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">selfballoon_min_usable_mb</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">selfballoon_min_usable_mb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_selfballoon_min_usable_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					       <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">selfballoon_min_usable_mb</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">selfballoon_min_usable_mb</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_selfballoon_min_usable_mb</span><span class="p">,</span>
		   <span class="n">store_selfballoon_min_usable_mb</span><span class="p">);</span>

<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">selfballoon_reserved_mb</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">selfballoon_reserved_mb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_selfballoon_reserved_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					     <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">selfballoon_reserved_mb</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">selfballoon_reserved_mb</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_selfballoon_reserved_mb</span><span class="p">,</span>
		   <span class="n">store_selfballoon_reserved_mb</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">frontswap_selfshrinking</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">frontswap_selfshrinking</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_frontswap_selfshrinking</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					     <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">was_enabled</span> <span class="o">=</span> <span class="n">frontswap_selfshrinking</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">frontswap_selfshrinking</span> <span class="o">=</span> <span class="o">!!</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xen_selfballooning_enabled</span> <span class="o">&amp;&amp;</span>
	     <span class="n">frontswap_selfshrinking</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selfballoon_worker</span><span class="p">,</span>
			<span class="n">selfballoon_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">frontswap_selfshrinking</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_frontswap_selfshrinking</span><span class="p">,</span> <span class="n">store_frontswap_selfshrinking</span><span class="p">);</span>

<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">frontswap_inertia</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">frontswap_inertia</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_frontswap_inertia</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">frontswap_inertia</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">frontswap_inertia_counter</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">frontswap_inertia</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_frontswap_inertia</span><span class="p">,</span> <span class="n">store_frontswap_inertia</span><span class="p">);</span>

<span class="n">SELFBALLOON_SHOW</span><span class="p">(</span><span class="n">frontswap_hysteresis</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">frontswap_hysteresis</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_frontswap_hysteresis</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">frontswap_hysteresis</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">frontswap_hysteresis</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">show_frontswap_hysteresis</span><span class="p">,</span> <span class="n">store_frontswap_hysteresis</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FRONTSWAP */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">selfballoon_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_selfballooning</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_selfballoon_interval</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_selfballoon_downhysteresis</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_selfballoon_uphysteresis</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_selfballoon_min_usable_mb</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_selfballoon_reserved_mb</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
	<span class="o">&amp;</span><span class="n">dev_attr_frontswap_selfshrinking</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_frontswap_hysteresis</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_frontswap_inertia</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">selfballoon_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;selfballoon&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">selfballoon_attrs</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">register_xen_selfballooning</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">selfballoon_group</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_xen_selfballooning</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xen_selfballoon_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xen_domain</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xen_initial_domain</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;xen/balloon: Xen selfballooning driver &quot;</span>
				<span class="s">&quot;disabled for domain0.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xen_selfballooning_enabled</span> <span class="o">=</span> <span class="n">tmem_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">use_selfballooning</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_selfballooning_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;xen/balloon: Initializing Xen &quot;</span>
					<span class="s">&quot;selfballooning driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
	<span class="n">frontswap_selfshrinking</span> <span class="o">=</span> <span class="n">tmem_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">use_frontswap_selfshrink</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_selfshrinking</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;xen/balloon: Initializing frontswap &quot;</span>
					<span class="s">&quot;selfshrinking driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">selfballoon_worker</span><span class="p">,</span> <span class="n">selfballoon_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">xen_selfballoon_init</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
