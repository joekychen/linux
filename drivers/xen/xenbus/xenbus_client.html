<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › xen › xenbus › xenbus_client.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xenbus_client.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * Client-facing interface for the Xenbus driver.  In other words, the</span>
<span class="cm"> * interface between the Xenbus and the device-specific code, be it the</span>
<span class="cm"> * frontend or the backend of that driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 XenSource Ltd</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version 2</span>
<span class="cm"> * as published by the Free Software Foundation; or, when distributed</span>
<span class="cm"> * separately from the Linux kernel or incorporated into other</span>
<span class="cm"> * software packages, subject to the following license:</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="cm"> * of this source file (the &quot;Software&quot;), to deal in the Software without</span>
<span class="cm"> * restriction, including without limitation the rights to use, copy, modify,</span>
<span class="cm"> * merge, publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="cm"> * and to permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in</span>
<span class="cm"> * all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="cm"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span>
<span class="cm"> * IN THE SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;asm/xen/hypervisor.h&gt;</span>
<span class="cp">#include &lt;asm/xen/page.h&gt;</span>
<span class="cp">#include &lt;xen/interface/xen.h&gt;</span>
<span class="cp">#include &lt;xen/interface/event_channel.h&gt;</span>
<span class="cp">#include &lt;xen/balloon.h&gt;</span>
<span class="cp">#include &lt;xen/events.h&gt;</span>
<span class="cp">#include &lt;xen/grant_table.h&gt;</span>
<span class="cp">#include &lt;xen/xenbus.h&gt;</span>
<span class="cp">#include &lt;xen/xen.h&gt;</span>

<span class="cp">#include &quot;xenbus_probe.h&quot;</span>

<span class="k">struct</span> <span class="n">xenbus_map_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_struct</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span> <span class="cm">/* PV */</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>     <span class="cm">/* HVM */</span>
	<span class="p">};</span>
	<span class="n">grant_handle_t</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">xenbus_valloc_pages</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">xenbus_ring_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">map</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gnt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unmap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xenbus_ring_ops</span> <span class="o">*</span><span class="n">ring_ops</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">xenbus_strstate</span><span class="p">(</span><span class="k">enum</span> <span class="n">xenbus_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span> <span class="n">XenbusStateUnknown</span>      <span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span>
		<span class="p">[</span> <span class="n">XenbusStateInitialising</span> <span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Initialising&quot;</span><span class="p">,</span>
		<span class="p">[</span> <span class="n">XenbusStateInitWait</span>     <span class="p">]</span> <span class="o">=</span> <span class="s">&quot;InitWait&quot;</span><span class="p">,</span>
		<span class="p">[</span> <span class="n">XenbusStateInitialised</span>  <span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Initialised&quot;</span><span class="p">,</span>
		<span class="p">[</span> <span class="n">XenbusStateConnected</span>    <span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Connected&quot;</span><span class="p">,</span>
		<span class="p">[</span> <span class="n">XenbusStateClosing</span>      <span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Closing&quot;</span><span class="p">,</span>
		<span class="p">[</span> <span class="n">XenbusStateClosed</span>	  <span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Closed&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">XenbusStateReconfiguring</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Reconfiguring&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">XenbusStateReconfigured</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Reconfigured&quot;</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="o">?</span> <span class="n">name</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;INVALID&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_strstate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * xenbus_watch_path - register a watch</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @path: path to watch</span>
<span class="cm"> * @watch: watch to register</span>
<span class="cm"> * @callback: callback to register</span>
<span class="cm"> *</span>
<span class="cm"> * Register a @watch on the given path, using the given xenbus_watch structure</span>
<span class="cm"> * for storage, and the given @callback function as the callback.  Return 0 on</span>
<span class="cm"> * success, or -errno on error.  On success, the given @path will be saved as</span>
<span class="cm"> * @watch-&gt;node, and remains the caller&#39;s to free.  On error, @watch-&gt;node will</span>
<span class="cm"> * be NULL, the device will switch to %XenbusStateClosing, and the error will</span>
<span class="cm"> * be saved in the store.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_watch_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">xenbus_watch</span> <span class="o">*</span><span class="n">watch</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xenbus_watch</span> <span class="o">*</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">watch</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="n">watch</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_xenbus_watch</span><span class="p">(</span><span class="n">watch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">watch</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">watch</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">xenbus_dev_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&quot;adding watch on %s&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_watch_path</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * xenbus_watch_pathfmt - register a watch on a sprintf-formatted path</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @watch: watch to register</span>
<span class="cm"> * @callback: callback to register</span>
<span class="cm"> * @pathfmt: format of path to watch</span>
<span class="cm"> *</span>
<span class="cm"> * Register a watch on the given @path, using the given xenbus_watch</span>
<span class="cm"> * structure for storage, and the given @callback function as the callback.</span>
<span class="cm"> * Return 0 on success, or -errno on error.  On success, the watched path</span>
<span class="cm"> * (@path/@path2) will be saved as @watch-&gt;node, and becomes the caller&#39;s to</span>
<span class="cm"> * kfree().  On error, watch-&gt;node will be NULL, so the caller has nothing to</span>
<span class="cm"> * free, the device will switch to %XenbusStateClosing, and the error will be</span>
<span class="cm"> * saved in the store.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_watch_pathfmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">xenbus_watch</span> <span class="o">*</span><span class="n">watch</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xenbus_watch</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathfmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">pathfmt</span><span class="p">);</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">kvasprintf</span><span class="p">(</span><span class="n">GFP_NOIO</span> <span class="o">|</span> <span class="n">__GFP_HIGH</span><span class="p">,</span> <span class="n">pathfmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xenbus_dev_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">,</span> <span class="s">&quot;allocating path for watch&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">xenbus_watch_path</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">watch</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_watch_pathfmt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">xenbus_switch_fatal</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__xenbus_switch_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">xenbus_state</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We check whether the state is currently set to the given value, and</span>
<span class="cm">	   if not, then the state is set.  We don&#39;t want to unconditionally</span>
<span class="cm">	   write the given state, because we don&#39;t want to fire watches</span>
<span class="cm">	   unnecessarily.  Furthermore, if the node has gone, we don&#39;t write</span>
<span class="cm">	   to it, as the device will be tearing down, and we don&#39;t want to</span>
<span class="cm">	   resurrect that directory.</span>

<span class="cm">	   Note that, because of this cached value of our state, this</span>
<span class="cm">	   function will not take a caller&#39;s Xenstore transaction</span>
<span class="cm">	   (something it was trying to in the past) because dev-&gt;state</span>
<span class="cm">	   would not get reset if the transaction was aborted.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">xenbus_transaction</span> <span class="n">xbt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">current_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">abort</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">xenbus_transaction_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xbt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xenbus_switch_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&quot;starting transaction&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">xenbus_scanf</span><span class="p">(</span><span class="n">xbt</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">,</span> <span class="s">&quot;state&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">xenbus_printf</span><span class="p">(</span><span class="n">xbt</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">,</span> <span class="s">&quot;state&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xenbus_switch_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&quot;writing new state&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">abort:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">xenbus_transaction_end</span><span class="p">(</span><span class="n">xbt</span><span class="p">,</span> <span class="n">abort</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">abort</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="n">xenbus_switch_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&quot;ending transaction&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xenbus_switch_state</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @state: new state</span>
<span class="cm"> *</span>
<span class="cm"> * Advertise in the store a change of the given driver to the given new_state.</span>
<span class="cm"> * Return 0 on success, or -errno on error.  On error, the device will switch</span>
<span class="cm"> * to XenbusStateClosing, and the error will be saved in the store.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_switch_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">xenbus_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xenbus_switch_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_switch_state</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">xenbus_frontend_closed</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xenbus_switch_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">XenbusStateClosed</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_frontend_closed</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Return the path to the error node for the given device, or NULL on failure.</span>
<span class="cm"> * If the value returned is non-NULL, then it is the caller&#39;s to kfree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">error_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;error/%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">xenbus_va_dev_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">printf_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">path_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#define PRINTF_BUFFER_SIZE 4096</span>
	<span class="n">printf_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PRINTF_BUFFER_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printf_buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">printf_buffer</span><span class="p">,</span> <span class="s">&quot;%i &quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">err</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">printf_buffer</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="n">PRINTF_BUFFER_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="n">PRINTF_BUFFER_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">printf_buffer</span><span class="p">);</span>

	<span class="n">path_buffer</span> <span class="o">=</span> <span class="n">error_path</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path_buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to write error node for %s (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">,</span> <span class="n">printf_buffer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xenbus_write</span><span class="p">(</span><span class="n">XBT_NIL</span><span class="p">,</span> <span class="n">path_buffer</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">,</span> <span class="n">printf_buffer</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to write error node for %s (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">,</span> <span class="n">printf_buffer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">printf_buffer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">path_buffer</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * xenbus_dev_error</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @err: error to report</span>
<span class="cm"> * @fmt: error message format</span>
<span class="cm"> *</span>
<span class="cm"> * Report the given negative errno into the store, along with the given</span>
<span class="cm"> * formatted message.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xenbus_dev_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">xenbus_va_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_dev_error</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * xenbus_dev_fatal</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @err: error to report</span>
<span class="cm"> * @fmt: error message format</span>
<span class="cm"> *</span>
<span class="cm"> * Equivalent to xenbus_dev_error(dev, err, fmt, args), followed by</span>
<span class="cm"> * xenbus_switch_state(dev, XenbusStateClosing) to schedule an orderly</span>
<span class="cm"> * closedown of this driver and its peer.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">xenbus_dev_fatal</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">xenbus_va_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">xenbus_switch_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">XenbusStateClosing</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_dev_fatal</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Equivalent to xenbus_dev_fatal(dev, err, fmt, args), but helps</span>
<span class="cm"> * avoiding recursion within xenbus_switch_state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xenbus_switch_fatal</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">xenbus_va_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">depth</span><span class="p">)</span>
		<span class="n">__xenbus_switch_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">XenbusStateClosing</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xenbus_grant_ring</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @ring_mfn: mfn of ring to grant</span>

<span class="cm"> * Grant access to the given @ring_mfn to the peer of the given device.  Return</span>
<span class="cm"> * 0 on success, or -errno on error.  On error, the device will switch to</span>
<span class="cm"> * XenbusStateClosing, and the error will be saved in the store.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_grant_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ring_mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">gnttab_grant_foreign_access</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">,</span> <span class="n">ring_mfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xenbus_dev_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&quot;granting access to ring page&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_grant_ring</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * Allocate an event channel for the given xenbus_device, assigning the newly</span>
<span class="cm"> * created local port to *port.  Return 0 on success, or -errno on error.  On</span>
<span class="cm"> * error, the device will switch to XenbusStateClosing, and the error will be</span>
<span class="cm"> * saved in the store.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_alloc_evtchn</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_alloc_unbound</span> <span class="n">alloc_unbound</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">alloc_unbound</span><span class="p">.</span><span class="n">dom</span> <span class="o">=</span> <span class="n">DOMID_SELF</span><span class="p">;</span>
	<span class="n">alloc_unbound</span><span class="p">.</span><span class="n">remote_dom</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_alloc_unbound</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">alloc_unbound</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">xenbus_dev_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&quot;allocating event channel&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">alloc_unbound</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_alloc_evtchn</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * Bind to an existing interdomain event channel in another domain. Returns 0</span>
<span class="cm"> * on success and stores the local port in *port. On error, returns -errno,</span>
<span class="cm"> * switches the device to XenbusStateClosing, and saves the error in XenStore.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_bind_evtchn</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remote_port</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_bind_interdomain</span> <span class="n">bind_interdomain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">bind_interdomain</span><span class="p">.</span><span class="n">remote_dom</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">;</span>
	<span class="n">bind_interdomain</span><span class="p">.</span><span class="n">remote_port</span> <span class="o">=</span> <span class="n">remote_port</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_bind_interdomain</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">bind_interdomain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">xenbus_dev_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span>
				 <span class="s">&quot;binding to event channel %d from domain %d&quot;</span><span class="p">,</span>
				 <span class="n">remote_port</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">bind_interdomain</span><span class="p">.</span><span class="n">local_port</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_bind_evtchn</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * Free an existing event channel. Returns 0 on success or -errno on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_free_evtchn</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">evtchn_close</span> <span class="n">close</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">close</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">HYPERVISOR_event_channel_op</span><span class="p">(</span><span class="n">EVTCHNOP_close</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">close</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">xenbus_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="s">&quot;freeing event channel %d&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_free_evtchn</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * xenbus_map_ring_valloc</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @gnt_ref: grant reference</span>
<span class="cm"> * @vaddr: pointer to address to be filled out by mapping</span>
<span class="cm"> *</span>
<span class="cm"> * Based on Rusty Russell&#39;s skeleton driver&#39;s map_page.</span>
<span class="cm"> * Map a page of memory into this domain from another domain&#39;s grant table.</span>
<span class="cm"> * xenbus_map_ring_valloc allocates a page of virtual address space, maps the</span>
<span class="cm"> * page to that address, and sets *vaddr to that address.</span>
<span class="cm"> * Returns 0 on success, and GNTST_* (see xen/include/interface/grant_table.h)</span>
<span class="cm"> * or -ENOMEM on error. If an error is returned, device will switch to</span>
<span class="cm"> * XenbusStateClosing and the error message will be saved in XenStore.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_map_ring_valloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gnt_ref</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ring_ops</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">gnt_ref</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_map_ring_valloc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xenbus_map_ring_valloc_pv</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">gnt_ref</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gnttab_map_grant_ref</span> <span class="n">op</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">GNTMAP_host_map</span> <span class="o">|</span> <span class="n">GNTMAP_contains_pte</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ref</span>   <span class="o">=</span> <span class="n">gnt_ref</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dom</span>   <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">xenbus_map_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_struct</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">area</span> <span class="o">=</span> <span class="n">alloc_vm_area</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">area</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">op</span><span class="p">.</span><span class="n">host_addr</span> <span class="o">=</span> <span class="n">arbitrary_virt_to_machine</span><span class="p">(</span><span class="n">pte</span><span class="p">).</span><span class="n">maddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_grant_table_op</span><span class="p">(</span><span class="n">GNTTABOP_map_grant_ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">GNTST_okay</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_vm_area</span><span class="p">(</span><span class="n">area</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">xenbus_dev_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
				 <span class="s">&quot;mapping in shared page %d from domain %d&quot;</span><span class="p">,</span>
				 <span class="n">gnt_ref</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xenbus_valloc_pages</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xenbus_map_ring_valloc_hvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">gnt_ref</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xenbus_map_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_xenballooned_pages</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/* lowmem */</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">xenbus_map_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">gnt_ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xenbus_valloc_pages</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_err:</span>
	<span class="n">free_xenballooned_pages</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * xenbus_map_ring</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @gnt_ref: grant reference</span>
<span class="cm"> * @handle: pointer to grant handle to be filled</span>
<span class="cm"> * @vaddr: address to be mapped to</span>
<span class="cm"> *</span>
<span class="cm"> * Map a page of memory into this domain from another domain&#39;s grant table.</span>
<span class="cm"> * xenbus_map_ring does not allocate the virtual address space (you must do</span>
<span class="cm"> * this yourself!). It only maps in the page to the specified address.</span>
<span class="cm"> * Returns 0 on success, and GNTST_* (see xen/include/interface/grant_table.h)</span>
<span class="cm"> * or -ENOMEM on error. If an error is returned, device will switch to</span>
<span class="cm"> * XenbusStateClosing and the error message will be saved in XenStore.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_map_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gnt_ref</span><span class="p">,</span>
		    <span class="n">grant_handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gnttab_map_grant_ref</span> <span class="n">op</span><span class="p">;</span>

	<span class="n">gnttab_set_map_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">GNTMAP_host_map</span><span class="p">,</span> <span class="n">gnt_ref</span><span class="p">,</span>
			  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_grant_table_op</span><span class="p">(</span><span class="n">GNTTABOP_map_grant_ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">GNTST_okay</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xenbus_dev_fatal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
				 <span class="s">&quot;mapping in shared page %d from domain %d&quot;</span><span class="p">,</span>
				 <span class="n">gnt_ref</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">otherend_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">handle</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_map_ring</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * xenbus_unmap_ring_vfree</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @vaddr: addr to unmap</span>
<span class="cm"> *</span>
<span class="cm"> * Based on Rusty Russell&#39;s skeleton driver&#39;s unmap_page.</span>
<span class="cm"> * Unmap a page of memory in this domain that was imported from another domain.</span>
<span class="cm"> * Use xenbus_unmap_ring_vfree if you mapped in your memory with</span>
<span class="cm"> * xenbus_map_ring_valloc (it will free the virtual address space).</span>
<span class="cm"> * Returns 0 on success and returns GNTST_* on error</span>
<span class="cm"> * (see xen/include/interface/grant_table.h).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_unmap_ring_vfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ring_ops</span><span class="o">-&gt;</span><span class="n">unmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_unmap_ring_vfree</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xenbus_unmap_ring_vfree_pv</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xenbus_map_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gnttab_unmap_grant_ref</span> <span class="n">op</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">host_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xenbus_valloc_pages</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="nl">found:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xenbus_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">,</span>
				 <span class="s">&quot;can&#39;t find mapped virtual address %p&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">GNTST_bad_virt_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">op</span><span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">op</span><span class="p">.</span><span class="n">host_addr</span> <span class="o">=</span> <span class="n">arbitrary_virt_to_machine</span><span class="p">(</span>
		<span class="n">lookup_address</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">)).</span><span class="n">maddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_grant_table_op</span><span class="p">(</span><span class="n">GNTTABOP_unmap_grant_ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">GNTST_okay</span><span class="p">)</span>
		<span class="n">free_vm_area</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xenbus_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
				 <span class="s">&quot;unmapping page at handle %d error %d&quot;</span><span class="p">,</span>
				 <span class="n">node</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xenbus_unmap_ring_vfree_hvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xenbus_map_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xenbus_valloc_pages</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="nl">found:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xenbus_valloc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xenbus_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">,</span>
				 <span class="s">&quot;can&#39;t find mapped virtual address %p&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">GNTST_bad_virt_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">xenbus_unmap_ring</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">free_xenballooned_pages</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Leaking %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xenbus_unmap_ring</span>
<span class="cm"> * @dev: xenbus device</span>
<span class="cm"> * @handle: grant handle</span>
<span class="cm"> * @vaddr: addr to unmap</span>
<span class="cm"> *</span>
<span class="cm"> * Unmap a page of memory in this domain that was imported from another domain.</span>
<span class="cm"> * Returns 0 on success and returns GNTST_* on error</span>
<span class="cm"> * (see xen/include/interface/grant_table.h).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xenbus_unmap_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">xenbus_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		      <span class="n">grant_handle_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gnttab_unmap_grant_ref</span> <span class="n">op</span><span class="p">;</span>

	<span class="n">gnttab_set_unmap_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">GNTMAP_host_map</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_grant_table_op</span><span class="p">(</span><span class="n">GNTTABOP_unmap_grant_ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">GNTST_okay</span><span class="p">)</span>
		<span class="n">xenbus_dev_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
				 <span class="s">&quot;unmapping page at handle %d error %d&quot;</span><span class="p">,</span>
				 <span class="n">handle</span><span class="p">,</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">op</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_unmap_ring</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * xenbus_read_driver_state</span>
<span class="cm"> * @path: path for driver</span>
<span class="cm"> *</span>
<span class="cm"> * Return the state of the driver rooted at the given store path, or</span>
<span class="cm"> * XenbusStateUnknown if no state can be read.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xenbus_state</span> <span class="nf">xenbus_read_driver_state</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xenbus_state</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">xenbus_gather</span><span class="p">(</span><span class="n">XBT_NIL</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="s">&quot;state&quot;</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">XenbusStateUnknown</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xenbus_read_driver_state</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xenbus_ring_ops</span> <span class="n">ring_ops_pv</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">xenbus_map_ring_valloc_pv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap</span> <span class="o">=</span> <span class="n">xenbus_unmap_ring_vfree_pv</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xenbus_ring_ops</span> <span class="n">ring_ops_hvm</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">xenbus_map_ring_valloc_hvm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap</span> <span class="o">=</span> <span class="n">xenbus_unmap_ring_vfree_hvm</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">xenbus_ring_ops_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_pv_domain</span><span class="p">())</span>
		<span class="n">ring_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ring_ops_pv</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ring_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ring_ops_hvm</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
