<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mfd › ab8500-gpadc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ab8500-gpadc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) ST-Ericsson SA 2010</span>
<span class="cm"> *</span>
<span class="cm"> * License Terms: GNU General Public License v2</span>
<span class="cm"> * Author: Arun R Murthy &lt;arun.murthy@stericsson.com&gt;</span>
<span class="cm"> * Author: Daniel Willerud &lt;daniel.willerud@stericsson.com&gt;</span>
<span class="cm"> * Author: Johan Palsson &lt;johan.palsson@stericsson.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/regulator/consumer.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mfd/abx500.h&gt;</span>
<span class="cp">#include &lt;linux/mfd/abx500/ab8500.h&gt;</span>
<span class="cp">#include &lt;linux/mfd/abx500/ab8500-gpadc.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * GPADC register offsets</span>
<span class="cm"> * Bank : 0x0A</span>
<span class="cm"> */</span>
<span class="cp">#define AB8500_GPADC_CTRL1_REG		0x00</span>
<span class="cp">#define AB8500_GPADC_CTRL2_REG		0x01</span>
<span class="cp">#define AB8500_GPADC_CTRL3_REG		0x02</span>
<span class="cp">#define AB8500_GPADC_AUTO_TIMER_REG	0x03</span>
<span class="cp">#define AB8500_GPADC_STAT_REG		0x04</span>
<span class="cp">#define AB8500_GPADC_MANDATAL_REG	0x05</span>
<span class="cp">#define AB8500_GPADC_MANDATAH_REG	0x06</span>
<span class="cp">#define AB8500_GPADC_AUTODATAL_REG	0x07</span>
<span class="cp">#define AB8500_GPADC_AUTODATAH_REG	0x08</span>
<span class="cp">#define AB8500_GPADC_MUX_CTRL_REG	0x09</span>

<span class="cm">/*</span>
<span class="cm"> * OTP register offsets</span>
<span class="cm"> * Bank : 0x15</span>
<span class="cm"> */</span>
<span class="cp">#define AB8500_GPADC_CAL_1		0x0F</span>
<span class="cp">#define AB8500_GPADC_CAL_2		0x10</span>
<span class="cp">#define AB8500_GPADC_CAL_3		0x11</span>
<span class="cp">#define AB8500_GPADC_CAL_4		0x12</span>
<span class="cp">#define AB8500_GPADC_CAL_5		0x13</span>
<span class="cp">#define AB8500_GPADC_CAL_6		0x14</span>
<span class="cp">#define AB8500_GPADC_CAL_7		0x15</span>

<span class="cm">/* gpadc constants */</span>
<span class="cp">#define EN_VINTCORE12			0x04</span>
<span class="cp">#define EN_VTVOUT			0x02</span>
<span class="cp">#define EN_GPADC			0x01</span>
<span class="cp">#define DIS_GPADC			0x00</span>
<span class="cp">#define SW_AVG_16			0x60</span>
<span class="cp">#define ADC_SW_CONV			0x04</span>
<span class="cp">#define EN_ICHAR			0x80</span>
<span class="cp">#define BTEMP_PULL_UP			0x08</span>
<span class="cp">#define EN_BUF				0x40</span>
<span class="cp">#define DIS_ZERO			0x00</span>
<span class="cp">#define GPADC_BUSY			0x01</span>

<span class="cm">/* GPADC constants from AB8500 spec, UM0836 */</span>
<span class="cp">#define ADC_RESOLUTION			1024</span>
<span class="cp">#define ADC_CH_BTEMP_MIN		0</span>
<span class="cp">#define ADC_CH_BTEMP_MAX		1350</span>
<span class="cp">#define ADC_CH_DIETEMP_MIN		0</span>
<span class="cp">#define ADC_CH_DIETEMP_MAX		1350</span>
<span class="cp">#define ADC_CH_CHG_V_MIN		0</span>
<span class="cp">#define ADC_CH_CHG_V_MAX		20030</span>
<span class="cp">#define ADC_CH_ACCDET2_MIN		0</span>
<span class="cp">#define ADC_CH_ACCDET2_MAX		2500</span>
<span class="cp">#define ADC_CH_VBAT_MIN			2300</span>
<span class="cp">#define ADC_CH_VBAT_MAX			4800</span>
<span class="cp">#define ADC_CH_CHG_I_MIN		0</span>
<span class="cp">#define ADC_CH_CHG_I_MAX		1500</span>
<span class="cp">#define ADC_CH_BKBAT_MIN		0</span>
<span class="cp">#define ADC_CH_BKBAT_MAX		3200</span>

<span class="cm">/* This is used to not lose precision when dividing to get gain and offset */</span>
<span class="cp">#define CALIB_SCALE			1000</span>

<span class="k">enum</span> <span class="n">cal_channels</span> <span class="p">{</span>
	<span class="n">ADC_INPUT_VMAIN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ADC_INPUT_BTEMP</span><span class="p">,</span>
	<span class="n">ADC_INPUT_VBAT</span><span class="p">,</span>
	<span class="n">NBR_CAL_INPUTS</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct adc_cal_data - Table for storing gain and offset for the calibrated</span>
<span class="cm"> * ADC channels</span>
<span class="cm"> * @gain:		Gain of the ADC channel</span>
<span class="cm"> * @offset:		Offset of the ADC channel</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">adc_cal_data</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">gain</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ab8500_gpadc - AB8500 GPADC device information</span>
<span class="cm"> * @chip_id			ABB chip id</span>
<span class="cm"> * @dev:			pointer to the struct device</span>
<span class="cm"> * @node:			a list of AB8500 GPADCs, hence prepared for</span>
<span class="cm">				reentrance</span>
<span class="cm"> * @ab8500_gpadc_complete:	pointer to the struct completion, to indicate</span>
<span class="cm"> *				the completion of gpadc conversion</span>
<span class="cm"> * @ab8500_gpadc_lock:		structure of type mutex</span>
<span class="cm"> * @regu:			pointer to the struct regulator</span>
<span class="cm"> * @irq:			interrupt number that is used by gpadc</span>
<span class="cm"> * @cal_data			array of ADC calibration data structs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">chip_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">ab8500_gpadc_complete</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ab8500_gpadc_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">regu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adc_cal_data</span> <span class="n">cal_data</span><span class="p">[</span><span class="n">NBR_CAL_INPUTS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ab8500_gpadc_list</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ab8500_gpadc_get() - returns a reference to the primary AB8500 GPADC</span>
<span class="cm"> * (i.e. the first GPADC in the instance list)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="nf">ab8500_gpadc_get</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">gpadc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ab8500_gpadc_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)))</span>
		    <span class="k">return</span> <span class="n">gpadc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ab8500_gpadc_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ab8500_gpadc_ad_to_voltage() - Convert a raw ADC value to a voltage</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ab8500_gpadc_ad_to_voltage</span><span class="p">(</span><span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">channel</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">ad_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MAIN_CHARGER_V</span>:
		<span class="cm">/* For some reason we don&#39;t have calibrated data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">gain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_CHG_V_MIN</span> <span class="o">+</span> <span class="p">(</span><span class="n">ADC_CH_CHG_V_MAX</span> <span class="o">-</span>
				<span class="n">ADC_CH_CHG_V_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
				<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Here we can use the calibrated data */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ad_value</span> <span class="o">*</span> <span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">gain</span> <span class="o">+</span>
			<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">CALIB_SCALE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">BAT_CTRL</span>:
	<span class="k">case</span> <span class="n">BTEMP_BALL</span>:
	<span class="k">case</span> <span class="n">ACC_DETECT1</span>:
	<span class="k">case</span> <span class="n">ADC_AUX1</span>:
	<span class="k">case</span> <span class="n">ADC_AUX2</span>:
		<span class="cm">/* For some reason we don&#39;t have calibrated data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">gain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_BTEMP_MIN</span> <span class="o">+</span> <span class="p">(</span><span class="n">ADC_CH_BTEMP_MAX</span> <span class="o">-</span>
				<span class="n">ADC_CH_BTEMP_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
				<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Here we can use the calibrated data */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ad_value</span> <span class="o">*</span> <span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">gain</span> <span class="o">+</span>
			<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">CALIB_SCALE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MAIN_BAT_V</span>:
		<span class="cm">/* For some reason we don&#39;t have calibrated data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">gain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_VBAT_MIN</span> <span class="o">+</span> <span class="p">(</span><span class="n">ADC_CH_VBAT_MAX</span> <span class="o">-</span>
				<span class="n">ADC_CH_VBAT_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
				<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Here we can use the calibrated data */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ad_value</span> <span class="o">*</span> <span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">gain</span> <span class="o">+</span>
			<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">CALIB_SCALE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DIE_TEMP</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_DIETEMP_MIN</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">ADC_CH_DIETEMP_MAX</span> <span class="o">-</span> <span class="n">ADC_CH_DIETEMP_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
			<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ACC_DETECT2</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_ACCDET2_MIN</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">ADC_CH_ACCDET2_MAX</span> <span class="o">-</span> <span class="n">ADC_CH_ACCDET2_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
			<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VBUS_V</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_CHG_V_MIN</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">ADC_CH_CHG_V_MAX</span> <span class="o">-</span> <span class="n">ADC_CH_CHG_V_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
			<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MAIN_CHARGER_C</span>:
	<span class="k">case</span> <span class="n">USB_CHARGER_C</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_CHG_I_MIN</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">ADC_CH_CHG_I_MAX</span> <span class="o">-</span> <span class="n">ADC_CH_CHG_I_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
			<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">BK_BAT_V</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">ADC_CH_BKBAT_MIN</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">ADC_CH_BKBAT_MAX</span> <span class="o">-</span> <span class="n">ADC_CH_BKBAT_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="n">ad_value</span> <span class="o">/</span>
			<span class="n">ADC_RESOLUTION</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;unknown channel, not possible to convert</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ab8500_gpadc_ad_to_voltage</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ab8500_gpadc_convert() - gpadc conversion</span>
<span class="cm"> * @channel:	analog channel to be converted to digital data</span>
<span class="cm"> *</span>
<span class="cm"> * This function converts the selected analog i/p to digital</span>
<span class="cm"> * data.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ab8500_gpadc_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ad_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">voltage</span><span class="p">;</span>

	<span class="n">ad_value</span> <span class="o">=</span> <span class="n">ab8500_gpadc_read_raw</span><span class="p">(</span><span class="n">gpadc</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ad_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;GPADC raw value failed ch: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ad_value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">voltage</span> <span class="o">=</span> <span class="n">ab8500_gpadc_ad_to_voltage</span><span class="p">(</span><span class="n">gpadc</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">ad_value</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">voltage</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;GPADC to voltage conversion failed ch:&quot;</span>
			<span class="s">&quot; %d AD: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">ad_value</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">voltage</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ab8500_gpadc_convert</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ab8500_gpadc_read_raw() - gpadc read</span>
<span class="cm"> * @channel:	analog channel to be read</span>
<span class="cm"> *</span>
<span class="cm"> * This function obtains the raw ADC value, this then needs</span>
<span class="cm"> * to be converted by calling ab8500_gpadc_ad_to_voltage()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ab8500_gpadc_read_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">looplimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">,</span> <span class="n">low_data</span><span class="p">,</span> <span class="n">high_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpadc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">ab8500_gpadc_lock</span><span class="p">);</span>
	<span class="cm">/* Enable VTVout LDO this is required for GPADC */</span>
	<span class="n">regulator_enable</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">regu</span><span class="p">);</span>

	<span class="cm">/* Check if ADC is not busy, lock and proceed */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_get_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">AB8500_GPADC</span><span class="p">,</span> <span class="n">AB8500_GPADC_STAT_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">GPADC_BUSY</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">looplimit</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">looplimit</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">GPADC_BUSY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gpadc_conversion: GPADC busy&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable GPADC */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_mask_and_set_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">AB8500_GPADC</span><span class="p">,</span> <span class="n">AB8500_GPADC_CTRL1_REG</span><span class="p">,</span> <span class="n">EN_GPADC</span><span class="p">,</span> <span class="n">EN_GPADC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gpadc_conversion: enable gpadc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Select the channel source and set average samples to 16 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_set_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">AB8500_GPADC</span><span class="p">,</span>
		<span class="n">AB8500_GPADC_CTRL2_REG</span><span class="p">,</span> <span class="p">(</span><span class="n">channel</span> <span class="o">|</span> <span class="n">SW_AVG_16</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;gpadc_conversion: set avg samples failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable ADC, buffering, select rising edge and enable ADC path</span>
<span class="cm">	 * charging current sense if it needed, ABB 3.0 needs some special</span>
<span class="cm">	 * treatment too.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MAIN_CHARGER_C</span>:
	<span class="k">case</span> <span class="n">USB_CHARGER_C</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_mask_and_set_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">AB8500_GPADC</span><span class="p">,</span> <span class="n">AB8500_GPADC_CTRL1_REG</span><span class="p">,</span>
			<span class="n">EN_BUF</span> <span class="o">|</span> <span class="n">EN_ICHAR</span><span class="p">,</span>
			<span class="n">EN_BUF</span> <span class="o">|</span> <span class="n">EN_ICHAR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BTEMP_BALL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">&gt;=</span> <span class="n">AB8500_CUT3P0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Turn on btemp pull-up on ABB 3.0 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_mask_and_set_register_interruptible</span><span class="p">(</span>
				<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">AB8500_GPADC</span><span class="p">,</span> <span class="n">AB8500_GPADC_CTRL1_REG</span><span class="p">,</span>
				<span class="n">EN_BUF</span> <span class="o">|</span> <span class="n">BTEMP_PULL_UP</span><span class="p">,</span>
				<span class="n">EN_BUF</span> <span class="o">|</span> <span class="n">BTEMP_PULL_UP</span><span class="p">);</span>

		 <span class="cm">/*</span>
<span class="cm">		  * Delay might be needed for ABB8500 cut 3.0, if not, remove</span>
<span class="cm">		  * when hardware will be availible</span>
<span class="cm">		  */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Intentional fallthrough */</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_mask_and_set_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">AB8500_GPADC</span><span class="p">,</span> <span class="n">AB8500_GPADC_CTRL1_REG</span><span class="p">,</span> <span class="n">EN_BUF</span><span class="p">,</span> <span class="n">EN_BUF</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;gpadc_conversion: select falling edge failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_mask_and_set_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">AB8500_GPADC</span><span class="p">,</span> <span class="n">AB8500_GPADC_CTRL1_REG</span><span class="p">,</span> <span class="n">ADC_SW_CONV</span><span class="p">,</span> <span class="n">ADC_SW_CONV</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;gpadc_conversion: start s/w conversion failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* wait for completion of conversion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">ab8500_gpadc_complete</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;timeout: didn&#39;t receive GPADC conversion interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read the converted RAW data */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_get_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">AB8500_GPADC</span><span class="p">,</span>
		<span class="n">AB8500_GPADC_MANDATAL_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">low_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gpadc_conversion: read low data failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_get_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">AB8500_GPADC</span><span class="p">,</span>
		<span class="n">AB8500_GPADC_MANDATAH_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">high_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;gpadc_conversion: read high data failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable GPADC */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_set_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">AB8500_GPADC</span><span class="p">,</span>
		<span class="n">AB8500_GPADC_CTRL1_REG</span><span class="p">,</span> <span class="n">DIS_GPADC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;gpadc_conversion: disable gpadc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Disable VTVout LDO this is required for GPADC */</span>
	<span class="n">regulator_disable</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">regu</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">ab8500_gpadc_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">high_data</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">low_data</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * It has shown to be needed to turn off the GPADC if an error occurs,</span>
<span class="cm">	 * otherwise we might have problem when waiting for the busy bit in the</span>
<span class="cm">	 * GPADC status register to go low. In V1.1 there wait_for_completion</span>
<span class="cm">	 * seems to timeout when waiting for an interrupt.. Not seen in V2.0</span>
<span class="cm">	 */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">abx500_set_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">AB8500_GPADC</span><span class="p">,</span>
		<span class="n">AB8500_GPADC_CTRL1_REG</span><span class="p">,</span> <span class="n">DIS_GPADC</span><span class="p">);</span>
	<span class="n">regulator_disable</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">regu</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">ab8500_gpadc_lock</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;gpadc_conversion: Failed to AD convert channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ab8500_gpadc_read_raw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ab8500_bm_gpswadcconvend_handler() - isr for s/w gpadc conversion completion</span>
<span class="cm"> * @irq:	irq number</span>
<span class="cm"> * @data:	pointer to the data passed during request irq</span>
<span class="cm"> *</span>
<span class="cm"> * This is a interrupt service routine for s/w gpadc conversion completion.</span>
<span class="cm"> * Notifies the gpadc completion is completed and the converted raw value</span>
<span class="cm"> * can be read from the registers.</span>
<span class="cm"> * Returns IRQ status(IRQ_HANDLED)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ab8500_bm_gpswadcconvend_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_gpadc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span> <span class="o">=</span> <span class="n">_gpadc</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">ab8500_gpadc_complete</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">otp_cal_regs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">AB8500_GPADC_CAL_1</span><span class="p">,</span>
	<span class="n">AB8500_GPADC_CAL_2</span><span class="p">,</span>
	<span class="n">AB8500_GPADC_CAL_3</span><span class="p">,</span>
	<span class="n">AB8500_GPADC_CAL_4</span><span class="p">,</span>
	<span class="n">AB8500_GPADC_CAL_5</span><span class="p">,</span>
	<span class="n">AB8500_GPADC_CAL_6</span><span class="p">,</span>
	<span class="n">AB8500_GPADC_CAL_7</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ab8500_gpadc_read_calibration_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">otp_cal_regs</span><span class="p">)];</span>
	<span class="n">u8</span> <span class="n">gpadc_cal</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">otp_cal_regs</span><span class="p">)];</span>

	<span class="kt">int</span> <span class="n">vmain_high</span><span class="p">,</span> <span class="n">vmain_low</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">btemp_high</span><span class="p">,</span> <span class="n">btemp_low</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vbat_high</span><span class="p">,</span> <span class="n">vbat_low</span><span class="p">;</span>

	<span class="cm">/* First we read all OTP registers and store the error code */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">otp_cal_regs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">abx500_get_register_interruptible</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">AB8500_OTP_EMUL</span><span class="p">,</span> <span class="n">otp_cal_regs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>  <span class="o">&amp;</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: read otp reg 0x%02x failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">otp_cal_regs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ADC calibration data is stored in OTP registers.</span>
<span class="cm">	 * The layout of the calibration data is outlined below and a more</span>
<span class="cm">	 * detailed description can be found in UM0836</span>
<span class="cm">	 *</span>
<span class="cm">	 * vm_h/l = vmain_high/low</span>
<span class="cm">	 * bt_h/l = btemp_high/low</span>
<span class="cm">	 * vb_h/l = vbat_high/low</span>
<span class="cm">	 *</span>
<span class="cm">	 * Data bits:</span>
<span class="cm">	 * | 7	   | 6	   | 5	   | 4	   | 3	   | 2	   | 1	   | 0</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 * |						   | vm_h9 | vm_h8</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 * |		   | vm_h7 | vm_h6 | vm_h5 | vm_h4 | vm_h3 | vm_h2</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 * | vm_h1 | vm_h0 | vm_l4 | vm_l3 | vm_l2 | vm_l1 | vm_l0 | bt_h9</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 * | bt_h8 | bt_h7 | bt_h6 | bt_h5 | bt_h4 | bt_h3 | bt_h2 | bt_h1</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 * | bt_h0 | bt_l4 | bt_l3 | bt_l2 | bt_l1 | bt_l0 | vb_h9 | vb_h8</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 * | vb_h7 | vb_h6 | vb_h5 | vb_h4 | vb_h3 | vb_h2 | vb_h1 | vb_h0</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 * | vb_l5 | vb_l4 | vb_l3 | vb_l2 | vb_l1 | vb_l0 |</span>
<span class="cm">	 * |.......|.......|.......|.......|.......|.......|.......|.......</span>
<span class="cm">	 *</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ideal output ADC codes corresponding to injected input voltages</span>
<span class="cm">	 * during manufacturing is:</span>
<span class="cm">	 *</span>
<span class="cm">	 * vmain_high: Vin = 19500mV / ADC ideal code = 997</span>
<span class="cm">	 * vmain_low:  Vin = 315mV   / ADC ideal code = 16</span>
<span class="cm">	 * btemp_high: Vin = 1300mV  / ADC ideal code = 985</span>
<span class="cm">	 * btemp_low:  Vin = 21mV    / ADC ideal code = 16</span>
<span class="cm">	 * vbat_high:  Vin = 4700mV  / ADC ideal code = 982</span>
<span class="cm">	 * vbat_low:   Vin = 2380mV  / ADC ideal code = 33</span>
<span class="cm">	 */</span>

	<span class="cm">/* Calculate gain and offset for VMAIN if all reads succeeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmain_high</span> <span class="o">=</span> <span class="p">(((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">));</span>

		<span class="n">vmain_low</span> <span class="o">=</span> <span class="p">((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3E</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">gain</span> <span class="o">=</span> <span class="n">CALIB_SCALE</span> <span class="o">*</span>
			<span class="p">(</span><span class="mi">19500</span> <span class="o">-</span> <span class="mi">315</span><span class="p">)</span> <span class="o">/</span>	<span class="p">(</span><span class="n">vmain_high</span> <span class="o">-</span> <span class="n">vmain_low</span><span class="p">);</span>

		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">CALIB_SCALE</span> <span class="o">*</span> <span class="mi">19500</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">CALIB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">19500</span> <span class="o">-</span> <span class="mi">315</span><span class="p">)</span> <span class="o">/</span>
			 <span class="p">(</span><span class="n">vmain_high</span> <span class="o">-</span> <span class="n">vmain_low</span><span class="p">))</span> <span class="o">*</span> <span class="n">vmain_high</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">gain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate gain and offset for BTEMP if all reads succeeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btemp_high</span> <span class="o">=</span> <span class="p">(((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">));</span>

		<span class="n">btemp_low</span> <span class="o">=</span> <span class="p">((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7C</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">gain</span> <span class="o">=</span>
			<span class="n">CALIB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1300</span> <span class="o">-</span> <span class="mi">21</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">btemp_high</span> <span class="o">-</span> <span class="n">btemp_low</span><span class="p">);</span>

		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">CALIB_SCALE</span> <span class="o">*</span> <span class="mi">1300</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">CALIB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1300</span> <span class="o">-</span> <span class="mi">21</span><span class="p">)</span> <span class="o">/</span>
			<span class="p">(</span><span class="n">btemp_high</span> <span class="o">-</span> <span class="n">btemp_low</span><span class="p">))</span> <span class="o">*</span> <span class="n">btemp_high</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">gain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate gain and offset for VBAT if all reads succeeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vbat_high</span> <span class="o">=</span> <span class="p">(((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
		<span class="n">vbat_low</span> <span class="o">=</span> <span class="p">((</span><span class="n">gpadc_cal</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">gain</span> <span class="o">=</span> <span class="n">CALIB_SCALE</span> <span class="o">*</span>
			<span class="p">(</span><span class="mi">4700</span> <span class="o">-</span> <span class="mi">2380</span><span class="p">)</span> <span class="o">/</span>	<span class="p">(</span><span class="n">vbat_high</span> <span class="o">-</span> <span class="n">vbat_low</span><span class="p">);</span>

		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">CALIB_SCALE</span> <span class="o">*</span> <span class="mi">4700</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">CALIB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4700</span> <span class="o">-</span> <span class="mi">2380</span><span class="p">)</span> <span class="o">/</span>
			<span class="p">(</span><span class="n">vbat_high</span> <span class="o">-</span> <span class="n">vbat_low</span><span class="p">))</span> <span class="o">*</span> <span class="n">vbat_high</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">gain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VMAIN gain %llu offset %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">gain</span><span class="p">,</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VMAIN</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BTEMP gain %llu offset %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">gain</span><span class="p">,</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_BTEMP</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VBAT gain %llu offset %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">gain</span><span class="p">,</span>
		<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">cal_data</span><span class="p">[</span><span class="n">ADC_INPUT_VBAT</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ab8500_gpadc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span><span class="p">;</span>

	<span class="n">gpadc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ab8500_gpadc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpadc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error: No memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;SW_CONV_END&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get platform irq-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">ab8500_gpadc_lock</span><span class="p">);</span>

	<span class="cm">/* Initialize completion used to notify completion of conversion */</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">ab8500_gpadc_complete</span><span class="p">);</span>

	<span class="cm">/* Register interrupt  - SwAdcComplete */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="n">ab8500_bm_gpswadcconvend_handler</span><span class="p">,</span>
		<span class="n">IRQF_NO_SUSPEND</span> <span class="o">|</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;ab8500-gpadc&quot;</span><span class="p">,</span> <span class="n">gpadc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to register interrupt, irq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get Chip ID of the ABB ASIC  */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">abx500_get_chip_id</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get chip ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* VTVout LDO used to power up ab8500-GPADC */</span>
	<span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">regu</span> <span class="o">=</span> <span class="n">regulator_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vddadc&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">regu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">regu</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get vtvout LDO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ab8500_gpadc_read_calibration_data</span><span class="p">(</span><span class="n">gpadc</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ab8500_gpadc_list</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probe success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">gpadc</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gpadc</span><span class="p">);</span>
	<span class="n">gpadc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">ab8500_gpadc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ab8500_gpadc</span> <span class="o">*</span><span class="n">gpadc</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* remove this gpadc entry from the list */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="cm">/* remove interrupt  - completion of Sw ADC conversion */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">gpadc</span><span class="p">);</span>
	<span class="cm">/* disable VTVout LDO that is being used by GPADC */</span>
	<span class="n">regulator_put</span><span class="p">(</span><span class="n">gpadc</span><span class="o">-&gt;</span><span class="n">regu</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gpadc</span><span class="p">);</span>
	<span class="n">gpadc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ab8500_gpadc_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;stericsson,ab8500-gpadc&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ab8500_gpadc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ab8500_gpadc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ab8500_gpadc_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ab8500-gpadc&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">ab8500_gpadc_match</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ab8500_gpadc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab8500_gpadc_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ab8500_gpadc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab8500_gpadc_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall_sync</span><span class="p">(</span><span class="n">ab8500_gpadc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ab8500_gpadc_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Arun R Murthy, Daniel Willerud, Johan Palsson&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:ab8500_gpadc&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;AB8500 GPADC driver&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
