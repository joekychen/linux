<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › char › xilinx_hwicap › buffer_icap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>buffer_icap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *     Author: Xilinx, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *     under the terms of the GNU General Public License as published by the</span>
<span class="cm"> *     Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> *     option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION &quot;AS IS&quot;</span>
<span class="cm"> *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND</span>
<span class="cm"> *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,</span>
<span class="cm"> *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,</span>
<span class="cm"> *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION</span>
<span class="cm"> *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,</span>
<span class="cm"> *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE</span>
<span class="cm"> *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY</span>
<span class="cm"> *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE</span>
<span class="cm"> *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR</span>
<span class="cm"> *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF</span>
<span class="cm"> *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="cm"> *     FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> *</span>
<span class="cm"> *     (c) Copyright 2003-2008 Xilinx Inc.</span>
<span class="cm"> *     All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *     You should have received a copy of the GNU General Public License along</span>
<span class="cm"> *     with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> *     675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#include &quot;buffer_icap.h&quot;</span>

<span class="cm">/* Indicates how many bytes will fit in a buffer. (1 BRAM) */</span>
<span class="cp">#define XHI_MAX_BUFFER_BYTES        2048</span>
<span class="cp">#define XHI_MAX_BUFFER_INTS         (XHI_MAX_BUFFER_BYTES &gt;&gt; 2)</span>

<span class="cm">/* File access and error constants */</span>
<span class="cp">#define XHI_DEVICE_READ_ERROR       -1</span>
<span class="cp">#define XHI_DEVICE_WRITE_ERROR      -2</span>
<span class="cp">#define XHI_BUFFER_OVERFLOW_ERROR   -3</span>

<span class="cp">#define XHI_DEVICE_READ             0x1</span>
<span class="cp">#define XHI_DEVICE_WRITE            0x0</span>

<span class="cm">/* Constants for checking transfer status */</span>
<span class="cp">#define XHI_CYCLE_DONE              0</span>
<span class="cp">#define XHI_CYCLE_EXECUTING         1</span>

<span class="cm">/* buffer_icap register offsets */</span>

<span class="cm">/* Size of transfer, read &amp; write */</span>
<span class="cp">#define XHI_SIZE_REG_OFFSET        0x800L</span>
<span class="cm">/* offset into bram, read &amp; write */</span>
<span class="cp">#define XHI_BRAM_OFFSET_REG_OFFSET 0x804L</span>
<span class="cm">/* Read not Configure, direction of transfer.  Write only */</span>
<span class="cp">#define XHI_RNC_REG_OFFSET         0x808L</span>
<span class="cm">/* Indicates transfer complete. Read only */</span>
<span class="cp">#define XHI_STATUS_REG_OFFSET      0x80CL</span>

<span class="cm">/* Constants for setting the RNC register */</span>
<span class="cp">#define XHI_CONFIGURE              0x0UL</span>
<span class="cp">#define XHI_READBACK               0x1UL</span>

<span class="cm">/* Constants for the Done register */</span>
<span class="cp">#define XHI_NOT_FINISHED           0x0UL</span>
<span class="cp">#define XHI_FINISHED               0x1UL</span>

<span class="cp">#define XHI_BUFFER_START 0</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_get_status - Get the contents of the status register.</span>
<span class="cm"> * @drvdata: a pointer to the drvdata.</span>
<span class="cm"> *</span>
<span class="cm"> * The status register contains the ICAP status and the done bit.</span>
<span class="cm"> *</span>
<span class="cm"> * D8 - cfgerr</span>
<span class="cm"> * D7 - dalign</span>
<span class="cm"> * D6 - rip</span>
<span class="cm"> * D5 - in_abort_l</span>
<span class="cm"> * D4 - Always 1</span>
<span class="cm"> * D3 - Always 1</span>
<span class="cm"> * D2 - Always 1</span>
<span class="cm"> * D1 - Always 1</span>
<span class="cm"> * D0 - Done bit</span>
<span class="cm"> **/</span>
<span class="n">u32</span> <span class="nf">buffer_icap_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">hwicap_drvdata</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">XHI_STATUS_REG_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_get_bram - Reads data from the storage buffer bram.</span>
<span class="cm"> * @base_address: contains the base address of the component.</span>
<span class="cm"> * @offset: The word offset from which the data should be read.</span>
<span class="cm"> *</span>
<span class="cm"> * A bram is used as a configuration memory cache.  One frame of data can</span>
<span class="cm"> * be stored in this &quot;storage buffer&quot;.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">buffer_icap_get_bram</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_busy - Return true if the icap device is busy</span>
<span class="cm"> * @base_address: is the base address of the device</span>
<span class="cm"> *</span>
<span class="cm"> * The queries the low order bit of the status register, which</span>
<span class="cm"> * indicates whether the current configuration or readback operation</span>
<span class="cm"> * has completed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">buffer_icap_busy</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">XHI_STATUS_REG_OFFSET</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">XHI_NOT_FINISHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_set_size - Set the size register.</span>
<span class="cm"> * @base_address: is the base address of the device</span>
<span class="cm"> * @data: The size in bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * The size register holds the number of 8 bit bytes to transfer between</span>
<span class="cm"> * bram and the icap (or icap to bram).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_icap_set_size</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">XHI_SIZE_REG_OFFSET</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_set_offset - Set the bram offset register.</span>
<span class="cm"> * @base_address: contains the base address of the device.</span>
<span class="cm"> * @data: is the value to be written to the data register.</span>
<span class="cm"> *</span>
<span class="cm"> * The bram offset register holds the starting bram address to transfer</span>
<span class="cm"> * data from during configuration or write data to during readback.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_icap_set_offset</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">XHI_BRAM_OFFSET_REG_OFFSET</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_set_rnc - Set the RNC (Readback not Configure) register.</span>
<span class="cm"> * @base_address: contains the base address of the device.</span>
<span class="cm"> * @data: is the value to be written to the data register.</span>
<span class="cm"> *</span>
<span class="cm"> * The RNC register determines the direction of the data transfer.  It</span>
<span class="cm"> * controls whether a configuration or readback take place.  Writing to</span>
<span class="cm"> * this register initiates the transfer.  A value of 1 initiates a</span>
<span class="cm"> * readback while writing a value of 0 initiates a configuration.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_icap_set_rnc</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">XHI_RNC_REG_OFFSET</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_set_bram - Write data to the storage buffer bram.</span>
<span class="cm"> * @base_address: contains the base address of the component.</span>
<span class="cm"> * @offset: The word offset at which the data should be written.</span>
<span class="cm"> * @data: The value to be written to the bram offset.</span>
<span class="cm"> *</span>
<span class="cm"> * A bram is used as a configuration memory cache.  One frame of data can</span>
<span class="cm"> * be stored in this &quot;storage buffer&quot;.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_icap_set_bram</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_device_read - Transfer bytes from ICAP to the storage buffer.</span>
<span class="cm"> * @drvdata: a pointer to the drvdata.</span>
<span class="cm"> * @offset: The storage buffer start address.</span>
<span class="cm"> * @count: The number of words (32 bit) to read from the</span>
<span class="cm"> *           device (ICAP).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_icap_device_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">hwicap_drvdata</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">s32</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span> <span class="o">=</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_icap_busy</span><span class="p">(</span><span class="n">base_address</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">XHI_MAX_BUFFER_INTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* setSize count*4 to get bytes. */</span>
	<span class="n">buffer_icap_set_size</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">buffer_icap_set_offset</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">buffer_icap_set_rnc</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">XHI_READBACK</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">buffer_icap_busy</span><span class="p">(</span><span class="n">base_address</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retries</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="n">XHI_MAX_RETRIES</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_device_write - Transfer bytes from ICAP to the storage buffer.</span>
<span class="cm"> * @drvdata: a pointer to the drvdata.</span>
<span class="cm"> * @offset: The storage buffer start address.</span>
<span class="cm"> * @count: The number of words (32 bit) to read from the</span>
<span class="cm"> *           device (ICAP).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_icap_device_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">hwicap_drvdata</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">s32</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span> <span class="o">=</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_icap_busy</span><span class="p">(</span><span class="n">base_address</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">XHI_MAX_BUFFER_INTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* setSize count*4 to get bytes. */</span>
	<span class="n">buffer_icap_set_size</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">buffer_icap_set_offset</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">buffer_icap_set_rnc</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">XHI_CONFIGURE</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">buffer_icap_busy</span><span class="p">(</span><span class="n">base_address</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retries</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="n">XHI_MAX_RETRIES</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_reset - Reset the logic of the icap device.</span>
<span class="cm"> * @drvdata: a pointer to the drvdata.</span>
<span class="cm"> *</span>
<span class="cm"> * Writing to the status register resets the ICAP logic in an internal</span>
<span class="cm"> * version of the core.  For the version of the core published in EDK,</span>
<span class="cm"> * this is a noop.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">buffer_icap_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hwicap_drvdata</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">out_be32</span><span class="p">(</span><span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">XHI_STATUS_REG_OFFSET</span><span class="p">,</span> <span class="mh">0xFEFE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_set_configuration - Load a partial bitstream from system memory.</span>
<span class="cm"> * @drvdata: a pointer to the drvdata.</span>
<span class="cm"> * @data: Kernel address of the partial bitstream.</span>
<span class="cm"> * @size: the size of the partial bitstream in 32 bit words.</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">buffer_icap_set_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">hwicap_drvdata</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">num_writes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span> <span class="o">=</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_address</span><span class="p">;</span>

	<span class="cm">/* Loop through all the data */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Copy data to bram */</span>
		<span class="n">buffer_icap_set_bram</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">buffer_count</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_count</span> <span class="o">&lt;</span> <span class="n">XHI_MAX_BUFFER_INTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buffer_count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Write data to ICAP */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">buffer_icap_device_write</span><span class="p">(</span>
				<span class="n">drvdata</span><span class="p">,</span>
				<span class="n">XHI_BUFFER_START</span><span class="p">,</span>
				<span class="n">XHI_MAX_BUFFER_INTS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* abort. */</span>
			<span class="n">buffer_icap_reset</span><span class="p">(</span><span class="n">drvdata</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">num_writes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write unwritten data to ICAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Write data to ICAP */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">buffer_icap_device_write</span><span class="p">(</span><span class="n">drvdata</span><span class="p">,</span> <span class="n">XHI_BUFFER_START</span><span class="p">,</span>
					     <span class="n">buffer_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* abort. */</span>
			<span class="n">buffer_icap_reset</span><span class="p">(</span><span class="n">drvdata</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * buffer_icap_get_configuration - Read configuration data from the device.</span>
<span class="cm"> * @drvdata: a pointer to the drvdata.</span>
<span class="cm"> * @data: Address of the data representing the partial bitstream</span>
<span class="cm"> * @size: the size of the partial bitstream in 32 bit words.</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">buffer_icap_get_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">hwicap_drvdata</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">read_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_address</span> <span class="o">=</span> <span class="n">drvdata</span><span class="o">-&gt;</span><span class="n">base_address</span><span class="p">;</span>

	<span class="cm">/* Loop through all the data */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer_count</span> <span class="o">=</span> <span class="n">XHI_MAX_BUFFER_INTS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_count</span> <span class="o">==</span> <span class="n">XHI_MAX_BUFFER_INTS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">words_remaining</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">words_to_read</span> <span class="o">=</span>
				<span class="n">words_remaining</span> <span class="o">&lt;</span>
				<span class="n">XHI_MAX_BUFFER_INTS</span> <span class="o">?</span> <span class="n">words_remaining</span> <span class="o">:</span>
				<span class="n">XHI_MAX_BUFFER_INTS</span><span class="p">;</span>

			<span class="cm">/* Read data from ICAP */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">buffer_icap_device_read</span><span class="p">(</span>
					<span class="n">drvdata</span><span class="p">,</span>
					<span class="n">XHI_BUFFER_START</span><span class="p">,</span>
					<span class="n">words_to_read</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* abort. */</span>
				<span class="n">buffer_icap_reset</span><span class="p">(</span><span class="n">drvdata</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">read_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy data from bram */</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buffer_icap_get_bram</span><span class="p">(</span><span class="n">base_address</span><span class="p">,</span> <span class="n">buffer_count</span><span class="p">);</span>
		<span class="n">buffer_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
