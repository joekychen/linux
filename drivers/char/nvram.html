<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › char › nvram.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nvram.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * CMOS/NV-RAM driver for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1997 Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;</span>
<span class="cm"> * idea by and with help from Richard Jelinek &lt;rj@suse.de&gt;</span>
<span class="cm"> * Portions copyright (c) 2001,2002 Sun Microsystems (thockin@sun.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This driver allows you to access the contents of the non-volatile memory in</span>
<span class="cm"> * the mc146818rtc.h real-time clock. This chip is built into all PCs and into</span>
<span class="cm"> * many Atari machines. In the former it&#39;s called &quot;CMOS-RAM&quot;, in the latter</span>
<span class="cm"> * &quot;NVRAM&quot; (NV stands for non-volatile).</span>
<span class="cm"> *</span>
<span class="cm"> * The data are supplied as a (seekable) character device, /dev/nvram. The</span>
<span class="cm"> * size of this file is dependent on the controller.  The usual size is 114,</span>
<span class="cm"> * the number of freely available bytes in the memory (i.e., not used by the</span>
<span class="cm"> * RTC itself).</span>
<span class="cm"> *</span>
<span class="cm"> * Checksums over the NVRAM contents are managed by this driver. In case of a</span>
<span class="cm"> * bad checksum, reads and writes return -EIO. The checksum can be initialized</span>
<span class="cm"> * to a sane state either by ioctl(NVRAM_INIT) (clear whole NVRAM) or</span>
<span class="cm"> * ioctl(NVRAM_SETCKS) (doesn&#39;t change contents, just makes checksum valid</span>
<span class="cm"> * again; use with care!)</span>
<span class="cm"> *</span>
<span class="cm"> * This file also provides some functions for other parts of the kernel that</span>
<span class="cm"> * want to access the NVRAM: nvram_{read,write,check_checksum,set_checksum}.</span>
<span class="cm"> * Obviously this can be used only if this driver is always configured into</span>
<span class="cm"> * the kernel and is not a module. Since the functions are used by some Atari</span>
<span class="cm"> * drivers, this is the case on the Atari.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 	1.1	Cesar Barros: SMP locking fixes</span>
<span class="cm"> * 		added changelog</span>
<span class="cm"> * 	1.2	Erik Gilling: Cobalt Networks support</span>
<span class="cm"> * 		Tim Hockin: general cleanup, Cobalt support</span>
<span class="cm"> * 	1.3	Wim Van Sebroeck: convert PRINT_PROC to seq_file</span>
<span class="cm"> */</span>

<span class="cp">#define NVRAM_VERSION	&quot;1.3&quot;</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/nvram.h&gt;</span>

<span class="cp">#define PC		1</span>
<span class="cp">#define ATARI		2</span>

<span class="cm">/* select machine configuration */</span>
<span class="cp">#if defined(CONFIG_ATARI)</span>
<span class="cp">#  define MACH ATARI</span>
<span class="cp">#elif defined(__i386__) || defined(__x86_64__) || defined(__arm__)  </span><span class="cm">/* and ?? */</span><span class="cp"></span>
<span class="cp">#  define MACH PC</span>
<span class="cp">#else</span>
<span class="cp">#  error Cannot build nvram driver for this machine configuration.</span>
<span class="cp">#endif</span>

<span class="cp">#if MACH == PC</span>

<span class="cm">/* RTC in a PC */</span>
<span class="cp">#define CHECK_DRIVER_INIT()	1</span>

<span class="cm">/* On PCs, the checksum is built only over bytes 2..31 */</span>
<span class="cp">#define PC_CKS_RANGE_START	2</span>
<span class="cp">#define PC_CKS_RANGE_END	31</span>
<span class="cp">#define PC_CKS_LOC		32</span>
<span class="cp">#define NVRAM_BYTES		(128-NVRAM_FIRST_BYTE)</span>

<span class="cp">#define mach_check_checksum	pc_check_checksum</span>
<span class="cp">#define mach_set_checksum	pc_set_checksum</span>
<span class="cp">#define mach_proc_infos		pc_proc_infos</span>

<span class="cp">#endif</span>

<span class="cp">#if MACH == ATARI</span>

<span class="cm">/* Special parameters for RTC in Atari machines */</span>
<span class="cp">#include &lt;asm/atarihw.h&gt;</span>
<span class="cp">#include &lt;asm/atariints.h&gt;</span>
<span class="cp">#define RTC_PORT(x)		(TT_RTC_BAS + 2*(x))</span>
<span class="cp">#define CHECK_DRIVER_INIT()	(MACH_IS_ATARI &amp;&amp; ATARIHW_PRESENT(TT_CLK))</span>

<span class="cp">#define NVRAM_BYTES		50</span>

<span class="cm">/* On Ataris, the checksum is over all bytes except the checksum bytes</span>
<span class="cm"> * themselves; these are at the very end */</span>
<span class="cp">#define ATARI_CKS_RANGE_START	0</span>
<span class="cp">#define ATARI_CKS_RANGE_END	47</span>
<span class="cp">#define ATARI_CKS_LOC		48</span>

<span class="cp">#define mach_check_checksum	atari_check_checksum</span>
<span class="cp">#define mach_set_checksum	atari_set_checksum</span>
<span class="cp">#define mach_proc_infos		atari_proc_infos</span>

<span class="cp">#endif</span>

<span class="cm">/* Note that *all* calls to CMOS_READ and CMOS_WRITE must be done with</span>
<span class="cm"> * rtc_lock held. Due to the index-port/data-port design of the RTC, we</span>
<span class="cm"> * don&#39;t want two different things trying to get to it at once. (e.g. the</span>
<span class="cm"> * periodic 11 min sync from kernel/time/ntp.c vs. this driver.)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/mc146818rtc.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>


<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">nvram_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">nvram_state_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nvram_open_cnt</span><span class="p">;</span>	<span class="cm">/* #times opened */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nvram_open_mode</span><span class="p">;</span>	<span class="cm">/* special open modes */</span>
<span class="cp">#define NVRAM_WRITE		1 </span><span class="cm">/* opened for writing (exclusive) */</span><span class="cp"></span>
<span class="cp">#define NVRAM_EXCL		2 </span><span class="cm">/* opened with O_EXCL */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mach_check_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mach_set_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mach_proc_infos</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">contents</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
								<span class="kt">void</span> <span class="o">*</span><span class="n">offset</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * These functions are provided to be called internally or by other parts of</span>
<span class="cm"> * the kernel. It&#39;s up to the caller to ensure correct checksum before reading</span>
<span class="cm"> * or after writing (needs to be done only once).</span>
<span class="cm"> *</span>
<span class="cm"> * It is worth noting that these functions all access bytes of general</span>
<span class="cm"> * purpose memory in the NVRAM - that is to say, they all add the</span>
<span class="cm"> * NVRAM_FIRST_BYTE offset.  Pass them offsets into NVRAM as if you did not</span>
<span class="cm"> * know about the RTC cruft.</span>
<span class="cm"> */</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">__nvram_read_byte</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">NVRAM_FIRST_BYTE</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__nvram_read_byte</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">nvram_read_byte</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">nvram_read_byte</span><span class="p">);</span>

<span class="cm">/* This races nicely with trying to read with checksum checking (nvram_read) */</span>
<span class="kt">void</span> <span class="nf">__nvram_write_byte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">NVRAM_FIRST_BYTE</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__nvram_write_byte</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">nvram_write_byte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__nvram_write_byte</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">nvram_write_byte</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__nvram_check_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mach_check_checksum</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__nvram_check_checksum</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">nvram_check_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">__nvram_check_checksum</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">nvram_check_checksum</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__nvram_set_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mach_set_checksum</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">void nvram_set_checksum(void)</span>
<span class="c">{</span>
<span class="c">	unsigned long flags;</span>

<span class="c">	spin_lock_irqsave(&amp;rtc_lock, flags);</span>
<span class="c">	__nvram_set_checksum();</span>
<span class="c">	spin_unlock_irqrestore(&amp;rtc_lock, flags);</span>
<span class="c">}</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cm">/*</span>
<span class="cm"> * The are the file operation function for user access to /dev/nvram</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">nvram_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* nothing to do */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">NVRAM_BYTES</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nvram_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">contents</span><span class="p">[</span><span class="n">NVRAM_BYTES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__nvram_check_checksum</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">checksum_err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">contents</span><span class="p">;</span> <span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVRAM_BYTES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">tmp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">contents</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">contents</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">contents</span><span class="p">;</span>

<span class="nl">checksum_err:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nvram_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">contents</span><span class="p">[</span><span class="n">NVRAM_BYTES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NVRAM_BYTES</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Past EOF */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">NVRAM_BYTES</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">NVRAM_BYTES</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">NVRAM_BYTES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>	<span class="cm">/* Can&#39;t happen, but prove it to gcc */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__nvram_check_checksum</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">checksum_err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">contents</span><span class="p">;</span> <span class="n">count</span><span class="o">--</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">tmp</span><span class="p">)</span>
		<span class="n">__nvram_write_byte</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">__nvram_set_checksum</span><span class="p">();</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">contents</span><span class="p">;</span>

<span class="nl">checksum_err:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">nvram_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">NVRAM_INIT</span>:
		<span class="cm">/* initialize NVRAM contents and checksum */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_mutex</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVRAM_BYTES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">__nvram_write_byte</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">__nvram_set_checksum</span><span class="p">();</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NVRAM_SETCKS</span>:
		<span class="cm">/* just set checksum, contents unchanged (maybe useful after</span>
<span class="cm">		 * checksum garbaged somehow...) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_mutex</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="n">__nvram_set_checksum</span><span class="p">();</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nvram_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nvram_open_cnt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">nvram_open_mode</span> <span class="o">&amp;</span> <span class="n">NVRAM_EXCL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nvram_open_mode</span> <span class="o">&amp;</span> <span class="n">NVRAM_WRITE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_state_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)</span>
		<span class="n">nvram_open_mode</span> <span class="o">|=</span> <span class="n">NVRAM_EXCL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
		<span class="n">nvram_open_mode</span> <span class="o">|=</span> <span class="n">NVRAM_WRITE</span><span class="p">;</span>
	<span class="n">nvram_open_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_state_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nvram_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_state_lock</span><span class="p">);</span>

	<span class="n">nvram_open_cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* if only one instance is open, clear the EXCL bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvram_open_mode</span> <span class="o">&amp;</span> <span class="n">NVRAM_EXCL</span><span class="p">)</span>
		<span class="n">nvram_open_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NVRAM_EXCL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
		<span class="n">nvram_open_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NVRAM_WRITE</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_state_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nvram_add_proc_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nvram_proc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">contents</span><span class="p">[</span><span class="n">NVRAM_BYTES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVRAM_BYTES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">contents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="n">mach_proc_infos</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nvram_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">nvram_proc_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">nvram_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">nvram_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nvram_add_proc_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;driver/nvram&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvram_proc_fops</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">nvram_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">nvram_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">nvram_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">nvram_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">nvram_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">nvram_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">nvram_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">nvram_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">NVRAM_MINOR</span><span class="p">,</span>
	<span class="s">&quot;nvram&quot;</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">nvram_fops</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nvram_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* First test whether the driver should init at all */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CHECK_DRIVER_INIT</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nvram: can&#39;t misc_register on minor=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">NVRAM_MINOR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nvram_add_proc_fs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nvram: can&#39;t create /proc/driver/nvram</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">outmisc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Non-volatile memory driver v&quot;</span> <span class="n">NVRAM_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">outmisc:</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_dev</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">nvram_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;driver/nvram&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">nvram_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">nvram_cleanup_module</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Machine specific functions</span>
<span class="cm"> */</span>

<span class="cp">#if MACH == PC</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pc_check_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">expect</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PC_CKS_RANGE_START</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PC_CKS_RANGE_END</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">expect</span> <span class="o">=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">PC_CKS_LOC</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span>
	    <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">PC_CKS_LOC</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pc_set_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PC_CKS_RANGE_START</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PC_CKS_RANGE_END</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">__nvram_write_byte</span><span class="p">(</span><span class="n">sum</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">PC_CKS_LOC</span><span class="p">);</span>
	<span class="n">__nvram_write_byte</span><span class="p">(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">PC_CKS_LOC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">floppy_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="s">&quot;5.25&#39;&#39; 360k&quot;</span><span class="p">,</span> <span class="s">&quot;5.25&#39;&#39; 1.2M&quot;</span><span class="p">,</span> <span class="s">&quot;3.5&#39;&#39; 720k&quot;</span><span class="p">,</span> <span class="s">&quot;3.5&#39;&#39; 1.44M&quot;</span><span class="p">,</span>
	<span class="s">&quot;3.5&#39;&#39; 2.88M&quot;</span><span class="p">,</span> <span class="s">&quot;3.5&#39;&#39; 2.88M&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">gfx_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;EGA, VGA, ... (with BIOS)&quot;</span><span class="p">,</span>
	<span class="s">&quot;CGA (40 cols)&quot;</span><span class="p">,</span>
	<span class="s">&quot;CGA (80 cols)&quot;</span><span class="p">,</span>
	<span class="s">&quot;monochrome&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pc_proc_infos</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nvram</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
								<span class="kt">void</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">__nvram_check_checksum</span><span class="p">();</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Checksum status: %svalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">checksum</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;# floppies     : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Floppy 0 type  : &quot;</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">floppy_types</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">floppy_types</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d (unknown)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Floppy 1 type  : &quot;</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">floppy_types</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">floppy_types</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d (unknown)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;HD 0 type      : &quot;</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span> <span class="o">==</span> <span class="mh">0x0f</span> <span class="o">?</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">:</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;HD 1 type      : &quot;</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span> <span class="o">==</span> <span class="mh">0x0f</span> <span class="o">?</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">:</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;HD type 48 data: %d/%d/%d C/H/S, precomp %d, lz %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">20</span><span class="p">],</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;HD type 49 data: %d/%d/%d C/H/S, precomp %d, lz %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">41</span><span class="p">],</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">46</span><span class="p">],</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">43</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">44</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">45</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;DOS base memory: %d kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Extended memory: %d kB (configured), %d kB (tested)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">34</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">35</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Gfx adapter    : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">gfx_types</span><span class="p">[(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">]);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;FPU            : %sinstalled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* MACH == PC */</span><span class="cp"></span>

<span class="cp">#if MACH == ATARI</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atari_check_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ATARI_CKS_RANGE_START</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ATARI_CKS_RANGE_END</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">ATARI_CKS_LOC</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="o">~</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">ATARI_CKS_LOC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atari_set_checksum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ATARI_CKS_RANGE_START</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ATARI_CKS_RANGE_END</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">__nvram_write_byte</span><span class="p">(</span><span class="o">~</span><span class="n">sum</span><span class="p">,</span> <span class="n">ATARI_CKS_LOC</span><span class="p">);</span>
	<span class="n">__nvram_write_byte</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">ATARI_CKS_LOC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">boot_prefs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">&quot;TOS&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x40</span><span class="p">,</span> <span class="s">&quot;ASV&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x20</span><span class="p">,</span> <span class="s">&quot;NetBSD (?)&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x10</span><span class="p">,</span> <span class="s">&quot;Linux&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s">&quot;unspecified&quot;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">languages</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;English (US)&quot;</span><span class="p">,</span>
	<span class="s">&quot;German&quot;</span><span class="p">,</span>
	<span class="s">&quot;French&quot;</span><span class="p">,</span>
	<span class="s">&quot;English (UK)&quot;</span><span class="p">,</span>
	<span class="s">&quot;Spanish&quot;</span><span class="p">,</span>
	<span class="s">&quot;Italian&quot;</span><span class="p">,</span>
	<span class="s">&quot;6 (undefined)&quot;</span><span class="p">,</span>
	<span class="s">&quot;Swiss (French)&quot;</span><span class="p">,</span>
	<span class="s">&quot;Swiss (German)&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dateformat</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;MM%cDD%cYY&quot;</span><span class="p">,</span>
	<span class="s">&quot;DD%cMM%cYY&quot;</span><span class="p">,</span>
	<span class="s">&quot;YY%cMM%cDD&quot;</span><span class="p">,</span>
	<span class="s">&quot;YY%cDD%cMM&quot;</span><span class="p">,</span>
	<span class="s">&quot;4 (undefined)&quot;</span><span class="p">,</span>
	<span class="s">&quot;5 (undefined)&quot;</span><span class="p">,</span>
	<span class="s">&quot;6 (undefined)&quot;</span><span class="p">,</span>
	<span class="s">&quot;7 (undefined)&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">colors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="s">&quot;16&quot;</span><span class="p">,</span> <span class="s">&quot;256&quot;</span><span class="p">,</span> <span class="s">&quot;65536&quot;</span><span class="p">,</span> <span class="s">&quot;??&quot;</span><span class="p">,</span> <span class="s">&quot;??&quot;</span><span class="p">,</span> <span class="s">&quot;??&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atari_proc_infos</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nvram</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
								<span class="kt">void</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">nvram_check_checksum</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vmode</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Checksum status  : %svalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">checksum</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Boot preference  : &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">boot_prefs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">boot_prefs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boot_prefs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;0x%02x (undefined)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;SCSI arbitration : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;SCSI host ID     : &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;n/a</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* the following entries are defined only for the Falcon */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">atari_mch_cookie</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ATARI_MCH_FALCON</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;OS language      : &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">languages</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">languages</span><span class="p">[</span><span class="n">nvram</span><span class="p">[</span><span class="mi">6</span><span class="p">]]);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%u (undefined)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Keyboard language: &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">languages</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">languages</span><span class="p">[</span><span class="n">nvram</span><span class="p">[</span><span class="mi">7</span><span class="p">]]);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%u (undefined)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Date format      : &quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">dateformat</span><span class="p">[</span><span class="n">nvram</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">],</span>
	    <span class="n">nvram</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">?</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">:</span> <span class="sc">&#39;/&#39;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">?</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">:</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;, %dh clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">16</span> <span class="o">?</span> <span class="mi">24</span> <span class="o">:</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Boot delay       : &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;default&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%ds%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
		    <span class="n">nvram</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">?</span> <span class="s">&quot;, no memory test&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">vmode</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvram</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="n">nvram</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
	    <span class="s">&quot;Video mode       : %s colors, %d columns, %s %s monitor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">colors</span><span class="p">[</span><span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">],</span>
	    <span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">8</span> <span class="o">?</span> <span class="mi">80</span> <span class="o">:</span> <span class="mi">40</span><span class="p">,</span>
	    <span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">16</span> <span class="o">?</span> <span class="s">&quot;VGA&quot;</span> <span class="o">:</span> <span class="s">&quot;TV&quot;</span><span class="p">,</span> <span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">32</span> <span class="o">?</span> <span class="s">&quot;PAL&quot;</span> <span class="o">:</span> <span class="s">&quot;NTSC&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;                   %soverscan, compat. mode %s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">64</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;no &quot;</span><span class="p">,</span>
	    <span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">128</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">,</span>
	    <span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">256</span> <span class="o">?</span>
	    <span class="p">(</span><span class="n">vmode</span> <span class="o">&amp;</span> <span class="mi">16</span> <span class="o">?</span> <span class="s">&quot;, line doubling&quot;</span> <span class="o">:</span> <span class="s">&quot;, half screen&quot;</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* MACH == ATARI */</span><span class="cp"></span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">NVRAM_MINOR</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
