f | mmtimer.c | s | 20K | 710 | Thomas Gleixner | tglx@linutronix.de | 1296656899 |  | posix-timers: Cleanup namespace  Rename register_posix_clock() to posix_timers_register_clock(). That's what the function really does. As a side effect this cleans up the posix_clock namespace for the upcoming dynamic posix_clock infrastructure.  Signed-off-by: Thomas Gleixner <tglx@linutronix.de> Tested-by: Richard Cochran <richard.cochran@omicron.at> Cc: John Stultz <johnstul@us.ibm.com> LKML-Reference: <alpine.LFD.2.00.1102021222240.31804@localhost6.localdomain6>
f | generic_nvram.c | s | 3.4K | 148 | Josef Bacik | josef@redhat.com | 1311209278 |  | drivers: fix up various ->llseek() implementations  Fix up a few ->llseek() implementations that won't deal with SEEK_HOLE/SEEK_DATA properly.  Make them future proof so that if we ever add new options they will return -EINVAL.  Thanks,  Signed-off-by: Josef Bacik <josef@redhat.com> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | mbcs.c | s | 19K | 691 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | nwbutton.h | s | 1.1K | 29 | David Howells | dhowells@redhat.com | 1160057412 |  | IRQ: Maintain regs pointer globally rather than passing to IRQ handlers  Maintain a per-CPU global "struct pt_regs *" variable which can be used instead of passing regs around manually through all ~1800 interrupt handlers in the Linux kernel.  The regs pointer is used in few places, but it potentially costs both stack space and code to pass it around.  On the FRV arch, removing the regs parameter from all the genirq function results in a 20% speed up of the IRQ exit path (ie: from leaving timer_interrupt() to leaving do_IRQ()).  Where appropriate, an arch may override the generic storage facility and do something different with the variable.  On FRV, for instance, the address is maintained in GR28 at all times inside the kernel as part of general exception handling.  Having looked over the code, it appears that the parameter may be handed down through up to twenty or so layers of functions.  Consider a USB character device attached to a USB hub, attached to a USB controller that posts its interrupts through a cascaded auxiliary interrupt controller.  A character device driver may want to pass regs to the sysrq handler through the input layer which adds another few layers of parameter passing.  I've build this code with allyesconfig for x86_64 and i386.  I've runtested the main part of the code on FRV and i386, though I can't test most of the drivers. I've also done partial conversion for powerpc and MIPS - these at least compile with minimal configurations.  This will affect all archs.  Mostly the changes should be relatively easy. Take do_IRQ(), store the regs pointer at the beginning, saving the old one:  	struct pt_regs *old_regs = set_irq_regs(regs);  And put the old one back at the end:  	set_irq_regs(old_regs);  Don't pass regs through to generic_handle_irq() or __do_IRQ().  In timer_interrupt(), this sort of change will be necessary:  	-	update_process_times(user_mode(regs)); 	-	profile_tick(CPU_PROFILING, regs); 	+	update_process_times(user_mode(get_irq_regs())); 	+	profile_tick(CPU_PROFILING);  I'd like to move update_process_times()'s use of get_irq_regs() into itself, except that i386, alone of the archs, uses something other than user_mode().  Some notes on the interrupt handling in the drivers:   (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in      the input_dev struct.   (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does      something different depending on whether it's been supplied with a regs      pointer or not.   (*) Various IRQ handler function pointers have been moved to type      irq_handler_t.  Signed-Off-By: David Howells <dhowells@redhat.com> (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)
f | Makefile | g | 1.9K |  | Anton Vorontsov | anton.vorontsov@linaro.org | 1337180797 |  | ramoops: Move to fs/pstore/ram.c  Since ramoops was converted to pstore, it has nothing to do with character devices nowadays. Instead, today it is just a RAM backend for pstore.  The patch just moves things around. There are a few changes were needed because of the move:  1. Kconfig and Makefiles fixups, of course.  2. In pstore/ram.c we have to play a bit with MODULE_PARAM_PREFIX, this    is needed to keep user experience the same as with ramoops driver    (i.e. so that ramoops.foo kernel command line arguments would still    work).  Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org> Acked-by: Marco Stornelli <marco.stornelli@gmail.com> Acked-by: Kees Cook <keescook@chromium.org> Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
f | nwflash.c | s | 13K | 571 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | tile-srom.c | s | 11K | 417 | Chris Metcalf | cmetcalf@tilera.com | 1333383250 |  | tile-srom.c driver: minor code cleanup  Signed-off-by: Chris Metcalf <cmetcalf@tilera.com>
f | ps3flash.c | s | 10K | 394 | Paul Gortmaker | paul.gortmaker@windriver.com | 1320103900 |  | drivers/char: Add module.h to those who were using it implicitly  A pending cleanup will mean that module.h won't be implicitly everywhere anymore.  Make sure the modular drivers in char are actually calling out for <module.h> explicitly in advance.  Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
f | apm-emulation.c | s | 17K | 627 | Linus Torvalds | torvalds@linux-foundation.org | 1333672470 |  | Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/apm  Pull an APM fix from Jiri Kosina:  "One deadlock/race fix from Niel that got introduced when we were   moving away from freezer_*_count() to wait_event_freezable()."  * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/apm:   APM: fix deadlock in APM_IOC_SUSPEND ioctl
f | i8k.c | s | 17K | 656 | Rusty Russell | rusty@rustcorp.com.au | 1326409340 |  | module_param: make bool parameters really bool (drivers & misc)  module_param(bool) used to counter-intuitively take an int.  In fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy trick.  It's time to remove the int/unsigned int option.  For this version it'll simply give a warning, but it'll break next kernel version.  Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com> Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
f | scx200_gpio.c | s | 3.1K | 103 | Arnd Bergmann | arnd@arndb.de | 1287150807 |  | llseek: automatically add .llseek fop  All file_operations should get a .llseek operation so we can make nonseekable_open the default for future file operations without a .llseek pointer.  The three cases that we can automatically detect are no_llseek, seq_lseek and default_llseek. For cases where we can we can automatically prove that the file offset is always ignored, we use noop_llseek, which maintains the current behavior of not returning an error from a seek.  New drivers should normally not use noop_llseek but instead use no_llseek and call nonseekable_open at open time.  Existing drivers can be converted to do the same when the maintainer knows for certain that no user code relies on calling seek on the device file.  The generated code is often incorrectly indented and right now contains comments that clarify for each added line why a specific variant was chosen. In the version that gets submitted upstream, the comments will be gone and I will manually fix the indentation, because there does not seem to be a way to do that using coccinelle.  Some amount of new code is currently sitting in linux-next that should get the same modifications, which I will do at the end of the merge window.  Many thanks to Julia Lawall for helping me learn to write a semantic patch that does all this.  ===== begin semantic patch ===== // This adds an llseek= method to all file operations, // as a preparation for making no_llseek the default. // // The rules are // - use no_llseek explicitly if we do nonseekable_open // - use seq_lseek for sequential files // - use default_llseek if we know we access f_pos // - use noop_llseek if we know we don't access f_pos, //   but we still want to allow users to call lseek // @ open1 exists @ identifier nested_open; @@ nested_open(...) { <+... nonseekable_open(...) ...+> }  @ open exists@ identifier open_f; identifier i, f; identifier open1.nested_open; @@ int open_f(struct inode *i, struct file *f) { <+... ( nonseekable_open(...) || nested_open(...) ) ...+> }  @ read disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { <+... (    *off = E ||    *off += E ||    func(..., off, ...) ||    E = *off ) ...+> }  @ read_no_fpos disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { ... when != off }  @ write @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { <+... (   *off = E ||   *off += E ||   func(..., off, ...) ||   E = *off ) ...+> }  @ write_no_fpos @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { ... when != off }  @ fops0 @ identifier fops; @@ struct file_operations fops = {  ... };  @ has_llseek depends on fops0 @ identifier fops0.fops; identifier llseek_f; @@ struct file_operations fops = { ...  .llseek = llseek_f, ... };  @ has_read depends on fops0 @ identifier fops0.fops; identifier read_f; @@ struct file_operations fops = { ...  .read = read_f, ... };  @ has_write depends on fops0 @ identifier fops0.fops; identifier write_f; @@ struct file_operations fops = { ...  .write = write_f, ... };  @ has_open depends on fops0 @ identifier fops0.fops; identifier open_f; @@ struct file_operations fops = { ...  .open = open_f, ... };  // use no_llseek if we call nonseekable_open //////////////////////////////////////////// @ nonseekable1 depends on !has_llseek && has_open @ identifier fops0.fops; identifier nso ~= "nonseekable_open"; @@ struct file_operations fops = { ...  .open = nso, ... +.llseek = no_llseek, /* nonseekable */ };  @ nonseekable2 depends on !has_llseek @ identifier fops0.fops; identifier open.open_f; @@ struct file_operations fops = { ...  .open = open_f, ... +.llseek = no_llseek, /* open uses nonseekable */ };  // use seq_lseek for sequential files ///////////////////////////////////// @ seq depends on !has_llseek @ identifier fops0.fops; identifier sr ~= "seq_read"; @@ struct file_operations fops = { ...  .read = sr, ... +.llseek = seq_lseek, /* we have seq_read */ };  // use default_llseek if there is a readdir /////////////////////////////////////////// @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier readdir_e; @@ // any other fop is used that changes pos struct file_operations fops = { ... .readdir = readdir_e, ... +.llseek = default_llseek, /* readdir is present */ };  // use default_llseek if at least one of read/write touches f_pos ///////////////////////////////////////////////////////////////// @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read.read_f; @@ // read fops use offset struct file_operations fops = { ... .read = read_f, ... +.llseek = default_llseek, /* read accesses f_pos */ };  @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write.write_f; @@ // write fops use offset struct file_operations fops = { ... .write = write_f, ... +	.llseek = default_llseek, /* write accesses f_pos */ };  // Use noop_llseek if neither read nor write accesses f_pos ///////////////////////////////////////////////////////////  @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; identifier write_no_fpos.write_f; @@ // write fops use offset struct file_operations fops = { ...  .write = write_f,  .read = read_f, ... +.llseek = noop_llseek, /* read and write both use no f_pos */ };  @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write_no_fpos.write_f; @@ struct file_operations fops = { ... .write = write_f, ... +.llseek = noop_llseek, /* write uses no f_pos */ };  @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; @@ struct file_operations fops = { ... .read = read_f, ... +.llseek = noop_llseek, /* read uses no f_pos */ };  @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; @@ struct file_operations fops = { ... +.llseek = noop_llseek, /* no read or write fn */ }; ===== End semantic patch =====  Signed-off-by: Arnd Bergmann <arnd@arndb.de> Cc: Julia Lawall <julia@diku.dk> Cc: Christoph Hellwig <hch@infradead.org>
f | hangcheck-timer.c | s | 6.2K | 180 | Dmitry Torokhov | dmitry.torokhov@gmail.com | 1282376085 |  | Input: sysrq - drop tty argument form handle_sysrq()  Sysrq operations do not accept tty argument anymore so no need to pass it to us.  [Stephen Rothwell <sfr@canb.auug.org.au>: fix build breakage in drm code  caused by sysrq using bool but not including linux/types.h]  [Sachin Sant <sachinp@in.ibm.com>: fix build breakage in s390 keyboadr  driver]  Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk> Acked-by: Jason Wessel <jason.wessel@windriver.com> Acked-by: Greg Kroah-Hartman <gregkh@suse.de> Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
f | hpet.c | s | 24K | 899 | Kay Sievers | kay@vrfy.org | 1333992639 |  | printk(): add KERN_CONT where needed in hpet and vt code  A prototype for kmsg records instead of a byte-stream buffer revealed a couple of missing printk(KERN_CONT ...) uses. Subsequent calls produce one record per printk() call, while all should have ended up in a single record.  Instead of:   ACPI: (supports S0 S5)   ACPI: PCI Interrupt Link [LNKA] (IRQs 5 *10 11)   hpet0: at MMIO 0xfed00000, IRQs 2 , 8 , 0  It prints:   ACPI: (supports S0    S5   )   ACPI: PCI Interrupt Link [LNKA] (IRQs    5    *10    11   )   hpet0: at MMIO 0xfed00000, IRQs    2   , 8   , 0  Cc: Andrew Morton <akpm@linux-foundation.org> Cc: Len Brown <lenb@kernel.org> Signed-off-by: Kay Sievers <kay@vrfy.org> Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
f | nvram.c | s | 17K | 589 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | nwbutton.c | s | 7.9K | 213 | Lucas De Marchi | lucas.demarchi@profusion.mobi | 1301581583 |  | Fix common misspellings  Fixes generated by 'codespell' and manually reviewed.  Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>
f | bfin-otp.c | s | 5.9K | 225 | Arnd Bergmann | arnd@arndb.de | 1287150807 |  | llseek: automatically add .llseek fop  All file_operations should get a .llseek operation so we can make nonseekable_open the default for future file operations without a .llseek pointer.  The three cases that we can automatically detect are no_llseek, seq_lseek and default_llseek. For cases where we can we can automatically prove that the file offset is always ignored, we use noop_llseek, which maintains the current behavior of not returning an error from a seek.  New drivers should normally not use noop_llseek but instead use no_llseek and call nonseekable_open at open time.  Existing drivers can be converted to do the same when the maintainer knows for certain that no user code relies on calling seek on the device file.  The generated code is often incorrectly indented and right now contains comments that clarify for each added line why a specific variant was chosen. In the version that gets submitted upstream, the comments will be gone and I will manually fix the indentation, because there does not seem to be a way to do that using coccinelle.  Some amount of new code is currently sitting in linux-next that should get the same modifications, which I will do at the end of the merge window.  Many thanks to Julia Lawall for helping me learn to write a semantic patch that does all this.  ===== begin semantic patch ===== // This adds an llseek= method to all file operations, // as a preparation for making no_llseek the default. // // The rules are // - use no_llseek explicitly if we do nonseekable_open // - use seq_lseek for sequential files // - use default_llseek if we know we access f_pos // - use noop_llseek if we know we don't access f_pos, //   but we still want to allow users to call lseek // @ open1 exists @ identifier nested_open; @@ nested_open(...) { <+... nonseekable_open(...) ...+> }  @ open exists@ identifier open_f; identifier i, f; identifier open1.nested_open; @@ int open_f(struct inode *i, struct file *f) { <+... ( nonseekable_open(...) || nested_open(...) ) ...+> }  @ read disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { <+... (    *off = E ||    *off += E ||    func(..., off, ...) ||    E = *off ) ...+> }  @ read_no_fpos disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { ... when != off }  @ write @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { <+... (   *off = E ||   *off += E ||   func(..., off, ...) ||   E = *off ) ...+> }  @ write_no_fpos @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { ... when != off }  @ fops0 @ identifier fops; @@ struct file_operations fops = {  ... };  @ has_llseek depends on fops0 @ identifier fops0.fops; identifier llseek_f; @@ struct file_operations fops = { ...  .llseek = llseek_f, ... };  @ has_read depends on fops0 @ identifier fops0.fops; identifier read_f; @@ struct file_operations fops = { ...  .read = read_f, ... };  @ has_write depends on fops0 @ identifier fops0.fops; identifier write_f; @@ struct file_operations fops = { ...  .write = write_f, ... };  @ has_open depends on fops0 @ identifier fops0.fops; identifier open_f; @@ struct file_operations fops = { ...  .open = open_f, ... };  // use no_llseek if we call nonseekable_open //////////////////////////////////////////// @ nonseekable1 depends on !has_llseek && has_open @ identifier fops0.fops; identifier nso ~= "nonseekable_open"; @@ struct file_operations fops = { ...  .open = nso, ... +.llseek = no_llseek, /* nonseekable */ };  @ nonseekable2 depends on !has_llseek @ identifier fops0.fops; identifier open.open_f; @@ struct file_operations fops = { ...  .open = open_f, ... +.llseek = no_llseek, /* open uses nonseekable */ };  // use seq_lseek for sequential files ///////////////////////////////////// @ seq depends on !has_llseek @ identifier fops0.fops; identifier sr ~= "seq_read"; @@ struct file_operations fops = { ...  .read = sr, ... +.llseek = seq_lseek, /* we have seq_read */ };  // use default_llseek if there is a readdir /////////////////////////////////////////// @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier readdir_e; @@ // any other fop is used that changes pos struct file_operations fops = { ... .readdir = readdir_e, ... +.llseek = default_llseek, /* readdir is present */ };  // use default_llseek if at least one of read/write touches f_pos ///////////////////////////////////////////////////////////////// @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read.read_f; @@ // read fops use offset struct file_operations fops = { ... .read = read_f, ... +.llseek = default_llseek, /* read accesses f_pos */ };  @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write.write_f; @@ // write fops use offset struct file_operations fops = { ... .write = write_f, ... +	.llseek = default_llseek, /* write accesses f_pos */ };  // Use noop_llseek if neither read nor write accesses f_pos ///////////////////////////////////////////////////////////  @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; identifier write_no_fpos.write_f; @@ // write fops use offset struct file_operations fops = { ...  .write = write_f,  .read = read_f, ... +.llseek = noop_llseek, /* read and write both use no f_pos */ };  @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write_no_fpos.write_f; @@ struct file_operations fops = { ... .write = write_f, ... +.llseek = noop_llseek, /* write uses no f_pos */ };  @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; @@ struct file_operations fops = { ... .read = read_f, ... +.llseek = noop_llseek, /* read uses no f_pos */ };  @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; @@ struct file_operations fops = { ... +.llseek = noop_llseek, /* no read or write fn */ }; ===== End semantic patch =====  Signed-off-by: Arnd Bergmann <arnd@arndb.de> Cc: Julia Lawall <julia@diku.dk> Cc: Christoph Hellwig <hch@infradead.org>
d | agp |  | 27 items |  | Eugeni Dodonov | eugeni.dodonov@intel.com | 1338995129 |  | char/agp: add another Ironlake host bridge  This seems to come on Gigabyte H55M-S2V and was discovered through the https://bugs.freedesktop.org/show_bug.cgi?id=50381 debugging.  Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=50381 Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com> Cc: stable@vger.kernel.org Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
d | pcmcia |  | 6 items |  | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | ppdev.c | s | 19K | 702 | Julia Lawall | julia@diku.dk | 1306455157 |  | drivers/char/ppdev.c: put gotten port value  parport_find_number() calls parport_get_port() on its result, so there should be a corresponding call to parport_put_port() before dropping the reference.  Similar code is found in the function register_device() in the same file.  The semantic match that finds this problem is as follows: (http://coccinelle.lip6.fr/)    // <smpl>   @exists@   local idexpression struct parport * x;   expression ra,rr;   statement S1,S2;   @@    x = parport_find_number(...)   ... when != x = rr       when any       when != parport_put_port(x,...)       when != if (...) { ... parport_put_port(x,...) ...}   (   if(<+...x...+>) S1 else S2   ||   if(...) { ... when != x = ra        when forall        when != parport_put_port(x,...)   *return...;   }   )   // </smpl>  Signed-off-by: Julia Lawall <julia@diku.dk> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | efirtc.c | s | 9.5K | 332 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | mem.c | s | 19K | 783 | Kay Sievers | kay@vrfy.org | 1336603869 |  | printk - fix compilation for CONFIG_PRINTK=n  Reported-by: Randy Dunlap <rdunlap@xenotime.net> Signed-off-by: Kay Sievers <kay@vrfy.org> Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
d | tpm |  | 10 items |  | Linus Torvalds | torvalds@linux-foundation.org | 1332361504 |  | Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security  Pull security subsystem updates for 3.4 from James Morris:  "The main addition here is the new Yama security module from Kees Cook,   which was discussed at the Linux Security Summit last year.  Its   purpose is to collect miscellaneous DAC security enhancements in one   place.  This also marks a departure in policy for LSM modules, which   were previously limited to being standalone access control systems.   Chromium OS is using Yama, and I believe there are plans for Ubuntu,   at least.    This patchset also includes maintenance updates for AppArmor, TOMOYO   and others."  Fix trivial conflict in <net/sock.h> due to the jumo_label->static_key rename.  * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (38 commits)   AppArmor: Fix location of const qualifier on generated string tables   TOMOYO: Return error if fails to delete a domain   AppArmor: add const qualifiers to string arrays   AppArmor: Add ability to load extended policy   TOMOYO: Return appropriate value to poll().   AppArmor: Move path failure information into aa_get_name and rename   AppArmor: Update dfa matching routines.   AppArmor: Minor cleanup of d_namespace_path to consolidate error handling   AppArmor: Retrieve the dentry_path for error reporting when path lookup fails   AppArmor: Add const qualifiers to generated string tables   AppArmor: Fix oops in policy unpack auditing   AppArmor: Fix error returned when a path lookup is disconnected   KEYS: testing wrong bit for KEY_FLAG_REVOKED   TOMOYO: Fix mount flags checking order.   security: fix ima kconfig warning   AppArmor: Fix the error case for chroot relative path name lookup   AppArmor: fix mapping of META_READ to audit and quiet flags   AppArmor: Fix underflow in xindex calculation   AppArmor: Fix dropping of allowed operations that are force audited   AppArmor: Add mising end of structure test to caps unpacking   ...
f | misc.c | s | 6.9K | 257 | Al Viro | viro@zeniv.linux.org.uk | 1325649295 |  | switch device_get_devnode() and ->devnode() to umode_t *  both callers of device_get_devnode() are only interested in lower 16bits and nobody tries to return anything wider than 16bit anyway.  Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | snsc.h | s | 2.8K | 74 | Alexey Dobriyan | adobriyan@gmail.com | 1294678304 |  | headers: kobject.h redux  Remove kobject.h from files which don't need it, notably, sched.h and fs.h.  Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | dsp56k.c | s | 12K | 461 | Linus Torvalds | torvalds@linux-foundation.org | 1287769976 |  | Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl  * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:   vfs: make no_llseek the default   vfs: don't use BKL in default_llseek   llseek: automatically add .llseek fop   libfs: use generic_file_llseek for simple_attr   mac80211: disallow seeks in minstrel debug code   lirc: make chardev nonseekable   viotape: use noop_llseek   raw: use explicit llseek file operations   ibmasmfs: use generic_file_llseek   spufs: use llseek in all file operations   arm/omap: use generic_file_llseek in iommu_debug   lkdtm: use generic_file_llseek in debugfs   net/wireless: use generic_file_llseek in debugfs   drm: use noop_llseek
f | ds1302.c | s | 7.5K | 277 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | bsr.c | s | 8.8K | 295 | Joe Perches | joe@perches.com | 1307710536 |  | treewide: Convert uses of struct resource to resource_size(ptr)  Several fixes as well where the +1 was missing.  Done via coccinelle scripts like:  @@ struct resource *ptr; @@  - ptr->end - ptr->start + 1 + resource_size(ptr)  and some grep and typing.  Mostly uncompiled, no cross-compilers.  Signed-off-by: Joe Perches <joe@perches.com> Signed-off-by: Jiri Kosina <jkosina@suse.cz>
f | applicom.h | s | 2.5K | 77 | Linus Torvalds | torvalds@ppc970.osdl.org | 1113690036 |  | Linux-2.6.12-rc2  Initial git repository build. I'm not bothering with the full history, even though we have it. We can create a separate "historical" git archive of that later if we want to, and in the meantime it's about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we don't have a lot of good infrastructure for it.  Let it rip!
d | ipmi |  | 11 items |  | Linus Torvalds | torvalds@linux-foundation.org | 1332980368 |  | Merge branch 'akpm' (Andrew's patch-bomb)  Merge third batch of patches from Andrew Morton:  - Some MM stragglers  - core SMP library cleanups (on_each_cpu_mask)  - Some IPI optimisations  - kexec  - kdump  - IPMI  - the radix-tree iterator work  - various other misc bits.   "That'll do for -rc1.  I still have ~10 patches for 3.4, will send   those along when they've baked a little more."  * emailed from Andrew Morton <akpm@linux-foundation.org>: (35 commits)   backlight: fix typo in tosa_lcd.c   crc32: add help text for the algorithm select option   mm: move hugepage test examples to tools/testing/selftests/vm   mm: move slabinfo.c to tools/vm   mm: move page-types.c from Documentation to tools/vm   selftests/Makefile: make `run_tests' depend on `all'   selftests: launch individual selftests from the main Makefile   radix-tree: use iterators in find_get_pages* functions   radix-tree: rewrite gang lookup using iterator   radix-tree: introduce bit-optimized iterator   fs/proc/namespaces.c: prevent crash when ns_entries[] is empty   nbd: rename the nbd_device variable from lo to nbd   pidns: add reboot_pid_ns() to handle the reboot syscall   sysctl: use bitmap library functions   ipmi: use locks on watchdog timeout set on reboot   ipmi: simplify locking   ipmi: fix message handling during panics   ipmi: use a tasklet for handling received messages   ipmi: increase KCS timeouts   ipmi: decrease the IPMI message transaction time in interrupt mode   ...
f | sonypi.c | s | 41K | 1350 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | tb0219.c | s | 7.8K | 305 | Arnd Bergmann | arnd@arndb.de | 1287150807 |  | llseek: automatically add .llseek fop  All file_operations should get a .llseek operation so we can make nonseekable_open the default for future file operations without a .llseek pointer.  The three cases that we can automatically detect are no_llseek, seq_lseek and default_llseek. For cases where we can we can automatically prove that the file offset is always ignored, we use noop_llseek, which maintains the current behavior of not returning an error from a seek.  New drivers should normally not use noop_llseek but instead use no_llseek and call nonseekable_open at open time.  Existing drivers can be converted to do the same when the maintainer knows for certain that no user code relies on calling seek on the device file.  The generated code is often incorrectly indented and right now contains comments that clarify for each added line why a specific variant was chosen. In the version that gets submitted upstream, the comments will be gone and I will manually fix the indentation, because there does not seem to be a way to do that using coccinelle.  Some amount of new code is currently sitting in linux-next that should get the same modifications, which I will do at the end of the merge window.  Many thanks to Julia Lawall for helping me learn to write a semantic patch that does all this.  ===== begin semantic patch ===== // This adds an llseek= method to all file operations, // as a preparation for making no_llseek the default. // // The rules are // - use no_llseek explicitly if we do nonseekable_open // - use seq_lseek for sequential files // - use default_llseek if we know we access f_pos // - use noop_llseek if we know we don't access f_pos, //   but we still want to allow users to call lseek // @ open1 exists @ identifier nested_open; @@ nested_open(...) { <+... nonseekable_open(...) ...+> }  @ open exists@ identifier open_f; identifier i, f; identifier open1.nested_open; @@ int open_f(struct inode *i, struct file *f) { <+... ( nonseekable_open(...) || nested_open(...) ) ...+> }  @ read disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { <+... (    *off = E ||    *off += E ||    func(..., off, ...) ||    E = *off ) ...+> }  @ read_no_fpos disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { ... when != off }  @ write @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { <+... (   *off = E ||   *off += E ||   func(..., off, ...) ||   E = *off ) ...+> }  @ write_no_fpos @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { ... when != off }  @ fops0 @ identifier fops; @@ struct file_operations fops = {  ... };  @ has_llseek depends on fops0 @ identifier fops0.fops; identifier llseek_f; @@ struct file_operations fops = { ...  .llseek = llseek_f, ... };  @ has_read depends on fops0 @ identifier fops0.fops; identifier read_f; @@ struct file_operations fops = { ...  .read = read_f, ... };  @ has_write depends on fops0 @ identifier fops0.fops; identifier write_f; @@ struct file_operations fops = { ...  .write = write_f, ... };  @ has_open depends on fops0 @ identifier fops0.fops; identifier open_f; @@ struct file_operations fops = { ...  .open = open_f, ... };  // use no_llseek if we call nonseekable_open //////////////////////////////////////////// @ nonseekable1 depends on !has_llseek && has_open @ identifier fops0.fops; identifier nso ~= "nonseekable_open"; @@ struct file_operations fops = { ...  .open = nso, ... +.llseek = no_llseek, /* nonseekable */ };  @ nonseekable2 depends on !has_llseek @ identifier fops0.fops; identifier open.open_f; @@ struct file_operations fops = { ...  .open = open_f, ... +.llseek = no_llseek, /* open uses nonseekable */ };  // use seq_lseek for sequential files ///////////////////////////////////// @ seq depends on !has_llseek @ identifier fops0.fops; identifier sr ~= "seq_read"; @@ struct file_operations fops = { ...  .read = sr, ... +.llseek = seq_lseek, /* we have seq_read */ };  // use default_llseek if there is a readdir /////////////////////////////////////////// @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier readdir_e; @@ // any other fop is used that changes pos struct file_operations fops = { ... .readdir = readdir_e, ... +.llseek = default_llseek, /* readdir is present */ };  // use default_llseek if at least one of read/write touches f_pos ///////////////////////////////////////////////////////////////// @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read.read_f; @@ // read fops use offset struct file_operations fops = { ... .read = read_f, ... +.llseek = default_llseek, /* read accesses f_pos */ };  @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write.write_f; @@ // write fops use offset struct file_operations fops = { ... .write = write_f, ... +	.llseek = default_llseek, /* write accesses f_pos */ };  // Use noop_llseek if neither read nor write accesses f_pos ///////////////////////////////////////////////////////////  @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; identifier write_no_fpos.write_f; @@ // write fops use offset struct file_operations fops = { ...  .write = write_f,  .read = read_f, ... +.llseek = noop_llseek, /* read and write both use no f_pos */ };  @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write_no_fpos.write_f; @@ struct file_operations fops = { ... .write = write_f, ... +.llseek = noop_llseek, /* write uses no f_pos */ };  @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; @@ struct file_operations fops = { ... .read = read_f, ... +.llseek = noop_llseek, /* read uses no f_pos */ };  @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; @@ struct file_operations fops = { ... +.llseek = noop_llseek, /* no read or write fn */ }; ===== End semantic patch =====  Signed-off-by: Arnd Bergmann <arnd@arndb.de> Cc: Julia Lawall <julia@diku.dk> Cc: Christoph Hellwig <hch@infradead.org>
f | pc8736x_gpio.c | s | 8.8K | 277 | Arnd Bergmann | arnd@arndb.de | 1287150807 |  | llseek: automatically add .llseek fop  All file_operations should get a .llseek operation so we can make nonseekable_open the default for future file operations without a .llseek pointer.  The three cases that we can automatically detect are no_llseek, seq_lseek and default_llseek. For cases where we can we can automatically prove that the file offset is always ignored, we use noop_llseek, which maintains the current behavior of not returning an error from a seek.  New drivers should normally not use noop_llseek but instead use no_llseek and call nonseekable_open at open time.  Existing drivers can be converted to do the same when the maintainer knows for certain that no user code relies on calling seek on the device file.  The generated code is often incorrectly indented and right now contains comments that clarify for each added line why a specific variant was chosen. In the version that gets submitted upstream, the comments will be gone and I will manually fix the indentation, because there does not seem to be a way to do that using coccinelle.  Some amount of new code is currently sitting in linux-next that should get the same modifications, which I will do at the end of the merge window.  Many thanks to Julia Lawall for helping me learn to write a semantic patch that does all this.  ===== begin semantic patch ===== // This adds an llseek= method to all file operations, // as a preparation for making no_llseek the default. // // The rules are // - use no_llseek explicitly if we do nonseekable_open // - use seq_lseek for sequential files // - use default_llseek if we know we access f_pos // - use noop_llseek if we know we don't access f_pos, //   but we still want to allow users to call lseek // @ open1 exists @ identifier nested_open; @@ nested_open(...) { <+... nonseekable_open(...) ...+> }  @ open exists@ identifier open_f; identifier i, f; identifier open1.nested_open; @@ int open_f(struct inode *i, struct file *f) { <+... ( nonseekable_open(...) || nested_open(...) ) ...+> }  @ read disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { <+... (    *off = E ||    *off += E ||    func(..., off, ...) ||    E = *off ) ...+> }  @ read_no_fpos disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { ... when != off }  @ write @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { <+... (   *off = E ||   *off += E ||   func(..., off, ...) ||   E = *off ) ...+> }  @ write_no_fpos @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { ... when != off }  @ fops0 @ identifier fops; @@ struct file_operations fops = {  ... };  @ has_llseek depends on fops0 @ identifier fops0.fops; identifier llseek_f; @@ struct file_operations fops = { ...  .llseek = llseek_f, ... };  @ has_read depends on fops0 @ identifier fops0.fops; identifier read_f; @@ struct file_operations fops = { ...  .read = read_f, ... };  @ has_write depends on fops0 @ identifier fops0.fops; identifier write_f; @@ struct file_operations fops = { ...  .write = write_f, ... };  @ has_open depends on fops0 @ identifier fops0.fops; identifier open_f; @@ struct file_operations fops = { ...  .open = open_f, ... };  // use no_llseek if we call nonseekable_open //////////////////////////////////////////// @ nonseekable1 depends on !has_llseek && has_open @ identifier fops0.fops; identifier nso ~= "nonseekable_open"; @@ struct file_operations fops = { ...  .open = nso, ... +.llseek = no_llseek, /* nonseekable */ };  @ nonseekable2 depends on !has_llseek @ identifier fops0.fops; identifier open.open_f; @@ struct file_operations fops = { ...  .open = open_f, ... +.llseek = no_llseek, /* open uses nonseekable */ };  // use seq_lseek for sequential files ///////////////////////////////////// @ seq depends on !has_llseek @ identifier fops0.fops; identifier sr ~= "seq_read"; @@ struct file_operations fops = { ...  .read = sr, ... +.llseek = seq_lseek, /* we have seq_read */ };  // use default_llseek if there is a readdir /////////////////////////////////////////// @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier readdir_e; @@ // any other fop is used that changes pos struct file_operations fops = { ... .readdir = readdir_e, ... +.llseek = default_llseek, /* readdir is present */ };  // use default_llseek if at least one of read/write touches f_pos ///////////////////////////////////////////////////////////////// @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read.read_f; @@ // read fops use offset struct file_operations fops = { ... .read = read_f, ... +.llseek = default_llseek, /* read accesses f_pos */ };  @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write.write_f; @@ // write fops use offset struct file_operations fops = { ... .write = write_f, ... +	.llseek = default_llseek, /* write accesses f_pos */ };  // Use noop_llseek if neither read nor write accesses f_pos ///////////////////////////////////////////////////////////  @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; identifier write_no_fpos.write_f; @@ // write fops use offset struct file_operations fops = { ...  .write = write_f,  .read = read_f, ... +.llseek = noop_llseek, /* read and write both use no f_pos */ };  @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write_no_fpos.write_f; @@ struct file_operations fops = { ... .write = write_f, ... +.llseek = noop_llseek, /* write uses no f_pos */ };  @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; @@ struct file_operations fops = { ... .read = read_f, ... +.llseek = noop_llseek, /* read uses no f_pos */ };  @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; @@ struct file_operations fops = { ... +.llseek = noop_llseek, /* no read or write fn */ }; ===== End semantic patch =====  Signed-off-by: Arnd Bergmann <arnd@arndb.de> Cc: Julia Lawall <julia@diku.dk> Cc: Christoph Hellwig <hch@infradead.org>
f | virtio_console.c | s | 46K | 1629 | Amit Shah | amit.shah@redhat.com | 1337246073 |  | virtio: console: tell host of open ports after resume from s3/s4  If a port was open before going into one of the sleep states, the port can continue normal operation after restore.  However, the host has to be told that the guest side of the connection is open to restore pre-suspend state.  This wasn't noticed so far due to a bug in qemu that was fixed recently (which marked the guest-side connection as always open).  CC: stable@vger.kernel.org   # Only for 3.3  Signed-off-by: Amit Shah <amit.shah@redhat.com> Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
f | lp.c | s | 26K | 917 | Linus Torvalds | torvalds@linux-foundation.org | 1333069943 |  | Merge branch 'x86-x32-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip  Pull x32 support for x86-64 from Ingo Molnar:  "This tree introduces the X32 binary format and execution mode for x86:   32-bit data space binaries using 64-bit instructions and 64-bit kernel   syscalls.    This allows applications whose working set fits into a 32 bits address   space to make use of 64-bit instructions while using a 32-bit address   space with shorter pointers, more compressed data structures, etc."  Fix up trivial context conflicts in arch/x86/{Kconfig,vdso/vma.c}  * 'x86-x32-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (71 commits)   x32: Fix alignment fail in struct compat_siginfo   x32: Fix stupid ia32/x32 inversion in the siginfo format   x32: Add ptrace for x32   x32: Switch to a 64-bit clock_t   x32: Provide separate is_ia32_task() and is_x32_task() predicates   x86, mtrr: Use explicit sizing and padding for the 64-bit ioctls   x86/x32: Fix the binutils auto-detect   x32: Warn and disable rather than error if binutils too old   x32: Only clear TIF_X32 flag once   x32: Make sure TS_COMPAT is cleared for x32 tasks   fs: Remove missed ->fds_bits from cessation use of fd_set structs internally   fs: Fix close_on_exec pointer in alloc_fdtable   x32: Drop non-__vdso weak symbols from the x32 VDSO   x32: Fix coding style violations in the x32 VDSO code   x32: Add x32 VDSO support   x32: Allow x32 to be configured   x32: If configured, add x32 system calls to system call tables   x32: Handle process creation   x32: Signal-related system calls   x86: Add #ifdef CONFIG_COMPAT to <asm/sys_ia32.h>   ...
f | applicom.c | s | 23K | 683 | Vasiliy Kulikov | segooon@gmail.com | 1288227794 |  | drivers/char/applicom.c: fix information leak to userland  Structure st_loc is copied to userland with some fields unitialized.  It leads to leaking of stack memory.  Signed-off-by: Vasiliy Kulikov <segooon@gmail.com> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | mbcs.h | s | 13K | 517 | Lucas De Marchi | lucas.demarchi@profusion.mobi | 1301581583 |  | Fix common misspellings  Fixes generated by 'codespell' and manually reviewed.  Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>
f | tlclk.c | s | 23K | 752 | Masanari Iida | standby24x7@gmail.com | 1328806191 |  | char: Fix typo in tlclk.c  Correct spelling "telclk_interrup" to "telclk_interrupt" in drivers/char/tlclk.c  Signed-off-by: Masanari Iida <standby24x7@gmail.com> Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
f | ds1620.c | s | 8.5K | 334 | Linus Torvalds | torvalds@linux-foundation.org | 1287769976 |  | Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl  * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:   vfs: make no_llseek the default   vfs: don't use BKL in default_llseek   llseek: automatically add .llseek fop   libfs: use generic_file_llseek for simple_attr   mac80211: disallow seeks in minstrel debug code   lirc: make chardev nonseekable   viotape: use noop_llseek   raw: use explicit llseek file operations   ibmasmfs: use generic_file_llseek   spufs: use llseek in all file operations   arm/omap: use generic_file_llseek in iommu_debug   lkdtm: use generic_file_llseek in debugfs   net/wireless: use generic_file_llseek in debugfs   drm: use noop_llseek
f | toshiba.c | s | 13K | 457 | Linus Torvalds | torvalds@linux-foundation.org | 1287769976 |  | Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl  * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:   vfs: make no_llseek the default   vfs: don't use BKL in default_llseek   llseek: automatically add .llseek fop   libfs: use generic_file_llseek for simple_attr   mac80211: disallow seeks in minstrel debug code   lirc: make chardev nonseekable   viotape: use noop_llseek   raw: use explicit llseek file operations   ibmasmfs: use generic_file_llseek   spufs: use llseek in all file operations   arm/omap: use generic_file_llseek in iommu_debug   lkdtm: use generic_file_llseek in debugfs   net/wireless: use generic_file_llseek in debugfs   drm: use noop_llseek
f | snsc.c | s | 10K | 398 | Linus Torvalds | torvalds@linux-foundation.org | 1287769976 |  | Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl  * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:   vfs: make no_llseek the default   vfs: don't use BKL in default_llseek   llseek: automatically add .llseek fop   libfs: use generic_file_llseek for simple_attr   mac80211: disallow seeks in minstrel debug code   lirc: make chardev nonseekable   viotape: use noop_llseek   raw: use explicit llseek file operations   ibmasmfs: use generic_file_llseek   spufs: use llseek in all file operations   arm/omap: use generic_file_llseek in iommu_debug   lkdtm: use generic_file_llseek in debugfs   net/wireless: use generic_file_llseek in debugfs   drm: use noop_llseek
f | Kconfig | g | 20K |  | Anton Vorontsov | anton.vorontsov@linaro.org | 1337180797 |  | ramoops: Move to fs/pstore/ram.c  Since ramoops was converted to pstore, it has nothing to do with character devices nowadays. Instead, today it is just a RAM backend for pstore.  The patch just moves things around. There are a few changes were needed because of the move:  1. Kconfig and Makefiles fixups, of course.  2. In pstore/ram.c we have to play a bit with MODULE_PARAM_PREFIX, this    is needed to keep user experience the same as with ramoops driver    (i.e. so that ramoops.foo kernel command line arguments would still    work).  Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org> Acked-by: Marco Stornelli <marco.stornelli@gmail.com> Acked-by: Kees Cook <keescook@chromium.org> Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
f | mspec.c | s | 10K | 392 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | random.c | s | 39K | 1202 | Mathieu Desnoyers | mathieu.desnoyers@efficios.com | 1334261532 |  | drivers/char/random.c: fix boot id uniqueness race  /proc/sys/kernel/random/boot_id can be read concurrently by userspace processes.  If two (or more) user-space processes concurrently read boot_id when sysctl_bootid is not yet assigned, a race can occur making boot_id differ between the reads.  Because the whole point of the boot id is to be unique across a kernel execution, fix this by protecting this operation with a spinlock.  Given that this operation is not frequently used, hitting the spinlock on each call should not be an issue.  Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com> Cc: "Theodore Ts'o" <tytso@mit.edu> Cc: Matt Mackall <mpm@selenic.com> Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Cc: Greg Kroah-Hartman <greg@kroah.com> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | ttyprintk.c | s | 5.2K | 191 | Jiri Slaby | jslaby@suse.cz | 1331235478 |  | TTY: remove re-assignments to tty_driver members  All num, magic and owner are set by alloc_tty_driver. No need to re-set them on each allocation site.  pti driver sets something different to what it passes to alloc_tty_driver. It is not a bug, since we don't use the lines parameter in any way. Anyway this is fixed, and now we do the right thing.  Signed-off-by: Jiri Slaby <jslaby@suse.cz> Acked-by: Tilman Schmidt <tilman@imap.cc> Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
d | mwave |  | 11 items |  | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | genrtc.c | s | 12K | 447 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | msm_smd_pkt.c | s | 10K | 388 | Thomas Meyer | thomas@m3y3r.de | 1314314733 |  | drivers/char/msm_smd_pkt.c: don't use IS_ERR()  The various basic memory allocation function return NULL, not an ERR_PTR.  The semantic patch that makes this change is available in scripts/coccinelle/null/eno.cocci.  More information about semantic patching is available at http://coccinelle.lip6.fr/  Signed-off-by: Thomas Meyer <thomas@m3y3r.de> Cc: Niranjana Vishwanathapura <nvishwan@codeaurora.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | dtlk.c | s | 16K | 572 | Linus Torvalds | torvalds@linux-foundation.org | 1287769976 |  | Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl  * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:   vfs: make no_llseek the default   vfs: don't use BKL in default_llseek   llseek: automatically add .llseek fop   libfs: use generic_file_llseek for simple_attr   mac80211: disallow seeks in minstrel debug code   lirc: make chardev nonseekable   viotape: use noop_llseek   raw: use explicit llseek file operations   ibmasmfs: use generic_file_llseek   spufs: use llseek in all file operations   arm/omap: use generic_file_llseek in iommu_debug   lkdtm: use generic_file_llseek in debugfs   net/wireless: use generic_file_llseek in debugfs   drm: use noop_llseek
d | xilinx_hwicap |  | 7 items |  | Daniel Borkmann | danborkmann@iogearbox.net | 1334887758 |  | xilinx_hwicap: reset XHI_MAX_RETRIES  Reset the XHI_MAX_RETRIES value. This allows the hardware enough time to write configuration frames during partial reconfiguration. In case of 10 the driver returns an error, although it should just have polled the register longer.  Tested on an ML605 board. The patch is against the latest linus-tree.  Signed-off-by: Ariane Keller <ariane.keller@tik.ee.ethz.ch> Signed-off-by: Daniel Borkmann <daniel.borkmann@tik.ee.ethz.ch> Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
f | rtc.c | s | 33K | 1229 | David Howells | dhowells@redhat.com | 1332955803 |  | Remove all #inclusions of asm/system.h  Remove all #inclusions of asm/system.h preparatory to splitting and killing it.  Performed with the following command:  perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`  Signed-off-by: David Howells <dhowells@redhat.com>
f | uv_mmtimer.c | s | 5.5K | 189 | Arnd Bergmann | arnd@arndb.de | 1290013172 |  | BKL: remove extraneous #include <smp_lock.h>  The big kernel lock has been removed from all these files at some point, leaving only the #include.  Remove this too as a cleanup.  Signed-off-by: Arnd Bergmann <arnd@arndb.de> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | nsc_gpio.c | s | 3.5K | 121 | Josef Sipek | jsipek@fsl.cs.sunysb.edu | 1165595324 |  | [PATCH] struct path: convert char-drivers  Signed-off-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu> Signed-off-by: Andrew Morton <akpm@osdl.org> Signed-off-by: Linus Torvalds <torvalds@osdl.org>
d | hw_random |  | 23 items |  | Linus Torvalds | torvalds@linux-foundation.org | 1340047236 |  | Merge git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6  Pull a crypto fix from Herbert Xu:  "This push fixes another bug in the atmel-rng that made it produce   completely useless output."  * git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6:   hwrng: atmel-rng - fix data valid check
f | raw.c | s | 8.4K | 313 | Al Viro | viro@zeniv.linux.org.uk | 1325649295 |  | switch device_get_devnode() and ->devnode() to umode_t *  both callers of device_get_devnode() are only interested in lower 16bits and nobody tries to return anything wider than 16bit anyway.  Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | snsc_event.c | s | 7.3K | 264 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
