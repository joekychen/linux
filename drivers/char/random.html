<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › char › random.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>random.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * random.c -- A strong random number generator</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright Matt Mackall &lt;mpm@selenic.com&gt;, 2003, 2004, 2005</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright Theodore Ts&#39;o, 1994, 1995, 1996, 1997, 1998, 1999.  All</span>
<span class="cm"> * rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, and the entire permission notice in its entirety,</span>
<span class="cm"> *    including the disclaimer of warranties.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. The name of the author may not be used to endorse or promote</span>
<span class="cm"> *    products derived from this software without specific prior</span>
<span class="cm"> *    written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * ALTERNATIVELY, this product may be distributed under the terms of</span>
<span class="cm"> * the GNU General Public License, in which case the provisions of the GPL are</span>
<span class="cm"> * required INSTEAD OF the above restrictions.  (This clause is</span>
<span class="cm"> * necessary due to a potential bad interaction between the GPL and</span>
<span class="cm"> * the restrictions contained in a BSD-style copyright.)</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<span class="cm"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF</span>
<span class="cm"> * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
<span class="cm"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
<span class="cm"> * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="cm"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE</span>
<span class="cm"> * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH</span>
<span class="cm"> * DAMAGE.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * (now, with legal B.S. out of the way.....)</span>
<span class="cm"> *</span>
<span class="cm"> * This routine gathers environmental noise from device drivers, etc.,</span>
<span class="cm"> * and returns good random numbers, suitable for cryptographic use.</span>
<span class="cm"> * Besides the obvious cryptographic uses, these numbers are also good</span>
<span class="cm"> * for seeding TCP sequence numbers, and other places where it is</span>
<span class="cm"> * desirable to have numbers which are not only random, but hard to</span>
<span class="cm"> * predict by an attacker.</span>
<span class="cm"> *</span>
<span class="cm"> * Theory of operation</span>
<span class="cm"> * ===================</span>
<span class="cm"> *</span>
<span class="cm"> * Computers are very predictable devices.  Hence it is extremely hard</span>
<span class="cm"> * to produce truly random numbers on a computer --- as opposed to</span>
<span class="cm"> * pseudo-random numbers, which can easily generated by using a</span>
<span class="cm"> * algorithm.  Unfortunately, it is very easy for attackers to guess</span>
<span class="cm"> * the sequence of pseudo-random number generators, and for some</span>
<span class="cm"> * applications this is not acceptable.  So instead, we must try to</span>
<span class="cm"> * gather &quot;environmental noise&quot; from the computer&#39;s environment, which</span>
<span class="cm"> * must be hard for outside attackers to observe, and use that to</span>
<span class="cm"> * generate random numbers.  In a Unix environment, this is best done</span>
<span class="cm"> * from inside the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Sources of randomness from the environment include inter-keyboard</span>
<span class="cm"> * timings, inter-interrupt timings from some interrupts, and other</span>
<span class="cm"> * events which are both (a) non-deterministic and (b) hard for an</span>
<span class="cm"> * outside observer to measure.  Randomness from these sources are</span>
<span class="cm"> * added to an &quot;entropy pool&quot;, which is mixed using a CRC-like function.</span>
<span class="cm"> * This is not cryptographically strong, but it is adequate assuming</span>
<span class="cm"> * the randomness is not chosen maliciously, and it is fast enough that</span>
<span class="cm"> * the overhead of doing it on every interrupt is very reasonable.</span>
<span class="cm"> * As random bytes are mixed into the entropy pool, the routines keep</span>
<span class="cm"> * an *estimate* of how many bits of randomness have been stored into</span>
<span class="cm"> * the random number generator&#39;s internal state.</span>
<span class="cm"> *</span>
<span class="cm"> * When random bytes are desired, they are obtained by taking the SHA</span>
<span class="cm"> * hash of the contents of the &quot;entropy pool&quot;.  The SHA hash avoids</span>
<span class="cm"> * exposing the internal state of the entropy pool.  It is believed to</span>
<span class="cm"> * be computationally infeasible to derive any useful information</span>
<span class="cm"> * about the input of SHA from its output.  Even if it is possible to</span>
<span class="cm"> * analyze SHA in some clever way, as long as the amount of data</span>
<span class="cm"> * returned from the generator is less than the inherent entropy in</span>
<span class="cm"> * the pool, the output data is totally unpredictable.  For this</span>
<span class="cm"> * reason, the routine decreases its internal estimate of how many</span>
<span class="cm"> * bits of &quot;true randomness&quot; are contained in the entropy pool as it</span>
<span class="cm"> * outputs random numbers.</span>
<span class="cm"> *</span>
<span class="cm"> * If this estimate goes to zero, the routine can still generate</span>
<span class="cm"> * random numbers; however, an attacker may (at least in theory) be</span>
<span class="cm"> * able to infer the future output of the generator from prior</span>
<span class="cm"> * outputs.  This requires successful cryptanalysis of SHA, which is</span>
<span class="cm"> * not believed to be feasible, but there is a remote possibility.</span>
<span class="cm"> * Nonetheless, these numbers should be useful for the vast majority</span>
<span class="cm"> * of purposes.</span>
<span class="cm"> *</span>
<span class="cm"> * Exported interfaces ---- output</span>
<span class="cm"> * ===============================</span>
<span class="cm"> *</span>
<span class="cm"> * There are three exported interfaces; the first is one designed to</span>
<span class="cm"> * be used from within the kernel:</span>
<span class="cm"> *</span>
<span class="cm"> * 	void get_random_bytes(void *buf, int nbytes);</span>
<span class="cm"> *</span>
<span class="cm"> * This interface will return the requested number of random bytes,</span>
<span class="cm"> * and place it in the requested buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The two other interfaces are two character devices /dev/random and</span>
<span class="cm"> * /dev/urandom.  /dev/random is suitable for use when very high</span>
<span class="cm"> * quality randomness is desired (for example, for key generation or</span>
<span class="cm"> * one-time pads), as it will only return a maximum of the number of</span>
<span class="cm"> * bits of randomness (as estimated by the random number generator)</span>
<span class="cm"> * contained in the entropy pool.</span>
<span class="cm"> *</span>
<span class="cm"> * The /dev/urandom device does not have this limit, and will return</span>
<span class="cm"> * as many bytes as are requested.  As more and more random bytes are</span>
<span class="cm"> * requested without giving time for the entropy pool to recharge,</span>
<span class="cm"> * this will result in random numbers that are merely cryptographically</span>
<span class="cm"> * strong.  For many applications, however, this is acceptable.</span>
<span class="cm"> *</span>
<span class="cm"> * Exported interfaces ---- input</span>
<span class="cm"> * ==============================</span>
<span class="cm"> *</span>
<span class="cm"> * The current exported interfaces for gathering environmental noise</span>
<span class="cm"> * from the devices are:</span>
<span class="cm"> *</span>
<span class="cm"> * 	void add_input_randomness(unsigned int type, unsigned int code,</span>
<span class="cm"> *                                unsigned int value);</span>
<span class="cm"> * 	void add_interrupt_randomness(int irq);</span>
<span class="cm"> * 	void add_disk_randomness(struct gendisk *disk);</span>
<span class="cm"> *</span>
<span class="cm"> * add_input_randomness() uses the input layer interrupt timing, as well as</span>
<span class="cm"> * the event type information from the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * add_interrupt_randomness() uses the inter-interrupt timing as random</span>
<span class="cm"> * inputs to the entropy pool.  Note that not all interrupts are good</span>
<span class="cm"> * sources of randomness!  For example, the timer interrupts is not a</span>
<span class="cm"> * good choice, because the periodicity of the interrupts is too</span>
<span class="cm"> * regular, and hence predictable to an attacker.  Network Interface</span>
<span class="cm"> * Controller interrupts are a better measure, since the timing of the</span>
<span class="cm"> * NIC interrupts are more unpredictable.</span>
<span class="cm"> *</span>
<span class="cm"> * add_disk_randomness() uses what amounts to the seek time of block</span>
<span class="cm"> * layer request events, on a per-disk_devt basis, as input to the</span>
<span class="cm"> * entropy pool. Note that high-speed solid state drives with very low</span>
<span class="cm"> * seek times do not make for good sources of entropy, as their seek</span>
<span class="cm"> * times are usually fairly consistent.</span>
<span class="cm"> *</span>
<span class="cm"> * All of these routines try to estimate how many bits of randomness a</span>
<span class="cm"> * particular randomness source.  They do this by keeping track of the</span>
<span class="cm"> * first and second order deltas of the event timings.</span>
<span class="cm"> *</span>
<span class="cm"> * Ensuring unpredictability at system startup</span>
<span class="cm"> * ============================================</span>
<span class="cm"> *</span>
<span class="cm"> * When any operating system starts up, it will go through a sequence</span>
<span class="cm"> * of actions that are fairly predictable by an adversary, especially</span>
<span class="cm"> * if the start-up does not involve interaction with a human operator.</span>
<span class="cm"> * This reduces the actual number of bits of unpredictability in the</span>
<span class="cm"> * entropy pool below the value in entropy_count.  In order to</span>
<span class="cm"> * counteract this effect, it helps to carry information in the</span>
<span class="cm"> * entropy pool across shut-downs and start-ups.  To do this, put the</span>
<span class="cm"> * following lines an appropriate script which is run during the boot</span>
<span class="cm"> * sequence:</span>
<span class="cm"> *</span>
<span class="cm"> *	echo &quot;Initializing random number generator...&quot;</span>
<span class="cm"> *	random_seed=/var/run/random-seed</span>
<span class="cm"> *	# Carry a random seed from start-up to start-up</span>
<span class="cm"> *	# Load and then save the whole entropy pool</span>
<span class="cm"> *	if [ -f $random_seed ]; then</span>
<span class="cm"> *		cat $random_seed &gt;/dev/urandom</span>
<span class="cm"> *	else</span>
<span class="cm"> *		touch $random_seed</span>
<span class="cm"> *	fi</span>
<span class="cm"> *	chmod 600 $random_seed</span>
<span class="cm"> *	dd if=/dev/urandom of=$random_seed count=1 bs=512</span>
<span class="cm"> *</span>
<span class="cm"> * and the following lines in an appropriate script which is run as</span>
<span class="cm"> * the system is shutdown:</span>
<span class="cm"> *</span>
<span class="cm"> *	# Carry a random seed from shut-down to start-up</span>
<span class="cm"> *	# Save the whole entropy pool</span>
<span class="cm"> *	echo &quot;Saving random seed...&quot;</span>
<span class="cm"> *	random_seed=/var/run/random-seed</span>
<span class="cm"> *	touch $random_seed</span>
<span class="cm"> *	chmod 600 $random_seed</span>
<span class="cm"> *	dd if=/dev/urandom of=$random_seed count=1 bs=512</span>
<span class="cm"> *</span>
<span class="cm"> * For example, on most modern systems using the System V init</span>
<span class="cm"> * scripts, such code fragments would be found in</span>
<span class="cm"> * /etc/rc.d/init.d/random.  On older Linux systems, the correct script</span>
<span class="cm"> * location might be in /etc/rcb.d/rc.local or /etc/rc.d/rc.0.</span>
<span class="cm"> *</span>
<span class="cm"> * Effectively, these commands cause the contents of the entropy pool</span>
<span class="cm"> * to be saved at shut-down time and reloaded into the entropy pool at</span>
<span class="cm"> * start-up.  (The &#39;dd&#39; in the addition to the bootup script is to</span>
<span class="cm"> * make sure that /etc/random-seed is different for every start-up,</span>
<span class="cm"> * even if the system crashes without executing rc.0.)  Even with</span>
<span class="cm"> * complete knowledge of the start-up activities, predicting the state</span>
<span class="cm"> * of the entropy pool requires knowledge of the previous history of</span>
<span class="cm"> * the system.</span>
<span class="cm"> *</span>
<span class="cm"> * Configuring the /dev/random driver under Linux</span>
<span class="cm"> * ==============================================</span>
<span class="cm"> *</span>
<span class="cm"> * The /dev/random driver under Linux uses minor numbers 8 and 9 of</span>
<span class="cm"> * the /dev/mem major number (#1).  So if your system does not have</span>
<span class="cm"> * /dev/random and /dev/urandom created already, they can be created</span>
<span class="cm"> * by using the commands:</span>
<span class="cm"> *</span>
<span class="cm"> * 	mknod /dev/random c 1 8</span>
<span class="cm"> * 	mknod /dev/urandom c 1 9</span>
<span class="cm"> *</span>
<span class="cm"> * Acknowledgements:</span>
<span class="cm"> * =================</span>
<span class="cm"> *</span>
<span class="cm"> * Ideas for constructing this random number generator were derived</span>
<span class="cm"> * from Pretty Good Privacy&#39;s random number generator, and from private</span>
<span class="cm"> * discussions with Phil Karn.  Colin Plumb provided a faster random</span>
<span class="cm"> * number generator, which speed up the mixing function of the entropy</span>
<span class="cm"> * pool, taken from PGPfone.  Dale Worley has also contributed many</span>
<span class="cm"> * useful ideas and suggestions to improve this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Any flaws in the design are solely my responsibility, and should</span>
<span class="cm"> * not be attributed to the Phil, Colin, or any of authors of PGP.</span>
<span class="cm"> *</span>
<span class="cm"> * Further background information on this topic may be obtained from</span>
<span class="cm"> * RFC 1750, &quot;Randomness Recommendations for Security&quot;, by Donald</span>
<span class="cm"> * Eastlake, Steve Crocker, and Jeff Schiller.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/cryptohash.h&gt;</span>
<span class="cp">#include &lt;linux/fips.h&gt;</span>

<span class="cp">#ifdef CONFIG_GENERIC_HARDIRQS</span>
<span class="cp"># include &lt;linux/irq.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration information</span>
<span class="cm"> */</span>
<span class="cp">#define INPUT_POOL_WORDS 128</span>
<span class="cp">#define OUTPUT_POOL_WORDS 32</span>
<span class="cp">#define SEC_XFER_SIZE 512</span>
<span class="cp">#define EXTRACT_SIZE 10</span>

<span class="cm">/*</span>
<span class="cm"> * The minimum number of bits of entropy before we wake up a read on</span>
<span class="cm"> * /dev/random.  Should be enough to do a significant reseed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">random_read_wakeup_thresh</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If the entropy count falls under this number of bits, then we</span>
<span class="cm"> * should wake up processes which are selecting or polling on write</span>
<span class="cm"> * access to /dev/random.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">random_write_wakeup_thresh</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * When the input pool goes over trickle_thresh, start dropping most</span>
<span class="cm"> * samples to avoid wasting CPU time and reduce lock contention.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">trickle_thresh</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">INPUT_POOL_WORDS</span> <span class="o">*</span> <span class="mi">28</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">trickle_count</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A pool of size .poolwords is stirred with a primitive polynomial</span>
<span class="cm"> * of degree .poolwords over GF(2).  The taps for various sizes are</span>
<span class="cm"> * defined below.  They are chosen to be evenly spaced (minimum RMS</span>
<span class="cm"> * distance from evenly spaced; the numbers in the comments are a</span>
<span class="cm"> * scaled squared error sum) except for the last tap, which is 1 to</span>
<span class="cm"> * get the twisting happening as fast as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">poolinfo</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">poolwords</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tap1</span><span class="p">,</span> <span class="n">tap2</span><span class="p">,</span> <span class="n">tap3</span><span class="p">,</span> <span class="n">tap4</span><span class="p">,</span> <span class="n">tap5</span><span class="p">;</span>
<span class="p">}</span> <span class="n">poolinfo_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 -- 105 */</span>
	<span class="p">{</span> <span class="mi">128</span><span class="p">,</span>	<span class="mi">103</span><span class="p">,</span>	<span class="mi">76</span><span class="p">,</span>	<span class="mi">51</span><span class="p">,</span>	<span class="mi">25</span><span class="p">,</span>	<span class="mi">1</span> <span class="p">},</span>
	<span class="cm">/* x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 -- 15 */</span>
	<span class="p">{</span> <span class="mi">32</span><span class="p">,</span>	<span class="mi">26</span><span class="p">,</span>	<span class="mi">20</span><span class="p">,</span>	<span class="mi">14</span><span class="p">,</span>	<span class="mi">7</span><span class="p">,</span>	<span class="mi">1</span> <span class="p">},</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */</span>
<span class="c">	{ 2048,	1638,	1231,	819,	411,	1 },</span>

<span class="c">	/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */</span>
<span class="c">	{ 1024,	817,	615,	412,	204,	1 },</span>

<span class="c">	/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */</span>
<span class="c">	{ 1024,	819,	616,	410,	207,	2 },</span>

<span class="c">	/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */</span>
<span class="c">	{ 512,	411,	308,	208,	104,	1 },</span>

<span class="c">	/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */</span>
<span class="c">	{ 512,	409,	307,	206,	102,	2 },</span>
<span class="c">	/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */</span>
<span class="c">	{ 512,	409,	309,	205,	103,	2 },</span>

<span class="c">	/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */</span>
<span class="c">	{ 256,	205,	155,	101,	52,	1 },</span>

<span class="c">	/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */</span>
<span class="c">	{ 128,	103,	78,	51,	27,	2 },</span>

<span class="c">	/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */</span>
<span class="c">	{ 64,	52,	39,	26,	14,	1 },</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define POOLBITS	poolwords*32</span>
<span class="cp">#define POOLBYTES	poolwords*4</span>

<span class="cm">/*</span>
<span class="cm"> * For the purposes of better mixing, we use the CRC-32 polynomial as</span>
<span class="cm"> * well to make a twisted Generalized Feedback Shift Reigster</span>
<span class="cm"> *</span>
<span class="cm"> * (See M. Matsumoto &amp; Y. Kurita, 1992.  Twisted GFSR generators.  ACM</span>
<span class="cm"> * Transactions on Modeling and Computer Simulation 2(3):179-194.</span>
<span class="cm"> * Also see M. Matsumoto &amp; Y. Kurita, 1994.  Twisted GFSR generators</span>
<span class="cm"> * II.  ACM Transactions on Mdeling and Computer Simulation 4:254-266)</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks to Colin Plumb for suggesting this.</span>
<span class="cm"> *</span>
<span class="cm"> * We have not analyzed the resultant polynomial to prove it primitive;</span>
<span class="cm"> * in fact it almost certainly isn&#39;t.  Nonetheless, the irreducible factors</span>
<span class="cm"> * of a random large-degree polynomial over GF(2) are more than large enough</span>
<span class="cm"> * that periodicity is not a concern.</span>
<span class="cm"> *</span>
<span class="cm"> * The input hash is much less sensitive than the output hash.  All</span>
<span class="cm"> * that we want of it is that it be a good non-cryptographic hash;</span>
<span class="cm"> * i.e. it not produce collisions when fed &quot;random&quot; data of the sort</span>
<span class="cm"> * we expect to see.  As long as the pool state differs for different</span>
<span class="cm"> * inputs, we have preserved the input entropy and done a good job.</span>
<span class="cm"> * The fact that an intelligent attacker can construct inputs that</span>
<span class="cm"> * will produce controlled alterations to the pool&#39;s state is not</span>
<span class="cm"> * important because we don&#39;t consider such inputs to contribute any</span>
<span class="cm"> * randomness.  The only property we need with respect to them is that</span>
<span class="cm"> * the attacker can&#39;t increase his/her knowledge of the pool&#39;s state.</span>
<span class="cm"> * Since all additions are reversible (knowing the final state and the</span>
<span class="cm"> * input, you can reconstruct the initial state), if an attacker has</span>
<span class="cm"> * any uncertainty about the initial state, he/she can only shuffle</span>
<span class="cm"> * that uncertainty about, but never cause any collisions (which would</span>
<span class="cm"> * decrease the uncertainty).</span>
<span class="cm"> *</span>
<span class="cm"> * The chosen system lets the state of the pool be (essentially) the input</span>
<span class="cm"> * modulo the generator polymnomial.  Now, for random primitive polynomials,</span>
<span class="cm"> * this is a universal class of hash functions, meaning that the chance</span>
<span class="cm"> * of a collision is limited by the attacker&#39;s knowledge of the generator</span>
<span class="cm"> * polynomail, so if it is chosen at random, an attacker can never force</span>
<span class="cm"> * a collision.  Here, we use a fixed polynomial, but we *can* assume that</span>
<span class="cm"> * ###--&gt; it is unknown to the processes generating the input entropy. &lt;-###</span>
<span class="cm"> * Because of this important property, this is a good, collision-resistant</span>
<span class="cm"> * hash; hash collisions will occur no more often than chance.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Static global variables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">random_read_wait</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">random_write_wait</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">fasync</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static bool debug;</span>
<span class="c">module_param(debug, bool, 0644);</span>
<span class="c">#define DEBUG_ENT(fmt, arg...) do { \</span>
<span class="c">	if (debug) \</span>
<span class="c">		printk(KERN_DEBUG &quot;random %04d %04d %04d: &quot; \</span>
<span class="c">		fmt,\</span>
<span class="c">		input_pool.entropy_count,\</span>
<span class="c">		blocking_pool.entropy_count,\</span>
<span class="c">		nonblocking_pool.entropy_count,\</span>
<span class="c">		## arg); } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define DEBUG_ENT(fmt, arg...) do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * OS independent entropy store.   Here are the functions which handle</span>
<span class="cm"> * storing entropy in an entropy pool.</span>
<span class="cm"> *</span>
<span class="cm"> **********************************************************************/</span>

<span class="k">struct</span> <span class="n">entropy_store</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">entropy_store</span> <span class="p">{</span>
	<span class="cm">/* read-only data: */</span>
	<span class="k">struct</span> <span class="n">poolinfo</span> <span class="o">*</span><span class="n">poolinfo</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">pull</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>

	<span class="cm">/* read-write data: */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">add_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entropy_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">input_rotate</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">last_data</span><span class="p">[</span><span class="n">EXTRACT_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__u32</span> <span class="n">input_pool_data</span><span class="p">[</span><span class="n">INPUT_POOL_WORDS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">blocking_pool_data</span><span class="p">[</span><span class="n">OUTPUT_POOL_WORDS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">nonblocking_pool_data</span><span class="p">[</span><span class="n">OUTPUT_POOL_WORDS</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">entropy_store</span> <span class="n">input_pool</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">poolinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poolinfo_table</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;input&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">input_pool_data</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">entropy_store</span> <span class="n">blocking_pool</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">poolinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poolinfo_table</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;blocking&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pull</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">input_pool</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocking_pool</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">blocking_pool_data</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">entropy_store</span> <span class="n">nonblocking_pool</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">poolinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poolinfo_table</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;nonblocking&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pull</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">input_pool</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonblocking_pool</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">nonblocking_pool_data</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This function adds bytes into the entropy &quot;pool&quot;.  It does not</span>
<span class="cm"> * update the entropy estimate.  The caller should call</span>
<span class="cm"> * credit_entropy_bits if this is appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> * The pool is stirred with a primitive polynomial of the appropriate</span>
<span class="cm"> * degree, and then twisted.  We twist by three bits at a time because</span>
<span class="cm"> * it&#39;s cheap to do so and helps slightly in the expected case where</span>
<span class="cm"> * the entropy is concentrated in the low-order bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mix_pool_bytes_extract</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">out</span><span class="p">[</span><span class="mi">64</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">__u32</span> <span class="k">const</span> <span class="n">twist_table</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x3b6e20c8</span><span class="p">,</span> <span class="mh">0x76dc4190</span><span class="p">,</span> <span class="mh">0x4db26158</span><span class="p">,</span>
		<span class="mh">0xedb88320</span><span class="p">,</span> <span class="mh">0xd6d6a3e8</span><span class="p">,</span> <span class="mh">0x9b64c2b0</span><span class="p">,</span> <span class="mh">0xa00ae278</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">tap1</span><span class="p">,</span> <span class="n">tap2</span><span class="p">,</span> <span class="n">tap3</span><span class="p">,</span> <span class="n">tap4</span><span class="p">,</span> <span class="n">tap5</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">input_rotate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wordmask</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">poolwords</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">w</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Taps are constant, so we can load them without holding r-&gt;lock.  */</span>
	<span class="n">tap1</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">tap1</span><span class="p">;</span>
	<span class="n">tap2</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">tap2</span><span class="p">;</span>
	<span class="n">tap3</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">tap3</span><span class="p">;</span>
	<span class="n">tap4</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">tap4</span><span class="p">;</span>
	<span class="n">tap5</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">tap5</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">input_rotate</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">input_rotate</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">add_ptr</span><span class="p">;</span>

	<span class="cm">/* mix one byte at a time to simplify size handling and churn faster */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nbytes</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">rol32</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">++</span><span class="p">,</span> <span class="n">input_rotate</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wordmask</span><span class="p">;</span>

		<span class="cm">/* XOR in the various taps */</span>
		<span class="n">w</span> <span class="o">^=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">w</span> <span class="o">^=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">tap1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wordmask</span><span class="p">];</span>
		<span class="n">w</span> <span class="o">^=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">tap2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wordmask</span><span class="p">];</span>
		<span class="n">w</span> <span class="o">^=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">tap3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wordmask</span><span class="p">];</span>
		<span class="n">w</span> <span class="o">^=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">tap4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wordmask</span><span class="p">];</span>
		<span class="n">w</span> <span class="o">^=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">tap5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wordmask</span><span class="p">];</span>

		<span class="cm">/* Mix the result back in with a twist */</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">^</span> <span class="n">twist_table</span><span class="p">[</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Normally, we add 7 bits of rotation to the pool.</span>
<span class="cm">		 * At the beginning of the pool, add an extra 7 bits</span>
<span class="cm">		 * rotation, so that successive passes spread the</span>
<span class="cm">		 * input bits across the pool evenly.</span>
<span class="cm">		 */</span>
		<span class="n">input_rotate</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">14</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span><span class="o">-&gt;</span><span class="n">input_rotate</span> <span class="o">=</span> <span class="n">input_rotate</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">add_ptr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">((</span><span class="n">__u32</span> <span class="o">*</span><span class="p">)</span><span class="n">out</span><span class="p">)[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wordmask</span><span class="p">];</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mix_pool_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">mix_pool_bytes_extract</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Credit (or debit) the entropy store with n bits of entropy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">credit_entropy_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entropy_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nbits</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;added %d entropy credits to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">entropy_count</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span><span class="p">;</span>
	<span class="n">entropy_count</span> <span class="o">+=</span> <span class="n">nbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entropy_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;negative entropy/overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">entropy_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">entropy_count</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">POOLBITS</span><span class="p">)</span>
		<span class="n">entropy_count</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">POOLBITS</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">=</span> <span class="n">entropy_count</span><span class="p">;</span>

	<span class="cm">/* should we wake readers? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">input_pool</span> <span class="o">&amp;&amp;</span> <span class="n">entropy_count</span> <span class="o">&gt;=</span> <span class="n">random_read_wakeup_thresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">random_read_wait</span><span class="p">);</span>
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Entropy input management</span>
<span class="cm"> *</span>
<span class="cm"> *********************************************************************/</span>

<span class="cm">/* There is one of these per entropy source */</span>
<span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="p">{</span>
	<span class="n">cycles_t</span> <span class="n">last_time</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">last_delta</span><span class="p">,</span> <span class="n">last_delta2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">dont_count_entropy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifndef CONFIG_GENERIC_HARDIRQS</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">irq_timer_state</span><span class="p">[</span><span class="n">NR_IRQS</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="nf">get_timer_rand_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_timer_state</span><span class="p">[</span><span class="n">irq</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_timer_rand_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_timer_state</span><span class="p">[</span><span class="n">irq</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="nf">get_timer_rand_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">timer_rand_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_timer_rand_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">timer_rand_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="n">input_timer_state</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This function adds entropy to the entropy &quot;pool&quot; by using timing</span>
<span class="cm"> * delays.  It uses the timer_rand_state structure to make an estimate</span>
<span class="cm"> * of how many bits of entropy this call has added to the pool.</span>
<span class="cm"> *</span>
<span class="cm"> * The number &quot;num&quot; is also added to the pool - it should somehow describe</span>
<span class="cm"> * the type of event which just happened.  This is currently 0-255 for</span>
<span class="cm"> * keyboard scan codes, and 256 upwards for interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_timer_randomness</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">cycles</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sample</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="n">delta2</span><span class="p">,</span> <span class="n">delta3</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="cm">/* if over the trickle threshold, use only 1 in 4096 samples */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_pool</span><span class="p">.</span><span class="n">entropy_count</span> <span class="o">&gt;</span> <span class="n">trickle_thresh</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">__this_cpu_inc_return</span><span class="p">(</span><span class="n">trickle_count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sample</span><span class="p">.</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* Use arch random value, fall back to cycles */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_get_random_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sample</span><span class="p">.</span><span class="n">cycles</span><span class="p">))</span>
		<span class="n">sample</span><span class="p">.</span><span class="n">cycles</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>

	<span class="n">sample</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">mix_pool_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sample</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate number of bits of randomness we probably added.</span>
<span class="cm">	 * We take into account the first, second and third-order deltas</span>
<span class="cm">	 * in order to make our estimate.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">dont_count_entropy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">sample</span><span class="p">.</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_time</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">last_time</span> <span class="o">=</span> <span class="n">sample</span><span class="p">.</span><span class="n">jiffies</span><span class="p">;</span>

		<span class="n">delta2</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_delta</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">last_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="n">delta3</span> <span class="o">=</span> <span class="n">delta2</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_delta2</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">last_delta2</span> <span class="o">=</span> <span class="n">delta2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta2</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta3</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta3</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">delta2</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">delta2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">delta3</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">delta3</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * delta is now minimum absolute delta.</span>
<span class="cm">		 * Round down by 1 bit on general principles,</span>
<span class="cm">		 * and limit entropy entimate to 12 bits.</span>
<span class="cm">		 */</span>
		<span class="n">credit_entropy_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">,</span>
				    <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">fls</span><span class="p">(</span><span class="n">delta</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">11</span><span class="p">));</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_input_randomness</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">last_value</span><span class="p">;</span>

	<span class="cm">/* ignore autorepeat and the like */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">last_value</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;input event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">last_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">add_timer_randomness</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_timer_state</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">^</span> <span class="n">code</span> <span class="o">^</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">^</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">add_input_randomness</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">add_interrupt_randomness</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">get_timer_rand_state</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;irq event %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">add_timer_randomness</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mh">0x100</span> <span class="o">+</span> <span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="kt">void</span> <span class="nf">add_disk_randomness</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span> <span class="o">||</span> <span class="o">!</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">random</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* first major is 1, so we get &gt;= 0x200 here */</span>
	<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;disk event %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">MAJOR</span><span class="p">(</span><span class="n">disk_devt</span><span class="p">(</span><span class="n">disk</span><span class="p">)),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">disk_devt</span><span class="p">(</span><span class="n">disk</span><span class="p">)));</span>

	<span class="n">add_timer_randomness</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">random</span><span class="p">,</span> <span class="mh">0x100</span> <span class="o">+</span> <span class="n">disk_devt</span><span class="p">(</span><span class="n">disk</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Entropy extraction routines</span>
<span class="cm"> *</span>
<span class="cm"> *********************************************************************/</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">extract_entropy</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rsvd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This utility inline function is responsible for transferring entropy</span>
<span class="cm"> * from the primary pool to the secondary extraction pool. We make</span>
<span class="cm"> * sure we pull enough for a &#39;catastrophic reseed&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xfer_secondary_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">tmp</span><span class="p">[</span><span class="n">OUTPUT_POOL_WORDS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">pull</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">&lt;</span> <span class="n">nbytes</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span>
	    <span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">POOLBITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we&#39;re limited, always leave two wakeup worth&#39;s BITS */</span>
		<span class="kt">int</span> <span class="n">rsvd</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">random_read_wakeup_thresh</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">nbytes</span><span class="p">;</span>

		<span class="cm">/* pull at least as many as BYTES as wakeup BITS */</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">random_read_wakeup_thresh</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
		<span class="cm">/* but never more than the buffer size */</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

		<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;going to reseed %s with %d bits &quot;</span>
			  <span class="s">&quot;(%d of %d requested)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">nbytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span><span class="p">);</span>

		<span class="n">bytes</span> <span class="o">=</span> <span class="n">extract_entropy</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">pull</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
					<span class="n">random_read_wakeup_thresh</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">rsvd</span><span class="p">);</span>
		<span class="n">mix_pool_bytes</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">credit_entropy_bits</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">bytes</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These functions extracts randomness from the &quot;entropy pool&quot;, and</span>
<span class="cm"> * returns it in a buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The min parameter specifies the minimum amount we can pull before</span>
<span class="cm"> * failing to avoid races that defeat catastrophic reseeding while the</span>
<span class="cm"> * reserved parameter indicates how much entropy we must leave in the</span>
<span class="cm"> * pool after each pull to avoid starving other readers.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: extract_entropy() assumes that .poolwords is a multiple of 16 words.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">account</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Hold lock while accounting */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">POOLBITS</span><span class="p">);</span>
	<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;trying to extract %d bits from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">nbytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Can we pull enough? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="o">+</span> <span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If limited, never pull more than available */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">nbytes</span> <span class="o">+</span> <span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">nbytes</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span><span class="o">/</span><span class="mi">8</span> <span class="o">-</span> <span class="n">reserved</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">&gt;=</span> <span class="n">nbytes</span> <span class="o">+</span> <span class="n">reserved</span><span class="p">)</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">-=</span> <span class="n">nbytes</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">=</span> <span class="n">reserved</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">&lt;</span> <span class="n">random_write_wakeup_thresh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">random_write_wait</span><span class="p">);</span>
			<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;debiting %d entropy credits from %s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">nbytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; (unlimited)&quot;</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">extract_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">hash</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">workspace</span><span class="p">[</span><span class="n">SHA_WORKSPACE_WORDS</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">extract</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="cm">/* Generate a hash across the pool, 16 words (512 bits) at a time */</span>
	<span class="n">sha_init</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">poolwords</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">sha_transform</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">workspace</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We mix the hash back into the pool to prevent backtracking</span>
<span class="cm">	 * attacks (where the attacker knows the state of the pool</span>
<span class="cm">	 * plus the current outputs, and attempts to find previous</span>
<span class="cm">	 * ouputs), unless the hash function can be inverted. By</span>
<span class="cm">	 * mixing at least a SHA1 worth of hash data back, we make</span>
<span class="cm">	 * brute-forcing the feedback as hard as brute-forcing the</span>
<span class="cm">	 * hash.</span>
<span class="cm">	 */</span>
	<span class="n">mix_pool_bytes_extract</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hash</span><span class="p">),</span> <span class="n">extract</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * To avoid duplicates, we atomically extract a portion of the</span>
<span class="cm">	 * pool while mixing, and hash one final time.</span>
<span class="cm">	 */</span>
	<span class="n">sha_transform</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">extract</span><span class="p">,</span> <span class="n">workspace</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">extract</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">extract</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">workspace</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case the hash function has some recognizable output</span>
<span class="cm">	 * pattern, we fold it in half. Thus, we always feed back</span>
<span class="cm">	 * twice as much data as we output.</span>
<span class="cm">	 */</span>
	<span class="n">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^=</span> <span class="n">hash</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^=</span> <span class="n">hash</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^=</span> <span class="n">rol32</span><span class="p">(</span><span class="n">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">EXTRACT_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hash</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">extract_entropy</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">tmp</span><span class="p">[</span><span class="n">EXTRACT_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">xfer_secondary_pool</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">account</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extract_buf</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fips_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">last_data</span><span class="p">,</span> <span class="n">EXTRACT_SIZE</span><span class="p">))</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Hardware RNG duplicated output!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">last_data</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">EXTRACT_SIZE</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">EXTRACT_SIZE</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">nbytes</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wipe data just returned from memory */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">extract_entropy_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">tmp</span><span class="p">[</span><span class="n">EXTRACT_SIZE</span><span class="p">];</span>

	<span class="n">xfer_secondary_pool</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">account</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">extract_buf</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">EXTRACT_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nbytes</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wipe data just returned from memory */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is the exported kernel interface.  It returns some</span>
<span class="cm"> * number of good random numbers, suitable for seeding TCP sequence</span>
<span class="cm"> * numbers, etc.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">get_random_bytes</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nbytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_get_random_long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">nbytes</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">extract_entropy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonblocking_pool</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_random_bytes</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * init_std_data - initialize pool with system data</span>
<span class="cm"> *</span>
<span class="cm"> * @r: pool to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * This function clears the pool&#39;s entropy count and mixes some system</span>
<span class="cm"> * data into the pool to prepare it for use. The pool is not cleared</span>
<span class="cm"> * as that can only decrease the entropy in the pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_std_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">entropy_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="n">mix_pool_bytes</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">now</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">poolinfo</span><span class="o">-&gt;</span><span class="n">POOLBYTES</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="k">sizeof</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_get_random_long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mix_pool_bytes</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flags</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">mix_pool_bytes</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">utsname</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">utsname</span><span class="p">())));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rand_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_std_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">);</span>
	<span class="n">init_std_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocking_pool</span><span class="p">);</span>
	<span class="n">init_std_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonblocking_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">rand_initialize</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rand_initialize_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">get_timer_rand_state</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If kzalloc returns null, we just won&#39;t use that entropy</span>
<span class="cm">	 * source.</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_rand_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="n">set_timer_rand_state</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="kt">void</span> <span class="nf">rand_initialize_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If kzalloc returns null, we just won&#39;t use that entropy</span>
<span class="cm">	 * source.</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_rand_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="n">disk</span><span class="o">-&gt;</span><span class="n">random</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">random_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">nbytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">SEC_XFER_SIZE</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">SEC_XFER_SIZE</span><span class="p">;</span>

		<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;reading %d bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">extract_entropy_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocking_pool</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;read got %d bits (%d still needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">n</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="n">nbytes</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;sleeping?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">random_read_wait</span><span class="p">,</span>
				<span class="n">input_pool</span><span class="p">.</span><span class="n">entropy_count</span> <span class="o">&gt;=</span>
						 <span class="n">random_read_wakeup_thresh</span><span class="p">);</span>

			<span class="n">DEBUG_ENT</span><span class="p">(</span><span class="s">&quot;awake</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">nbytes</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>		<span class="cm">/* This break makes the device work */</span>
				<span class="cm">/* like a named pipe */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">count</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">urandom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">extract_entropy_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonblocking_pool</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">random_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">random_read_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">random_write_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_pool</span><span class="p">.</span><span class="n">entropy_count</span> <span class="o">&gt;=</span> <span class="n">random_read_wakeup_thresh</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_pool</span><span class="p">.</span><span class="n">entropy_count</span> <span class="o">&lt;</span> <span class="n">random_write_wakeup_thresh</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">write_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">entropy_store</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">count</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>

		<span class="n">mix_pool_bytes</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">random_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">write_pool</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocking_pool</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">write_pool</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonblocking_pool</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">random_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">ent_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RNDGETENTCNT</span>:
		<span class="cm">/* inherently racy, no point locking */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">input_pool</span><span class="p">.</span><span class="n">entropy_count</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RNDADDTOENTCNT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ent_count</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">credit_entropy_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">,</span> <span class="n">ent_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RNDADDENTROPY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ent_count</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ent_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">write_pool</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span>
				    <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">credit_entropy_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">,</span> <span class="n">ent_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RNDZAPENTCNT</span>:
	<span class="k">case</span> <span class="n">RNDCLEARPOOL</span>:
		<span class="cm">/* Clear the entropy pool counters. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">rand_initialize</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">random_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fasync</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">random_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>  <span class="o">=</span> <span class="n">random_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">random_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>  <span class="o">=</span> <span class="n">random_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">random_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span> <span class="o">=</span> <span class="n">random_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">urandom_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>  <span class="o">=</span> <span class="n">urandom_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">random_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">random_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span> <span class="o">=</span> <span class="n">random_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/***************************************************************</span>
<span class="cm"> * Random UUID interface</span>
<span class="cm"> *</span>
<span class="cm"> * Used here for a Boot ID, but can be useful for other kernel</span>
<span class="cm"> * drivers.</span>
<span class="cm"> ***************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Generate random UUID</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">generate_random_uuid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uuid_out</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">uuid_out</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="cm">/* Set UUID version to 4 --- truly random generation */</span>
	<span class="n">uuid_out</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uuid_out</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="cm">/* Set the UUID variant to DCE */</span>
	<span class="n">uuid_out</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uuid_out</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generate_random_uuid</span><span class="p">);</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Sysctl interface</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>

<span class="cp">#include &lt;linux/sysctl.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">min_read_thresh</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">min_write_thresh</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_read_thresh</span> <span class="o">=</span> <span class="n">INPUT_POOL_WORDS</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_write_thresh</span> <span class="o">=</span> <span class="n">INPUT_POOL_WORDS</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">sysctl_bootid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * These functions is used to return both the bootid UUID, and random</span>
<span class="cm"> * UUID.  The difference is in whether table-&gt;data is NULL; if it is,</span>
<span class="cm"> * then a new UUID is generated and returned to the user.</span>
<span class="cm"> *</span>
<span class="cm"> * If the user accesses this via the proc interface, it will be returned</span>
<span class="cm"> * as an ASCII string in the standard UUID format.  If accesses via the</span>
<span class="cm"> * sysctl system call, it is returned as 16 bytes of binary data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_do_uuid</span><span class="p">(</span><span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctl_table</span> <span class="n">fake_table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">],</span> <span class="n">tmp_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="o">*</span><span class="n">uuid</span><span class="p">;</span>

	<span class="n">uuid</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uuid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uuid</span> <span class="o">=</span> <span class="n">tmp_uuid</span><span class="p">;</span>
		<span class="n">generate_random_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">bootid_spinlock</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bootid_spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uuid</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
			<span class="n">generate_random_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bootid_spinlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%pU&quot;</span><span class="p">,</span> <span class="n">uuid</span><span class="p">);</span>

	<span class="n">fake_table</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">fake_table</span><span class="p">.</span><span class="n">maxlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">proc_dostring</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fake_table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sysctl_poolsize</span> <span class="o">=</span> <span class="n">INPUT_POOL_WORDS</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
<span class="n">ctl_table</span> <span class="n">random_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;poolsize&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">sysctl_poolsize</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0444</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;entropy_avail&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0444</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">input_pool</span><span class="p">.</span><span class="n">entropy_count</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;read_wakeup_threshold&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">random_read_wakeup_thresh</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">min_read_thresh</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">max_read_thresh</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;write_wakeup_threshold&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">random_write_wakeup_thresh</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">min_write_thresh</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">max_write_thresh</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;boot_id&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">sysctl_bootid</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0444</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_do_uuid</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;uuid&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0444</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_do_uuid</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="cp">#endif 	</span><span class="cm">/* CONFIG_SYSCTL */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">random_int_secret</span><span class="p">[</span><span class="n">MD5_MESSAGE_BYTES</span> <span class="o">/</span> <span class="mi">4</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">random_int_secret_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">random_int_secret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">random_int_secret</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">random_int_secret_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Get a random word for internal kernel use only. Similar to urandom but</span>
<span class="cm"> * with the goal of minimal entropy pool depletion. As a result, the random</span>
<span class="cm"> * value is not cryptographically secure but for several uses the cost of</span>
<span class="cm"> * depleting entropy is too high</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">__u32</span> <span class="p">[</span><span class="n">MD5_DIGEST_WORDS</span><span class="p">],</span> <span class="n">get_random_int_hash</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_random_int</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_get_random_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">get_cpu_var</span><span class="p">(</span><span class="n">get_random_int_hash</span><span class="p">);</span>

	<span class="n">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">+</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">get_cycles</span><span class="p">();</span>
	<span class="n">md5_transform</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">random_int_secret</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">get_random_int_hash</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * randomize_range() returns a start address such that</span>
<span class="cm"> *</span>
<span class="cm"> *    [...... &lt;range&gt; .....]</span>
<span class="cm"> *  start                  end</span>
<span class="cm"> *</span>
<span class="cm"> * a &lt;range&gt; with size &quot;len&quot; starting at the return value is inside in the</span>
<span class="cm"> * area defined by [start, end], but is otherwise randomized.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">randomize_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">len</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">get_random_int</span><span class="p">()</span> <span class="o">%</span> <span class="n">range</span> <span class="o">+</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
