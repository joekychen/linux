<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › char › rtc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rtc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Real Time Clock interface for Linux</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 1996 Paul Gortmaker</span>
<span class="cm"> *</span>
<span class="cm"> *	This driver allows use of the real time clock (built into</span>
<span class="cm"> *	nearly all computers) from user space. It exports the /dev/rtc</span>
<span class="cm"> *	interface supporting various ioctl() and also the</span>
<span class="cm"> *	/proc/driver/rtc pseudo-file for status information.</span>
<span class="cm"> *</span>
<span class="cm"> *	The ioctls can be used to set the interrupt behaviour and</span>
<span class="cm"> *	generation rate from the RTC via IRQ 8. Then the /dev/rtc</span>
<span class="cm"> *	interface can be used to make use of these timer interrupts,</span>
<span class="cm"> *	be they interval or alarm based.</span>
<span class="cm"> *</span>
<span class="cm"> *	The /dev/rtc interface will block on reads until an interrupt</span>
<span class="cm"> *	has been received. If a RTC interrupt has already happened,</span>
<span class="cm"> *	it will output an unsigned long and then block. The output value</span>
<span class="cm"> *	contains the interrupt status in the low byte and the number of</span>
<span class="cm"> *	interrupts since the last read in the remaining high bytes. The</span>
<span class="cm"> *	/dev/rtc interface can also be used with the select(2) call.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	Based on other minimal char device drivers, like Alan&#39;s</span>
<span class="cm"> *	watchdog, Ted&#39;s random, etc. etc.</span>
<span class="cm"> *</span>
<span class="cm"> *	1.07	Paul Gortmaker.</span>
<span class="cm"> *	1.08	Miquel van Smoorenburg: disallow certain things on the</span>
<span class="cm"> *		DEC Alpha as the CMOS clock is also used for other things.</span>
<span class="cm"> *	1.09	Nikita Schmidt: epoch support and some Alpha cleanup.</span>
<span class="cm"> *	1.09a	Pete Zaitcev: Sun SPARC</span>
<span class="cm"> *	1.09b	Jeff Garzik: Modularize, init cleanup</span>
<span class="cm"> *	1.09c	Jeff Garzik: SMP cleanup</span>
<span class="cm"> *	1.10	Paul Barton-Davis: add support for async I/O</span>
<span class="cm"> *	1.10a	Andrea Arcangeli: Alpha updates</span>
<span class="cm"> *	1.10b	Andrew Morton: SMP lock fix</span>
<span class="cm"> *	1.10c	Cesar Barros: SMP locking fixes and cleanup</span>
<span class="cm"> *	1.10d	Paul Gortmaker: delete paranoia check in rtc_exit</span>
<span class="cm"> *	1.10e	Maciej W. Rozycki: Handle DECstation&#39;s year weirdness.</span>
<span class="cm"> *	1.11	Takashi Iwai: Kernel access functions</span>
<span class="cm"> *			      rtc_register/rtc_unregister/rtc_control</span>
<span class="cm"> *      1.11a   Daniele Bellucci: Audit create_proc_read_entry in rtc_init</span>
<span class="cm"> *	1.12	Venkatesh Pallipadi: Hooks for emulating rtc on HPET base-timer</span>
<span class="cm"> *		CONFIG_HPET_EMULATE_RTC</span>
<span class="cm"> *	1.12a	Maciej W. Rozycki: Handle memory-mapped chips properly.</span>
<span class="cm"> *	1.12ac	Alan Cox: Allow read access to the day of week register</span>
<span class="cm"> *	1.12b	David John: Remove calls to the BKL.</span>
<span class="cm"> */</span>

<span class="cp">#define RTC_VERSION		&quot;1.12b&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *	Note that *all* calls to CMOS_READ and CMOS_WRITE are done with</span>
<span class="cm"> *	interrupts disabled. Due to the index-port/data-port (0x70/0x71)</span>
<span class="cm"> *	design of the RTC, we don&#39;t want two different things trying to</span>
<span class="cm"> *	get to it at once. (e.g. the periodic 11 min sync from</span>
<span class="cm"> *      kernel/time/ntp.c vs. this driver.)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/mc146818rtc.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/bcd.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#include &lt;asm/current.h&gt;</span>

<span class="cp">#ifdef CONFIG_X86</span>
<span class="cp">#include &lt;asm/hpet.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SPARC32</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rtc_port</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtc_irq</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	CONFIG_HPET_EMULATE_RTC</span>
<span class="cp">#undef	RTC_IRQ</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtc_has_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_HPET_EMULATE_RTC</span>
<span class="cp">#define is_hpet_enabled()			0</span>
<span class="cp">#define hpet_set_alarm_time(hrs, min, sec)	0</span>
<span class="cp">#define hpet_set_periodic_freq(arg)		0</span>
<span class="cp">#define hpet_mask_rtc_irq_bit(arg)		0</span>
<span class="cp">#define hpet_set_rtc_irq_bit(arg)		0</span>
<span class="cp">#define hpet_rtc_timer_init()			do { } while (0)</span>
<span class="cp">#define hpet_rtc_dropped_irq()			0</span>
<span class="cp">#define hpet_register_irq_handler(h)		({ 0; })</span>
<span class="cp">#define hpet_unregister_irq_handler(h)		({ 0; })</span>
<span class="cp">#ifdef RTC_IRQ</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">hpet_rtc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	We sponge a minor off of the misc major. No need slurping</span>
<span class="cm"> *	up another valuable major dev number for this. If you add</span>
<span class="cm"> *	an ioctl, make sure you don&#39;t conflict with SPARC&#39;s RTC</span>
<span class="cm"> *	ioctls.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">rtc_async_queue</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">rtc_wait</span><span class="p">);</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rtc_dropped_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_TIMER</span><span class="p">(</span><span class="n">rtc_irq_timer</span><span class="p">,</span> <span class="n">rtc_dropped_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">rtc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">rtc_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rtc_get_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">rtc_tm</span><span class="p">);</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rtc_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">get_rtc_alm_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">alm_tm</span><span class="p">);</span>
<span class="cp">#ifdef RTC_IRQ</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_rtc_irq_bit_locked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mask_rtc_irq_bit_locked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_rtc_irq_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">set_rtc_irq_bit_locked</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_rtc_irq_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">mask_rtc_irq_bit_locked</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rtc_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Bits in rtc_status. (6 bits of room for future expansion)</span>
<span class="cm"> */</span>

<span class="cp">#define RTC_IS_OPEN		0x01	</span><span class="cm">/* means /dev/rtc is in use	*/</span><span class="cp"></span>
<span class="cp">#define RTC_TIMER_ON		0x02	</span><span class="cm">/* missed irq timer active	*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * rtc_status is never changed by rtc_interrupt, and ioctl/open/close is</span>
<span class="cm"> * protected by the spin lock rtc_lock. However, ioctl can still disable the</span>
<span class="cm"> * timer in rtc_status and then with del_timer after the interrupt has read</span>
<span class="cm"> * rtc_status but before mod_timer is called, which would then reenable the</span>
<span class="cm"> * timer (but you would need to have an awful timing before you&#39;d trip on it)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rtc_status</span><span class="p">;</span>	<span class="cm">/* bitmapped status byte.	*/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rtc_freq</span><span class="p">;</span>		<span class="cm">/* Current periodic IRQ rate	*/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rtc_irq_data</span><span class="p">;</span>	<span class="cm">/* our output to the world	*/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rtc_max_user_freq</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span> <span class="cm">/* &gt; this, need CAP_SYS_RESOURCE */</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="cm">/*</span>
<span class="cm"> * rtc_task_lock nests inside rtc_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">rtc_task_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">rtc_task_t</span> <span class="o">*</span><span class="n">rtc_callback</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	If this driver ever becomes modularised, it will be really nice</span>
<span class="cm"> *	to make the epoch retain its value across module reload...</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">epoch</span> <span class="o">=</span> <span class="mi">1900</span><span class="p">;</span>	<span class="cm">/* year corresponding to 0x00	*/</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">days_in_mo</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Returns true if a clock update is in progress</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">rtc_is_updating</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uip</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">uip</span> <span class="o">=</span> <span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_UIP</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">uip</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="cm">/*</span>
<span class="cm"> *	A very tiny interrupt handler. It runs with IRQF_DISABLED set,</span>
<span class="cm"> *	but there is possibility of conflicting with the set_rtc_mmss()</span>
<span class="cm"> *	call (the rtc irq and the timer irq can easily run at the same</span>
<span class="cm"> *	time in two different CPUs). So we need to serialize</span>
<span class="cm"> *	accesses to the chip with the rtc_lock spinlock that each</span>
<span class="cm"> *	architecture should implement in the timer code.</span>
<span class="cm"> *	(See ./arch/XXXX/kernel/time.c for the set_rtc_mmss() function.)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">rtc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Can be an alarm interrupt, update complete interrupt,</span>
<span class="cm">	 *	or a periodic interrupt. We store the status in the</span>
<span class="cm">	 *	low byte and the number of interrupts received since</span>
<span class="cm">	 *	the last read in the remainder of rtc_irq_data.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">rtc_irq_data</span> <span class="o">+=</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="n">rtc_irq_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hpet_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In this case it is HPET RTC interrupt handler</span>
<span class="cm">		 * calling us, with the interrupt information</span>
<span class="cm">		 * passed as arg1, instead of irq.</span>
<span class="cm">		 */</span>
		<span class="n">rtc_irq_data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">irq</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rtc_irq_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_TIMER_ON</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_irq_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="n">rtc_freq</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="cm">/* Now do the rest of the actions */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_callback</span><span class="p">)</span>
		<span class="n">rtc_callback</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">rtc_callback</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_wait</span><span class="p">);</span>

	<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_async_queue</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * sysctl-tuning infrastructure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">rtc_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;max-user-freq&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">rtc_max_user_freq</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">rtc_root</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;rtc&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
		<span class="p">.</span><span class="n">child</span>		<span class="o">=</span> <span class="n">rtc_table</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">dev_root</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;dev&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
		<span class="p">.</span><span class="n">child</span>		<span class="o">=</span> <span class="n">rtc_root</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">sysctl_header</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sysctl_header</span> <span class="o">=</span> <span class="n">register_sysctl_table</span><span class="p">(</span><span class="n">dev_root</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unregister_sysctl_table</span><span class="p">(</span><span class="n">sysctl_header</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Now all the various file operations that we export.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rtc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef RTC_IRQ</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_has_irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Historically this function used to assume that sizeof(unsigned long)</span>
<span class="cm">	 * is the same in userspace and kernelspace.  This lead to problems</span>
<span class="cm">	 * for configurations with multiple ABIs such a the MIPS o32 and 64</span>
<span class="cm">	 * ABIs supported on the same kernel.  So now we support read of both</span>
<span class="cm">	 * 4 and 8 bytes and assume that&#39;s the sizeof(unsigned long) in the</span>
<span class="cm">	 * userspace ABI.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">!=</span>  <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* First make it right. Then make it fast. Putting this whole</span>
<span class="cm">		 * block within the parentheses of a while would be too</span>
<span class="cm">		 * confusing. And no, xchg() is not the answer. */</span>

		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">rtc_irq_data</span><span class="p">;</span>
		<span class="n">rtc_irq_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)</span> <span class="o">?:</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)</span> <span class="o">?:</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtc_do_ioctl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kernel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">wtime</span><span class="p">;</span>

<span class="cp">#ifdef RTC_IRQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_has_irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RTC_AIE_OFF</span>:
		<span class="k">case</span> <span class="n">RTC_AIE_ON</span>:
		<span class="k">case</span> <span class="n">RTC_PIE_OFF</span>:
		<span class="k">case</span> <span class="n">RTC_PIE_ON</span>:
		<span class="k">case</span> <span class="n">RTC_UIE_OFF</span>:
		<span class="k">case</span> <span class="n">RTC_UIE_ON</span>:
		<span class="k">case</span> <span class="n">RTC_IRQP_READ</span>:
		<span class="k">case</span> <span class="n">RTC_IRQP_SET</span>:
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef RTC_IRQ</span>
	<span class="k">case</span> <span class="n">RTC_AIE_OFF</span>:	<span class="cm">/* Mask alarm int. enab. bit	*/</span>
	<span class="p">{</span>
		<span class="n">mask_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_AIE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_AIE_ON</span>:	<span class="cm">/* Allow alarm interrupts.	*/</span>
	<span class="p">{</span>
		<span class="n">set_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_AIE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_PIE_OFF</span>:	<span class="cm">/* Mask periodic int. enab. bit	*/</span>
	<span class="p">{</span>
		<span class="cm">/* can be called from isr via rtc_control() */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">mask_rtc_irq_bit_locked</span><span class="p">(</span><span class="n">RTC_PIE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_TIMER_ON</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rtc_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_TIMER_ON</span><span class="p">;</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_irq_timer</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_PIE_ON</span>:	<span class="cm">/* Allow periodic ints		*/</span>
	<span class="p">{</span>
		<span class="cm">/* can be called from isr via rtc_control() */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t really want Joe User enabling more</span>
<span class="cm">		 * than 64Hz of interrupts on a multi-user machine.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rtc_freq</span> <span class="o">&gt;</span> <span class="n">rtc_max_user_freq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						<span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_TIMER_ON</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_irq_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="n">rtc_freq</span> <span class="o">+</span>
					<span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span>
			<span class="n">rtc_status</span> <span class="o">|=</span> <span class="n">RTC_TIMER_ON</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_rtc_irq_bit_locked</span><span class="p">(</span><span class="n">RTC_PIE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_UIE_OFF</span>:	<span class="cm">/* Mask ints from RTC updates.	*/</span>
	<span class="p">{</span>
		<span class="n">mask_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_UIE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_UIE_ON</span>:	<span class="cm">/* Allow ints for RTC updates.	*/</span>
	<span class="p">{</span>
		<span class="n">set_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_UIE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">RTC_ALM_READ</span>:	<span class="cm">/* Read the present alarm time */</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This returns a struct rtc_time. Reading &gt;= 0xc0</span>
<span class="cm">		 * means &quot;don&#39;t care&quot; or &quot;match all&quot;. Only the tm_hour,</span>
<span class="cm">		 * tm_min, and tm_sec values are filled in.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span><span class="p">));</span>
		<span class="n">get_rtc_alm_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wtime</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_ALM_SET</span>:	<span class="cm">/* Store a time into the alarm */</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This expects a struct rtc_time. Writing 0xff means</span>
<span class="cm">		 * &quot;don&#39;t care&quot; or &quot;match all&quot;. Only the tm_hour,</span>
<span class="cm">		 * tm_min and tm_sec are used.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hrs</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">alm_tm</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alm_tm</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">hrs</span> <span class="o">=</span> <span class="n">alm_tm</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">;</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">alm_tm</span><span class="p">.</span><span class="n">tm_min</span><span class="p">;</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="n">alm_tm</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpet_set_alarm_time</span><span class="p">(</span><span class="n">hrs</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Fallthru and set alarm time in CMOS too,</span>
<span class="cm">			 * so that we will get proper value in RTC_ALM_READ</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span>
							<span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span>
				<span class="n">sec</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">sec</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sec</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">min</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">min</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hrs</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span>
				<span class="n">hrs</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">hrs</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">hrs</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">hrs</span><span class="p">,</span> <span class="n">RTC_HOURS_ALARM</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">RTC_MINUTES_ALARM</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">RTC_SECONDS_ALARM</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_RD_TIME</span>:	<span class="cm">/* Read the time/date from RTC	*/</span>
	<span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span><span class="p">));</span>
		<span class="n">rtc_get_rtc_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wtime</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_SET_TIME</span>:	<span class="cm">/* Set the RTC */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">rtc_tm</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mon</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">hrs</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">,</span> <span class="n">leap_yr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">save_control</span><span class="p">,</span> <span class="n">save_freq_select</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">yrs</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MACH_DECSTATION</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">real_yrs</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_TIME</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_tm</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">yrs</span> <span class="o">=</span> <span class="n">rtc_tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span><span class="p">;</span>
		<span class="n">mon</span> <span class="o">=</span> <span class="n">rtc_tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* tm_mon starts at zero */</span>
		<span class="n">day</span> <span class="o">=</span> <span class="n">rtc_tm</span><span class="p">.</span><span class="n">tm_mday</span><span class="p">;</span>
		<span class="n">hrs</span> <span class="o">=</span> <span class="n">rtc_tm</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">;</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">rtc_tm</span><span class="p">.</span><span class="n">tm_min</span><span class="p">;</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="n">rtc_tm</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">yrs</span> <span class="o">&lt;</span> <span class="mi">1970</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">leap_yr</span> <span class="o">=</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">yrs</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">yrs</span> <span class="o">%</span> <span class="mi">100</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">yrs</span> <span class="o">%</span> <span class="mi">400</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mon</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">day</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">day</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">days_in_mo</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">mon</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">leap_yr</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">hrs</span> <span class="o">&gt;=</span> <span class="mi">24</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">min</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sec</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">yrs</span> <span class="o">-=</span> <span class="n">epoch</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">yrs</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>		<span class="cm">/* They are unsigned */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MACH_DECSTATION</span>
		<span class="n">real_yrs</span> <span class="o">=</span> <span class="n">yrs</span><span class="p">;</span>
		<span class="n">yrs</span> <span class="o">=</span> <span class="mi">72</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We want to keep the year set to 73 until March</span>
<span class="cm">		 * for non-leap years, so that Feb, 29th is handled</span>
<span class="cm">		 * correctly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leap_yr</span> <span class="o">&amp;&amp;</span> <span class="n">mon</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">real_yrs</span><span class="o">--</span><span class="p">;</span>
			<span class="n">yrs</span> <span class="o">=</span> <span class="mi">73</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="cm">/* These limits and adjustments are independent of</span>
<span class="cm">		 * whether the chip is in binary mode or not.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">yrs</span> <span class="o">&gt;</span> <span class="mi">169</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">yrs</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span>
			<span class="n">yrs</span> <span class="o">-=</span> <span class="mi">100</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sec</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">sec</span><span class="p">);</span>
			<span class="n">min</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">min</span><span class="p">);</span>
			<span class="n">hrs</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">hrs</span><span class="p">);</span>
			<span class="n">day</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">day</span><span class="p">);</span>
			<span class="n">mon</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">mon</span><span class="p">);</span>
			<span class="n">yrs</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">yrs</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">save_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">((</span><span class="n">save_control</span><span class="o">|</span><span class="n">RTC_SET</span><span class="p">),</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">save_freq_select</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">((</span><span class="n">save_freq_select</span><span class="o">|</span><span class="n">RTC_DIV_RESET2</span><span class="p">),</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MACH_DECSTATION</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">real_yrs</span><span class="p">,</span> <span class="n">RTC_DEC_YEAR</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">yrs</span><span class="p">,</span> <span class="n">RTC_YEAR</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">mon</span><span class="p">,</span> <span class="n">RTC_MONTH</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">RTC_DAY_OF_MONTH</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">hrs</span><span class="p">,</span> <span class="n">RTC_HOURS</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">RTC_MINUTES</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">RTC_SECONDS</span><span class="p">);</span>

		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">save_control</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">save_freq_select</span><span class="p">,</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef RTC_IRQ</span>
	<span class="k">case</span> <span class="n">RTC_IRQP_READ</span>:	<span class="cm">/* Read the periodic IRQ rate.	*/</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">rtc_freq</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_IRQP_SET</span>:	<span class="cm">/* Set periodic IRQ rate.	*/</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>
		<span class="cm">/* can be called from isr via rtc_control() */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The max we can do is 8192Hz.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t really want Joe User generating more</span>
<span class="cm">		 * than 64Hz of interrupts on a multi-user machine.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="n">rtc_max_user_freq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">tmp</span><span class="p">))</span>
			<span class="n">tmp</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check that the input was really a power of 2.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">tmp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">rtc_freq</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpet_set_periodic_freq</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">RTC_EPOCH_READ</span>:	<span class="cm">/* Read the epoch.	*/</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RTC_EPOCH_SET</span>:	<span class="cm">/* Set the epoch.	*/</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There were no RTC clocks before 1900.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&lt;</span> <span class="mi">1900</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_TIME</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="n">epoch</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">wtime</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">wtime</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">rtc_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rtc_do_ioctl</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	We enforce only one user at a time here with the open/close.</span>
<span class="cm"> *	Also clear the previous interrupt data on an open, and clean</span>
<span class="cm"> *	up things on a close.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_IS_OPEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_busy</span><span class="p">;</span>

	<span class="n">rtc_status</span> <span class="o">|=</span> <span class="n">RTC_IS_OPEN</span><span class="p">;</span>

	<span class="n">rtc_irq_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_busy:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtc_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtc_async_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef RTC_IRQ</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_has_irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Turn off all interrupts once the device is no longer</span>
<span class="cm">	 * in use, and clear the data.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_PIE</span> <span class="o">|</span> <span class="n">RTC_AIE</span> <span class="o">|</span> <span class="n">RTC_UIE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="n">RTC_PIE</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="n">RTC_AIE</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="n">RTC_UIE</span><span class="p">;</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_TIMER_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtc_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_TIMER_ON</span><span class="p">;</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_irq_timer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

<span class="nl">no_irq:</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">rtc_irq_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rtc_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_IS_OPEN</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">rtc_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_has_irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtc_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">rtc_irq_data</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">rtc_register</span><span class="p">(</span><span class="n">rtc_task_t</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef RTC_IRQ</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_IS_OPEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rtc_status</span> <span class="o">|=</span> <span class="n">RTC_IS_OPEN</span><span class="p">;</span>
	<span class="n">rtc_callback</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rtc_register</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">rtc_unregister</span><span class="p">(</span><span class="n">rtc_task_t</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef RTC_IRQ</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_callback</span> <span class="o">!=</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rtc_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* disable controls */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_PIE</span> <span class="o">|</span> <span class="n">RTC_AIE</span> <span class="o">|</span> <span class="n">RTC_UIE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_PIE</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_AIE</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_UIE</span><span class="p">;</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_TIMER_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtc_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_TIMER_ON</span><span class="p">;</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_irq_timer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rtc_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_IS_OPEN</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rtc_unregister</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">rtc_control</span><span class="p">(</span><span class="n">rtc_task_t</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef RTC_IRQ</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">RTC_PIE_ON</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">!=</span> <span class="n">RTC_PIE_OFF</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">!=</span> <span class="n">RTC_IRQP_SET</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_callback</span> <span class="o">!=</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_task_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rtc_do_ioctl</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rtc_control</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	The various file operations we support.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">rtc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">rtc_read</span><span class="p">,</span>
<span class="cp">#ifdef RTC_IRQ</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">rtc_poll</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">rtc_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">rtc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">rtc_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span>		<span class="o">=</span> <span class="n">rtc_fasync</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">rtc_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span>		<span class="o">=</span> <span class="n">RTC_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rtc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">rtc_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">rtc_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">rtc_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">resource_size_t</span> <span class="n">rtc_size</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">rtc_request_region</span><span class="p">(</span><span class="n">resource_size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RTC_IOMAPPED</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">request_region</span><span class="p">(</span><span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;rtc&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">request_mem_region</span><span class="p">(</span><span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;rtc&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">rtc_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtc_release_region</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RTC_IOMAPPED</span><span class="p">)</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rtc_size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rtc_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rtc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(__alpha__) || defined(__mips__)</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">guess</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SPARC32</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ebus_dp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
<span class="cp">#ifdef RTC_IRQ</span>
	<span class="n">irq_handler_t</span> <span class="n">rtc_int_handler_ptr</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SPARC32</span>
	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">ebus_dp</span><span class="p">,</span> <span class="s">&quot;ebus&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">dp</span> <span class="o">=</span> <span class="n">ebus_dp</span><span class="p">;</span> <span class="n">dp</span><span class="p">;</span> <span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;rtc&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">op</span> <span class="o">=</span> <span class="n">of_find_device_by_node</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">rtc_port</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
					<span class="n">rtc_irq</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
					<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rtc_has_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rtc_init: no PC rtc found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtc_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtc_has_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX Interrupt pin #7 in Espresso is shared between RTC and</span>
<span class="cm">	 * PCI Slot 2 INTA# (and some INTx# in Slot 1).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">,</span> <span class="n">rtc_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;rtc&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rtc_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rtc_has_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rtc: cannot register IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rtc_irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">no_irq:</span>
<span class="cp">#else</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">rtc_request_region</span><span class="p">(</span><span class="n">RTC_IO_EXTENT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;ve already requested a smaller range (for example, because</span>
<span class="cm">	 * PNPBIOS or ACPI told us how the device is configured), the request</span>
<span class="cm">	 * above might fail because it&#39;s too big.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If so, request just the range we actually use.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">rtc_request_region</span><span class="p">(</span><span class="n">RTC_IO_EXTENT_USED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef RTC_IRQ</span>
		<span class="n">rtc_has_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rtc: I/O resource %lx is not free.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef RTC_IRQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hpet_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">rtc_int_handler_ptr</span> <span class="o">=</span> <span class="n">hpet_rtc_interrupt</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">hpet_register_irq_handler</span><span class="p">(</span><span class="n">rtc_interrupt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hpet_register_irq_handler failed &quot;</span>
					<span class="s">&quot;in rtc_init().&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rtc_int_handler_ptr</span> <span class="o">=</span> <span class="n">rtc_interrupt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">RTC_IRQ</span><span class="p">,</span> <span class="n">rtc_int_handler_ptr</span><span class="p">,</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span>
			<span class="s">&quot;rtc&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Yeah right, seeing as irq 8 doesn&#39;t even hit the bus. */</span>
		<span class="n">rtc_has_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rtc: IRQ %d is not free.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">RTC_IRQ</span><span class="p">);</span>
		<span class="n">rtc_release_region</span><span class="p">();</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hpet_rtc_timer_init</span><span class="p">();</span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SPARC32 vs. others */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_dev</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef RTC_IRQ</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">RTC_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">hpet_unregister_irq_handler</span><span class="p">(</span><span class="n">rtc_interrupt</span><span class="p">);</span>
		<span class="n">rtc_has_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">rtc_release_region</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">ent</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;driver/rtc&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtc_proc_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ent</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;rtc: Failed to register with procfs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(__alpha__) || defined(__mips__)</span>
	<span class="n">rtc_freq</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/* Each operating system on an Alpha uses its own epoch.</span>
<span class="cm">	   Let&#39;s try to guess which one we are using now. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_is_updating</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">year</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_YEAR</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span>
		<span class="n">year</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">year</span><span class="p">);</span>       <span class="cm">/* This should never happen... */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
		<span class="n">guess</span> <span class="o">=</span> <span class="s">&quot;SRM (post-2000)&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">20</span> <span class="o">&amp;&amp;</span> <span class="n">year</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">1980</span><span class="p">;</span>
		<span class="n">guess</span> <span class="o">=</span> <span class="s">&quot;ARC console&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">48</span> <span class="o">&amp;&amp;</span> <span class="n">year</span> <span class="o">&lt;</span> <span class="mi">72</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">1952</span><span class="p">;</span>
		<span class="n">guess</span> <span class="o">=</span> <span class="s">&quot;Digital UNIX&quot;</span><span class="p">;</span>
<span class="cp">#if defined(__mips__)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">72</span> <span class="o">&amp;&amp;</span> <span class="n">year</span> <span class="o">&lt;</span> <span class="mi">74</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
		<span class="n">guess</span> <span class="o">=</span> <span class="s">&quot;Digital DECstation&quot;</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">1900</span><span class="p">;</span>
		<span class="n">guess</span> <span class="o">=</span> <span class="s">&quot;Standard PC (1900)&quot;</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">guess</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;rtc: %s epoch (%lu) detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">guess</span><span class="p">,</span> <span class="n">epoch</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef RTC_IRQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_has_irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_irq2</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">rtc_freq</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpet_set_periodic_freq</span><span class="p">(</span><span class="n">rtc_freq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Initialize periodic frequency to CMOS reset default,</span>
<span class="cm">		 * which is 1024Hz</span>
<span class="cm">		 */</span>
		<span class="n">CMOS_WRITE</span><span class="p">(((</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x06</span><span class="p">),</span>
			   <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
<span class="nl">no_irq2:</span>
<span class="cp">#endif</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">init_sysctl</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Real Time Clock Driver v&quot;</span> <span class="n">RTC_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">rtc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cleanup_sysctl</span><span class="p">();</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;driver/rtc&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SPARC32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_has_irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtc_port</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">rtc_release_region</span><span class="p">();</span>
<span class="cp">#ifdef RTC_IRQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_has_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">RTC_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">hpet_unregister_irq_handler</span><span class="p">(</span><span class="n">hpet_rtc_interrupt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPARC32 */</span><span class="cp"></span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">rtc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">rtc_exit</span><span class="p">);</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="cm">/*</span>
<span class="cm"> *	At IRQ rates &gt;= 4096Hz, an interrupt may get lost altogether.</span>
<span class="cm"> *	(usually during an IDE disk interrupt, with IRQ unmasking off)</span>
<span class="cm"> *	Since the interrupt handler doesn&#39;t get called, the IRQ status</span>
<span class="cm"> *	byte doesn&#39;t get read, and the RTC stops generating interrupts.</span>
<span class="cm"> *	A timer is set, and will call this function if/when that happens.</span>
<span class="cm"> *	To get it out of this stalled state, we just read the status.</span>
<span class="cm"> *	At least a jiffy of interrupts (rtc_freq/HZ) will have been lost.</span>
<span class="cm"> *	(You *really* shouldn&#39;t be trying to use a non-realtime system</span>
<span class="cm"> *	for something that requires a steady &gt; 1KHz signal anyways.)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtc_dropped_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpet_rtc_dropped_irq</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Just in case someone disabled the timer from behind our back... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_status</span> <span class="o">&amp;</span> <span class="n">RTC_TIMER_ON</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_irq_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="n">rtc_freq</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">rtc_irq_data</span> <span class="o">+=</span> <span class="p">((</span><span class="n">rtc_freq</span><span class="o">/</span><span class="n">HZ</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">rtc_irq_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xff</span><span class="p">;</span>
	<span class="n">rtc_irq_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">);</span>	<span class="cm">/* restart */</span>

	<span class="n">freq</span> <span class="o">=</span> <span class="n">rtc_freq</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;rtc: lost some interrupts at %ldHz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">freq</span><span class="p">);</span>

	<span class="cm">/* Now we have new data */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_wait</span><span class="p">);</span>

	<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_async_queue</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/*</span>
<span class="cm"> *	Info exported via &quot;/proc/driver/rtc&quot;.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtc_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define YN(bit) ((ctrl &amp; bit) ? &quot;yes&quot; : &quot;no&quot;)</span>
<span class="cp">#define NY(bit) ((ctrl &amp; bit) ? &quot;no&quot; : &quot;yes&quot;)</span>
	<span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">tm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">batt</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">batt</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_VALID</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_VRT</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">freq</span> <span class="o">=</span> <span class="n">rtc_freq</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>


	<span class="n">rtc_get_rtc_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no way to tell if the luser has the RTC set for local</span>
<span class="cm">	 * time or for Universal Standard Time (GMT). Probably local though.</span>
<span class="cm">	 */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
		   <span class="s">&quot;rtc_time</span><span class="se">\t</span><span class="s">: %02d:%02d:%02d</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;rtc_date</span><span class="se">\t</span><span class="s">: %04d-%02d-%02d</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;rtc_epoch</span><span class="se">\t</span><span class="s">: %04lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">tm</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_min</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">,</span>
		   <span class="n">tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_mday</span><span class="p">,</span> <span class="n">epoch</span><span class="p">);</span>

	<span class="n">get_rtc_alm_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We implicitly assume 24hr mode here. Alarm values &gt;= 0xc0 will</span>
<span class="cm">	 * match any value for that particular field. Values that are</span>
<span class="cm">	 * greater than a valid time, but less than 0xc0 shouldn&#39;t appear.</span>
<span class="cm">	 */</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;alarm</span><span class="se">\t\t</span><span class="s">: &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">tm_hour</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%02d:&quot;</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;**:&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">tm_min</span> <span class="o">&lt;=</span> <span class="mi">59</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%02d:&quot;</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_min</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;**:&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">tm_sec</span> <span class="o">&lt;=</span> <span class="mi">59</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;**</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
		   <span class="s">&quot;DST_enable</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BCD</span><span class="se">\t\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;24hr</span><span class="se">\t\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;square_wave</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;alarm_IRQ</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;update_IRQ</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;periodic_IRQ</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;periodic_freq</span><span class="se">\t</span><span class="s">: %ld</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;batt_status</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">YN</span><span class="p">(</span><span class="n">RTC_DST_EN</span><span class="p">),</span>
		   <span class="n">NY</span><span class="p">(</span><span class="n">RTC_DM_BINARY</span><span class="p">),</span>
		   <span class="n">YN</span><span class="p">(</span><span class="n">RTC_24H</span><span class="p">),</span>
		   <span class="n">YN</span><span class="p">(</span><span class="n">RTC_SQWE</span><span class="p">),</span>
		   <span class="n">YN</span><span class="p">(</span><span class="n">RTC_AIE</span><span class="p">),</span>
		   <span class="n">YN</span><span class="p">(</span><span class="n">RTC_UIE</span><span class="p">),</span>
		   <span class="n">YN</span><span class="p">(</span><span class="n">RTC_PIE</span><span class="p">),</span>
		   <span class="n">freq</span><span class="p">,</span>
		   <span class="n">batt</span> <span class="o">?</span> <span class="s">&quot;okay&quot;</span> <span class="o">:</span> <span class="s">&quot;dead&quot;</span><span class="p">);</span>

	<span class="k">return</span>  <span class="mi">0</span><span class="p">;</span>
<span class="cp">#undef YN</span>
<span class="cp">#undef NY</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rtc_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">rtc_proc_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtc_get_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">rtc_tm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uip_watchdog</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ctrl</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MACH_DECSTATION</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">real_year</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * read RTC once any update in progress is done. The update</span>
<span class="cm">	 * can take just over 2ms. We wait 20ms. There is no need to</span>
<span class="cm">	 * to poll-wait (up to 1s - eeccch) for the falling edge of RTC_UIP.</span>
<span class="cm">	 * If you need to know *exactly* when a second has started, enable</span>
<span class="cm">	 * periodic update complete interrupts, (via ioctl) and then</span>
<span class="cm">	 * immediately read /dev/rtc which will block until you get the IRQ.</span>
<span class="cm">	 * Once the read clears, read the RTC time (again via ioctl). Easy.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rtc_is_updating</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	       <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">uip_watchdog</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only the values that we read from the RTC are set. We leave</span>
<span class="cm">	 * tm_wday, tm_yday and tm_isdst untouched. Note that while the</span>
<span class="cm">	 * RTC has RTC_DAY_OF_WEEK, we should usually ignore it, as it is</span>
<span class="cm">	 * only updated by the RTC when initially set to a non-zero value.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_SECONDS</span><span class="p">);</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_MINUTES</span><span class="p">);</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_HOURS</span><span class="p">);</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_DAY_OF_MONTH</span><span class="p">);</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_MONTH</span><span class="p">);</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_YEAR</span><span class="p">);</span>
	<span class="cm">/* Only set from 2.6.16 onwards */</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_DAY_OF_WEEK</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MACH_DECSTATION</span>
	<span class="n">real_year</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_DEC_YEAR</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">);</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">);</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">);</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">);</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="p">);</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_year</span><span class="p">);</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_wday</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MACH_DECSTATION</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+=</span> <span class="n">real_year</span> <span class="o">-</span> <span class="mi">72</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Account for differences between how the RTC uses the values</span>
<span class="cm">	 * and how they are defined in a struct rtc_time;</span>
<span class="cm">	 */</span>
	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+=</span> <span class="n">epoch</span> <span class="o">-</span> <span class="mi">1900</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">&lt;=</span> <span class="mi">69</span><span class="p">)</span>
		<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">rtc_tm</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_rtc_alm_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">alm_tm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only the values that we read from the RTC are set. That</span>
<span class="cm">	 * means only tm_hour, tm_min, and tm_sec.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_SECONDS_ALARM</span><span class="p">);</span>
	<span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_MINUTES_ALARM</span><span class="p">);</span>
	<span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_HOURS_ALARM</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">);</span>
		<span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">);</span>
		<span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">alm_tm</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef RTC_IRQ</span>
<span class="cm">/*</span>
<span class="cm"> * Used to disable/enable interrupts for any one of UIE, AIE, PIE.</span>
<span class="cm"> * Rumour has it that if you frob the interrupt enable/disable</span>
<span class="cm"> * bits in RTC_CONTROL, you should read RTC_INTR_FLAGS, to</span>
<span class="cm"> * ensure you actually start getting interrupts. Probably for</span>
<span class="cm"> * compatibility with older/broken chipset RTC implementations.</span>
<span class="cm"> * We also clear out any old irq data after an ioctl() that</span>
<span class="cm"> * meddles with the interrupt enable/disable bits.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_rtc_irq_bit_locked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="n">bit</span><span class="p">;</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>

	<span class="n">rtc_irq_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_rtc_irq_bit_locked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpet_set_rtc_irq_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>

	<span class="n">rtc_irq_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Paul Gortmaker&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">RTC_MINOR</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
