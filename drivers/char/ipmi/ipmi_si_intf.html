<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › char › ipmi › ipmi_si_intf.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ipmi_si_intf.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ipmi_si.c</span>
<span class="cm"> *</span>
<span class="cm"> * The interface to the IPMI driver for the system interfaces (KCS, SMIC,</span>
<span class="cm"> * BT).</span>
<span class="cm"> *</span>
<span class="cm"> * Author: MontaVista Software, Inc.</span>
<span class="cm"> *         Corey Minyard &lt;minyard@mvista.com&gt;</span>
<span class="cm"> *         source@mvista.com</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2002 MontaVista Software Inc.</span>
<span class="cm"> * Copyright 2006 IBM Corp., Christian Krafft &lt;krafft@de.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the</span>
<span class="cm"> *  Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> *  option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<span class="cm"> *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="cm"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS</span>
<span class="cm"> *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm"> *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</span>
<span class="cm"> *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE</span>
<span class="cm"> *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along</span>
<span class="cm"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> *  675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file holds the &quot;policy&quot; for the interface to the SMI state</span>
<span class="cm"> * machine.  It does the configuration, handles timers and interrupts,</span>
<span class="cm"> * and drives the real SMI state machine.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/ipmi.h&gt;</span>
<span class="cp">#include &lt;linux/ipmi_smi.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &quot;ipmi_si_sm.h&quot;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/pnp.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/of_address.h&gt;</span>
<span class="cp">#include &lt;linux/of_irq.h&gt;</span>

<span class="cp">#define PFX &quot;ipmi_si: &quot;</span>

<span class="cm">/* Measure times between events in the driver. */</span>
<span class="cp">#undef DEBUG_TIMING</span>

<span class="cm">/* Call every 10 ms. */</span>
<span class="cp">#define SI_TIMEOUT_TIME_USEC	10000</span>
<span class="cp">#define SI_USEC_PER_JIFFY	(1000000/HZ)</span>
<span class="cp">#define SI_TIMEOUT_JIFFIES	(SI_TIMEOUT_TIME_USEC/SI_USEC_PER_JIFFY)</span>
<span class="cp">#define SI_SHORT_TIMEOUT_USEC  250 </span><span class="cm">/* .25ms when the SM request a</span>
<span class="cm">				      short timeout */</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">si_intf_state</span> <span class="p">{</span>
	<span class="n">SI_NORMAL</span><span class="p">,</span>
	<span class="n">SI_GETTING_FLAGS</span><span class="p">,</span>
	<span class="n">SI_GETTING_EVENTS</span><span class="p">,</span>
	<span class="n">SI_CLEARING_FLAGS</span><span class="p">,</span>
	<span class="n">SI_CLEARING_FLAGS_THEN_SET_IRQ</span><span class="p">,</span>
	<span class="n">SI_GETTING_MESSAGES</span><span class="p">,</span>
	<span class="n">SI_ENABLE_INTERRUPTS1</span><span class="p">,</span>
	<span class="n">SI_ENABLE_INTERRUPTS2</span><span class="p">,</span>
	<span class="n">SI_DISABLE_INTERRUPTS1</span><span class="p">,</span>
	<span class="n">SI_DISABLE_INTERRUPTS2</span>
	<span class="cm">/* FIXME - add watchdog stuff. */</span>
<span class="p">};</span>

<span class="cm">/* Some BT-specific defines we need here. */</span>
<span class="cp">#define IPMI_BT_INTMASK_REG		2</span>
<span class="cp">#define IPMI_BT_INTMASK_CLEAR_IRQ_BIT	2</span>
<span class="cp">#define IPMI_BT_INTMASK_ENABLE_IRQ_BIT	1</span>

<span class="k">enum</span> <span class="n">si_type</span> <span class="p">{</span>
    <span class="n">SI_KCS</span><span class="p">,</span> <span class="n">SI_SMIC</span><span class="p">,</span> <span class="n">SI_BT</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">si_to_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;kcs&quot;</span><span class="p">,</span> <span class="s">&quot;smic&quot;</span><span class="p">,</span> <span class="s">&quot;bt&quot;</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ipmi_addr_src_to_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;hotmod&quot;</span><span class="p">,</span> <span class="s">&quot;hardcoded&quot;</span><span class="p">,</span> <span class="s">&quot;SPMI&quot;</span><span class="p">,</span>
					<span class="s">&quot;ACPI&quot;</span><span class="p">,</span> <span class="s">&quot;SMBIOS&quot;</span><span class="p">,</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
					<span class="s">&quot;device-tree&quot;</span><span class="p">,</span> <span class="s">&quot;default&quot;</span> <span class="p">};</span>

<span class="cp">#define DEVICE_NAME &quot;ipmi_si&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ipmi_driver</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Indexes into stats[] in smi_info below.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">si_stat_indexes</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Number of times the driver requested a timer while an operation</span>
<span class="cm">	 * was in progress.</span>
<span class="cm">	 */</span>
	<span class="n">SI_STAT_short_timeouts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of times the driver requested a timer while nothing was in</span>
<span class="cm">	 * progress.</span>
<span class="cm">	 */</span>
	<span class="n">SI_STAT_long_timeouts</span><span class="p">,</span>

	<span class="cm">/* Number of times the interface was idle while being polled. */</span>
	<span class="n">SI_STAT_idles</span><span class="p">,</span>

	<span class="cm">/* Number of interrupts the driver handled. */</span>
	<span class="n">SI_STAT_interrupts</span><span class="p">,</span>

	<span class="cm">/* Number of time the driver got an ATTN from the hardware. */</span>
	<span class="n">SI_STAT_attentions</span><span class="p">,</span>

	<span class="cm">/* Number of times the driver requested flags from the hardware. */</span>
	<span class="n">SI_STAT_flag_fetches</span><span class="p">,</span>

	<span class="cm">/* Number of times the hardware didn&#39;t follow the state machine. */</span>
	<span class="n">SI_STAT_hosed_count</span><span class="p">,</span>

	<span class="cm">/* Number of completed messages. */</span>
	<span class="n">SI_STAT_complete_transactions</span><span class="p">,</span>

	<span class="cm">/* Number of IPMI events received from the hardware. */</span>
	<span class="n">SI_STAT_events</span><span class="p">,</span>

	<span class="cm">/* Number of watchdog pretimeouts. */</span>
	<span class="n">SI_STAT_watchdog_pretimeouts</span><span class="p">,</span>

	<span class="cm">/* Number of asyncronous messages received. */</span>
	<span class="n">SI_STAT_incoming_messages</span><span class="p">,</span>


	<span class="cm">/* This *must* remain last, add new values above this. */</span>
	<span class="n">SI_NUM_STATS</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smi_info</span> <span class="p">{</span>
	<span class="kt">int</span>                    <span class="n">intf_num</span><span class="p">;</span>
	<span class="n">ipmi_smi_t</span>             <span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">si_sm_data</span>      <span class="o">*</span><span class="n">si_sm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">si_sm_handlers</span>  <span class="o">*</span><span class="n">handlers</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">si_type</span>           <span class="n">si_type</span><span class="p">;</span>
	<span class="n">spinlock_t</span>             <span class="n">si_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>       <span class="n">xmit_msgs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>       <span class="n">hp_xmit_msgs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipmi_smi_msg</span>    <span class="o">*</span><span class="n">curr_msg</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">si_intf_state</span>     <span class="n">si_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Used to handle the various types of I/O that can occur with</span>
<span class="cm">	 * IPMI</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">si_sm_io</span> <span class="n">io</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">io_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">io_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_size</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ipmi_addr_src</span> <span class="n">addr_source</span><span class="p">;</span> <span class="cm">/* ACPI, PCI, SMBIOS, hardcode, etc. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">addr_source_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr_source_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per-OEM handler, called from handle_flags().  Returns 1</span>
<span class="cm">	 * when handle_flags() needs to be re-run or 0 indicating it</span>
<span class="cm">	 * set si_state itself.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">oem_data_avail_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flags from the last GET_MSG_FLAGS command, used when an ATTN</span>
<span class="cm">	 * is set to hold the flags until we are done handling everything</span>
<span class="cm">	 * from the flags.</span>
<span class="cm">	 */</span>
<span class="cp">#define RECEIVE_MSG_AVAIL	0x01</span>
<span class="cp">#define EVENT_MSG_BUFFER_FULL	0x02</span>
<span class="cp">#define WDT_PRE_TIMEOUT_INT	0x08</span>
<span class="cp">#define OEM0_DATA_AVAIL     0x20</span>
<span class="cp">#define OEM1_DATA_AVAIL     0x40</span>
<span class="cp">#define OEM2_DATA_AVAIL     0x80</span>
<span class="cp">#define OEM_DATA_AVAIL      (OEM0_DATA_AVAIL | \</span>
<span class="cp">			     OEM1_DATA_AVAIL | \</span>
<span class="cp">			     OEM2_DATA_AVAIL)</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>       <span class="n">msg_flags</span><span class="p">;</span>

	<span class="cm">/* Does the BMC have an event buffer? */</span>
	<span class="kt">char</span>		    <span class="n">has_event_buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If set to true, this will request events the next time the</span>
<span class="cm">	 * state machine is idle.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>            <span class="n">req_events</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If true, run the state machine to completion on every send</span>
<span class="cm">	 * call.  Generally used after a panic to make sure stuff goes</span>
<span class="cm">	 * out.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>                 <span class="n">run_to_completion</span><span class="p">;</span>

	<span class="cm">/* The I/O port of an SI interface. */</span>
	<span class="kt">int</span>                 <span class="n">port</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The space between start addresses of the two ports.  For</span>
<span class="cm">	 * instance, if the first port is 0xca2 and the spacing is 4, then</span>
<span class="cm">	 * the second port is 0xca6.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">spacing</span><span class="p">;</span>

	<span class="cm">/* zero if no irq; */</span>
	<span class="kt">int</span>                 <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* The timer for this si. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>   <span class="n">si_timer</span><span class="p">;</span>

	<span class="cm">/* The time (in jiffies) the last timeout occurred at. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">last_timeout_jiffies</span><span class="p">;</span>

	<span class="cm">/* Used to gracefully stop the timer without race conditions. */</span>
	<span class="n">atomic_t</span>            <span class="n">stop_operation</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The driver will disable interrupts when it gets into a</span>
<span class="cm">	 * situation where it cannot handle messages due to lack of</span>
<span class="cm">	 * memory.  Once that situation clears up, it will re-enable</span>
<span class="cm">	 * interrupts.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">interrupt_disabled</span><span class="p">;</span>

	<span class="cm">/* From the get device id response... */</span>
	<span class="k">struct</span> <span class="n">ipmi_device_id</span> <span class="n">device_id</span><span class="p">;</span>

	<span class="cm">/* Driver model stuff. */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if we allocated the device, false if it came from</span>
<span class="cm">	 * someplace else (like PCI).</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">dev_registered</span><span class="p">;</span>

	<span class="cm">/* Slave address, could be reported from DMI. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">slave_addr</span><span class="p">;</span>

	<span class="cm">/* Counters and things for the proc filesystem. */</span>
	<span class="n">atomic_t</span> <span class="n">stats</span><span class="p">[</span><span class="n">SI_NUM_STATS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ipmi_smi_info_union</span> <span class="n">addr_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define smi_inc_stat(smi, stat) \</span>
<span class="cp">	atomic_inc(&amp;(smi)-&gt;stats[SI_STAT_ ## stat])</span>
<span class="cp">#define smi_get_stat(smi, stat) \</span>
<span class="cp">	((unsigned int) atomic_read(&amp;(smi)-&gt;stats[SI_STAT_ ## stat]))</span>

<span class="cp">#define SI_MAX_PARMS 4</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">force_kipmid</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_force_kipmid</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci_registered</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ACPI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pnp_registered</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kipmid_max_busy_us</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_max_busy_us</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">unload_when_empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">add_smi</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">try_smi_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cleanup_one_si</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">to_clean</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cleanup_ipmi_si</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="n">ATOMIC_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">xaction_notifier_list</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_xaction_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xaction_notifier_list</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">deliver_recv_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ipmi_smi_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Deliver the message to the upper layer. */</span>
	<span class="n">ipmi_smi_msg_received</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">return_hosed_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cCode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipmi_smi_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cCode</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cCode</span> <span class="o">&gt;</span> <span class="n">IPMI_ERR_UNSPECIFIED</span><span class="p">)</span>
		<span class="n">cCode</span> <span class="o">=</span> <span class="n">IPMI_ERR_UNSPECIFIED</span><span class="p">;</span>
	<span class="cm">/* else use it as is */</span>

	<span class="cm">/* Make it a response */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cCode</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp_size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">deliver_recv_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">si_sm_result</span> <span class="nf">start_next_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>              <span class="n">rv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Pick the high priority queue first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">hp_xmit_msgs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">hp_xmit_msgs</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">xmit_msgs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">xmit_msgs</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">SI_SM_IDLE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">list_del</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ipmi_smi_msg</span><span class="p">,</span>
						<span class="n">link</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;**Start2: %d.%9.9d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">atomic_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xaction_notifier_list</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="n">smi_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">NOTIFY_STOP_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">SI_SM_CALL_WITHOUT_DELAY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">return_hosed_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">SI_SM_CALL_WITHOUT_DELAY</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_enable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are enabling interrupts, we have to tell the</span>
<span class="cm">	 * BMC to use them.</span>
<span class="cm">	 */</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_GET_BMC_GLOBAL_ENABLES_CMD</span><span class="p">;</span>

	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_ENABLE_INTERRUPTS1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_disable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_GET_BMC_GLOBAL_ENABLES_CMD</span><span class="p">;</span>

	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_DISABLE_INTERRUPTS1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_clear_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/* Make sure the watchdog pre-timeout flag is not set at startup. */</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_CLEAR_MSG_FLAGS_CMD</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">WDT_PRE_TIMEOUT_INT</span><span class="p">;</span>

	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_CLEARING_FLAGS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we have a situtaion where we run out of memory and cannot</span>
<span class="cm"> * allocate messages, we just leave them in the BMC and run the system</span>
<span class="cm"> * polled until we can allocate some memory.  Once we have some</span>
<span class="cm"> * memory, we will re-enable the interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_si_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">start_disable_irq</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">stop_operation</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_timer</span><span class="p">,</span>
				  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SI_TIMEOUT_JIFFIES</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_si_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">start_enable_irq</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
 <span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">WDT_PRE_TIMEOUT_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Watchdog pre-timeout */</span>
		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">watchdog_pretimeouts</span><span class="p">);</span>

		<span class="n">start_clear_flags</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WDT_PRE_TIMEOUT_INT</span><span class="p">;</span>
		<span class="n">ipmi_smi_watchdog_pretimeout</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">RECEIVE_MSG_AVAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Messages available. */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="n">ipmi_alloc_smi_msg</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disable_si_irq</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">enable_si_irq</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_GET_MSG_CMD</span><span class="p">;</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_GETTING_MESSAGES</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">EVENT_MSG_BUFFER_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Events available. */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="n">ipmi_alloc_smi_msg</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disable_si_irq</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">enable_si_irq</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_READ_EVENT_MSG_BUFFER_CMD</span><span class="p">;</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_GETTING_EVENTS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">OEM_DATA_AVAIL</span> <span class="o">&amp;&amp;</span>
		   <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">oem_data_avail_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">oem_data_avail_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_transaction_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipmi_smi_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;**Done: %d.%9.9d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SI_NORMAL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">rsp_size</span>
			<span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">,</span>
				<span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do this here becase deliver_recv_msg() releases the</span>
<span class="cm">		 * lock, and a new message can be put in during the</span>
<span class="cm">		 * time the lock is released.</span>
<span class="cm">		 */</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">;</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">deliver_recv_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SI_GETTING_FLAGS</span>:
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* We got the flags from the SMI, now handle them. */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Error fetching flags, just give up for now. */</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Hmm, no flags.  That&#39;s technically illegal, but</span>
<span class="cm">			 * don&#39;t use uninitialized data.</span>
<span class="cm">			 */</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">handle_flags</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SI_CLEARING_FLAGS</span>:
	<span class="k">case</span> <span class="n">SI_CLEARING_FLAGS_THEN_SET_IRQ</span>:
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		<span class="cm">/* We cleared the flags. */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Error clearing flags */</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Error clearing flags: %2.2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">==</span> <span class="n">SI_CLEARING_FLAGS_THEN_SET_IRQ</span><span class="p">)</span>
			<span class="n">start_enable_irq</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SI_GETTING_EVENTS</span>:
	<span class="p">{</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">rsp_size</span>
			<span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">,</span>
				<span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do this here becase deliver_recv_msg() releases the</span>
<span class="cm">		 * lock, and a new message can be put in during the</span>
<span class="cm">		 * time the lock is released.</span>
<span class="cm">		 */</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">;</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Error getting event, probably done. */</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

			<span class="cm">/* Take off the event flag. */</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EVENT_MSG_BUFFER_FULL</span><span class="p">;</span>
			<span class="n">handle_flags</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do this before we deliver the message</span>
<span class="cm">			 * because delivering the message releases the</span>
<span class="cm">			 * lock and something else can mess with the</span>
<span class="cm">			 * state.</span>
<span class="cm">			 */</span>
			<span class="n">handle_flags</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>

			<span class="n">deliver_recv_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SI_GETTING_MESSAGES</span>:
	<span class="p">{</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">rsp_size</span>
			<span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">,</span>
				<span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do this here becase deliver_recv_msg() releases the</span>
<span class="cm">		 * lock, and a new message can be put in during the</span>
<span class="cm">		 * time the lock is released.</span>
<span class="cm">		 */</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">;</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Error getting event, probably done. */</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

			<span class="cm">/* Take off the msg flag. */</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RECEIVE_MSG_AVAIL</span><span class="p">;</span>
			<span class="n">handle_flags</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">incoming_messages</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do this before we deliver the message</span>
<span class="cm">			 * because delivering the message releases the</span>
<span class="cm">			 * lock and something else can mess with the</span>
<span class="cm">			 * state.</span>
<span class="cm">			 */</span>
			<span class="n">handle_flags</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>

			<span class="n">deliver_recv_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SI_ENABLE_INTERRUPTS1</span>:
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="cm">/* We got the flags from the SMI, now handle them. */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not enable interrupts&quot;</span>
				 <span class="s">&quot;, failed get, using polled mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_SET_BMC_GLOBAL_ENABLES_CMD</span><span class="p">;</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span>
				  <span class="n">IPMI_BMC_RCV_MSG_INTR</span> <span class="o">|</span>
				  <span class="n">IPMI_BMC_EVT_MSG_INTR</span><span class="p">);</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_ENABLE_INTERRUPTS2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SI_ENABLE_INTERRUPTS2</span>:
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="cm">/* We got the flags from the SMI, now handle them. */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not enable interrupts&quot;</span>
				 <span class="s">&quot;, failed set, using polled mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SI_DISABLE_INTERRUPTS1</span>:
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="cm">/* We got the flags from the SMI, now handle them. */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not disable interrupts&quot;</span>
				 <span class="s">&quot;, failed get.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_SET_BMC_GLOBAL_ENABLES_CMD</span><span class="p">;</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span>
				  <span class="o">~</span><span class="p">(</span><span class="n">IPMI_BMC_RCV_MSG_INTR</span> <span class="o">|</span>
				    <span class="n">IPMI_BMC_EVT_MSG_INTR</span><span class="p">));</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_DISABLE_INTERRUPTS2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SI_DISABLE_INTERRUPTS2</span>:
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="cm">/* We got the flags from the SMI, now handle them. */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not disable interrupts&quot;</span>
				 <span class="s">&quot;, failed set.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called on timeouts and events.  Timeouts should pass the elapsed</span>
<span class="cm"> * time, interrupts should pass in zero.  Must be called with</span>
<span class="cm"> * si_lock held and interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">si_sm_result</span> <span class="nf">smi_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">si_sm_result</span> <span class="n">si_sm_result</span><span class="p">;</span>

 <span class="nl">restart:</span>
	<span class="cm">/*</span>
<span class="cm">	 * There used to be a loop here that waited a little while</span>
<span class="cm">	 * (around 25us) before giving up.  That turned out to be</span>
<span class="cm">	 * pointless, the minimum delays I was seeing were in the 300us</span>
<span class="cm">	 * range, which is far too long to wait in an interrupt.  So</span>
<span class="cm">	 * we just run until the state machine tells us something</span>
<span class="cm">	 * happened or it needs a delay.</span>
<span class="cm">	 */</span>
	<span class="n">si_sm_result</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
	<span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">si_sm_result</span> <span class="o">==</span> <span class="n">SI_SM_CALL_WITHOUT_DELAY</span><span class="p">)</span>
		<span class="n">si_sm_result</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si_sm_result</span> <span class="o">==</span> <span class="n">SI_SM_TRANSACTION_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">complete_transactions</span><span class="p">);</span>

		<span class="n">handle_transaction_done</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="n">si_sm_result</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">si_sm_result</span> <span class="o">==</span> <span class="n">SI_SM_HOSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">hosed_count</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do the before return_hosed_msg, because that</span>
<span class="cm">		 * releases the lock.</span>
<span class="cm">		 */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_NORMAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we were handling a user message, format</span>
<span class="cm">			 * a response to send to the upper layer to</span>
<span class="cm">			 * tell it about the error.</span>
<span class="cm">			 */</span>
			<span class="n">return_hosed_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">IPMI_ERR_UNSPECIFIED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">si_sm_result</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We prefer handling attn over new messages.  But don&#39;t do</span>
<span class="cm">	 * this if there is not yet an upper layer to handle anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">si_sm_result</span> <span class="o">==</span> <span class="n">SI_SM_ATTN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">attentions</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Got a attn, send down a get message flags to see</span>
<span class="cm">		 * what&#39;s causing it.  It would be better to handle</span>
<span class="cm">		 * this in the upper layer, but due to the way</span>
<span class="cm">		 * interrupts work with the SMI, that&#39;s not really</span>
<span class="cm">		 * possible.</span>
<span class="cm">		 */</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_GET_MSG_FLAGS_CMD</span><span class="p">;</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_GETTING_FLAGS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we are currently idle, try to start the next message. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">si_sm_result</span> <span class="o">==</span> <span class="n">SI_SM_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">idles</span><span class="p">);</span>

		<span class="n">si_sm_result</span> <span class="o">=</span> <span class="n">start_next_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">si_sm_result</span> <span class="o">!=</span> <span class="n">SI_SM_IDLE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">si_sm_result</span> <span class="o">==</span> <span class="n">SI_SM_IDLE</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">req_events</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are idle and the upper layer requested that I fetch</span>
<span class="cm">		 * events, so do so.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">req_events</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="n">ipmi_alloc_smi_msg</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_READ_EVENT_MSG_BUFFER_CMD</span><span class="p">;</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_GETTING_EVENTS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">si_sm_result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sender</span><span class="p">(</span><span class="kt">void</span>                <span class="o">*</span><span class="n">send_info</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ipmi_smi_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		   <span class="kt">int</span>                 <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span>   <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">send_info</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">si_sm_result</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>     <span class="n">flags</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="k">struct</span> <span class="n">timeval</span>    <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">stop_operation</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_ERR_UNSPECIFIED</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp_size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">deliver_recv_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;**Enqueue: %d.%9.9d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">run_to_completion</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are running to completion, then throw it in</span>
<span class="cm">		 * the list and run transactions until everything is</span>
<span class="cm">		 * clear.  Priority doesn&#39;t matter here.</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Run to completion means we are single-threaded, no</span>
<span class="cm">		 * need for locks.</span>
<span class="cm">		 */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">xmit_msgs</span><span class="p">));</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">SI_SM_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">SI_SHORT_TIMEOUT_USEC</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span>
						   <span class="n">SI_SHORT_TIMEOUT_USEC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">hp_xmit_msgs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">xmit_msgs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">==</span> <span class="n">SI_NORMAL</span> <span class="o">&amp;&amp;</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * last_timeout_jiffies is updated here to avoid</span>
<span class="cm">		 * smi_timeout() handler passing very large time_diff</span>
<span class="cm">		 * value to smi_event_handler() that causes</span>
<span class="cm">		 * the send command to abort.</span>
<span class="cm">		 */</span>
		<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">last_timeout_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SI_TIMEOUT_JIFFIES</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>

		<span class="n">start_next_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_run_to_completion</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">send_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i_run_to_completion</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span>   <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">send_info</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">si_sm_result</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">run_to_completion</span> <span class="o">=</span> <span class="n">i_run_to_completion</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_run_to_completion</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">SI_SM_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">SI_SHORT_TIMEOUT_USEC</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span>
						   <span class="n">SI_SHORT_TIMEOUT_USEC</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use -1 in the nsec value of the busy waiting timespec to tell that</span>
<span class="cm"> * we are spinning in kipmid looking for something and not delaying</span>
<span class="cm"> * between checks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipmi_si_set_not_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ipmi_si_is_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipmi_thread_busy_wait</span><span class="p">(</span><span class="k">enum</span> <span class="n">si_sm_result</span> <span class="n">smi_result</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">busy_until</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_busy_us</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">intf_num</span> <span class="o">&lt;</span> <span class="n">num_max_busy_us</span><span class="p">)</span>
		<span class="n">max_busy_us</span> <span class="o">=</span> <span class="n">kipmid_max_busy_us</span><span class="p">[</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">intf_num</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_busy_us</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">smi_result</span> <span class="o">!=</span> <span class="n">SI_SM_CALL_WITH_DELAY</span><span class="p">)</span>
		<span class="n">ipmi_si_set_not_busy</span><span class="p">(</span><span class="n">busy_until</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipmi_si_is_busy</span><span class="p">(</span><span class="n">busy_until</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">getnstimeofday</span><span class="p">(</span><span class="n">busy_until</span><span class="p">);</span>
		<span class="n">timespec_add_ns</span><span class="p">(</span><span class="n">busy_until</span><span class="p">,</span> <span class="n">max_busy_us</span><span class="o">*</span><span class="n">NSEC_PER_USEC</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="n">busy_until</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ipmi_si_set_not_busy</span><span class="p">(</span><span class="n">busy_until</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * A busy-waiting loop for speeding up IPMI operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Lousy hardware makes this hard.  This is only enabled for systems</span>
<span class="cm"> * that are not BT and do not have interrupts.  It starts spinning</span>
<span class="cm"> * when an operation is complete or until max_busy tells it to stop</span>
<span class="cm"> * (if that is enabled).  See the paragraph on kimid_max_busy_us in</span>
<span class="cm"> * Documentation/IPMI.txt for details.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipmi_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">si_sm_result</span> <span class="n">smi_result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">busy_until</span><span class="p">;</span>

	<span class="n">ipmi_si_set_not_busy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busy_until</span><span class="p">);</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">busy_wait</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">smi_result</span> <span class="o">=</span> <span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">busy_wait</span> <span class="o">=</span> <span class="n">ipmi_thread_busy_wait</span><span class="p">(</span><span class="n">smi_result</span><span class="p">,</span> <span class="n">smi_info</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">busy_until</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_CALL_WITHOUT_DELAY</span><span class="p">)</span>
			<span class="p">;</span> <span class="cm">/* do nothing */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_CALL_WITH_DELAY</span> <span class="o">&amp;&amp;</span> <span class="n">busy_wait</span><span class="p">)</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_IDLE</span><span class="p">)</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">poll</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">send_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">send_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">run_to_completion</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">run_to_completion</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure there is some delay in the poll loop so we can</span>
<span class="cm">	 * drive time forward and timeout things.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">run_to_completion</span><span class="p">)</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">run_to_completion</span><span class="p">)</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">request_events</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">send_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">send_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">stop_operation</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">has_event_buffer</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">req_events</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smi_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span>   <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">si_sm_result</span> <span class="n">smi_result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>     <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>     <span class="n">jiffies_now</span><span class="p">;</span>
	<span class="kt">long</span>              <span class="n">time_diff</span><span class="p">;</span>
	<span class="kt">long</span>		  <span class="n">timeout</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="k">struct</span> <span class="n">timeval</span>    <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;**Timer: %d.%9.9d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">jiffies_now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">time_diff</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span><span class="n">jiffies_now</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">last_timeout_jiffies</span><span class="p">)</span>
		     <span class="o">*</span> <span class="n">SI_USEC_PER_JIFFY</span><span class="p">);</span>
	<span class="n">smi_result</span> <span class="o">=</span> <span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">time_diff</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">last_timeout_jiffies</span> <span class="o">=</span> <span class="n">jiffies_now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Running with interrupts, only do long timeouts. */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SI_TIMEOUT_JIFFIES</span><span class="p">;</span>
		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">long_timeouts</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">do_mod_timer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the state machine asks for a short delay, then shorten</span>
<span class="cm">	 * the timer timeout.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_CALL_WITH_DELAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">short_timeouts</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">long_timeouts</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SI_TIMEOUT_JIFFIES</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">do_mod_timer:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">!=</span> <span class="n">SI_SM_IDLE</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_timer</span><span class="p">),</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">si_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">flags</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="k">struct</span> <span class="n">timeval</span>  <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">interrupts</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;**Interrupt: %d.%9.9d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">si_bt_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="cm">/* We need to clear the IRQ flag for the BT interface. */</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">,</span> <span class="n">IPMI_BT_INTMASK_REG</span><span class="p">,</span>
			     <span class="n">IPMI_BT_INTMASK_CLEAR_IRQ_BIT</span>
			     <span class="o">|</span> <span class="n">IPMI_BT_INTMASK_ENABLE_IRQ_BIT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">si_irq_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_start_processing</span><span class="p">(</span><span class="kt">void</span>       <span class="o">*</span><span class="n">send_info</span><span class="p">,</span>
				<span class="n">ipmi_smi_t</span> <span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">new_smi</span> <span class="o">=</span> <span class="n">send_info</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>

	<span class="cm">/* Try to claim any interrupts. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq_setup</span><span class="p">)</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq_setup</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>

	<span class="cm">/* Set up the timer that drives the interface. */</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_timer</span><span class="p">,</span> <span class="n">smi_timeout</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">new_smi</span><span class="p">);</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">last_timeout_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SI_TIMEOUT_JIFFIES</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the user forcefully enabled the daemon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf_num</span> <span class="o">&lt;</span> <span class="n">num_force_kipmid</span><span class="p">)</span>
		<span class="n">enable</span> <span class="o">=</span> <span class="n">force_kipmid</span><span class="p">[</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf_num</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * The BT interface is efficient enough to not need a thread,</span>
<span class="cm">	 * and there is no need for a thread if we have interrupts.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">!=</span> <span class="n">SI_BT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span>
		<span class="n">enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">ipmi_thread</span><span class="p">,</span> <span class="n">new_smi</span><span class="p">,</span>
					      <span class="s">&quot;kipmi%d&quot;</span><span class="p">,</span> <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not start&quot;</span>
				   <span class="s">&quot; kernel thread due to error %ld, only using&quot;</span>
				   <span class="s">&quot; timers to drive the interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">));</span>
			<span class="n">new_smi</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_smi_info</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">send_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipmi_smi_info</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi</span> <span class="o">=</span> <span class="n">send_info</span><span class="p">;</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">addr_src</span> <span class="o">=</span> <span class="n">smi</span><span class="o">-&gt;</span><span class="n">addr_source</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">addr_info</span> <span class="o">=</span> <span class="n">smi</span><span class="o">-&gt;</span><span class="n">addr_info</span><span class="p">;</span>
	<span class="n">get_device</span><span class="p">(</span><span class="n">smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_maintenance_mode</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">send_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span>   <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">send_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">req_events</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ipmi_smi_handlers</span> <span class="n">handlers</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>                  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_processing</span>       <span class="o">=</span> <span class="n">smi_start_processing</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_smi_info</span>		<span class="o">=</span> <span class="n">get_smi_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sender</span>			<span class="o">=</span> <span class="n">sender</span><span class="p">,</span>
	<span class="p">.</span><span class="n">request_events</span>		<span class="o">=</span> <span class="n">request_events</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_maintenance_mode</span>   <span class="o">=</span> <span class="n">set_maintenance_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_run_to_completion</span>  <span class="o">=</span> <span class="n">set_run_to_completion</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>			<span class="o">=</span> <span class="n">poll</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * There can be 4 IO ports passed in (with or without IRQs), 4 addresses,</span>
<span class="cm"> * a default IO port, and 1 ACPI/SPMI address.  That sets SI_MAX_DRIVERS.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">smi_infos</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">smi_infos_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smi_num</span><span class="p">;</span> <span class="cm">/* Used to sequence the SMIs */</span>

<span class="cp">#define DEFAULT_REGSPACING	1</span>
<span class="cp">#define DEFAULT_REGSIZE		1</span>

<span class="k">static</span> <span class="n">bool</span>          <span class="n">si_trydefaults</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span>          <span class="o">*</span><span class="n">si_type</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="cp">#define MAX_SI_TYPE_STR 30</span>
<span class="k">static</span> <span class="kt">char</span>          <span class="n">si_type_str</span><span class="p">[</span><span class="n">MAX_SI_TYPE_STR</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addrs</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_addrs</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">ports</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_ports</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>           <span class="n">irqs</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_irqs</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>           <span class="n">regspacings</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_regspacings</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>           <span class="n">regsizes</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_regsizes</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>           <span class="n">regshifts</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_regshifts</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slave_addrs</span><span class="p">[</span><span class="n">SI_MAX_PARMS</span><span class="p">];</span> <span class="cm">/* Leaving 0 chooses the default value */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_slave_addrs</span><span class="p">;</span>

<span class="cp">#define IPMI_IO_ADDR_SPACE  0</span>
<span class="cp">#define IPMI_MEM_ADDR_SPACE 1</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr_space_to_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;i/o&quot;</span><span class="p">,</span> <span class="s">&quot;mem&quot;</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hotmod_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">hotmod</span><span class="p">,</span> <span class="n">hotmod_handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0200</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hotmod</span><span class="p">,</span> <span class="s">&quot;Add and remove interfaces.  See&quot;</span>
		 <span class="s">&quot; Documentation/IPMI.txt in the kernel sources for the&quot;</span>
		 <span class="s">&quot; gory details.&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">trydefaults</span><span class="p">,</span> <span class="n">si_trydefaults</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">trydefaults</span><span class="p">,</span> <span class="s">&quot;Setting this to &#39;false&#39; will disable the&quot;</span>
		 <span class="s">&quot; default scan of the KCS and SMIC interface at the standard&quot;</span>
		 <span class="s">&quot; address&quot;</span><span class="p">);</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">si_type_str</span><span class="p">,</span> <span class="n">MAX_SI_TYPE_STR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;Defines the type of each interface, each&quot;</span>
		 <span class="s">&quot; interface separated by commas.  The types are &#39;kcs&#39;,&quot;</span>
		 <span class="s">&quot; &#39;smic&#39;, and &#39;bt&#39;.  For example si_type=kcs,bt will set&quot;</span>
		 <span class="s">&quot; the first interface to kcs and the second to bt&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">addrs</span><span class="p">,</span> <span class="n">ulong</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_addrs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">addrs</span><span class="p">,</span> <span class="s">&quot;Sets the memory address of each interface, the&quot;</span>
		 <span class="s">&quot; addresses separated by commas.  Only use if an interface&quot;</span>
		 <span class="s">&quot; is in memory.  Otherwise, set it to zero or leave&quot;</span>
		 <span class="s">&quot; it blank.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_ports</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="s">&quot;Sets the port address of each interface, the&quot;</span>
		 <span class="s">&quot; addresses separated by commas.  Only use if an interface&quot;</span>
		 <span class="s">&quot; is a port.  Otherwise, set it to zero or leave&quot;</span>
		 <span class="s">&quot; it blank.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">irqs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_irqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irqs</span><span class="p">,</span> <span class="s">&quot;Sets the interrupt of each interface, the&quot;</span>
		 <span class="s">&quot; addresses separated by commas.  Only use if an interface&quot;</span>
		 <span class="s">&quot; has an interrupt.  Otherwise, set it to zero or leave&quot;</span>
		 <span class="s">&quot; it blank.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">regspacings</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_regspacings</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">regspacings</span><span class="p">,</span> <span class="s">&quot;The number of bytes between the start address&quot;</span>
		 <span class="s">&quot; and each successive register used by the interface.  For&quot;</span>
		 <span class="s">&quot; instance, if the start address is 0xca2 and the spacing&quot;</span>
		 <span class="s">&quot; is 2, then the second address is at 0xca4.  Defaults&quot;</span>
		 <span class="s">&quot; to 1.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">regsizes</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_regsizes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">regsizes</span><span class="p">,</span> <span class="s">&quot;The size of the specific IPMI register in bytes.&quot;</span>
		 <span class="s">&quot; This should generally be 1, 2, 4, or 8 for an 8-bit,&quot;</span>
		 <span class="s">&quot; 16-bit, 32-bit, or 64-bit register.  Use this if you&quot;</span>
		 <span class="s">&quot; the 8-bit IPMI register has to be read from a larger&quot;</span>
		 <span class="s">&quot; register.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">regshifts</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_regshifts</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">regshifts</span><span class="p">,</span> <span class="s">&quot;The amount to shift the data read from the.&quot;</span>
		 <span class="s">&quot; IPMI register, in bits.  For instance, if the data&quot;</span>
		 <span class="s">&quot; is read from a 32-bit word and the IPMI data is in&quot;</span>
		 <span class="s">&quot; bit 8-15, then the shift would be 8&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">slave_addrs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_slave_addrs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">slave_addrs</span><span class="p">,</span> <span class="s">&quot;Set the default IPMB slave address for&quot;</span>
		 <span class="s">&quot; the controller.  Normally this is 0x20, but can be&quot;</span>
		 <span class="s">&quot; overridden by this parm.  This is an array indexed&quot;</span>
		 <span class="s">&quot; by interface number.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">force_kipmid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_force_kipmid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">force_kipmid</span><span class="p">,</span> <span class="s">&quot;Force the kipmi daemon to be enabled (1) or&quot;</span>
		 <span class="s">&quot; disabled(0).  Normally the IPMI driver auto-detects&quot;</span>
		 <span class="s">&quot; this, but the value may be overridden by this parm.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">unload_when_empty</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">unload_when_empty</span><span class="p">,</span> <span class="s">&quot;Unload the module if no interfaces are&quot;</span>
		 <span class="s">&quot; specified or found, default is 1.  Setting to 0&quot;</span>
		 <span class="s">&quot; is useful for hot add of devices using hotmod.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">kipmid_max_busy_us</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_max_busy_us</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">kipmid_max_busy_us</span><span class="p">,</span>
		 <span class="s">&quot;Max time (in microseconds) to busy-wait for IPMI data before&quot;</span>
		 <span class="s">&quot; sleeping. 0 (default) means to wait forever. Set to 100-500&quot;</span>
		 <span class="s">&quot; if kipmid is using up a lot of CPU time.&quot;</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">std_irq_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">==</span> <span class="n">SI_BT</span><span class="p">)</span>
		<span class="cm">/* Disable the interrupt in the BT interface. */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">,</span> <span class="n">IPMI_BT_INTMASK_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">std_irq_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">==</span> <span class="n">SI_BT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
				 <span class="n">si_bt_irq_handler</span><span class="p">,</span>
				 <span class="n">IRQF_SHARED</span> <span class="o">|</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span>
				 <span class="n">DEVICE_NAME</span><span class="p">,</span>
				 <span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
			<span class="cm">/* Enable the interrupt in the BT interface. */</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">,</span> <span class="n">IPMI_BT_INTMASK_REG</span><span class="p">,</span>
					 <span class="n">IPMI_BT_INTMASK_ENABLE_IRQ_BIT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
				 <span class="n">si_irq_handler</span><span class="p">,</span>
				 <span class="n">IRQF_SHARED</span> <span class="o">|</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span>
				 <span class="n">DEVICE_NAME</span><span class="p">,</span>
				 <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s unable to claim interrupt %d,&quot;</span>
			 <span class="s">&quot; running polled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">DEVICE_NAME</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_cleanup</span> <span class="o">=</span> <span class="n">std_irq_cleanup</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">port_inb</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">addr_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_outb</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">addr_data</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">port_inw</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">addr_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_outw</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">addr_data</span><span class="p">;</span>

	<span class="n">outw</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">port_inl</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">addr_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">inl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_outl</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">addr_data</span><span class="p">;</span>

	<span class="n">outl</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">,</span> <span class="n">addr</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">;</span>
	<span class="kt">int</span>          <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_size</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
			<span class="n">release_region</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
				       <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">port_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">;</span>
	<span class="kt">int</span>          <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_cleanup</span> <span class="o">=</span> <span class="n">port_cleanup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out the actual inb/inw/inl/etc routine to use based</span>
<span class="cm">	 * upon the register size.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">inputb</span> <span class="o">=</span> <span class="n">port_inb</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span> <span class="o">=</span> <span class="n">port_outb</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">inputb</span> <span class="o">=</span> <span class="n">port_inw</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span> <span class="o">=</span> <span class="n">port_outw</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">inputb</span> <span class="o">=</span> <span class="n">port_inl</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span> <span class="o">=</span> <span class="n">port_outl</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid register size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some BIOSes reserve disjoint I/O regions in their ACPI</span>
<span class="cm">	 * tables.  This causes problems when trying to register the</span>
<span class="cm">	 * entire I/O region.  Therefore we must register each I/O</span>
<span class="cm">	 * port separately.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_size</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_region</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
				   <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">,</span> <span class="n">DEVICE_NAME</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Undo allocations */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">idx</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">release_region</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
					       <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">intf_mem_inb</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">((</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intf_mem_outb</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">intf_mem_inw</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">readw</span><span class="p">((</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intf_mem_outw</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">,</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">intf_mem_inl</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">readl</span><span class="p">((</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intf_mem_outl</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">,</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef readq</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">mem_inq</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">readq</span><span class="p">((</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_outq</span><span class="p">(</span><span class="k">struct</span> <span class="n">si_sm_io</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">,</span> <span class="p">(</span><span class="n">io</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">io</span><span class="o">-&gt;</span><span class="n">regspacing</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">;</span>
	<span class="kt">int</span>           <span class="n">mapsize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>

		<span class="n">mapsize</span> <span class="o">=</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_size</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">)</span>
			   <span class="o">-</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">));</span>

		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">;</span>
	<span class="kt">int</span>           <span class="n">mapsize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_cleanup</span> <span class="o">=</span> <span class="n">mem_cleanup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out the actual readb/readw/readl/etc routine to use based</span>
<span class="cm">	 * upon the register size.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">inputb</span> <span class="o">=</span> <span class="n">intf_mem_inb</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span> <span class="o">=</span> <span class="n">intf_mem_outb</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">inputb</span> <span class="o">=</span> <span class="n">intf_mem_inw</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span> <span class="o">=</span> <span class="n">intf_mem_outw</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">inputb</span> <span class="o">=</span> <span class="n">intf_mem_inl</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span> <span class="o">=</span> <span class="n">intf_mem_outl</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef readq</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">inputb</span> <span class="o">=</span> <span class="n">mem_inq</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">outputb</span> <span class="o">=</span> <span class="n">mem_outq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid register size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the total amount of memory to claim.  This is an</span>
<span class="cm">	 * unusual looking calculation, but it avoids claiming any</span>
<span class="cm">	 * more memory than it has to.  It will claim everything</span>
<span class="cm">	 * between the first address to the end of the last full</span>
<span class="cm">	 * register.</span>
<span class="cm">	 */</span>
	<span class="n">mapsize</span> <span class="o">=</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_size</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">)</span>
		   <span class="o">-</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">,</span> <span class="n">DEVICE_NAME</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parms come in as &lt;op1&gt;[:op2[:op3...]].  ops are:</span>
<span class="cm"> *   add|remove,kcs|bt|smic,mem|i/o,&lt;address&gt;[,&lt;opt1&gt;[,&lt;opt2&gt;[,...]]]</span>
<span class="cm"> * Options are:</span>
<span class="cm"> *   rsp=&lt;regspacing&gt;</span>
<span class="cm"> *   rsi=&lt;regsize&gt;</span>
<span class="cm"> *   rsh=&lt;regshift&gt;</span>
<span class="cm"> *   irq=&lt;irq&gt;</span>
<span class="cm"> *   ipmb=&lt;ipmb addr&gt;</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">hotmod_op</span> <span class="p">{</span> <span class="n">HM_ADD</span><span class="p">,</span> <span class="n">HM_REMOVE</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">hotmod_vals</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hotmod_vals</span> <span class="n">hotmod_ops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;add&quot;</span><span class="p">,</span>	<span class="n">HM_ADD</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;remove&quot;</span><span class="p">,</span>	<span class="n">HM_REMOVE</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hotmod_vals</span> <span class="n">hotmod_si</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;kcs&quot;</span><span class="p">,</span>	<span class="n">SI_KCS</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;smic&quot;</span><span class="p">,</span>	<span class="n">SI_SMIC</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;bt&quot;</span><span class="p">,</span>		<span class="n">SI_BT</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hotmod_vals</span> <span class="n">hotmod_as</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;mem&quot;</span><span class="p">,</span>	<span class="n">IPMI_MEM_ADDR_SPACE</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;i/o&quot;</span><span class="p">,</span>	<span class="n">IPMI_IO_ADDR_SPACE</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_str</span><span class="p">(</span><span class="k">struct</span> <span class="n">hotmod_vals</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;No hotmod %s given.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">s</span><span class="o">++</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hotmod_ops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
			<span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Invalid hotmod %s &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_hotmod_int_op</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">option</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span>
			       <span class="s">&quot;No option given for &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">curr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">n</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">option</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span>
			       <span class="s">&quot;Bad option given for &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">curr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="nf">smi_info_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hotmod_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="n">rv</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hotmod_op</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">si_type</span> <span class="n">si_type</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">addr_space</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">regspacing</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">regsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">regshift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ipmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ival</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Kill any trailing spaces, as we can get a &quot;\n&quot; from echo. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="n">ival</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ival</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">ival</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">str</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">ival</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">curr</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span> <span class="n">curr</span><span class="p">;</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regspacing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">regsize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">regshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ipmb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Choose the default if not specified */</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">next</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">parse_str</span><span class="p">(</span><span class="n">hotmod_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ival</span><span class="p">,</span> <span class="s">&quot;operation&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">parse_str</span><span class="p">(</span><span class="n">hotmod_si</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ival</span><span class="p">,</span> <span class="s">&quot;interface type&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">si_type</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">parse_str</span><span class="p">(</span><span class="n">hotmod_as</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_space</span><span class="p">,</span> <span class="s">&quot;address space&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">s</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">n</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">curr</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Invalid hotmod address&quot;</span>
			       <span class="s">&quot; &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
				<span class="n">s</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">o</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">o</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
				<span class="n">o</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">check_hotmod_int_op</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;rsp&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regspacing</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">check_hotmod_int_op</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;rsi&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regsize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">check_hotmod_int_op</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;rsh&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regshift</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">check_hotmod_int_op</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;irq&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">check_hotmod_int_op</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;ipmb&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipmb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span>
			       <span class="s">&quot;Invalid hotmod option &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">curr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">HM_ADD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">=</span> <span class="n">SI_HOTMOD</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">si_type</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">addr_space</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr_space</span> <span class="o">==</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">mem_setup</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>

			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">regspacing</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">regsize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span> <span class="o">=</span> <span class="n">regshift</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">std_irq_setup</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">slave_addr</span> <span class="o">=</span> <span class="n">ipmb</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">try_smi_init</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
					<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* remove */</span>
			<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_e</span><span class="p">;</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">tmp_e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">!=</span> <span class="n">addr_space</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">!=</span> <span class="n">si_type</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
					<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hardcode_find_bmc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SI_MAX_PARMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">=</span> <span class="n">SI_HARDCODED</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;probing via hardcoded address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">si_type</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;kcs&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_KCS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">si_type</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;smic&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_SMIC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">si_type</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;bt&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_BT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Interface type specified &quot;</span>
			       <span class="s">&quot;for interface %d, was invalid: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="n">si_type</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* An I/O port */</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* A memory port */</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">mem_setup</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Interface type specified &quot;</span>
			       <span class="s">&quot;for interface %d, but port and address were &quot;</span>
			       <span class="s">&quot;not set or set to zero.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">regspacings</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">regsizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span> <span class="o">=</span> <span class="n">regshifts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irqs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">std_irq_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">slave_addr</span> <span class="o">=</span> <span class="n">slave_addrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">try_smi_init</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
				<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ACPI</span>

<span class="cp">#include &lt;linux/acpi.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Once we get an ACPI failure, we don&#39;t try any more, because we go</span>
<span class="cm"> * through the tables sequentially.  Once we don&#39;t find a table, there</span>
<span class="cm"> * are no more.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">acpi_failure</span><span class="p">;</span>

<span class="cm">/* For GPE-type interrupts. */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">ipmi_acpi_gpe</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">gpe_device</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">gpe_number</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">flags</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">t</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">smi_inc_stat</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">interrupts</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_TIMING</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;**ACPI_GPE: %d.%9.9d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">smi_event_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ACPI_INTERRUPT_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">acpi_gpe_irq_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">acpi_remove_gpe_handler</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipmi_acpi_gpe</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_gpe_irq_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* FIXME - is level triggered right? */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_install_gpe_handler</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
					  <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
					  <span class="n">ACPI_GPE_LEVEL_TRIGGERED</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">ipmi_acpi_gpe</span><span class="p">,</span>
					  <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">AE_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s unable to claim ACPI GPE %d,&quot;</span>
			 <span class="s">&quot; running polled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DEVICE_NAME</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_cleanup</span> <span class="o">=</span> <span class="n">acpi_gpe_irq_cleanup</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using ACPI GPE %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Defined at</span>
<span class="cm"> * http://h21007.www2.hp.com/portal/download/files/unprot/hpspmi.pdf</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">SPMITable</span> <span class="p">{</span>
	<span class="n">s8</span>	<span class="n">Signature</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span>	<span class="n">Length</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">Revision</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">Checksum</span><span class="p">;</span>
	<span class="n">s8</span>	<span class="n">OEMID</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">s8</span>	<span class="n">OEMTableID</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">s8</span>	<span class="n">OEMRevision</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">s8</span>	<span class="n">CreatorID</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">s8</span>	<span class="n">CreatorRevision</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">InterfaceType</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">IPMIlegacy</span><span class="p">;</span>
	<span class="n">s16</span>	<span class="n">SpecificationRevision</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bit 0 - SCI interrupt supported</span>
<span class="cm">	 * Bit 1 - I/O APIC/SAPIC</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>	<span class="n">InterruptType</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If bit 0 of InterruptType is set, then this is the SCI</span>
<span class="cm">	 * interrupt in the GPEx_STS register.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>	<span class="n">GPE</span><span class="p">;</span>

	<span class="n">s16</span>	<span class="n">Reserved</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If bit 1 of InterruptType is set, then this is the I/O</span>
<span class="cm">	 * APIC/SAPIC interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>	<span class="n">GlobalSystemInterrupt</span><span class="p">;</span>

	<span class="cm">/* The actual register address. */</span>
	<span class="k">struct</span> <span class="n">acpi_generic_address</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">u8</span>	<span class="n">UID</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="n">s8</span>      <span class="n">spmi_id</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* A &#39;\0&#39; terminated array starts here. */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">try_init_spmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">SPMITable</span> <span class="o">*</span><span class="n">spmi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span>  <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spmi</span><span class="o">-&gt;</span><span class="n">IPMIlegacy</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Bad SPMI legacy %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spmi</span><span class="o">-&gt;</span><span class="n">IPMIlegacy</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Could not allocate SI data (3)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">=</span> <span class="n">SI_SPMI</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;probing via SPMI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Figure out the interface type. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">spmi</span><span class="o">-&gt;</span><span class="n">InterfaceType</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* KCS */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_KCS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/* SMIC */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_SMIC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:	<span class="cm">/* BT */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_BT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Unknown ACPI/SPMI SI type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">spmi</span><span class="o">-&gt;</span><span class="n">InterfaceType</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spmi</span><span class="o">-&gt;</span><span class="n">InterruptType</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ve got a GPE interrupt. */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">spmi</span><span class="o">-&gt;</span><span class="n">GPE</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">acpi_gpe_irq_setup</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">spmi</span><span class="o">-&gt;</span><span class="n">InterruptType</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ve got an APIC/SAPIC interrupt. */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">spmi</span><span class="o">-&gt;</span><span class="n">GlobalSystemInterrupt</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">std_irq_setup</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Use the default interrupt setting. */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spmi</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">bit_width</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* A (hopefully) properly formed register bit width. */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">spmi</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">bit_width</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span> <span class="o">=</span> <span class="n">spmi</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">bit_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spmi</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">space_id</span> <span class="o">==</span> <span class="n">ACPI_ADR_SPACE_SYSTEM_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">mem_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">spmi</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">space_id</span> <span class="o">==</span> <span class="n">ACPI_ADR_SPACE_SYSTEM_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Unknown ACPI I/O Address type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">spmi</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">address</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">==</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;io&quot;</span> <span class="o">:</span> <span class="s">&quot;mem&quot;</span><span class="p">,</span>
		 <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
		 <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">spmi_find_bmc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span>      <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">SPMITable</span> <span class="o">*</span><span class="n">spmi</span><span class="p">;</span>
	<span class="kt">int</span>              <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_disabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_failure</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_get_table</span><span class="p">(</span><span class="n">ACPI_SIG_SPMI</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">spmi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">AE_OK</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">try_init_spmi</span><span class="p">(</span><span class="n">spmi</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ipmi_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_device</span> <span class="o">*</span><span class="n">acpi_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">res_second</span><span class="p">;</span>
	<span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">acpi_dev</span> <span class="o">=</span> <span class="n">pnp_acpi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">=</span> <span class="n">SI_ACPI</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;probing via ACPI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">acpi_dev</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_info</span><span class="p">.</span><span class="n">acpi_info</span><span class="p">.</span><span class="n">acpi_handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/* _IFT tells us the interface type: KCS, BT, etc */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_evaluate_integer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&quot;_IFT&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_KCS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_SMIC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_BT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown IPMI type %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">pnp_get_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">pnp_get_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">mem_setup</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no I/O or memory address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="n">res_second</span> <span class="o">=</span> <span class="n">pnp_get_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">==</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">IORESOURCE_IO</span> <span class="o">:</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span>
			       <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res_second</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res_second</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">res_second</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If _GPE exists, use it; otherwise use standard interrupts */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_evaluate_integer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&quot;_GPE&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">acpi_gpe_irq_setup</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pnp_irq_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pnp_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">std_irq_setup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pnp_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%pR regsize %d spacing %d irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">res</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
		 <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">ipmi_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pnp_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">pnp_dev_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;IPI0001&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">ipmi_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DEVICE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">ipmi_pnp_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ipmi_pnp_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">pnp_dev_table</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DMI</span>
<span class="k">struct</span> <span class="n">dmi_ipmi_data</span> <span class="p">{</span>
	<span class="n">u8</span>   		<span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span>   		<span class="n">addr_space</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u8</span>   		<span class="n">irq</span><span class="p">;</span>
	<span class="n">u8</span>              <span class="n">offset</span><span class="p">;</span>
	<span class="n">u8</span>              <span class="n">slave_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">decode_dmi</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_header</span> <span class="o">*</span><span class="n">dm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dmi_ipmi_data</span> <span class="o">*</span><span class="n">dmi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span>	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">dm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  	<span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">reg_spacing</span><span class="p">;</span>
	<span class="n">u8</span>              <span class="n">len</span> <span class="o">=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

	<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">data</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mh">0x11</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">base_addr</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* I/O */</span>
			<span class="n">base_addr</span> <span class="o">&amp;=</span> <span class="mh">0xFFFE</span><span class="p">;</span>
			<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">addr_space</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* Memory */</span>
			<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">addr_space</span> <span class="o">=</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">;</span>

		<span class="cm">/* If bit 4 of byte 0x10 is set, then the lsb for the address</span>
<span class="cm">		   is odd. */</span>
		<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">base_addr</span> <span class="o">|</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mh">0x10</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

		<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mh">0x11</span><span class="p">];</span>

		<span class="cm">/* The top two bits of byte 0x10 hold the register spacing. */</span>
		<span class="n">reg_spacing</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mh">0x10</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">reg_spacing</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x00</span>: <span class="cm">/* Byte boundaries */</span>
		    <span class="n">dmi</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* 32-bit boundaries */</span>
		    <span class="n">dmi</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x02</span>: <span class="cm">/* 16-byte boundaries */</span>
		    <span class="n">dmi</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		    <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
		    <span class="cm">/* Some other interface, just ignore it. */</span>
		    <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Old DMI spec. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note that technically, the lower bit of the base</span>
<span class="cm">		 * address should be 1 if the address is I/O and 0 if</span>
<span class="cm">		 * the address is in memory.  So many systems get that</span>
<span class="cm">		 * wrong (and all that I have seen are I/O) so we just</span>
<span class="cm">		 * ignore that bit and assume I/O.  Systems that use</span>
<span class="cm">		 * memory should use the newer spec, anyway.</span>
<span class="cm">		 */</span>
		<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">base_addr</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">;</span>
		<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">addr_space</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
		<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dmi</span><span class="o">-&gt;</span><span class="n">slave_addr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">try_init_dmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmi_ipmi_data</span> <span class="o">*</span><span class="n">ipmi_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Could not allocate SI data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">=</span> <span class="n">SI_SMBIOS</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;probing via SMBIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ipmi_data</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* KCS */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_KCS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02</span>: <span class="cm">/* SMIC */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_SMIC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x03</span>: <span class="cm">/* BT */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_BT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ipmi_data</span><span class="o">-&gt;</span><span class="n">addr_space</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPMI_MEM_ADDR_SPACE</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">mem_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPMI_IO_ADDR_SPACE</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Unknown SMBIOS I/O Address type: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ipmi_data</span><span class="o">-&gt;</span><span class="n">addr_space</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">ipmi_data</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">ipmi_data</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">slave_addr</span> <span class="o">=</span> <span class="n">ipmi_data</span><span class="o">-&gt;</span><span class="n">slave_addr</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">ipmi_data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">std_irq_setup</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">==</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;io&quot;</span> <span class="o">:</span> <span class="s">&quot;mem&quot;</span><span class="p">,</span>
		 <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
		 <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">dmi_find_bmc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmi_ipmi_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span>                  <span class="n">rv</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dmi_find_device</span><span class="p">(</span><span class="n">DMI_DEV_TYPE_IPMI</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">decode_dmi</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_header</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device_data</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
			<span class="n">try_init_dmi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DMI */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PCI</span>

<span class="cp">#define PCI_ERMC_CLASSCODE		0x0C0700</span>
<span class="cp">#define PCI_ERMC_CLASSCODE_MASK		0xffffff00</span>
<span class="cp">#define PCI_ERMC_CLASSCODE_TYPE_MASK	0xff</span>
<span class="cp">#define PCI_ERMC_CLASSCODE_TYPE_SMIC	0x00</span>
<span class="cp">#define PCI_ERMC_CLASSCODE_TYPE_KCS	0x01</span>
<span class="cp">#define PCI_ERMC_CLASSCODE_TYPE_BT	0x02</span>

<span class="cp">#define PCI_HP_VENDOR_ID    0x103C</span>
<span class="cp">#define PCI_MMC_DEVICE_ID   0x121A</span>
<span class="cp">#define PCI_MMC_ADDR_CW     0x10</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipmi_pci_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source_data</span><span class="p">;</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ipmi_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">class_type</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;</span> <span class="n">PCI_ERMC_CLASSCODE_TYPE_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">=</span> <span class="n">SI_PCI</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probing via PCI&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">class_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_ERMC_CLASSCODE_TYPE_SMIC</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_SMIC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_ERMC_CLASSCODE_TYPE_KCS</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_KCS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_ERMC_CLASSCODE_TYPE_BT</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">SI_BT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unknown IPMI type: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">class_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t enable PCI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source_cleanup</span> <span class="o">=</span> <span class="n">ipmi_pci_cleanup</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source_data</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">mem_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span> <span class="o">=</span> <span class="n">std_irq_setup</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%pR regsize %d spacing %d irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">ipmi_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipmi_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipmi_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">ipmi_pci_devices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_HP_VENDOR_ID</span><span class="p">,</span> <span class="n">PCI_MMC_DEVICE_ID</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE_CLASS</span><span class="p">(</span><span class="n">PCI_ERMC_CLASSCODE</span><span class="p">,</span> <span class="n">PCI_ERMC_CLASSCODE_MASK</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">ipmi_pci_devices</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">ipmi_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>         <span class="n">DEVICE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>     <span class="n">ipmi_pci_devices</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>        <span class="n">ipmi_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span>       <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ipmi_pci_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>      <span class="n">ipmi_pci_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>       <span class="n">ipmi_pci_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ipmi_match</span><span class="p">[];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ipmi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_OF</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">resource</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">regsize</span><span class="p">,</span> <span class="o">*</span><span class="n">regspacing</span><span class="p">,</span> <span class="o">*</span><span class="n">regshift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">proplen</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probing via device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">match</span> <span class="o">=</span> <span class="n">of_match_device</span><span class="p">(</span><span class="n">ipmi_match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resource</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PFX</span> <span class="s">&quot;invalid address from OF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">regsize</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;reg-size&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proplen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regsize</span> <span class="o">&amp;&amp;</span> <span class="n">proplen</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PFX</span> <span class="s">&quot;invalid regsize from OF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">regspacing</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;reg-spacing&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proplen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regspacing</span> <span class="o">&amp;&amp;</span> <span class="n">proplen</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PFX</span> <span class="s">&quot;invalid regspacing from OF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">regshift</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;reg-shift&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proplen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regshift</span> <span class="o">&amp;&amp;</span> <span class="n">proplen</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PFX</span> <span class="s">&quot;invalid regshift from OF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;could not allocate memory for OF probe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span>		<span class="o">=</span> <span class="p">(</span><span class="k">enum</span> <span class="n">si_type</span><span class="p">)</span> <span class="n">match</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span>	<span class="o">=</span> <span class="n">SI_DEVICETREE</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_setup</span>		<span class="o">=</span> <span class="n">std_irq_setup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resource</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span>		<span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span>	<span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span>		<span class="o">=</span> <span class="n">mem_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span>	<span class="o">=</span> <span class="n">IPMI_MEM_ADDR_SPACE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span>	<span class="o">=</span> <span class="n">resource</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span>	<span class="o">=</span> <span class="n">regsize</span> <span class="o">?</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">regsize</span><span class="p">)</span> <span class="o">:</span> <span class="n">DEFAULT_REGSIZE</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span>	<span class="o">=</span> <span class="n">regspacing</span> <span class="o">?</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">regspacing</span><span class="p">)</span> <span class="o">:</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span>	<span class="o">=</span> <span class="n">regshift</span> <span class="o">?</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">regshift</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span>		<span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;addr 0x%lx regsize %d spacing %d irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">ipmi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_OF</span>
	<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ipmi_match</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;ipmi&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;ipmi-kcs&quot;</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">SI_KCS</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;ipmi&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;ipmi-smic&quot;</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">SI_SMIC</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;ipmi&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;ipmi-bt&quot;</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">SI_BT</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ipmi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DEVICE_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">ipmi_match</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">ipmi_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ipmi_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_for_msg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">si_sm_result</span>     <span class="n">smi_result</span><span class="p">;</span>

	<span class="n">smi_result</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_CALL_WITH_DELAY</span> <span class="o">||</span>
		    <span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_CALL_WITH_TICK_DELAY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">smi_result</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">(</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_CALL_WITHOUT_DELAY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smi_result</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">(</span>
				<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smi_result</span> <span class="o">==</span> <span class="n">SI_SM_HOSED</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * We couldn&#39;t get the state machine to run, so whatever&#39;s at</span>
<span class="cm">		 * the port is probably not an IPMI SMI interface.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_get_dev_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="o">*</span><span class="n">resp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>         <span class="n">resp_len</span><span class="p">;</span>
	<span class="kt">int</span>                   <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">resp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do a Get Device ID command, since it comes back with some</span>
<span class="cm">	 * useful info.</span>
<span class="cm">	 */</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_GET_DEVICE_ID_CMD</span><span class="p">;</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">wait_for_msg_done</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">resp_len</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
						  <span class="n">resp</span><span class="p">,</span> <span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">);</span>

	<span class="cm">/* Check and record info from the get device id, in case we need it. */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">ipmi_demangle_device_id</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="n">resp_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">resp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_enable_event_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="o">*</span><span class="n">resp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>         <span class="n">resp_len</span><span class="p">;</span>
	<span class="kt">int</span>                   <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">resp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_GET_BMC_GLOBAL_ENABLES_CMD</span><span class="p">;</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">wait_for_msg_done</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Error getting response from get&quot;</span>
		       <span class="s">&quot; global enables command, the event buffer is not&quot;</span>
		       <span class="s">&quot; enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">resp_len</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
						  <span class="n">resp</span><span class="p">,</span> <span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resp_len</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">||</span>
			<span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">|</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">||</span>
			<span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IPMI_GET_BMC_GLOBAL_ENABLES_CMD</span>   <span class="o">||</span>
			<span class="n">resp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Invalid return from get global&quot;</span>
		       <span class="s">&quot; enables command, cannot enable the event buffer.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">IPMI_BMC_EVT_MSG_BUFF</span><span class="p">)</span>
		<span class="cm">/* buffer is already enabled, nothing to do. */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPMI_SET_BMC_GLOBAL_ENABLES_CMD</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">IPMI_BMC_EVT_MSG_BUFF</span><span class="p">;</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">start_transaction</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">wait_for_msg_done</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Error getting response from set&quot;</span>
		       <span class="s">&quot; global, enables command, the event buffer is not&quot;</span>
		       <span class="s">&quot; enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">resp_len</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">get_result</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
						  <span class="n">resp</span><span class="p">,</span> <span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resp_len</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span>
			<span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">IPMI_NETFN_APP_REQUEST</span> <span class="o">|</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">||</span>
			<span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IPMI_SET_BMC_GLOBAL_ENABLES_CMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span> <span class="s">&quot;Invalid return from get global,&quot;</span>
		       <span class="s">&quot;enables command, not enable the event buffer.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * An error when setting the event buffer bit means</span>
<span class="cm">		 * that the event buffer is not supported.</span>
<span class="cm">		 */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">resp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_type_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">si_to_str</span><span class="p">[</span><span class="n">smi</span><span class="o">-&gt;</span><span class="n">si_type</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_type_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">smi_type_proc_show</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smi_type_proc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">smi_type_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_si_stats_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;interrupts_enabled:    %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">smi</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;short_timeouts:        %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">short_timeouts</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;long_timeouts:         %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">long_timeouts</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;idles:                 %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">idles</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;interrupts:            %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">interrupts</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;attentions:            %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">attentions</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;flag_fetches:          %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">flag_fetches</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;hosed_count:           %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">hosed_count</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;complete_transactions: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">complete_transactions</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;events:                %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">events</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;watchdog_pretimeouts:  %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">watchdog_pretimeouts</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;incoming_messages:     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smi_get_stat</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">incoming_messages</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_si_stats_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">smi_si_stats_proc_show</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smi_si_stats_proc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">smi_si_stats_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_params_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		       <span class="s">&quot;%s,%s,0x%lx,rsp=%d,rsi=%d,rsh=%d,irq=%d,ipmb=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">si_to_str</span><span class="p">[</span><span class="n">smi</span><span class="o">-&gt;</span><span class="n">si_type</span><span class="p">],</span>
		       <span class="n">addr_space_to_str</span><span class="p">[</span><span class="n">smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span><span class="p">],</span>
		       <span class="n">smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">,</span>
		       <span class="n">smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span><span class="p">,</span>
		       <span class="n">smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span><span class="p">,</span>
		       <span class="n">smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span><span class="p">,</span>
		       <span class="n">smi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
		       <span class="n">smi</span><span class="o">-&gt;</span><span class="n">slave_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smi_params_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">smi_params_proc_show</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smi_params_proc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">smi_params_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * oem_data_avail_to_receive_msg_avail</span>
<span class="cm"> * @info - smi_info structure with msg_flags set</span>
<span class="cm"> *</span>
<span class="cm"> * Converts flags from OEM_DATA_AVAIL to RECEIVE_MSG_AVAIL</span>
<span class="cm"> * Returns 1 indicating need to re-run handle_flags().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">oem_data_avail_to_receive_msg_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="p">((</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">OEM_DATA_AVAIL</span><span class="p">)</span> <span class="o">|</span>
			       <span class="n">RECEIVE_MSG_AVAIL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setup_dell_poweredge_oem_data_handler</span>
<span class="cm"> * @info - smi_info.device_id must be populated</span>
<span class="cm"> *</span>
<span class="cm"> * Systems that match, but have firmware version &lt; 1.40 may assert</span>
<span class="cm"> * OEM0_DATA_AVAIL on their own, without being told via Set Flags that</span>
<span class="cm"> * it&#39;s safe to do so.  Such systems will de-assert OEM1_DATA_AVAIL</span>
<span class="cm"> * upon receipt of IPMI_GET_MSG_CMD, so we should treat these flags</span>
<span class="cm"> * as RECEIVE_MSG_AVAIL instead.</span>
<span class="cm"> *</span>
<span class="cm"> * As Dell has no plans to release IPMI 1.5 firmware that *ever*</span>
<span class="cm"> * assert the OEM[012] bits, and if it did, the driver would have to</span>
<span class="cm"> * change to handle that properly, we don&#39;t actually check for the</span>
<span class="cm"> * firmware version.</span>
<span class="cm"> * Device ID = 0x20                BMC on PowerEdge 8G servers</span>
<span class="cm"> * Device Revision = 0x80</span>
<span class="cm"> * Firmware Revision1 = 0x01       BMC version 1.40</span>
<span class="cm"> * Firmware Revision2 = 0x40       BCD encoded</span>
<span class="cm"> * IPMI Version = 0x51             IPMI 1.5</span>
<span class="cm"> * Manufacturer ID = A2 02 00      Dell IANA</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally, PowerEdge systems with IPMI &lt; 1.5 may also assert</span>
<span class="cm"> * OEM0_DATA_AVAIL and needs to be treated as RECEIVE_MSG_AVAIL.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define DELL_POWEREDGE_8G_BMC_DEVICE_ID  0x20</span>
<span class="cp">#define DELL_POWEREDGE_8G_BMC_DEVICE_REV 0x80</span>
<span class="cp">#define DELL_POWEREDGE_8G_BMC_IPMI_VERSION 0x51</span>
<span class="cp">#define DELL_IANA_MFR_ID 0x0002a2</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_dell_poweredge_oem_data_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipmi_device_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">manufacturer_id</span> <span class="o">==</span> <span class="n">DELL_IANA_MFR_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">device_id</span>       <span class="o">==</span> <span class="n">DELL_POWEREDGE_8G_BMC_DEVICE_ID</span>  <span class="o">&amp;&amp;</span>
		    <span class="n">id</span><span class="o">-&gt;</span><span class="n">device_revision</span> <span class="o">==</span> <span class="n">DELL_POWEREDGE_8G_BMC_DEVICE_REV</span> <span class="o">&amp;&amp;</span>
		    <span class="n">id</span><span class="o">-&gt;</span><span class="n">ipmi_version</span>   <span class="o">==</span> <span class="n">DELL_POWEREDGE_8G_BMC_IPMI_VERSION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">oem_data_avail_handler</span> <span class="o">=</span>
				<span class="n">oem_data_avail_to_receive_msg_avail</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ipmi_version_major</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span>
			   <span class="p">(</span><span class="n">ipmi_version_major</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ipmi_version_minor</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">oem_data_avail_handler</span> <span class="o">=</span>
				<span class="n">oem_data_avail_to_receive_msg_avail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define CANNOT_RETURN_REQUESTED_LENGTH 0xCA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">return_hosed_msg_badsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipmi_smi_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="p">;</span>

	<span class="cm">/* Make it a response */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">CANNOT_RETURN_REQUESTED_LENGTH</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">rsp_size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">deliver_recv_msg</span><span class="p">(</span><span class="n">smi_info</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dell_poweredge_bt_xaction_handler</span>
<span class="cm"> * @info - smi_info.device_id must be populated</span>
<span class="cm"> *</span>
<span class="cm"> * Dell PowerEdge servers with the BT interface (x6xx and 1750) will</span>
<span class="cm"> * not respond to a Get SDR command if the length of the data</span>
<span class="cm"> * requested is exactly 0x3A, which leads to command timeouts and no</span>
<span class="cm"> * data returned.  This intercepts such commands, and causes userspace</span>
<span class="cm"> * callers to try again with a different-sized buffer, which succeeds.</span>
<span class="cm"> */</span>

<span class="cp">#define STORAGE_NETFN 0x0A</span>
<span class="cp">#define STORAGE_CMD_GET_SDR 0x23</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dell_poweredge_bt_xaction_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unused</span><span class="p">,</span>
					     <span class="kt">void</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span>   <span class="o">=</span> <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">curr_msg</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">STORAGE_NETFN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">STORAGE_CMD_GET_SDR</span> <span class="o">&amp;&amp;</span>
	    <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x3A</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_hosed_msg_badsize</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NOTIFY_STOP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">dell_poweredge_bt_xaction_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">dell_poweredge_bt_xaction_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * setup_dell_poweredge_bt_xaction_handler</span>
<span class="cm"> * @info - smi_info.device_id must be filled in already</span>
<span class="cm"> *</span>
<span class="cm"> * Fills in smi_info.device_id.start_transaction_pre_hook</span>
<span class="cm"> * when we know what function to use there.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">setup_dell_poweredge_bt_xaction_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipmi_device_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">manufacturer_id</span> <span class="o">==</span> <span class="n">DELL_IANA_MFR_ID</span> <span class="o">&amp;&amp;</span>
	    <span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">==</span> <span class="n">SI_BT</span><span class="p">)</span>
		<span class="n">register_xaction_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dell_poweredge_bt_xaction_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setup_oem_data_handler</span>
<span class="cm"> * @info - smi_info.device_id must be filled in already</span>
<span class="cm"> *</span>
<span class="cm"> * Fills in smi_info.device_id.oem_data_available_handler</span>
<span class="cm"> * when we know what function to use there.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_oem_data_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_dell_poweredge_oem_data_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_xaction_handlers</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_dell_poweredge_bt_xaction_handler</span><span class="p">(</span><span class="n">smi_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_for_timer_and_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">smi_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The timer and thread are only running if the</span>
<span class="cm">		 * interface has been started up and registered.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">kthread_stop</span><span class="p">(</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_info</span><span class="o">-&gt;</span><span class="n">si_timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devinitdata</span> <span class="k">struct</span> <span class="n">ipmi_default_vals</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ipmi_defaults</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SI_KCS</span><span class="p">,</span> <span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0xca2</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SI_SMIC</span><span class="p">,</span> <span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0xca9</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SI_BT</span><span class="p">,</span> <span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mh">0xe4</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">default_find_bmc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipmi_defaults</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_legacy_ioport</span><span class="p">(</span><span class="n">ipmi_defaults</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">smi_info_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">=</span> <span class="n">SI_DEFAULT</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span> <span class="o">=</span> <span class="n">ipmi_defaults</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_setup</span> <span class="o">=</span> <span class="n">port_setup</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">=</span> <span class="n">ipmi_defaults</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IPMI_IO_ADDR_SPACE</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regspacing</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regsize</span> <span class="o">=</span> <span class="n">DEFAULT_REGSPACING</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">regshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">add_smi</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">try_smi_init</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Found one... */</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Found default %s&quot;</span>
				<span class="s">&quot; state machine at %s address 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">si_to_str</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_type</span><span class="p">],</span>
				<span class="n">addr_space_to_str</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span><span class="p">],</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_new_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_smi</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">new_smi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Adding %s-specified %s state machine&quot;</span><span class="p">,</span>
			<span class="n">ipmi_addr_src_to_str</span><span class="p">[</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">addr_source</span><span class="p">],</span>
			<span class="n">si_to_str</span><span class="p">[</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_type</span><span class="p">]);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_new_interface</span><span class="p">(</span><span class="n">new_smi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; duplicate interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* So we know not to free it unless we have allocated one. */</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">);</span>

<span class="nl">out_err:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_smi_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">new_smi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Trying %s-specified %s state&quot;</span>
	       <span class="s">&quot; machine at %s address 0x%lx, slave address 0x%x,&quot;</span>
	       <span class="s">&quot; irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ipmi_addr_src_to_str</span><span class="p">[</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">addr_source</span><span class="p">],</span>
	       <span class="n">si_to_str</span><span class="p">[</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_type</span><span class="p">],</span>
	       <span class="n">addr_space_to_str</span><span class="p">[</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_type</span><span class="p">],</span>
	       <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">addr_data</span><span class="p">,</span>
	       <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">slave_addr</span><span class="p">,</span> <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SI_KCS</span>:
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kcs_smi_handlers</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SI_SMIC</span>:
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smic_smi_handlers</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SI_BT</span>:
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bt_smi_handlers</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* No support for anything else yet. */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate the state machine&#39;s data and initialize it. */</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span>
		       <span class="s">&quot;Could not allocate state machine memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io_size</span> <span class="o">=</span> <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">init_data</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">);</span>

	<span class="cm">/* Now that we know the I/O size, we can set up the I/O. */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io_setup</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Could not set up I/O space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do low-level detection first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">detect</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">addr_source</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;Interface detection failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attempt a get device id command.  If it fails, we probably</span>
<span class="cm">	 * don&#39;t have a BMC here.</span>
<span class="cm">	 */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">try_get_dev_id</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">addr_source</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;There appears to be no BMC&quot;</span>
			       <span class="s">&quot; at this location</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setup_oem_data_handler</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
	<span class="n">setup_xaction_handlers</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">xmit_msgs</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">hp_xmit_msgs</span><span class="p">));</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">req_events</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">run_to_completion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SI_NUM_STATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">stop_operation</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf_num</span> <span class="o">=</span> <span class="n">smi_num</span><span class="p">;</span>
	<span class="n">smi_num</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">try_enable_event_buffer</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">has_event_buffer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start clearing the flags before we enable interrupts or the</span>
<span class="cm">	 * timer to avoid racing with the timer.</span>
<span class="cm">	 */</span>
	<span class="n">start_clear_flags</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
	<span class="cm">/* IRQ is defined to be set when non-zero. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">=</span> <span class="n">SI_CLEARING_FLAGS_THEN_SET_IRQ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we don&#39;t already have a device from something</span>
<span class="cm">		 * else (like PCI), then register a new one.</span>
<span class="cm">		 */</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">platform_device_alloc</span><span class="p">(</span><span class="s">&quot;ipmi_si&quot;</span><span class="p">,</span>
						      <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span>
			       <span class="s">&quot;Unable to allocate platform device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ipmi_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">platform_device_add</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span>
			       <span class="s">&quot;Unable to register system interface device:&quot;</span>
			       <span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rv</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">ipmi_register_smi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handlers</span><span class="p">,</span>
			       <span class="n">new_smi</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">,</span>
			       <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			       <span class="s">&quot;bmc&quot;</span><span class="p">,</span>
			       <span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">slave_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to register device: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rv</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err_stop_timer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">ipmi_smi_add_proc_entry</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">,</span> <span class="s">&quot;type&quot;</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">smi_type_proc_ops</span><span class="p">,</span>
				     <span class="n">new_smi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to create proc entry: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err_stop_timer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">ipmi_smi_add_proc_entry</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">,</span> <span class="s">&quot;si_stats&quot;</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">smi_si_stats_proc_ops</span><span class="p">,</span>
				     <span class="n">new_smi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to create proc entry: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err_stop_timer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">ipmi_smi_add_proc_entry</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">,</span> <span class="s">&quot;params&quot;</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">smi_params_proc_ops</span><span class="p">,</span>
				     <span class="n">new_smi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to create proc entry: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err_stop_timer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IPMI %s interface initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">si_to_str</span><span class="p">[</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_type</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_err_stop_timer:</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">stop_operation</span><span class="p">);</span>
	<span class="n">wait_for_timer_and_thread</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>

 <span class="nl">out_err:</span>
	<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">interrupt_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipmi_unregister_smi</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">intf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq_cleanup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq_cleanup</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">irq_cleanup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait until we know that we are out of any interrupt</span>
<span class="cm">	 * handlers might have been running before we freed the</span>
<span class="cm">	 * interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">)</span>
			<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">);</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">si_sm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">addr_source_cleanup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">addr_source_cleanup</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">addr_source_cleanup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io_cleanup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io_cleanup</span><span class="p">(</span><span class="n">new_smi</span><span class="p">);</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">io_cleanup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev_registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">new_smi</span><span class="o">-&gt;</span><span class="n">dev_registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">init_ipmi_si</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">rv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ipmi_addr_src</span> <span class="n">type</span> <span class="o">=</span> <span class="n">SI_INVALID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipmi_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Unable to register driver: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Parse out the si_type string into its components. */</span>
	<span class="n">str</span> <span class="o">=</span> <span class="n">si_type_str</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">SI_MAX_PARMS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">si_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
			<span class="n">str</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
				<span class="n">str</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;IPMI System Interface driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* If the user gave us a device, they presumably want us to use it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hardcode_find_bmc</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipmi_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Unable to register PCI driver: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pci_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipmi_pnp_driver</span><span class="p">);</span>
	<span class="n">pnp_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DMI</span>
	<span class="n">dmi_find_bmc</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="n">spmi_find_bmc</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* We prefer devices with interrupts, but in the case of a machine</span>
<span class="cm">	   with multiple BMCs we assume that there will be several instances</span>
<span class="cm">	   of a given type so if we succeed in registering a type then also</span>
<span class="cm">	   try to register everything else of the same type */</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Try to register a device if it has an IRQ and we either</span>
<span class="cm">		   haven&#39;t successfully registered a device yet or this</span>
<span class="cm">		   device has the same type as one we successfully registered */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span> <span class="o">||</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">==</span> <span class="n">type</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_smi_init</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_source</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* type will only have been set if we successfully registered an si */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fall back to the preferred device */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span> <span class="o">||</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_source</span> <span class="o">==</span> <span class="n">type</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_smi_init</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">addr_source</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si_trydefaults</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* No BMC was found, try defaults. */</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
			<span class="n">default_find_bmc</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unload_when_empty</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
		<span class="n">cleanup_ipmi_si</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PFX</span>
		       <span class="s">&quot;Unable to find any System Interface(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">init_ipmi_si</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_one_si</span><span class="p">(</span><span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">to_clean</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>           <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to_clean</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="cm">/* Tell the driver that we are shutting down. */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">stop_operation</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the timer and thread are stopped and will not run</span>
<span class="cm">	 * again.</span>
<span class="cm">	 */</span>
	<span class="n">wait_for_timer_and_thread</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Timeouts are stopped, now make sure the interrupts are off</span>
<span class="cm">	 * for the device.  A little tricky with locks to make sure</span>
<span class="cm">	 * there are no races.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">||</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">!=</span> <span class="n">SI_NORMAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">poll</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">disable_si_irq</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">||</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">!=</span> <span class="n">SI_NORMAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">poll</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up interrupts and make sure that everything is done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">irq_cleanup</span><span class="p">)</span>
		<span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">irq_cleanup</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">curr_msg</span> <span class="o">||</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_state</span> <span class="o">!=</span> <span class="n">SI_NORMAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">poll</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">)</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">ipmi_unregister_smi</span><span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;Unable to unregister device: errno=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">rv</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">)</span>
		<span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">si_sm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">addr_source_cleanup</span><span class="p">)</span>
		<span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">addr_source_cleanup</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">io_cleanup</span><span class="p">)</span>
		<span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">io_cleanup</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">dev_registered</span><span class="p">)</span>
		<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">to_clean</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">to_clean</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_ipmi_si</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smi_info</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_registered</span><span class="p">)</span>
		<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipmi_pci_driver</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_registered</span><span class="p">)</span>
		<span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipmi_pnp_driver</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipmi_driver</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">tmp_e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smi_infos</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="n">cleanup_one_si</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smi_infos_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_ipmi_si</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Corey Minyard &lt;minyard@mvista.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Interface to the IPMI driver for the KCS, SMIC, and BT&quot;</span>
		   <span class="s">&quot; system interfaces.&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
