<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › dma › fsldma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fsldma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale MPC85xx, MPC83xx DMA Engine support</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Author:</span>
<span class="cm"> *   Zhang Wei &lt;wei.zhang@freescale.com&gt;, Jul 2007</span>
<span class="cm"> *   Ebony Zhu &lt;ebony.zhu@freescale.com&gt;, May 2007</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   DMA engine driver for Freescale MPC8540 DMA controller, which is</span>
<span class="cm"> *   also fit for MPC8560, MPC8555, MPC8548, MPC8641, and etc.</span>
<span class="cm"> *   The support for MPC8349 DMA controller is also added.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver instructs the DMA controller to issue the PCI Read Multiple</span>
<span class="cm"> * command for PCI read operations, instead of using the default PCI Read Line</span>
<span class="cm"> * command. Please be aware that this setting may result in read pre-fetching</span>
<span class="cm"> * on some platforms.</span>
<span class="cm"> *</span>
<span class="cm"> * This is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>

<span class="cp">#include &quot;dmaengine.h&quot;</span>
<span class="cp">#include &quot;fsldma.h&quot;</span>

<span class="cp">#define chan_dbg(chan, fmt, arg...)					\</span>
<span class="cp">	dev_dbg(chan-&gt;dev, &quot;%s: &quot; fmt, chan-&gt;name, ##arg)</span>
<span class="cp">#define chan_err(chan, fmt, arg...)					\</span>
<span class="cp">	dev_err(chan-&gt;dev, &quot;%s: &quot; fmt, chan-&gt;name, ##arg)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">msg_ld_oom</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;No free memory for link descriptor&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Register Helpers</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_sr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">sr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_sr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">sr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_cdar</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cdar</span><span class="p">,</span> <span class="n">addr</span> <span class="o">|</span> <span class="n">FSL_DMA_SNEN</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">get_cdar</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cdar</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FSL_DMA_SNEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_bcr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">bcr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Descriptor Helpers</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_desc_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fsl_dma_ld_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">CPU_TO_DMA</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_desc_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DMA_TO_CPU</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_desc_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fsl_dma_ld_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">snoop_bits</span><span class="p">;</span>

	<span class="n">snoop_bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_85XX</span><span class="p">)</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">FSL_DMA_SATR_SREADTYPE_SNOOP_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">src_addr</span> <span class="o">=</span> <span class="n">CPU_TO_DMA</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">snoop_bits</span> <span class="o">|</span> <span class="n">src</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">get_desc_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">snoop_bits</span><span class="p">;</span>

	<span class="n">snoop_bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_85XX</span><span class="p">)</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">FSL_DMA_SATR_SREADTYPE_SNOOP_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">DMA_TO_CPU</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">src_addr</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">snoop_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_desc_dst</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fsl_dma_ld_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">snoop_bits</span><span class="p">;</span>

	<span class="n">snoop_bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_85XX</span><span class="p">)</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">FSL_DMA_DATR_DWRITETYPE_SNOOP_WRITE</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dst_addr</span> <span class="o">=</span> <span class="n">CPU_TO_DMA</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">snoop_bits</span> <span class="o">|</span> <span class="n">dst</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">get_desc_dst</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">snoop_bits</span><span class="p">;</span>

	<span class="n">snoop_bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_85XX</span><span class="p">)</span>
		<span class="o">?</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">FSL_DMA_DATR_DWRITETYPE_SNOOP_WRITE</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">DMA_TO_CPU</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">dst_addr</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">snoop_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_desc_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">fsl_dma_ld_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">snoop_bits</span><span class="p">;</span>

	<span class="n">snoop_bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_83XX</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">FSL_DMA_SNEN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">next_ln_addr</span> <span class="o">=</span> <span class="n">CPU_TO_DMA</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">snoop_bits</span> <span class="o">|</span> <span class="n">next</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ld_eol</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">snoop_bits</span><span class="p">;</span>

	<span class="n">snoop_bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_83XX</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">FSL_DMA_SNEN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">next_ln_addr</span> <span class="o">=</span> <span class="n">CPU_TO_DMA</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span>
		<span class="n">DMA_TO_CPU</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">next_ln_addr</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">|</span> <span class="n">FSL_DMA_EOL</span>
			<span class="o">|</span> <span class="n">snoop_bits</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * DMA Engine Hardware Control Helpers</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reset the channel */</span>
	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FSL_DMA_IP_85XX</span>:
		<span class="cm">/* Set the channel to below modes:</span>
<span class="cm">		 * EIE - Error interrupt enable</span>
<span class="cm">		 * EOLNIE - End of links interrupt enable</span>
<span class="cm">		 * BWC - Bandwidth sharing among channels</span>
<span class="cm">		 */</span>
		<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">FSL_DMA_MR_BWC</span>
				<span class="o">|</span> <span class="n">FSL_DMA_MR_EIE</span> <span class="o">|</span> <span class="n">FSL_DMA_MR_EOLNIE</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_DMA_IP_83XX</span>:
		<span class="cm">/* Set the channel to below modes:</span>
<span class="cm">		 * EOTIE - End-of-transfer interrupt enable</span>
<span class="cm">		 * PRC_RM - PCI read multiple</span>
<span class="cm">		 */</span>
		<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">FSL_DMA_MR_EOTIE</span>
				<span class="o">|</span> <span class="n">FSL_DMA_MR_PRC_RM</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_is_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">get_sr</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sr</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_SR_CB</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">sr</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_SR_CH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the DMA controller</span>
<span class="cm"> *</span>
<span class="cm"> * Preconditions:</span>
<span class="cm"> * - the CDAR register must point to the start descriptor</span>
<span class="cm"> * - the MRn[CS] bit must be cleared</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_CHAN_PAUSE_EXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">bcr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FSL_DMA_MR_EMP_EN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_MR_EMP_EN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_CHAN_START_EXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FSL_DMA_MR_EMS_EN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_MR_EMS_EN</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FSL_DMA_MR_CS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* read the mode register */</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The 85xx controller supports channel abort, which will stop</span>
<span class="cm">	 * the current transfer. On 83xx, this bit is the transfer error</span>
<span class="cm">	 * mask bit, which should not be changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_85XX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FSL_DMA_MR_CA</span><span class="p">;</span>
		<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_MR_CA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* stop the DMA controller */</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FSL_DMA_MR_CS</span> <span class="o">|</span> <span class="n">FSL_DMA_MR_EMS_EN</span><span class="p">);</span>
	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

	<span class="cm">/* wait for the DMA controller to become idle */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_is_idle</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_is_idle</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span>
		<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;DMA halt timeout!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_chan_set_src_loop_size - Set source address hold transfer size</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> * @size     : Address loop size, 0 for disable loop</span>
<span class="cm"> *</span>
<span class="cm"> * The set source address hold transfer size. The source</span>
<span class="cm"> * address hold or loop transfer size is when the DMA transfer</span>
<span class="cm"> * data from source address (SA), if the loop size is 4, the DMA will</span>
<span class="cm"> * read data from SA, SA + 1, SA + 2, SA + 3, then loop back to SA,</span>
<span class="cm"> * SA + 1 ... and so on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_chan_set_src_loop_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_MR_SAHE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="k">case</span> <span class="mi">4</span>:
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FSL_DMA_MR_SAHE</span> <span class="o">|</span> <span class="p">(</span><span class="n">__ilog2</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_chan_set_dst_loop_size - Set destination address hold transfer size</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> * @size     : Address loop size, 0 for disable loop</span>
<span class="cm"> *</span>
<span class="cm"> * The set destination address hold transfer size. The destination</span>
<span class="cm"> * address hold or loop transfer size is when the DMA transfer</span>
<span class="cm"> * data to destination address (TA), if the loop size is 4, the DMA will</span>
<span class="cm"> * write data to TA, TA + 1, TA + 2, TA + 3, then loop back to TA,</span>
<span class="cm"> * TA + 1 ... and so on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_chan_set_dst_loop_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_MR_DAHE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="k">case</span> <span class="mi">4</span>:
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FSL_DMA_MR_DAHE</span> <span class="o">|</span> <span class="p">(</span><span class="n">__ilog2</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_chan_set_request_count - Set DMA Request Count for external control</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> * @size     : Number of bytes to transfer in a single request</span>
<span class="cm"> *</span>
<span class="cm"> * The Freescale DMA channel can be controlled by the external signal DREQ#.</span>
<span class="cm"> * The DMA request count is how many bytes are allowed to transfer before</span>
<span class="cm"> * pausing the channel, after which a new assertion of DREQ# resumes channel</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * A size of 0 disables external pause control. The maximum size is 1024.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_chan_set_request_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">);</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">|=</span> <span class="p">(</span><span class="n">__ilog2</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f000000</span><span class="p">;</span>

	<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_chan_toggle_ext_pause - Toggle channel external pause status</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> * @enable   : 0 is disabled, 1 is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * The Freescale DMA channel can be controlled by the external signal DREQ#.</span>
<span class="cm"> * The DMA Request Count feature should be used in addition to this feature</span>
<span class="cm"> * to set the number of bytes to transfer before pausing the channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_chan_toggle_ext_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">|=</span> <span class="n">FSL_DMA_CHAN_PAUSE_EXT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_CHAN_PAUSE_EXT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_chan_toggle_ext_start - Toggle channel external start status</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> * @enable   : 0 is disabled, 1 is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * If enable the external start, the channel can be started by an</span>
<span class="cm"> * external DMA start pin. So the dma_start() does not start the</span>
<span class="cm"> * transfer immediately. The DMA channel will wait for the</span>
<span class="cm"> * control pin asserted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_chan_toggle_ext_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">|=</span> <span class="n">FSL_DMA_CHAN_START_EXT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_CHAN_START_EXT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">append_ld_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">to_fsl_desc</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_splice</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the hardware descriptor to the chain of hardware descriptors</span>
<span class="cm">	 * that already exists in memory.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This will un-set the EOL bit of the existing transaction, and the</span>
<span class="cm">	 * last link in this transaction will become the EOL descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">set_desc_next</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the software descriptor and all children to the list</span>
<span class="cm">	 * of pending transactions</span>
<span class="cm">	 */</span>
<span class="nl">out_splice:</span>
	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_cookie_t</span> <span class="nf">fsl_dma_tx_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">tx_to_fsl_desc</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * assign cookies to all of the software descriptors</span>
<span class="cm">	 * that make up this transaction</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cookie</span> <span class="o">=</span> <span class="n">dma_cookie_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* put this transaction onto the tail of the pending queue */</span>
	<span class="n">append_ld_queue</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cookie</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_dma_alloc_descriptor - Allocate descriptor from channel&#39;s DMA pool.</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> *</span>
<span class="cm"> * Return - The descriptor allocated. NULL for failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="nf">fsl_dma_alloc_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdesc</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdesc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;out of memory for link descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">);</span>
	<span class="n">dma_async_tx_descriptor_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">tx_submit</span> <span class="o">=</span> <span class="n">fsl_dma_tx_submit</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">phys</span> <span class="o">=</span> <span class="n">pdesc</span><span class="p">;</span>

<span class="cp">#ifdef FSL_DMA_LD_DEBUG</span>
	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;LD %p allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">desc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_dma_alloc_chan_resources - Allocate resources for DMA channel.</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> *</span>
<span class="cm"> * This function will create a dma pool for descriptor allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * Return - The number of descriptors allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_dma_alloc_chan_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>

	<span class="cm">/* Has this channel already been allocated? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need the descriptor to be aligned to 32bytes</span>
<span class="cm">	 * for meeting FSL DMA specification requirement.</span>
<span class="cm">	 */</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span> <span class="o">=</span> <span class="n">dma_pool_create</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_desc_sw</span><span class="p">),</span>
					  <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_desc_sw</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;unable to allocate descriptor pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* there is at least one descriptor free to be allocated */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsldma_free_desc_list - Free all descriptors in a queue</span>
<span class="cm"> * @chan: Freescae DMA channel</span>
<span class="cm"> * @list: the list to free</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING: must hold chan-&gt;desc_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsldma_free_desc_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="o">*</span><span class="n">_desc</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">_desc</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
<span class="cp">#ifdef FSL_DMA_LD_DEBUG</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;LD %p free</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsldma_free_desc_list_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="o">*</span><span class="n">_desc</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe_reverse</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">_desc</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
<span class="cp">#ifdef FSL_DMA_LD_DEBUG</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;LD %p free</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_dma_free_chan_resources - Free all resources of the channel.</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_dma_free_chan_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;free all channel resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fsldma_free_desc_list</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">);</span>
	<span class="n">fsldma_free_desc_list</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_running</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span>
<span class="nf">fsl_dma_prep_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dchan</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">fsl_dma_alloc_descriptor</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg_ld_oom</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Insert the link descriptor to the LD ring */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">);</span>

	<span class="cm">/* Set End-of-link to the last link descriptor of new list */</span>
	<span class="n">set_ld_eol</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span>
<span class="nf">fsl_dma_prep_memcpy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_dst</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_src</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dchan</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>

		<span class="cm">/* Allocate the link descriptor from DMA pool */</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">fsl_dma_alloc_descriptor</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg_ld_oom</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">copy</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">FSL_DMA_BCR_MAX_CNT</span><span class="p">);</span>

		<span class="n">set_desc_cnt</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="n">set_desc_src</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">dma_src</span><span class="p">);</span>
		<span class="n">set_desc_dst</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">dma_dst</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">set_desc_next</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

		<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">async_tx_ack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">);</span>

		<span class="n">prev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">dma_src</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">dma_dst</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>

		<span class="cm">/* Insert the link descriptor to the LD ring */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* client is in control of this ack */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* Set End-of-link to the last link descriptor of new list */</span>
	<span class="n">set_ld_eol</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">fsldma_free_desc_list_reverse</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">fsl_dma_prep_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dst_sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dst_nents</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">src_sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_nents</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">dst_avail</span><span class="p">,</span> <span class="n">src_avail</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* basic sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst_nents</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">src_nents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst_sg</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">src_sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: should we check that both scatterlists have the same</span>
<span class="cm">	 * TODO: number of bytes in total? Is that really an error?</span>
<span class="cm">	 */</span>

	<span class="cm">/* get prepared for the loop */</span>
	<span class="n">dst_avail</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">dst_sg</span><span class="p">);</span>
	<span class="n">src_avail</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">src_sg</span><span class="p">);</span>

	<span class="cm">/* run until we are out of scatterlist entries */</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* create the largest transaction possible */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">src_avail</span><span class="p">,</span> <span class="n">dst_avail</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">FSL_DMA_BCR_MAX_CNT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fetch</span><span class="p">;</span>

		<span class="n">dst</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">dst_sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">dst_sg</span><span class="p">)</span> <span class="o">-</span> <span class="n">dst_avail</span><span class="p">;</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">src_sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">src_sg</span><span class="p">)</span> <span class="o">-</span> <span class="n">src_avail</span><span class="p">;</span>

		<span class="cm">/* allocate and populate the descriptor */</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">fsl_dma_alloc_descriptor</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg_ld_oom</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">set_desc_cnt</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">set_desc_src</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
		<span class="n">set_desc_dst</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">set_desc_next</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

		<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">async_tx_ack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

		<span class="cm">/* Insert the link descriptor to the LD ring */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">);</span>

		<span class="cm">/* update metadata */</span>
		<span class="n">dst_avail</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">src_avail</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">fetch:</span>
		<span class="cm">/* fetch the next dst scatterlist entry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dst_avail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* no more entries: we&#39;re done */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dst_nents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* fetch the next entry: if there are no more: done */</span>
			<span class="n">dst_sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">dst_sg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dst_sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">dst_nents</span><span class="o">--</span><span class="p">;</span>
			<span class="n">dst_avail</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">dst_sg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* fetch the next src scatterlist entry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">src_avail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* no more entries: we&#39;re done */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">src_nents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* fetch the next entry: if there are no more: done */</span>
			<span class="n">src_sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">src_sg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">src_sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">src_nents</span><span class="o">--</span><span class="p">;</span>
			<span class="n">src_avail</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">src_sg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* client is in control of this ack */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* Set End-of-link to the last link descriptor of new list */</span>
	<span class="n">set_ld_eol</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">fsldma_free_desc_list_reverse</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_dma_prep_slave_sg - prepare descriptors for a DMA_SLAVE transaction</span>
<span class="cm"> * @chan: DMA channel</span>
<span class="cm"> * @sgl: scatterlist to transfer to/from</span>
<span class="cm"> * @sg_len: number of entries in @scatterlist</span>
<span class="cm"> * @direction: DMA direction</span>
<span class="cm"> * @flags: DMAEngine flags</span>
<span class="cm"> * @context: transaction context (ignored)</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare a set of descriptors for a DMA_SLAVE transaction. Following the</span>
<span class="cm"> * DMA_SLAVE API, this gets the device-specific information from the</span>
<span class="cm"> * chan-&gt;private variable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">fsl_dma_prep_slave_sg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_len</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This operation is not supported on the Freescale DMA controller</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, we need to provide the function pointer to allow the</span>
<span class="cm">	 * device_control() method to work.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_dma_device_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">dma_ctrl_cmd</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_slave_config</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dchan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_TERMINATE_ALL</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Halt the DMA engine */</span>
		<span class="n">dma_halt</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>

		<span class="cm">/* Remove and free all of the descriptors in the LD queue */</span>
		<span class="n">fsldma_free_desc_list</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">);</span>
		<span class="n">fsldma_free_desc_list</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_running</span><span class="p">);</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DMA_SLAVE_CONFIG</span>:
		<span class="n">config</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dma_slave_config</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

		<span class="cm">/* make sure the channel supports setting burst size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">set_request_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

		<span class="cm">/* we set the controller burst size depending on direction */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_MEM_TO_DEV</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">dst_addr_width</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">dst_maxburst</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">src_addr_width</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">src_maxburst</span><span class="p">;</span>

		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">set_request_count</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FSLDMA_EXTERNAL_START</span>:

		<span class="cm">/* make sure the channel supports external start */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">toggle_ext_start</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">toggle_ext_start</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsldma_cleanup_descriptor - cleanup and free a single link descriptor</span>
<span class="cm"> * @chan: Freescale DMA channel</span>
<span class="cm"> * @desc: descriptor to cleanup and free</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used on a descriptor which has been executed by the DMA</span>
<span class="cm"> * controller. It will run any callbacks, submit any dependencies, and then</span>
<span class="cm"> * free the descriptor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsldma_cleanup_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">src</span> <span class="o">=</span> <span class="n">get_desc_src</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">get_desc_dst</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">get_desc_cnt</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>

	<span class="cm">/* Run the link descriptor callback function */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef FSL_DMA_LD_DEBUG</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;LD %p callback</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">txd</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">callback_param</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Run any dependencies */</span>
	<span class="n">dma_run_dependencies</span><span class="p">(</span><span class="n">txd</span><span class="p">);</span>

	<span class="cm">/* Unmap the dst buffer, if requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_COMPL_SKIP_DEST_UNMAP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_COMPL_DEST_UNMAP_SINGLE</span><span class="p">)</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unmap the src buffer, if requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_COMPL_SKIP_SRC_UNMAP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_COMPL_SRC_UNMAP_SINGLE</span><span class="p">)</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef FSL_DMA_LD_DEBUG</span>
	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;LD %p free</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_pool</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">txd</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_chan_xfer_ld_queue - transfer any pending transactions</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> *</span>
<span class="cm"> * HARDWARE STATE: idle</span>
<span class="cm"> * LOCKING: must hold chan-&gt;desc_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_chan_xfer_ld_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the list of pending descriptors is empty, then we</span>
<span class="cm">	 * don&#39;t need to do any work at all</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;no pending LDs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The DMA controller is not idle, which means that the interrupt</span>
<span class="cm">	 * handler will start any queued transactions when it runs after</span>
<span class="cm">	 * this transaction finishes</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;DMA controller still busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are some link descriptors which have not been</span>
<span class="cm">	 * transferred, we need to start the controller</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move all elements from the queue of pending transactions</span>
<span class="cm">	 * onto the list of running transactions</span>
<span class="cm">	 */</span>
	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;idle, starting controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsl_desc_sw</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_running</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The 85xx DMA controller doesn&#39;t clear the channel start bit</span>
<span class="cm">	 * automatically at the end of a transfer. Therefore we must clear</span>
<span class="cm">	 * it in software before starting the transfer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FSL_DMA_IP_85XX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

		<span class="n">mode</span> <span class="o">=</span> <span class="n">DMA_IN</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_MR_CS</span><span class="p">;</span>
		<span class="n">DMA_OUT</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program the descriptor&#39;s address into the DMA controller,</span>
<span class="cm">	 * then start the DMA transaction</span>
<span class="cm">	 */</span>
	<span class="n">set_cdar</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">get_cdar</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>

	<span class="n">dma_start</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_dma_memcpy_issue_pending - Issue the DMA start command</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_dma_memcpy_issue_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fsl_chan_xfer_ld_queue</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_tx_status - Determine the DMA status</span>
<span class="cm"> * @chan : Freescale DMA channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">dma_status</span> <span class="nf">fsl_tx_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dchan</span><span class="p">,</span>
					<span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dma_tx_state</span> <span class="o">*</span><span class="n">txstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="n">to_fsl_chan</span><span class="p">(</span><span class="n">dchan</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">dma_status</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_cookie_status</span><span class="p">(</span><span class="n">dchan</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">txstate</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------------*/</span>
<span class="cm">/* Interrupt Handling                                                         */</span>
<span class="cm">/*----------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">fsldma_chan_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">stat</span><span class="p">;</span>

	<span class="cm">/* save and clear the status register */</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">get_sr</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">set_sr</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;irq: stat = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="cm">/* check that this was really our device */</span>
	<span class="n">stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FSL_DMA_SR_CB</span> <span class="o">|</span> <span class="n">FSL_DMA_SR_CH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_SR_TE</span><span class="p">)</span>
		<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;Transfer Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Programming Error</span>
<span class="cm">	 * The DMA_INTERRUPT async_tx is a NULL transfer, which will</span>
<span class="cm">	 * triger a PE interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_SR_PE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;irq: Programming Error INT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_SR_PE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_bcr</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;Programming Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For MPC8349, EOCDI event need to update cookie</span>
<span class="cm">	 * and start the next transfer if it exist.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_SR_EOCDI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;irq: End-of-Chain link INT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_SR_EOCDI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it current transfer is the end-of-transfer,</span>
<span class="cm">	 * we should clear the Channel Start bit for</span>
<span class="cm">	 * prepare next transfer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_SR_EOLNI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;irq: End-of-link INT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FSL_DMA_SR_EOLNI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check that the DMA controller is really idle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_is_idle</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span>
		<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;irq: controller not idle!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* check that we handled all of the bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;irq: unhandled sr 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Schedule the tasklet to handle all cleanup of the current</span>
<span class="cm">	 * transaction. It will start a new transaction if there is</span>
<span class="cm">	 * one pending.</span>
<span class="cm">	 */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;irq: Exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_do_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsl_desc_sw</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="o">*</span><span class="n">_desc</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ld_cleanup</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;tasklet entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* update the cookie if we have some descriptors to cleanup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_running</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">;</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="n">to_fsl_desc</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_running</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
		<span class="n">cookie</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">.</span><span class="n">cookie</span><span class="p">;</span>
		<span class="n">dma_cookie_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">async_tx</span><span class="p">);</span>

		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;completed_cookie=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * move the descriptors to a temporary list so we can drop the lock</span>
<span class="cm">	 * during the entire cleanup operation</span>
<span class="cm">	 */</span>
	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ld_cleanup</span><span class="p">);</span>

	<span class="cm">/* the hardware is now idle and ready for more */</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start any pending transactions automatically</span>
<span class="cm">	 *</span>
<span class="cm">	 * In the ideal case, we keep the DMA controller busy while we go</span>
<span class="cm">	 * ahead and free the descriptors below.</span>
<span class="cm">	 */</span>
	<span class="n">fsl_chan_xfer_ld_queue</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Run the callback for each descriptor, in order */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ld_cleanup</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Remove from the list of transactions */</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

		<span class="cm">/* Run all cleanup for this descriptor */</span>
		<span class="n">fsldma_cleanup_descriptor</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;tasklet exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">fsldma_ctrl_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_device</span> <span class="o">*</span><span class="n">fdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gsr</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">gsr</span> <span class="o">=</span> <span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_BIG_ENDIAN</span><span class="p">)</span> <span class="o">?</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span>
						   <span class="o">:</span> <span class="n">in_le32</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0xff000000</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IRQ: gsr 0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gsr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FSL_DMA_MAX_CHANS_PER_DEVICE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gsr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IRQ: chan %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
			<span class="n">fsldma_chan_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
			<span class="n">handled</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">gsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsldma_free_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_device</span> <span class="o">*</span><span class="n">fdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;free per-controller IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">fdev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FSL_DMA_MAX_CHANS_PER_DEVICE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&amp;&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;free per-channel IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsldma_request_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_device</span> <span class="o">*</span><span class="n">fdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* if we have a per-controller IRQ, use that */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request per-controller IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">fsldma_ctrl_irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				  <span class="s">&quot;fsldma-controller&quot;</span><span class="p">,</span> <span class="n">fdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* no per-controller IRQ, use the per-channel IRQs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FSL_DMA_MAX_CHANS_PER_DEVICE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;interrupts property missing in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unwind</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">chan_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;request per-channel IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">fsldma_chan_irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				  <span class="s">&quot;fsldma-chan&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan_err</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="s">&quot;unable to request per-channel IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unwind:</span>
	<span class="k">for</span> <span class="p">(</span><span class="cm">/* none */</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">free_irq</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------------*/</span>
<span class="cm">/* OpenFirmware Subsystem                                                     */</span>
<span class="cm">/*----------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">fsl_dma_chan_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_device</span> <span class="o">*</span><span class="n">fdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">feature</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compatible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* alloc channel */</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chan</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no free memory for DMA channels!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ioremap registers for use */</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">of_iomap</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to ioremap registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_chan</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to find &#39;reg&#39; property</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_iounmap_regs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">feature</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">)</span>
		<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the DMA device&#39;s feature is different than the feature</span>
<span class="cm">	 * of its channels, report the bug</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">!=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">);</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="p">((</span><span class="n">res</span><span class="p">.</span><span class="n">start</span> <span class="o">-</span> <span class="mh">0x100</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">FSL_DMA_MAX_CHANS_PER_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;too many channels for device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_iounmap_regs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">[</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">dma_do_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;chan%d&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/* Initialize the channel */</span>
	<span class="n">dma_init</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>

	<span class="cm">/* Clear cdar registers */</span>
	<span class="n">set_cdar</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">FSL_DMA_IP_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FSL_DMA_IP_85XX</span>:
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">toggle_ext_pause</span> <span class="o">=</span> <span class="n">fsl_chan_toggle_ext_pause</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_DMA_IP_83XX</span>:
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">toggle_ext_start</span> <span class="o">=</span> <span class="n">fsl_chan_toggle_ext_start</span><span class="p">;</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">set_src_loop_size</span> <span class="o">=</span> <span class="n">fsl_chan_set_src_loop_size</span><span class="p">;</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">set_dst_loop_size</span> <span class="o">=</span> <span class="n">fsl_chan_set_dst_loop_size</span><span class="p">;</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">set_request_count</span> <span class="o">=</span> <span class="n">fsl_chan_set_request_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_pending</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ld_running</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">;</span>
	<span class="n">dma_cookie_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>

	<span class="cm">/* find the IRQ line, if it exists in the device tree */</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Add the channel to DMA device channel list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">channels</span><span class="p">);</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">chancnt</span><span class="o">++</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;#%d (%s), irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">compatible</span><span class="p">,</span>
		 <span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">NO_IRQ</span> <span class="o">?</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">:</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_iounmap_regs:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">out_free_chan:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
<span class="nl">out_return:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_dma_chan_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsldma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_dispose_mapping</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_node</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">fsldma_of_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_device</span> <span class="o">*</span><span class="n">fdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">fdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fdev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No enough memory for &#39;priv&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">channels</span><span class="p">);</span>

	<span class="cm">/* ioremap the registers for use */</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">of_iomap</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to ioremap registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_fdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* map the channel IRQ if it exists, but don&#39;t hookup the handler yet */</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dma_cap_set</span><span class="p">(</span><span class="n">DMA_MEMCPY</span><span class="p">,</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">cap_mask</span><span class="p">);</span>
	<span class="n">dma_cap_set</span><span class="p">(</span><span class="n">DMA_INTERRUPT</span><span class="p">,</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">cap_mask</span><span class="p">);</span>
	<span class="n">dma_cap_set</span><span class="p">(</span><span class="n">DMA_SG</span><span class="p">,</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">cap_mask</span><span class="p">);</span>
	<span class="n">dma_cap_set</span><span class="p">(</span><span class="n">DMA_SLAVE</span><span class="p">,</span> <span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">cap_mask</span><span class="p">);</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_alloc_chan_resources</span> <span class="o">=</span> <span class="n">fsl_dma_alloc_chan_resources</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_free_chan_resources</span> <span class="o">=</span> <span class="n">fsl_dma_free_chan_resources</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_prep_dma_interrupt</span> <span class="o">=</span> <span class="n">fsl_dma_prep_interrupt</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_prep_dma_memcpy</span> <span class="o">=</span> <span class="n">fsl_dma_prep_memcpy</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_prep_dma_sg</span> <span class="o">=</span> <span class="n">fsl_dma_prep_sg</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_tx_status</span> <span class="o">=</span> <span class="n">fsl_tx_status</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_issue_pending</span> <span class="o">=</span> <span class="n">fsl_dma_memcpy_issue_pending</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_prep_slave_sg</span> <span class="o">=</span> <span class="n">fsl_dma_prep_slave_sg</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">device_control</span> <span class="o">=</span> <span class="n">fsl_dma_device_control</span><span class="p">;</span>
	<span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">36</span><span class="p">));</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">fdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We cannot use of_platform_bus_probe() because there is no</span>
<span class="cm">	 * of_platform_bus_remove(). Instead, we manually instantiate every DMA</span>
<span class="cm">	 * channel object.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&quot;fsl,eloplus-dma-channel&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fsl_dma_chan_probe</span><span class="p">(</span><span class="n">fdev</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span>
				<span class="n">FSL_DMA_IP_85XX</span> <span class="o">|</span> <span class="n">FSL_DMA_BIG_ENDIAN</span><span class="p">,</span>
				<span class="s">&quot;fsl,eloplus-dma-channel&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&quot;fsl,elo-dma-channel&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fsl_dma_chan_probe</span><span class="p">(</span><span class="n">fdev</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span>
				<span class="n">FSL_DMA_IP_83XX</span> <span class="o">|</span> <span class="n">FSL_DMA_LITTLE_ENDIAN</span><span class="p">,</span>
				<span class="s">&quot;fsl,elo-dma-channel&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hookup the IRQ handler(s)</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we have a per-controller interrupt, we prefer that to the</span>
<span class="cm">	 * per-channel interrupts to reduce the number of shared interrupt</span>
<span class="cm">	 * handlers on the same IRQ line</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fsldma_request_irqs</span><span class="p">(</span><span class="n">fdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to request IRQs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_fdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dma_async_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_fdev:</span>
	<span class="n">irq_dispose_mapping</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fdev</span><span class="p">);</span>
<span class="nl">out_return:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsldma_of_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsldma_device</span> <span class="o">*</span><span class="n">fdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">fdev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dma_async_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>

	<span class="n">fsldma_free_irqs</span><span class="p">(</span><span class="n">fdev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FSL_DMA_MAX_CHANS_PER_DEVICE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">fsl_dma_chan_remove</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">fdev</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">fsldma_of_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,eloplus-dma&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,elo-dma&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">fsldma_of_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;fsl-elo-dma&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">fsldma_of_ids</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">fsldma_of_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">fsldma_of_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------------------*/</span>
<span class="cm">/* Module Init / Exit                                                         */</span>
<span class="cm">/*----------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">fsldma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Freescale Elo / Elo Plus DMA driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsldma_of_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">fsldma_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsldma_of_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">fsldma_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">fsldma_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Freescale Elo / Elo Plus DMA driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
