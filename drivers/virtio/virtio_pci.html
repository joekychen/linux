<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › virtio › virtio_pci.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>virtio_pci.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Virtio PCI driver</span>
<span class="cm"> *</span>
<span class="cm"> * This module allows virtio devices to be used over a virtual PCI device.</span>
<span class="cm"> * This can be used with QEMU based VMMs like KVM or Xen.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright IBM Corp. 2007</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *  Anthony Liguori  &lt;aliguori@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2 or later.</span>
<span class="cm"> * See the COPYING file in the top-level directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/virtio.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_config.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_ring.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_pci.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Anthony Liguori &lt;aliguori@us.ibm.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;virtio-pci&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">);</span>

<span class="cm">/* Our device structure */</span>
<span class="k">struct</span> <span class="n">virtio_pci_device</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_device</span> <span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>

	<span class="cm">/* the IO mapping for the PCI config space */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/* a list of queues so we can dispatch IRQs */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">virtqueues</span><span class="p">;</span>

	<span class="cm">/* MSI-X support */</span>
	<span class="kt">int</span> <span class="n">msix_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">intx_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">msix_entries</span><span class="p">;</span>
	<span class="cm">/* Name strings for interrupts. This size should be enough,</span>
<span class="cm">	 * and I&#39;m too lazy to allocate each name separately. */</span>
	<span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">msix_names</span><span class="p">)[</span><span class="mi">256</span><span class="p">];</span>
	<span class="cm">/* Number of available vectors */</span>
	<span class="kt">unsigned</span> <span class="n">msix_vectors</span><span class="p">;</span>
	<span class="cm">/* Vectors allocated, excluding per-vq vectors if any */</span>
	<span class="kt">unsigned</span> <span class="n">msix_used_vectors</span><span class="p">;</span>

	<span class="cm">/* Status saved during hibernate/restore */</span>
	<span class="n">u8</span> <span class="n">saved_status</span><span class="p">;</span>

	<span class="cm">/* Whether we have vector per vq */</span>
	<span class="n">bool</span> <span class="n">per_vq_vectors</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Constants for MSI-X */</span>
<span class="cm">/* Use first vector for configuration changes, second and the rest for</span>
<span class="cm"> * virtqueues Thus, we need at least 2 vectors for MSI. */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VP_MSIX_CONFIG_VECTOR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VP_MSIX_VQ_VECTOR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">virtio_pci_vq_info</span>
<span class="p">{</span>
	<span class="cm">/* the actual virtqueue */</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>

	<span class="cm">/* the number of entries in the queue */</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

	<span class="cm">/* the index of the queue */</span>
	<span class="kt">int</span> <span class="n">queue_index</span><span class="p">;</span>

	<span class="cm">/* the virtual address of the ring queue */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="cm">/* the list node for the virtqueues list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* MSI-X vector (or none) */</span>
	<span class="kt">unsigned</span> <span class="n">msix_vector</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">virtio_pci_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x1af4</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">virtio_pci_id_table</span><span class="p">);</span>

<span class="cm">/* Convert a generic virtio device to our structure */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="nf">to_vp_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">virtio_pci_device</span><span class="p">,</span> <span class="n">vdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* virtio config-&gt;get_features() implementation */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vp_get_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="cm">/* When someone needs more than 32 feature bits, we&#39;ll need to</span>
<span class="cm">	 * steal a bit to indicate that the rest are somewhere else. */</span>
	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_HOST_FEATURES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* virtio config-&gt;finalize_features() implementation */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_finalize_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="cm">/* Give virtio_ring a chance to accept features. */</span>
	<span class="n">vring_transport_features</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="cm">/* We only support 32 feature bits. */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="o">+</span><span class="n">VIRTIO_PCI_GUEST_FEATURES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* virtio config-&gt;get() implementation */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span>
				<span class="n">VIRTIO_PCI_CONFIG</span><span class="p">(</span><span class="n">vp_dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* the config-&gt;set() implementation.  it&#39;s symmetric to the config-&gt;get()</span>
<span class="cm"> * implementation */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span>
				<span class="n">VIRTIO_PCI_CONFIG</span><span class="p">(</span><span class="n">vp_dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* config-&gt;{get,set}_status() implementations */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">vp_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_STATUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_set_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="cm">/* We should never be setting status to 0. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_STATUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* wait for pending irq handlers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_synchronize_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">intx_enabled</span><span class="p">)</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="cm">/* 0 status means a reset. */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_STATUS</span><span class="p">);</span>
	<span class="cm">/* Flush out the status write, and flush in device writes,</span>
<span class="cm">	 * including MSi-X interrupts, if any. */</span>
	<span class="n">ioread8</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_STATUS</span><span class="p">);</span>
	<span class="cm">/* Flush pending VQ/configuration callbacks. */</span>
	<span class="n">vp_synchronize_vectors</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* the notify function used when creating a virt queue */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtio_pci_vq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* we write the queue&#39;s selector into the notification register to</span>
<span class="cm">	 * signal the other end */</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_NOTIFY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle a configuration change: Tell driver if it wants to know. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">vp_config_changed</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="n">drv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">virtio_driver</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">config_changed</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">config_changed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Notify all virtqueues on an interrupt. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">vp_vring_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_pci_vq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">virtqueues</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vring_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">)</span> <span class="o">==</span> <span class="n">IRQ_HANDLED</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A small wrapper to also acknowledge the interrupt when it&#39;s handled.</span>
<span class="cm"> * I really need an EIO hook for the vring so I can ack the interrupt once we</span>
<span class="cm"> * know that we&#39;ll be handling the IRQ but before we invoke the callback since</span>
<span class="cm"> * the callback may notify the host which results in the host attempting to</span>
<span class="cm"> * raise an interrupt that we would then mask once we acknowledged the</span>
<span class="cm"> * interrupt. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">vp_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">isr</span><span class="p">;</span>

	<span class="cm">/* reading the ISR has the effect of also clearing it so it&#39;s very</span>
<span class="cm">	 * important to save off the value. */</span>
	<span class="n">isr</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_ISR</span><span class="p">);</span>

	<span class="cm">/* It&#39;s definitely not us if the ISR was not high */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Configuration change?  Tell driver if it wants to know. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="n">VIRTIO_PCI_ISR_CONFIG</span><span class="p">)</span>
		<span class="n">vp_config_changed</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">opaque</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vp_vring_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">opaque</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_free_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">intx_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">vp_dev</span><span class="p">);</span>
		<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">intx_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_used_vectors</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">vp_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable the vector used for configuration */</span>
		<span class="n">iowrite16</span><span class="p">(</span><span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">,</span>
			  <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_MSI_CONFIG_VECTOR</span><span class="p">);</span>
		<span class="cm">/* Flush the write out to device */</span>
		<span class="n">ioread16</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_MSI_CONFIG_VECTOR</span><span class="p">);</span>

		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_used_vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">);</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vp_request_msix_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nvectors</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">per_vq_vectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nvectors</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span>
				       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nvectors</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">,</span>
				     <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvectors</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* pci_enable_msix returns positive if we can&#39;t get this many. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span> <span class="n">nvectors</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="n">nvectors</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Set the vector used for configuration */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_used_vectors</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">,</span>
		 <span class="s">&quot;%s-config&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			  <span class="n">vp_config_changed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">[</span><span class="n">v</span><span class="p">],</span>
			  <span class="n">vp_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="o">++</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_used_vectors</span><span class="p">;</span>

	<span class="n">iowrite16</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_MSI_CONFIG_VECTOR</span><span class="p">);</span>
	<span class="cm">/* Verify we had enough resources to assign the vector */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_MSI_CONFIG_VECTOR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">per_vq_vectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Shared vector for all VQs */</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_used_vectors</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">,</span>
			 <span class="s">&quot;%s-virtqueues&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				  <span class="n">vp_vring_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">[</span><span class="n">v</span><span class="p">],</span>
				  <span class="n">vp_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="o">++</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_used_vectors</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">vp_free_vectors</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vp_request_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">vp_interrupt</span><span class="p">,</span>
			  <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">vp_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">intx_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="nf">setup_vq</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">),</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">msix_vec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtio_pci_vq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Select the queue we&#39;re interested in */</span>
	<span class="n">iowrite16</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_SEL</span><span class="p">);</span>

	<span class="cm">/* Check if queue is either not available or already active. */</span>
	<span class="n">num</span> <span class="o">=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_NUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span> <span class="o">||</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_PFN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="cm">/* allocate and fill out our structure the represents an active</span>
<span class="cm">	 * queue */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_pci_vq_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">queue_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">msix_vector</span> <span class="o">=</span> <span class="n">msix_vec</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">vring_size</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">VIRTIO_PCI_VRING_ALIGN</span><span class="p">));</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">alloc_pages_exact</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_info</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* activate the queue */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">VIRTIO_PCI_QUEUE_ADDR_SHIFT</span><span class="p">,</span>
		  <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_PFN</span><span class="p">);</span>

	<span class="cm">/* create the vring */</span>
	<span class="n">vq</span> <span class="o">=</span> <span class="n">vring_new_virtqueue</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">VIRTIO_PCI_VRING_ALIGN</span><span class="p">,</span> <span class="n">vdev</span><span class="p">,</span>
				 <span class="nb">true</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">vp_notify</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_activate_queue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">vq</span> <span class="o">=</span> <span class="n">vq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msix_vec</span> <span class="o">!=</span> <span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite16</span><span class="p">(</span><span class="n">msix_vec</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_MSI_QUEUE_VECTOR</span><span class="p">);</span>
		<span class="n">msix_vec</span> <span class="o">=</span> <span class="n">ioread16</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_MSI_QUEUE_VECTOR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msix_vec</span> <span class="o">==</span> <span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_assign</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">virtqueues</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">vq</span><span class="p">;</span>

<span class="nl">out_assign:</span>
	<span class="n">vring_del_virtqueue</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
<span class="nl">out_activate_queue:</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_PFN</span><span class="p">);</span>
	<span class="n">free_pages_exact</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="nl">out_info:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_del_vq</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtio_pci_vq_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iowrite16</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_SEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite16</span><span class="p">(</span><span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">,</span>
			  <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_MSI_QUEUE_VECTOR</span><span class="p">);</span>
		<span class="cm">/* Flush the write out to device */</span>
		<span class="n">ioread8</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_ISR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vring_del_virtqueue</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>

	<span class="cm">/* Select and deactivate the queue */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">+</span> <span class="n">VIRTIO_PCI_QUEUE_PFN</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">vring_size</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">VIRTIO_PCI_VRING_ALIGN</span><span class="p">));</span>
	<span class="n">free_pages_exact</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* the config-&gt;del_vqs() implementation */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vp_del_vqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_pci_vq_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">vqs</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">per_vq_vectors</span> <span class="o">&amp;&amp;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">msix_vector</span> <span class="o">!=</span> <span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msix_vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="n">vq</span><span class="p">);</span>
		<span class="n">vp_del_vq</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">per_vq_vectors</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">vp_free_vectors</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vp_try_to_find_vqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nvqs</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vqs</span><span class="p">[],</span>
			      <span class="n">vq_callback_t</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">[],</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">names</span><span class="p">[],</span>
			      <span class="n">bool</span> <span class="n">use_msix</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">per_vq_vectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">msix_vec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">nvectors</span><span class="p">,</span> <span class="n">allocated_vectors</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_msix</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Old style: one normal interrupt for change and all vqs. */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vp_request_intx</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_request</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per_vq_vectors</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Best option: one for change interrupt, one per vq. */</span>
			<span class="n">nvectors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvqs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">callbacks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="o">++</span><span class="n">nvectors</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Second best: one for change, shared for all vqs. */</span>
			<span class="n">nvectors</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">vp_request_msix_vectors</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">nvectors</span><span class="p">,</span> <span class="n">per_vq_vectors</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_request</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">per_vq_vectors</span> <span class="o">=</span> <span class="n">per_vq_vectors</span><span class="p">;</span>
	<span class="n">allocated_vectors</span> <span class="o">=</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_used_vectors</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvqs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">callbacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span>
			<span class="n">msix_vec</span> <span class="o">=</span> <span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">per_vq_vectors</span><span class="p">)</span>
			<span class="n">msix_vec</span> <span class="o">=</span> <span class="n">allocated_vectors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">msix_vec</span> <span class="o">=</span> <span class="n">VP_MSIX_VQ_VECTOR</span><span class="p">;</span>
		<span class="n">vqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">setup_vq</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">msix_vec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vqs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vqs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">error_find</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">per_vq_vectors</span> <span class="o">||</span> <span class="n">msix_vec</span> <span class="o">==</span> <span class="n">VIRTIO_MSI_NO_VECTOR</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* allocate per-vq irq if available and necessary */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">],</span>
			 <span class="k">sizeof</span> <span class="o">*</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">,</span>
			 <span class="s">&quot;%s-%s&quot;</span><span class="p">,</span>
			 <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">dev</span><span class="p">),</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				  <span class="n">vring_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">],</span>
				  <span class="n">vqs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vp_del_vq</span><span class="p">(</span><span class="n">vqs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">error_find</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_find:</span>
	<span class="n">vp_del_vqs</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

<span class="nl">error_request:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the config-&gt;find_vqs() implementation */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vp_find_vqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nvqs</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vqs</span><span class="p">[],</span>
		       <span class="n">vq_callback_t</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">[],</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">names</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Try MSI-X with one vector per queue. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vp_try_to_find_vqs</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">nvqs</span><span class="p">,</span> <span class="n">vqs</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Fallback: MSI-X with one vector for config, one shared for queues. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vp_try_to_find_vqs</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">nvqs</span><span class="p">,</span> <span class="n">vqs</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span>
				 <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Finally fall back to regular interrupts. */</span>
	<span class="k">return</span> <span class="n">vp_try_to_find_vqs</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="n">nvqs</span><span class="p">,</span> <span class="n">vqs</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span>
				  <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">vp_bus_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">to_vp_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">virtio_config_ops</span> <span class="n">virtio_pci_config_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get</span>		<span class="o">=</span> <span class="n">vp_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set</span>		<span class="o">=</span> <span class="n">vp_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_status</span>	<span class="o">=</span> <span class="n">vp_get_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_status</span>	<span class="o">=</span> <span class="n">vp_set_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>		<span class="o">=</span> <span class="n">vp_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">find_vqs</span>	<span class="o">=</span> <span class="n">vp_find_vqs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del_vqs</span>	<span class="o">=</span> <span class="n">vp_del_vqs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_features</span>	<span class="o">=</span> <span class="n">vp_get_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">finalize_features</span> <span class="o">=</span> <span class="n">vp_finalize_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_name</span>	<span class="o">=</span> <span class="n">vp_bus_name</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">virtio_pci_release_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">_d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need for a release method as we allocate/free</span>
<span class="cm">	 * all devices together with the pci devices.</span>
<span class="cm">	 * Provide an empty one to avoid getting a warning from core.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cm">/* the PCI probing function */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">virtio_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* We only own devices &gt;= 0x1000 and &lt;= 0x103f: leave the rest. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&lt;</span> <span class="mh">0x1000</span> <span class="o">||</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&gt;</span> <span class="mh">0x103f</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">!=</span> <span class="n">VIRTIO_PCI_ABI_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;virtio_pci: expected ABI version %d, got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">VIRTIO_PCI_ABI_VERSION</span><span class="p">,</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate our structure and fill it out */</span>
	<span class="n">vp_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_pci_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">virtio_pci_release_dev</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">virtio_pci_config_ops</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">virtqueues</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Disable MSI/MSIX to bring device to a known good state. */</span>
	<span class="n">pci_msi_off</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/* enable the device */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;virtio-pci&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_enable_device</span><span class="p">;</span>

	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_req_regions</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">vp_dev</span><span class="p">);</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/* we use the subsystem vendor/device id as the virtio vendor/device</span>
<span class="cm">	 * id.  this allows us to use the same PCI vendor/device id for all</span>
<span class="cm">	 * virtio devices and to identify the particular virtio driver by</span>
<span class="cm">	 * the subsystem ids */</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>

	<span class="cm">/* finally register the virtio device */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_virtio_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_set_drvdata</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_set_drvdata:</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
<span class="nl">out_req_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="nl">out_enable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vp_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">virtio_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">unregister_virtio_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="n">vp_del_vqs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vp_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">virtio_pci_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtio_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">drv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">virtio_driver</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">saved_status</span> <span class="o">=</span> <span class="n">vp_get_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">virtio_pci_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtio_pci_device</span> <span class="o">*</span><span class="n">vp_dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">virtio_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">drv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">virtio_driver</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">vp_finalize_features</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="cm">/* Finally, tell the device we&#39;re all set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">vp_set_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">saved_status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">virtio_pci_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SET_SYSTEM_SLEEP_PM_OPS</span><span class="p">(</span><span class="n">virtio_pci_freeze</span><span class="p">,</span> <span class="n">virtio_pci_restore</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">virtio_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;virtio-pci&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">virtio_pci_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">virtio_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">virtio_pci_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">virtio_pci_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">virtio_pci_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virtio_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">virtio_pci_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">virtio_pci_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virtio_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">virtio_pci_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
