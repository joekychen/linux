<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › uwb › beacon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>beacon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Ultra Wide Band</span>
<span class="cm"> * Beacon management</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: docs</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;uwb-internal.h&quot;</span>

<span class="cm">/* Start Beaconing command structure */</span>
<span class="k">struct</span> <span class="n">uwb_rc_cmd_start_beacon</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="n">rccb</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">wBPSTOffset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bChannelNumber</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">uwb_rc_start_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bpst_offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_cmd_start_beacon</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_confirm</span> <span class="n">reply</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rccb</span><span class="p">.</span><span class="n">bCommandType</span> <span class="o">=</span> <span class="n">UWB_RC_CET_GENERAL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rccb</span><span class="p">.</span><span class="n">wCommand</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">UWB_RC_CMD_START_BEACON</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wBPSTOffset</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">bpst_offset</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">bChannelNumber</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">reply</span><span class="p">.</span><span class="n">rceb</span><span class="p">.</span><span class="n">bEventType</span> <span class="o">=</span> <span class="n">UWB_RC_CET_GENERAL</span><span class="p">;</span>
	<span class="n">reply</span><span class="p">.</span><span class="n">rceb</span><span class="p">.</span><span class="n">wEvent</span> <span class="o">=</span> <span class="n">UWB_RC_CMD_START_BEACON</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_rc_cmd</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="s">&quot;START-BEACON&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rccb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span>
			    <span class="o">&amp;</span><span class="n">reply</span><span class="p">.</span><span class="n">rceb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">bResultCode</span> <span class="o">!=</span> <span class="n">UWB_RC_RES_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;START-BEACON: command execution failed: %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">uwb_rc_strerror</span><span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">bResultCode</span><span class="p">),</span> <span class="n">reply</span><span class="p">.</span><span class="n">bResultCode</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">error_cmd:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uwb_rc_stop_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_confirm</span> <span class="n">reply</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">bCommandType</span> <span class="o">=</span> <span class="n">UWB_RC_CET_GENERAL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wCommand</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">UWB_RC_CMD_STOP_BEACON</span><span class="p">);</span>
	<span class="n">reply</span><span class="p">.</span><span class="n">rceb</span><span class="p">.</span><span class="n">bEventType</span> <span class="o">=</span> <span class="n">UWB_RC_CET_GENERAL</span><span class="p">;</span>
	<span class="n">reply</span><span class="p">.</span><span class="n">rceb</span><span class="p">.</span><span class="n">wEvent</span> <span class="o">=</span> <span class="n">UWB_RC_CMD_STOP_BEACON</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_rc_cmd</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="s">&quot;STOP-BEACON&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span>
			    <span class="o">&amp;</span><span class="n">reply</span><span class="p">.</span><span class="n">rceb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">bResultCode</span> <span class="o">!=</span> <span class="n">UWB_RC_RES_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;STOP-BEACON: command execution failed: %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">uwb_rc_strerror</span><span class="p">(</span><span class="n">reply</span><span class="p">.</span><span class="n">bResultCode</span><span class="p">),</span> <span class="n">reply</span><span class="p">.</span><span class="n">bResultCode</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">error_cmd:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start/stop beacons</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:          UWB Radio Controller to operate on</span>
<span class="cm"> * @channel:     UWB channel on which to beacon (WUSB[table</span>
<span class="cm"> *               5-12]). If -1, stop beaconing.</span>
<span class="cm"> * @bpst_offset: Beacon Period Start Time offset; FIXME-do zero</span>
<span class="cm"> *</span>
<span class="cm"> * According to WHCI 0.95 [4.13.6] the driver will only receive the RCEB</span>
<span class="cm"> * of a SET IE command after the device sent the first beacon that includes</span>
<span class="cm"> * the IEs specified in the SET IE command. So, after we start beaconing we</span>
<span class="cm"> * check if there is anything in the IE cache and call the SET IE command</span>
<span class="cm"> * if needed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uwb_rc_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bpst_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_rc_stop_beacon</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* channel &gt;= 0...dah */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_rc_start_beacon</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">bpst_offset</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">ies</span><span class="o">-&gt;</span><span class="n">wIELength</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_rc_set_ie</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">ies</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot set new IE on device: &quot;</span>
					<span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_rc_stop_beacon</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
				<span class="n">channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">bpst_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">beaconing</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Beacon cache</span>
<span class="cm"> *</span>
<span class="cm"> * The purpose of this is to speed up the lookup of becon information</span>
<span class="cm"> * when a new beacon arrives. The UWB Daemon uses it also to keep a</span>
<span class="cm"> * tab of which devices are in radio distance and which not. When a</span>
<span class="cm"> * device&#39;s beacon stays present for more than a certain amount of</span>
<span class="cm"> * time, it is considered a new, usable device. When a beacon ceases</span>
<span class="cm"> * to be received for a certain amount of time, it is considered that</span>
<span class="cm"> * the device is gone.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: use an allocator for the entries</span>
<span class="cm"> * FIXME: use something faster for search than a list</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">uwb_bce_kfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">_bce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_bce</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_beca_e</span><span class="p">,</span> <span class="n">refcnt</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">be</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bce</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Find a beacon by dev addr in the cache */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="nf">__uwb_beca_find_bydev</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="n">dev_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bce</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bce</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">bce</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find a beacon by dev addr in the cache */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="nf">__uwb_beca_find_bymac</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> 
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bce</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">mac_addr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_mac_addr</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bce</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">bce</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_dev_get_by_devaddr - get a UWB device with a specific DevAddr</span>
<span class="cm"> * @rc:      the radio controller that saw the device</span>
<span class="cm"> * @devaddr: DevAddr of the UWB device to find</span>
<span class="cm"> *</span>
<span class="cm"> * There may be more than one matching device (in the case of a</span>
<span class="cm"> * DevAddr conflict), but only the first one is returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="nf">uwb_dev_get_by_devaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="n">devaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">bce</span> <span class="o">=</span> <span class="n">__uwb_beca_find_bydev</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">devaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bce</span><span class="p">)</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">uwb_dev_try_get</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">bce</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_dev_get_by_macaddr - get a UWB device with a specific EUI-48</span>
<span class="cm"> * @rc:      the radio controller that saw the device</span>
<span class="cm"> * @devaddr: EUI-48 of the UWB device to find</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="nf">uwb_dev_get_by_macaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">bce</span> <span class="o">=</span> <span class="n">__uwb_beca_find_bymac</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">macaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bce</span><span class="p">)</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">uwb_dev_try_get</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">bce</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize a beacon cache entry */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uwb_beca_e_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">stats_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">lqe_stats</span><span class="p">);</span>
	<span class="n">stats_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">rssi_stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a beacon to the cache</span>
<span class="cm"> *</span>
<span class="cm"> * @be:         Beacon event information</span>
<span class="cm"> * @bf:         Beacon frame (part of b, really)</span>
<span class="cm"> * @ts_jiffies: Timestamp (in jiffies) when the beacon was received</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="nf">__uwb_beca_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">uwb_rc_evt_beacon</span> <span class="o">*</span><span class="n">be</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">uwb_beacon_frame</span> <span class="o">*</span><span class="n">bf</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ts_jiffies</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">;</span>

	<span class="n">bce</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bce</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bce</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">uwb_beca_e_init</span><span class="p">(</span><span class="n">bce</span><span class="p">);</span>
	<span class="n">bce</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span> <span class="o">=</span> <span class="n">ts_jiffies</span><span class="p">;</span>
	<span class="n">bce</span><span class="o">-&gt;</span><span class="n">uwb_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bce</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wipe out beacon entries that became stale</span>
<span class="cm"> *</span>
<span class="cm"> * Remove associated devicest too.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uwb_beca_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bce</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">expires</span> <span class="o">=</span> <span class="n">bce</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">beacon_timeout_ms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">uwbd_dev_offair</span><span class="p">(</span><span class="n">bce</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Clean up the whole beacon cache. Called on shutdown */</span>
<span class="kt">void</span> <span class="nf">uwb_beca_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bce</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">uwb_bce_put</span><span class="p">(</span><span class="n">bce</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uwb_beacon_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_beacon</span> <span class="o">*</span><span class="n">be</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">uwb_beacon_frame</span> <span class="o">*</span><span class="n">bf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">macbuf</span><span class="p">[</span><span class="n">UWB_ADDR_STRSIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">devbuf</span><span class="p">[</span><span class="n">UWB_ADDR_STRSIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">dstbuf</span><span class="p">[</span><span class="n">UWB_ADDR_STRSIZE</span><span class="p">];</span>

	<span class="n">uwb_mac_addr_print</span><span class="p">(</span><span class="n">macbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">macbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">Device_Identifier</span><span class="p">);</span>
	<span class="n">uwb_dev_addr_print</span><span class="p">(</span><span class="n">devbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">devbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">SrcAddr</span><span class="p">);</span>
	<span class="n">uwb_dev_addr_print</span><span class="p">(</span><span class="n">dstbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dstbuf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">DestAddr</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
		 <span class="s">&quot;BEACON from %s to %s (ch%u offset %u slot %u MAC %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">devbuf</span><span class="p">,</span> <span class="n">dstbuf</span><span class="p">,</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">bChannelNumber</span><span class="p">,</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">wBPSTOffset</span><span class="p">,</span>
		 <span class="n">bf</span><span class="o">-&gt;</span><span class="n">Beacon_Slot_Number</span><span class="p">,</span> <span class="n">macbuf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @bce: beacon cache entry, referenced</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">uwb_bce_print_IEs</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_beacon</span> <span class="o">*</span><span class="n">be</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_beacon_frame</span> <span class="o">*</span><span class="n">bf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ies_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_ie_hdr</span> <span class="o">*</span><span class="n">ies</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">be</span> <span class="o">=</span> <span class="n">bce</span><span class="o">-&gt;</span><span class="n">be</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uwb_beacon_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">be</span><span class="o">-&gt;</span><span class="n">BeaconInfo</span><span class="p">;</span>
		<span class="n">ies_len</span> <span class="o">=</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">wBeaconInfoLength</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_beacon_frame</span><span class="p">);</span>
		<span class="n">ies</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uwb_ie_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">IEData</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_ie_dump_hex</span><span class="p">(</span><span class="n">ies</span><span class="p">,</span> <span class="n">ies_len</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Verify that the beacon event, frame and IEs are ok</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uwb_verify_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">uwb_rc_evt_beacon</span> <span class="o">*</span><span class="n">be</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_beacon_frame</span> <span class="o">*</span><span class="n">bf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Is there enough data to decode a beacon frame? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">be</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BEACON event: Not enough data to decode &quot;</span>
			<span class="s">&quot;(%zu vs %zu bytes needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">be</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bf</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME: make sure beacon frame IEs are fine and that the whole thing</span>
<span class="cm">	 * is consistent */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle UWB_RC_EVT_BEACON events</span>
<span class="cm"> *</span>
<span class="cm"> * We check the beacon cache to see how the received beacon fares. If</span>
<span class="cm"> * is there already we refresh the timestamp. If not we create a new</span>
<span class="cm"> * entry.</span>
<span class="cm"> *</span>
<span class="cm"> * According to the WHCI and WUSB specs, only one beacon frame is</span>
<span class="cm"> * allowed per notification block, so we don&#39;t bother about scanning</span>
<span class="cm"> * for more.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uwbd_evt_handle_rc_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_beacon</span> <span class="o">*</span><span class="n">be</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_beacon_frame</span> <span class="o">*</span><span class="n">bf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_ts</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">evt</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">;</span>
	<span class="n">be</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">rceb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_beacon</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_verify_beacon</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">evt</span><span class="p">,</span> <span class="n">be</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* FIXME: handle alien beacons. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be</span><span class="o">-&gt;</span><span class="n">bBeaconType</span> <span class="o">==</span> <span class="n">UWB_RC_BEACON_TYPE_OL_ALIEN</span> <span class="o">||</span>
	    <span class="n">be</span><span class="o">-&gt;</span><span class="n">bBeaconType</span> <span class="o">==</span> <span class="n">UWB_RC_BEACON_TYPE_NOL_ALIEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uwb_beacon_frame</span> <span class="o">*</span><span class="p">)</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">BeaconInfo</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop beacons from devices with a NULL EUI-48 -- they cannot</span>
<span class="cm">	 * be uniquely identified.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It&#39;s expected that these will all be WUSB devices and they</span>
<span class="cm">	 * have a WUSB specific connection method so ignoring them</span>
<span class="cm">	 * here shouldn&#39;t be a problem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uwb_mac_addr_bcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">Device_Identifier</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">bce</span> <span class="o">=</span> <span class="n">__uwb_beca_find_bymac</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">Device_Identifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bce</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not in there, a new device is pinging */</span>
		<span class="n">uwb_beacon_print</span><span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">bf</span><span class="p">);</span>
		<span class="n">bce</span> <span class="o">=</span> <span class="n">__uwb_beca_add</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span> <span class="n">evt</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bce</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_beca</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="cm">/* purge old beacon data */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">be</span><span class="p">);</span>

	<span class="n">last_ts</span> <span class="o">=</span> <span class="n">bce</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span><span class="p">;</span>

	<span class="cm">/* Update commonly used fields */</span>
	<span class="n">bce</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span> <span class="o">=</span> <span class="n">evt</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span><span class="p">;</span>
	<span class="n">bce</span><span class="o">-&gt;</span><span class="n">be</span> <span class="o">=</span> <span class="n">be</span><span class="p">;</span>
	<span class="n">bce</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="o">=</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">SrcAddr</span><span class="p">;</span>
	<span class="n">bce</span><span class="o">-&gt;</span><span class="n">mac_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">Device_Identifier</span><span class="p">;</span>
	<span class="n">be</span><span class="o">-&gt;</span><span class="n">wBPSTOffset</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">be</span><span class="o">-&gt;</span><span class="n">wBPSTOffset</span><span class="p">);</span>
	<span class="n">be</span><span class="o">-&gt;</span><span class="n">wBeaconInfoLength</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">be</span><span class="o">-&gt;</span><span class="n">wBeaconInfoLength</span><span class="p">);</span>
	<span class="n">stats_add_sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">lqe_stats</span><span class="p">,</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">bLQI</span> <span class="o">-</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">stats_add_sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">rssi_stats</span><span class="p">,</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">bRSSI</span> <span class="o">+</span> <span class="mi">18</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This might be a beacon from a new device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">uwb_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">uwbd_dev_onair</span><span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">bce</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bce</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* we keep the event data */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle UWB_RC_EVT_BEACON_SIZE events</span>
<span class="cm"> *</span>
<span class="cm"> * XXXXX</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uwbd_evt_handle_rc_beacon_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_beacon_size</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>

	<span class="cm">/* Is there enough data to decode the event? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BEACON SIZE notification: Not enough data to &quot;</span>
			<span class="s">&quot;decode (%zu vs %zu bytes needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bs</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bs</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">rceb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_beacon_size</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Beacon size changed to %u bytes &quot;</span>
			<span class="s">&quot;(FIXME: action?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">wNewBeaconSize</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* temporary hack until we do something with this message... */</span>
		<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Beacon size changed %u times &quot;</span>
				<span class="s">&quot;(FIXME: action?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uwbd_evt_handle_rc_bp_slot_change - handle a BP_SLOT_CHANGE event</span>
<span class="cm"> * @evt: the BP_SLOT_CHANGE notification from the radio controller</span>
<span class="cm"> *</span>
<span class="cm"> * If the event indicates that no beacon period slots were available</span>
<span class="cm"> * then radio controller has transitioned to a non-beaconing state.</span>
<span class="cm"> * Otherwise, simply save the current beacon slot.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uwbd_evt_handle_rc_bp_slot_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">evt</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_bp_slot_change</span> <span class="o">*</span><span class="n">bpsc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bpsc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BP SLOT CHANGE event: Not enough data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bpsc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">rceb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_bp_slot_change</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uwb_rc_evt_bp_slot_change_no_slot</span><span class="p">(</span><span class="n">bpsc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;stopped beaconing: No free slots in BP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">beaconing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">beacon_slot</span> <span class="o">=</span> <span class="n">uwb_rc_evt_bp_slot_change_slot_num</span><span class="p">(</span><span class="n">bpsc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Handle UWB_RC_EVT_BPOIE_CHANGE events</span>
<span class="cm"> *</span>
<span class="cm"> * XXXXX</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_ie_bpo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_ie_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span>                <span class="n">bp_length</span><span class="p">;</span>
	<span class="n">u8</span>                <span class="n">data</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="kt">int</span> <span class="nf">uwbd_evt_handle_rc_bpoie_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_bpoie_change</span> <span class="o">*</span><span class="n">bpoiec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_ie_bpo</span> <span class="o">*</span><span class="n">bpoie</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>	<span class="cm">/* FIXME: this is a temp hack */</span>
	<span class="kt">size_t</span> <span class="n">iesize</span><span class="p">;</span>

	<span class="cm">/* Is there enough data to decode it? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bpoiec</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BPOIEC notification: Not enough data to &quot;</span>
			<span class="s">&quot;decode (%zu vs %zu bytes needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bpoiec</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bpoiec</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">rceb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_bpoie_change</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>
	<span class="n">iesize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">bpoiec</span><span class="o">-&gt;</span><span class="n">wBPOIELength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iesize</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bpoie</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BPOIEC notification: Not enough IE data to &quot;</span>
			<span class="s">&quot;decode (%zu vs %zu bytes needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">iesize</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bpoie</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* Lame placeholder */</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BPOIE: %u changes received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: At this point we should go over all the IEs in the</span>
<span class="cm">	 *        bpoiec-&gt;BPOIE array and act on each.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print beaconing state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">uwb_rc_beacon_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev</span> <span class="o">=</span> <span class="n">to_uwb_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">uwb_dev</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">beaconing</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start beaconing on the specified channel, or stop beaconing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">uwb_rc_beacon_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev</span> <span class="o">=</span> <span class="n">to_uwb_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">uwb_dev</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_radio_force_channel</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">beacon</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">uwb_rc_beacon_show</span><span class="p">,</span> <span class="n">uwb_rc_beacon_store</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
