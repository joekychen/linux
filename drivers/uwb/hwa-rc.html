<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › uwb › hwa-rc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hwa-rc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * WUSB Host Wire Adapter: Radio Control Interface (WUSB[8.6])</span>
<span class="cm"> * Radio Control command/event transport</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the Radio Control interface Driver.</span>
<span class="cm"> *</span>
<span class="cm"> * For each device probed, creates an &#39;struct hwarc&#39; which contains</span>
<span class="cm"> * just the representation of the UWB Radio Controller, and the logic</span>
<span class="cm"> * for reading notifications and passing them to the UWB Core.</span>
<span class="cm"> *</span>
<span class="cm"> * So we initialize all of those, register the UWB Radio Controller</span>
<span class="cm"> * and setup the notification/event handle to pipe the notifications</span>
<span class="cm"> * to the UWB management Daemon.</span>
<span class="cm"> *</span>
<span class="cm"> * Command and event filtering.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the driver for the Radio Control Interface described in WUSB</span>
<span class="cm"> * 1.0. The core UWB module assumes that all drivers are compliant to the</span>
<span class="cm"> * WHCI 0.95 specification. We thus create a filter that parses all</span>
<span class="cm"> * incoming messages from the (WUSB 1.0) device and manipulate them to</span>
<span class="cm"> * conform to the WHCI 0.95 specification. Similarly, outgoing messages</span>
<span class="cm"> * are parsed and manipulated to conform to the WUSB 1.0 compliant messages</span>
<span class="cm"> * that the device expects. Only a few messages are affected:</span>
<span class="cm"> * Affected events:</span>
<span class="cm"> *    UWB_RC_EVT_BEACON</span>
<span class="cm"> *    UWB_RC_EVT_BP_SLOT_CHANGE</span>
<span class="cm"> *    UWB_RC_EVT_DRP_AVAIL</span>
<span class="cm"> *    UWB_RC_EVT_DRP</span>
<span class="cm"> * Affected commands:</span>
<span class="cm"> *    UWB_RC_CMD_SCAN</span>
<span class="cm"> *    UWB_RC_CMD_SET_DRP_IE</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/wusb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/wusb-wa.h&gt;</span>
<span class="cp">#include &lt;linux/uwb.h&gt;</span>

<span class="cp">#include &quot;uwb-internal.h&quot;</span>

<span class="cm">/* The device uses commands and events from the WHCI specification, although</span>
<span class="cm"> * reporting itself as WUSB compliant. */</span>
<span class="cp">#define WUSB_QUIRK_WHCI_CMD_EVT		0x01</span>

<span class="cm">/**</span>
<span class="cm"> * Descriptor for an instance of the UWB Radio Control Driver that</span>
<span class="cm"> * attaches to the RCI interface of the Host Wired Adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * Unless there is a lock specific to the &#39;data members&#39;, all access</span>
<span class="cm"> * is protected by uwb_rc-&gt;mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * The NEEP (Notification/Event EndPoint) URB (@neep_urb) writes to</span>
<span class="cm"> * @rd_buffer. Note there is no locking because it is perfectly (heh!)</span>
<span class="cm"> * serialized--probe() submits an URB, callback is called, processes</span>
<span class="cm"> * the data (synchronously), submits another URB, and so on. There is</span>
<span class="cm"> * no concurrent access to the buffer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hwarc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">usb_iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span><span class="p">;</span>		<span class="cm">/* UWB host controller */</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">neep_urb</span><span class="p">;</span>		<span class="cm">/* Notification endpoint handling */</span>
	<span class="k">struct</span> <span class="n">edc</span> <span class="n">neep_edc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rd_buffer</span><span class="p">;</span>		<span class="cm">/* NEEP read buffer */</span>
<span class="p">};</span>


<span class="cm">/* Beacon received notification (WUSB 1.0 [8.6.3.2]) */</span>
<span class="k">struct</span> <span class="n">uwb_rc_evt_beacon_WUSB_0100</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="n">rceb</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">bChannelNumber</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">wBPSTOffset</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">bLQI</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">bRSSI</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">wBeaconInfoLength</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">BeaconInfo</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * Filter WUSB 1.0 BEACON RCV notification to be WHCI 0.95</span>
<span class="cm"> *</span>
<span class="cm"> * @header: the incoming event</span>
<span class="cm"> * @buf_size: size of buffer containing incoming event</span>
<span class="cm"> * @new_size: size of event after filtering completed</span>
<span class="cm"> *</span>
<span class="cm"> * The WHCI 0.95 spec has a &quot;Beacon Type&quot; field. This value is unknown at</span>
<span class="cm"> * the time we receive the beacon from WUSB so we just set it to</span>
<span class="cm"> * UWB_RC_BEACON_TYPE_NEIGHBOR as a default.</span>
<span class="cm"> * The solution below allocates memory upon receipt of every beacon from a</span>
<span class="cm"> * WUSB device. This will deteriorate performance. What is the right way to</span>
<span class="cm"> * do this?</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_evt_beacon_WUSB_0100</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="o">*</span><span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_beacon_WUSB_0100</span> <span class="o">*</span><span class="n">be</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_beacon</span> <span class="o">*</span><span class="n">newbe</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes_left</span><span class="p">,</span> <span class="n">ielength</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">be</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_beacon_WUSB_0100</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>
	<span class="n">bytes_left</span> <span class="o">=</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">be</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Beacon Received Notification: Not enough data &quot;</span>
			<span class="s">&quot;to decode for filtering (%zu vs %zu bytes needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bytes_left</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">be</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bytes_left</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">be</span><span class="p">);</span>
	<span class="n">ielength</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">be</span><span class="o">-&gt;</span><span class="n">wBeaconInfoLength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&lt;</span> <span class="n">ielength</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Beacon Received Notification: Not enough data &quot;</span>
			<span class="s">&quot;to decode IEs (%zu vs %zu bytes needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bytes_left</span><span class="p">,</span> <span class="n">ielength</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newbe</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newbe</span><span class="p">)</span> <span class="o">+</span> <span class="n">ielength</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newbe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">newbe</span><span class="o">-&gt;</span><span class="n">rceb</span> <span class="o">=</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">rceb</span><span class="p">;</span>
	<span class="n">newbe</span><span class="o">-&gt;</span><span class="n">bChannelNumber</span> <span class="o">=</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">bChannelNumber</span><span class="p">;</span>
	<span class="n">newbe</span><span class="o">-&gt;</span><span class="n">bBeaconType</span> <span class="o">=</span> <span class="n">UWB_RC_BEACON_TYPE_NEIGHBOR</span><span class="p">;</span>
	<span class="n">newbe</span><span class="o">-&gt;</span><span class="n">wBPSTOffset</span> <span class="o">=</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">wBPSTOffset</span><span class="p">;</span>
	<span class="n">newbe</span><span class="o">-&gt;</span><span class="n">bLQI</span> <span class="o">=</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">bLQI</span><span class="p">;</span>
	<span class="n">newbe</span><span class="o">-&gt;</span><span class="n">bRSSI</span> <span class="o">=</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">bRSSI</span><span class="p">;</span>
	<span class="n">newbe</span><span class="o">-&gt;</span><span class="n">wBeaconInfoLength</span> <span class="o">=</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">wBeaconInfoLength</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">newbe</span><span class="o">-&gt;</span><span class="n">BeaconInfo</span><span class="p">,</span> <span class="n">be</span><span class="o">-&gt;</span><span class="n">BeaconInfo</span><span class="p">,</span> <span class="n">ielength</span><span class="p">);</span>
	<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newbe</span><span class="o">-&gt;</span><span class="n">rceb</span><span class="p">;</span>
	<span class="o">*</span><span class="n">new_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newbe</span><span class="p">)</span> <span class="o">+</span> <span class="n">ielength</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* calling function will free memory */</span>
<span class="p">}</span>


<span class="cm">/* DRP Availability change notification (WUSB 1.0 [8.6.3.8]) */</span>
<span class="k">struct</span> <span class="n">uwb_rc_evt_drp_avail_WUSB_0100</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="n">rceb</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">wIELength</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">IEData</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * Filter WUSB 1.0 DRP AVAILABILITY CHANGE notification to be WHCI 0.95</span>
<span class="cm"> *</span>
<span class="cm"> * @header: the incoming event</span>
<span class="cm"> * @buf_size: size of buffer containing incoming event</span>
<span class="cm"> * @new_size: size of event after filtering completed</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_evt_drp_avail_WUSB_0100</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="o">*</span><span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_drp_avail_WUSB_0100</span> <span class="o">*</span><span class="n">da</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_drp_avail</span> <span class="o">*</span><span class="n">newda</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_ie_hdr</span> <span class="o">*</span><span class="n">ie_hdr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes_left</span><span class="p">,</span> <span class="n">ielength</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>


	<span class="n">da</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_drp_avail_WUSB_0100</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>
	<span class="n">bytes_left</span> <span class="o">=</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">da</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not enough data to decode DRP Avail &quot;</span>
			<span class="s">&quot;Notification for filtering. Expected %zu, &quot;</span>
			<span class="s">&quot;received %zu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">da</span><span class="p">),</span> <span class="n">bytes_left</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bytes_left</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">da</span><span class="p">);</span>
	<span class="n">ielength</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">da</span><span class="o">-&gt;</span><span class="n">wIELength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&lt;</span> <span class="n">ielength</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DRP Avail Notification filter: IE length &quot;</span>
			<span class="s">&quot;[%zu bytes] does not match actual length &quot;</span>
			<span class="s">&quot;[%zu bytes].</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ielength</span><span class="p">,</span> <span class="n">bytes_left</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ielength</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ie_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DRP Avail Notification filter: Not enough &quot;</span>
			<span class="s">&quot;data to decode IE [%zu bytes, %zu needed]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ielength</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ie_hdr</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ie_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">da</span><span class="o">-&gt;</span><span class="n">IEData</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ie_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DRP Availability Change event has unexpected &quot;</span>
			<span class="s">&quot;length for filtering. Expected &lt; 32 bytes, &quot;</span>
			<span class="s">&quot;got %zu bytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">ie_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newda</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newda</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newda</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">newda</span><span class="o">-&gt;</span><span class="n">rceb</span> <span class="o">=</span> <span class="n">da</span><span class="o">-&gt;</span><span class="n">rceb</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">newda</span><span class="o">-&gt;</span><span class="n">bmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">ie_hdr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ie_hdr</span><span class="p">),</span> <span class="n">ie_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newda</span><span class="o">-&gt;</span><span class="n">rceb</span><span class="p">;</span>
	<span class="o">*</span><span class="n">new_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newda</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* calling function will free memory */</span>
<span class="p">}</span>


<span class="cm">/* DRP notification (WUSB 1.0 [8.6.3.9]) */</span>
<span class="k">struct</span> <span class="n">uwb_rc_evt_drp_WUSB_0100</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="n">rceb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="n">wSrcAddr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bExplicit</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">wIELength</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">IEData</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * Filter WUSB 1.0 DRP Notification to be WHCI 0.95</span>
<span class="cm"> *</span>
<span class="cm"> * @header: the incoming event</span>
<span class="cm"> * @buf_size: size of buffer containing incoming event</span>
<span class="cm"> * @new_size: size of event after filtering completed</span>
<span class="cm"> *</span>
<span class="cm"> * It is hard to manage DRP reservations without having a Reason code.</span>
<span class="cm"> * Unfortunately there is none in the WUSB spec. We just set the default to</span>
<span class="cm"> * DRP IE RECEIVED.</span>
<span class="cm"> * We do not currently use the bBeaconSlotNumber value, so we set this to</span>
<span class="cm"> * zero for now.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_evt_drp_WUSB_0100</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="o">*</span><span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_drp_WUSB_0100</span> <span class="o">*</span><span class="n">drpev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_evt_drp</span> <span class="o">*</span><span class="n">newdrpev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes_left</span><span class="p">,</span> <span class="n">ielength</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">drpev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_evt_drp_WUSB_0100</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>
	<span class="n">bytes_left</span> <span class="o">=</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">drpev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not enough data to decode DRP Notification &quot;</span>
			<span class="s">&quot;for filtering. Expected %zu, received %zu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">drpev</span><span class="p">),</span> <span class="n">bytes_left</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ielength</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">drpev</span><span class="o">-&gt;</span><span class="n">wIELength</span><span class="p">);</span>
	<span class="n">bytes_left</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">drpev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&lt;</span> <span class="n">ielength</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DRP Notification filter: header length [%zu &quot;</span>
			<span class="s">&quot;bytes] does not match actual length [%zu &quot;</span>
			<span class="s">&quot;bytes].</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ielength</span><span class="p">,</span> <span class="n">bytes_left</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newdrpev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newdrpev</span><span class="p">)</span> <span class="o">+</span> <span class="n">ielength</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newdrpev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">newdrpev</span><span class="o">-&gt;</span><span class="n">rceb</span> <span class="o">=</span> <span class="n">drpev</span><span class="o">-&gt;</span><span class="n">rceb</span><span class="p">;</span>
	<span class="n">newdrpev</span><span class="o">-&gt;</span><span class="n">src_addr</span> <span class="o">=</span> <span class="n">drpev</span><span class="o">-&gt;</span><span class="n">wSrcAddr</span><span class="p">;</span>
	<span class="n">newdrpev</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">=</span> <span class="n">UWB_DRP_NOTIF_DRP_IE_RCVD</span><span class="p">;</span>
	<span class="n">newdrpev</span><span class="o">-&gt;</span><span class="n">beacon_slot_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">newdrpev</span><span class="o">-&gt;</span><span class="n">ie_length</span> <span class="o">=</span> <span class="n">drpev</span><span class="o">-&gt;</span><span class="n">wIELength</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">newdrpev</span><span class="o">-&gt;</span><span class="n">ie_data</span><span class="p">,</span> <span class="n">drpev</span><span class="o">-&gt;</span><span class="n">IEData</span><span class="p">,</span> <span class="n">ielength</span><span class="p">);</span>
	<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newdrpev</span><span class="o">-&gt;</span><span class="n">rceb</span><span class="p">;</span>
	<span class="o">*</span><span class="n">new_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newdrpev</span><span class="p">)</span> <span class="o">+</span> <span class="n">ielength</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* calling function will free memory */</span>
<span class="p">}</span>


<span class="cm">/* Scan Command (WUSB 1.0 [8.6.2.5]) */</span>
<span class="k">struct</span> <span class="n">uwb_rc_cmd_scan_WUSB_0100</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="n">rccb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bChannelNumber</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bScanState</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * Filter WHCI 0.95 SCAN command to be WUSB 1.0 SCAN command</span>
<span class="cm"> *</span>
<span class="cm"> * @header:   command sent to device (compliant to WHCI 0.95)</span>
<span class="cm"> * @size:     size of command sent to device</span>
<span class="cm"> *</span>
<span class="cm"> * We only reduce the size by two bytes because the WUSB 1.0 scan command</span>
<span class="cm"> * does not have the last field (wStarttime). Also, make sure we don&#39;t send</span>
<span class="cm"> * the device an unexpected scan type.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_cmd_scan_WUSB_0100</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_cmd_scan</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_cmd_scan</span><span class="p">,</span> <span class="n">rccb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">bScanState</span> <span class="o">==</span> <span class="n">UWB_SCAN_ONLY_STARTTIME</span><span class="p">)</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">bScanState</span> <span class="o">=</span> <span class="n">UWB_SCAN_ONLY</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t send the last two bytes. */</span>
	<span class="o">*</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* SET DRP IE command (WUSB 1.0 [8.6.2.7]) */</span>
<span class="k">struct</span> <span class="n">uwb_rc_cmd_set_drp_ie_WUSB_0100</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="n">rccb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bExplicit</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">wIELength</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_ie_drp</span> <span class="n">IEData</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * Filter WHCI 0.95 SET DRP IE command to be WUSB 1.0 SET DRP IE command</span>
<span class="cm"> *</span>
<span class="cm"> * @header:   command sent to device (compliant to WHCI 0.95)</span>
<span class="cm"> * @size:     size of command sent to device</span>
<span class="cm"> *</span>
<span class="cm"> * WUSB has an extra bExplicit field - we assume always explicit</span>
<span class="cm"> * negotiation so this field is set. The command expected by the device is</span>
<span class="cm"> * thus larger than the one prepared by the driver so we need to</span>
<span class="cm"> * reallocate memory to accommodate this.</span>
<span class="cm"> * We trust the driver to send us the correct data so no checking is done</span>
<span class="cm"> * on incoming data - evn though it is variable length.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_cmd_set_drp_ie_WUSB_0100</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_cmd_set_drp_ie</span> <span class="o">*</span><span class="n">orgcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_cmd_set_drp_ie_WUSB_0100</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ielength</span><span class="p">;</span>

	<span class="n">orgcmd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_cmd_set_drp_ie</span><span class="p">,</span> <span class="n">rccb</span><span class="p">);</span>
	<span class="n">ielength</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">orgcmd</span><span class="o">-&gt;</span><span class="n">wIELength</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">)</span> <span class="o">+</span> <span class="n">ielength</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rccb</span> <span class="o">=</span> <span class="n">orgcmd</span><span class="o">-&gt;</span><span class="n">rccb</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">bExplicit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wIELength</span> <span class="o">=</span> <span class="n">orgcmd</span><span class="o">-&gt;</span><span class="n">wIELength</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">IEData</span><span class="p">,</span> <span class="n">orgcmd</span><span class="o">-&gt;</span><span class="n">IEData</span><span class="p">,</span> <span class="n">ielength</span><span class="p">);</span>
	<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rccb</span><span class="p">;</span>
	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">)</span> <span class="o">+</span> <span class="n">ielength</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* calling function will free memory */</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Filter data from WHCI driver to WUSB device</span>
<span class="cm"> *</span>
<span class="cm"> * @header: WHCI 0.95 compliant command from driver</span>
<span class="cm"> * @size:   length of command</span>
<span class="cm"> *</span>
<span class="cm"> * The routine managing commands to the device (uwb_rc_cmd()) will call the</span>
<span class="cm"> * filtering function pointer (if it exists) before it passes any data to</span>
<span class="cm"> * the device. At this time the command has been formatted according to</span>
<span class="cm"> * WHCI 0.95 and is ready to be sent to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * The filter function will be provided with the current command and its</span>
<span class="cm"> * length. The function will manipulate the command if necessary and</span>
<span class="cm"> * potentially reallocate memory for a command that needed more memory that</span>
<span class="cm"> * the given command. If new memory was created the function will return 1</span>
<span class="cm"> * to indicate to the calling function that the memory need to be freed</span>
<span class="cm"> * when not needed any more. The size will contain the new length of the</span>
<span class="cm"> * command.</span>
<span class="cm"> * If memory has not been allocated we rely on the original mechanisms to</span>
<span class="cm"> * free the memory of the command - even when we reduce the value of size.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_cmd_WUSB_0100</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="n">rccb</span> <span class="o">=</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rccb</span><span class="o">-&gt;</span><span class="n">wCommand</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UWB_RC_CMD_SCAN</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">hwarc_filter_cmd_scan_WUSB_0100</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UWB_RC_CMD_SET_DRP_IE</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">hwarc_filter_cmd_set_drp_ie_WUSB_0100</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOANO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Filter data from WHCI driver to WUSB device</span>
<span class="cm"> *</span>
<span class="cm"> * @header: WHCI 0.95 compliant command from driver</span>
<span class="cm"> * @size:   length of command</span>
<span class="cm"> *</span>
<span class="cm"> * Filter commands based on which protocol the device supports. The WUSB</span>
<span class="cm"> * errata should be the same as WHCI 0.95 so we do not filter that here -</span>
<span class="cm"> * only WUSB 1.0.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOANO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">==</span> <span class="mh">0x0100</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hwarc_filter_cmd_WUSB_0100</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Compute return value as sum of incoming value and value at given offset</span>
<span class="cm"> *</span>
<span class="cm"> * @rceb:      event for which we compute the size, it contains a variable</span>
<span class="cm"> *	       length field.</span>
<span class="cm"> * @core_size: size of the &quot;non variable&quot; part of the event</span>
<span class="cm"> * @offset:    place in event where the length of the variable part is stored</span>
<span class="cm"> * @buf_size: total length of buffer in which event arrived - we need to make</span>
<span class="cm"> *	       sure we read the offset in memory that is still part of the event</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">ssize_t</span> <span class="nf">hwarc_get_event_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">core_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">rceb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">type_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le16</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">type_size</span> <span class="o">&gt;=</span> <span class="n">buf_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not enough data to read extra size of event &quot;</span>
			<span class="s">&quot;0x%02x/%04x/%02x, only got %zu bytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span><span class="p">),</span>
			<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">core_size</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Beacon slot change notification (WUSB 1.0 [8.6.3.5]) */</span>
<span class="k">struct</span> <span class="n">uwb_rc_evt_bp_slot_change_WUSB_0100</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="n">rceb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bSlotNumber</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="cm">/**</span>
<span class="cm"> * Filter data from WUSB device to WHCI driver</span>
<span class="cm"> *</span>
<span class="cm"> * @header:	 incoming event</span>
<span class="cm"> * @buf_size:	 size of buffer in which event arrived</span>
<span class="cm"> * @_event_size: actual size of event in the buffer</span>
<span class="cm"> * @new_size:	 size of event after filtered</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t know how the buffer is constructed - there may be more than one</span>
<span class="cm"> * event in it so buffer length does not determine event length. We first</span>
<span class="cm"> * determine the expected size of the incoming event. This value is passed</span>
<span class="cm"> * back only if the actual filtering succeeded (so we know the computed</span>
<span class="cm"> * expected size is correct). This value will be zero if</span>
<span class="cm"> * the event did not need any filtering.</span>
<span class="cm"> *</span>
<span class="cm"> * WHCI interprets the BP Slot Change event&#39;s data differently than</span>
<span class="cm"> * WUSB. The event sizes are exactly the same. The data field</span>
<span class="cm"> * indicates the new beacon slot in which a RC is transmitting its</span>
<span class="cm"> * beacon. The maximum value of this is 96 (wMacBPLength ECMA-368</span>
<span class="cm"> * 17.16 (Table 117)). We thus know that the WUSB value will not set</span>
<span class="cm"> * the bit bNoSlot, so we don&#39;t really do anything (placeholder).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_event_WUSB_0100</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">_real_size</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="o">*</span><span class="n">_new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOANO</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span> <span class="o">=</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">event</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">event_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">core_size</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span> <span class="o">!=</span> <span class="n">UWB_RC_CET_GENERAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UWB_RC_EVT_BEACON</span>:
		<span class="n">core_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_evt_beacon_WUSB_0100</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_evt_beacon_WUSB_0100</span><span class="p">,</span>
				  <span class="n">wBeaconInfoLength</span><span class="p">);</span>
		<span class="n">event_size</span> <span class="o">=</span> <span class="n">hwarc_get_event_size</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">core_size</span><span class="p">,</span>
						  <span class="n">offset</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="o">*</span><span class="n">_real_size</span> <span class="o">=</span> <span class="n">event_size</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hwarc_filter_evt_beacon_WUSB_0100</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span>
							   <span class="n">buf_size</span><span class="p">,</span> <span class="n">_new_size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UWB_RC_EVT_BP_SLOT_CHANGE</span>:
		<span class="o">*</span><span class="n">_new_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">_real_size</span> <span class="o">=</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_evt_bp_slot_change_WUSB_0100</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">UWB_RC_EVT_DRP_AVAIL</span>:
		<span class="n">core_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_evt_drp_avail_WUSB_0100</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_evt_drp_avail_WUSB_0100</span><span class="p">,</span>
				  <span class="n">wIELength</span><span class="p">);</span>
		<span class="n">event_size</span> <span class="o">=</span> <span class="n">hwarc_get_event_size</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">core_size</span><span class="p">,</span>
						  <span class="n">offset</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="o">*</span><span class="n">_real_size</span> <span class="o">=</span> <span class="n">event_size</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hwarc_filter_evt_drp_avail_WUSB_0100</span><span class="p">(</span>
			<span class="n">rc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">_new_size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">UWB_RC_EVT_DRP</span>:
		<span class="n">core_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_evt_drp_WUSB_0100</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_evt_drp_WUSB_0100</span><span class="p">,</span> <span class="n">wIELength</span><span class="p">);</span>
		<span class="n">event_size</span> <span class="o">=</span> <span class="n">hwarc_get_event_size</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">core_size</span><span class="p">,</span>
						  <span class="n">offset</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="o">*</span><span class="n">_real_size</span> <span class="o">=</span> <span class="n">event_size</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">hwarc_filter_evt_drp_WUSB_0100</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span>
							<span class="n">buf_size</span><span class="p">,</span> <span class="n">_new_size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Filter data from WUSB device to WHCI driver</span>
<span class="cm"> *</span>
<span class="cm"> * @header:	 incoming event</span>
<span class="cm"> * @buf_size:	 size of buffer in which event arrived</span>
<span class="cm"> * @_event_size: actual size of event in the buffer</span>
<span class="cm"> * @_new_size:	 size of event after filtered</span>
<span class="cm"> *</span>
<span class="cm"> * Filter events based on which protocol the device supports. The WUSB</span>
<span class="cm"> * errata should be the same as WHCI 0.95 so we do not filter that here -</span>
<span class="cm"> * only WUSB 1.0.</span>
<span class="cm"> *</span>
<span class="cm"> * If we don&#39;t handle it, we return -ENOANO (why the weird error code?</span>
<span class="cm"> * well, so if I get it, I can pinpoint in the code that raised</span>
<span class="cm"> * it...after all, not too many places use the higher error codes).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_filter_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">**</span><span class="n">header</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">_real_size</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="o">*</span><span class="n">_new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOANO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">==</span> <span class="mh">0x0100</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span>  <span class="n">hwarc_filter_event_WUSB_0100</span><span class="p">(</span>
			<span class="n">rc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">_real_size</span><span class="p">,</span> <span class="n">_new_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Execute an UWB RC command on HWA</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:	      Instance of a Radio Controller that is a HWA</span>
<span class="cm"> * @cmd:      Buffer containing the RCCB and payload to execute</span>
<span class="cm"> * @cmd_size: Size of the command buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: rc&#39;s mutex has to be locked</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cmd_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span>
		<span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">WA_EXEC_RC_CMD</span><span class="p">,</span> <span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">,</span> <span class="mi">100</span> <span class="cm">/* FIXME: this is totally arbitrary */</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">hwarc_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usb_reset_device</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Callback for the notification and event endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * Check&#39;s that everything is fine and then passes the read data to</span>
<span class="cm"> * the notification/event handling mechanism (neh).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">hwarc_neep_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">usb_iface</span> <span class="o">=</span> <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">uwb_rc_neh_grok</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">uwb_rc</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:	<span class="cm">/* Not an error, but a controlled situation; */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* (we killed the URB)...so, no broadcast */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* going away! */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="cm">/* On general errors, retry unless it gets ugly */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edc_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_edc</span><span class="p">,</span> <span class="n">EDC_MAX_ERRORS</span><span class="p">,</span>
			    <span class="n">EDC_ERROR_TIMEFRAME</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error_exceeded</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NEEP: URB error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ignoring unrecoverable errors */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NEEP: Can&#39;t resubmit URB (%d) resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error_exceeded:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NEEP: URB max acceptable errors &quot;</span>
		<span class="s">&quot;exceeded, resetting device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">uwb_rc_neh_error</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">uwb_rc</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="n">uwb_rc_reset_all</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">uwb_rc</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hwarc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edc_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_edc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize the notification/event endpoint stuff</span>
<span class="cm"> *</span>
<span class="cm"> * Note this is effectively a parallel thread; it knows that</span>
<span class="cm"> * hwarc-&gt;uwb_rc always exists because the existence of a &#39;hwarc&#39;</span>
<span class="cm"> * means that there is a reverence on the hwarc-&gt;uwb_rc (see</span>
<span class="cm"> * _probe()), and thus _neep_cb() can execute safely.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hwarc_neep_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">epd</span><span class="p">;</span>

	<span class="n">epd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">rd_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">rd_buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate notification&#39;s read buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_rd_buffer</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate notification URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_urb_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_urb</span><span class="p">,</span> <span class="n">usb_dev</span><span class="p">,</span>
			 <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">usb_dev</span><span class="p">,</span> <span class="n">epd</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">),</span>
			 <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">rd_buffer</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			 <span class="n">hwarc_neep_cb</span><span class="p">,</span> <span class="n">hwarc</span><span class="p">,</span> <span class="n">epd</span><span class="o">-&gt;</span><span class="n">bInterval</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot submit notification URB: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_neep_submit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_neep_submit:</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_urb</span><span class="p">);</span>
<span class="nl">error_urb_alloc:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">rd_buffer</span><span class="p">);</span>
<span class="nl">error_rd_buffer:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Clean up all the notification endpoint resources */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hwarc_neep_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_urb</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">neep_urb</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">rd_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the version from class-specific descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this descriptor comes with the big bundled configuration</span>
<span class="cm"> *	 descriptor that includes the interfaces&#39; and endpoints&#39;, so</span>
<span class="cm"> *	 we just look for it in the cached copy kept by the USB stack.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE2: We convert LE fields to CPU order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hwarc_get_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_control_intf_class_desc</span> <span class="o">*</span><span class="n">descr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">itr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">itr_size</span><span class="p">,</span> <span class="n">actconfig_idx</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">version</span><span class="p">;</span>

	<span class="n">actconfig_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">actconfig</span> <span class="o">-</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">)</span> <span class="o">/</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">itr</span> <span class="o">=</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">rawdescriptors</span><span class="p">[</span><span class="n">actconfig_idx</span><span class="p">];</span>
	<span class="n">itr_size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">actconfig</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">wTotalLength</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">itr_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">*</span><span class="p">)</span> <span class="n">itr</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Extra device descriptor: &quot;</span>
			<span class="s">&quot;type %02x/%u bytes @ %zu (%zu left)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">,</span>
			<span class="p">(</span><span class="n">itr</span> <span class="o">-</span> <span class="n">usb_dev</span><span class="o">-&gt;</span><span class="n">rawdescriptors</span><span class="p">[</span><span class="n">actconfig_idx</span><span class="p">]),</span>
			<span class="n">itr_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">==</span> <span class="n">USB_DT_CS_RADIO_CONTROL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="n">itr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
		<span class="n">itr_size</span> <span class="o">-=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot find Radio Control Interface Class descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">&gt;</span> <span class="n">itr_size</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* is it available? */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;incomplete Radio Control Interface Class &quot;</span>
			<span class="s">&quot;descriptor (%zu bytes left, %u needed)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">itr_size</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">descr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;short Radio Control Interface Class &quot;</span>
			<span class="s">&quot;descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">descr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_control_intf_class_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="cm">/* Make LE fields CPU order */</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">__le16_to_cpu</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">bcdRCIVersion</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">!=</span> <span class="mh">0x0100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device reports protocol version 0x%04x. We &quot;</span>
			<span class="s">&quot;do not support that. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Device supports WUSB protocol version 0x%04x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>	<span class="n">rc</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * By creating a &#39;uwb_rc&#39;, we have a reference on it -- that reference</span>
<span class="cm"> * is the one we drop when we disconnect.</span>
<span class="cm"> *</span>
<span class="cm"> * No need to switch altsettings; according to WUSB1.0[8.6.1.1], there</span>
<span class="cm"> * is only one altsetting allowed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hwarc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">uwb_rc</span> <span class="o">=</span> <span class="n">uwb_rc_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uwb_rc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to allocate RC instance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_rc_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hwarc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hwarc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwarc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to allocate HWA RC instance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hwarc_init</span><span class="p">(</span><span class="n">hwarc</span><span class="p">);</span>
	<span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_dev</span> <span class="o">=</span> <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">iface</span><span class="p">));</span>
	<span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_iface</span> <span class="o">=</span> <span class="n">usb_get_intf</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">uwb_rc</span> <span class="o">=</span> <span class="n">uwb_rc</span><span class="p">;</span>

	<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">hwarc_neep_init</span><span class="p">;</span>
	<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">hwarc_neep_release</span><span class="p">;</span>
	<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">cmd</span>   <span class="o">=</span> <span class="n">hwarc_cmd</span><span class="p">;</span>
	<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="o">=</span> <span class="n">hwarc_reset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span> <span class="o">&amp;</span> <span class="n">WUSB_QUIRK_WHCI_CMD_EVT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">filter_cmd</span>   <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">filter_event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">filter_cmd</span>   <span class="o">=</span> <span class="n">hwarc_filter_cmd</span><span class="p">;</span>
		<span class="n">uwb_rc</span><span class="o">-&gt;</span><span class="n">filter_event</span> <span class="o">=</span> <span class="n">hwarc_filter_event</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">uwb_rc_add</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">hwarc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_rc_add</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">hwarc_get_version</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot retrieve version of RC </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_get_version</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">hwarc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_get_version:</span>
	<span class="n">uwb_rc_rm</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">);</span>
<span class="nl">error_rc_add:</span>
	<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">);</span>
<span class="nl">error_alloc:</span>
	<span class="n">uwb_rc_put</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">);</span>
<span class="nl">error_rc_alloc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hwarc_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span> <span class="o">=</span> <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">uwb_rc</span><span class="p">;</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">uwb_rc_rm</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">);</span>
	<span class="n">usb_put_intf</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_iface</span><span class="p">);</span>
	<span class="n">usb_put_dev</span><span class="p">(</span><span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">usb_dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hwarc</span><span class="p">);</span>
	<span class="n">uwb_rc_put</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">);</span>	<span class="cm">/* when creating the device, refcount = 1 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hwarc_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span> <span class="o">=</span> <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">uwb_rc</span><span class="p">;</span>

	<span class="n">uwb_rc_pre_reset</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hwarc_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwarc</span> <span class="o">*</span><span class="n">hwarc</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span> <span class="o">=</span> <span class="n">hwarc</span><span class="o">-&gt;</span><span class="n">uwb_rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">uwb_rc_post_reset</span><span class="p">(</span><span class="n">uwb_rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/** USB device ID&#39;s that we handle */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">hwarc_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* D-Link DUB-1210 */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE_AND_INTERFACE_INFO</span><span class="p">(</span><span class="mh">0x07d1</span><span class="p">,</span> <span class="mh">0x3d02</span><span class="p">,</span> <span class="mh">0xe0</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">WUSB_QUIRK_WHCI_CMD_EVT</span> <span class="p">},</span>
	<span class="cm">/* Intel i1480 (using firmware 1.3PA2-20070828) */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE_AND_INTERFACE_INFO</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x0c3b</span><span class="p">,</span> <span class="mh">0xe0</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">WUSB_QUIRK_WHCI_CMD_EVT</span> <span class="p">},</span>
	<span class="cm">/* Generic match for the Radio Control interface */</span>
	<span class="p">{</span> <span class="n">USB_INTERFACE_INFO</span><span class="p">(</span><span class="mh">0xe0</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">hwarc_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">hwarc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;hwa-rc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">hwarc_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">hwarc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">hwarc_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_reset</span> <span class="o">=</span>    <span class="n">hwarc_pre_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_reset</span> <span class="o">=</span>   <span class="n">hwarc_post_reset</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">hwarc_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Host Wireless Adapter Radio Control Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
