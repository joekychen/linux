<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › uwb › neh.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>neh.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * WUSB Wire Adapter: Radio Control Interface (WUSB[8])</span>
<span class="cm"> * Notification and Event Handling</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The RC interface of the Host Wire Adapter (USB dongle) or WHCI PCI</span>
<span class="cm"> * card delivers a stream of notifications and events to the</span>
<span class="cm"> * notification end event endpoint or area. This code takes care of</span>
<span class="cm"> * getting a buffer with that data, breaking it up in separate</span>
<span class="cm"> * notifications and events and then deliver those.</span>
<span class="cm"> *</span>
<span class="cm"> * Events are answers to commands and they carry a context ID that</span>
<span class="cm"> * associates them to the command. Notifications are that,</span>
<span class="cm"> * notifications, they come out of the blue and have a context ID of</span>
<span class="cm"> * zero. Think of the context ID kind of like a handler. The</span>
<span class="cm"> * uwb_rc_neh_* code deals with managing context IDs.</span>
<span class="cm"> *</span>
<span class="cm"> * This is why you require a handle to operate on a UWB host. When you</span>
<span class="cm"> * open a handle a context ID is assigned to you.</span>
<span class="cm"> *</span>
<span class="cm"> * So, as it is done is:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Add an event handler [uwb_rc_neh_add()] (assigns a ctx id)</span>
<span class="cm"> * 2. Issue command [rc-&gt;cmd(rc, ...)]</span>
<span class="cm"> * 3. Arm the timeout timer [uwb_rc_neh_arm()]</span>
<span class="cm"> * 4, Release the reference to the neh [uwb_rc_neh_put()]</span>
<span class="cm"> * 5. Wait for the callback</span>
<span class="cm"> * 6. Command result (RCEB) is passed to the callback</span>
<span class="cm"> *</span>
<span class="cm"> * If (2) fails, you should remove the handle [uwb_rc_neh_rm()]</span>
<span class="cm"> * instead of arming the timer.</span>
<span class="cm"> *</span>
<span class="cm"> * Handles are for using in *serialized* code, single thread.</span>
<span class="cm"> *</span>
<span class="cm"> * When the notification/event comes, the IRQ handler/endpoint</span>
<span class="cm"> * callback passes the data read to uwb_rc_neh_grok() which will break</span>
<span class="cm"> * it up in a discrete series of events, look up who is listening for</span>
<span class="cm"> * them and execute the pertinent callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * If the reader detects an error while reading the data stream, call</span>
<span class="cm"> * uwb_rc_neh_error().</span>
<span class="cm"> *</span>
<span class="cm"> * CONSTRAINTS/ASSUMPTIONS:</span>
<span class="cm"> *</span>
<span class="cm"> * - Most notifications/events are small (less thank .5k), copying</span>
<span class="cm"> *   around is ok.</span>
<span class="cm"> *</span>
<span class="cm"> * - Notifications/events are ALWAYS smaller than PAGE_SIZE</span>
<span class="cm"> *</span>
<span class="cm"> * - Notifications/events always come in a single piece (ie: a buffer</span>
<span class="cm"> *   will always contain entire notifications/events).</span>
<span class="cm"> *</span>
<span class="cm"> * - we cannot know in advance how long each event is (because they</span>
<span class="cm"> *   lack a length field in their header--smart move by the standards</span>
<span class="cm"> *   body, btw). So we need a facility to get the event size given the</span>
<span class="cm"> *   header. This is what the EST code does (notif/Event Size</span>
<span class="cm"> *   Tables), check nest.c--as well, you can associate the size to</span>
<span class="cm"> *   the handle [w/ neh-&gt;extra_size()].</span>
<span class="cm"> *</span>
<span class="cm"> * - Most notifications/events are fixed size; only a few are variable</span>
<span class="cm"> *   size (NEST takes care of that).</span>
<span class="cm"> *</span>
<span class="cm"> * - Listeners of events expect them, so they usually provide a</span>
<span class="cm"> *   buffer, as they know the size. Listeners to notifications don&#39;t,</span>
<span class="cm"> *   so we allocate their buffers dynamically.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &quot;uwb-internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * UWB Radio Controller Notification/Event Handle</span>
<span class="cm"> *</span>
<span class="cm"> * Represents an entity waiting for an event coming from the UWB Radio</span>
<span class="cm"> * Controller with a given context id (context) and type (evt_type and</span>
<span class="cm"> * evt). On reception of the notification/event, the callback (cb) is</span>
<span class="cm"> * called with the event.</span>
<span class="cm"> *</span>
<span class="cm"> * If the timer expires before the event is received, the callback is</span>
<span class="cm"> * called with -ETIMEDOUT as the event size.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">evt_type</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">evt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">completed</span><span class="p">;</span>
	<span class="n">uwb_rc_cmd_cb_f</span> <span class="n">cb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">uwb_rc_neh_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uwb_rc_neh_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uwb_rc_neh_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_rc_neh_put - release reference to a neh</span>
<span class="cm"> * @neh: the neh</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uwb_rc_neh_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">uwb_rc_neh_release</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Assigns @neh a context id from @rc&#39;s pool</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:	    UWB Radio Controller descriptor; @rc-&gt;neh_lock taken</span>
<span class="cm"> * @neh:    Notification/Event Handle</span>
<span class="cm"> * @returns 0 if context id was assigned ok; &lt; 0 errno on error (if</span>
<span class="cm"> *	    all the context IDs are taken).</span>
<span class="cm"> *</span>
<span class="cm"> * (assumes @wa is locked).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: WUSB spec reserves context ids 0x00 for notifications and</span>
<span class="cm"> *	 0xff is invalid, so they must not be used. Initialization</span>
<span class="cm"> *	 fills up those two in the bitmap so they are not allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * We spread the allocation around to reduce the possibility of two</span>
<span class="cm"> * consecutive opened @neh&#39;s getting the same context ID assigned (to</span>
<span class="cm"> * avoid surprises with late events that timed out long time ago). So</span>
<span class="cm"> * first we search from where @rc-&gt;ctx_roll is, if not found, we</span>
<span class="cm"> * search from zero.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">__uwb_rc_ctx_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_bm</span><span class="p">,</span> <span class="n">UWB_RC_CTX_MAX</span><span class="p">,</span>
				    <span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_roll</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">UWB_RC_CTX_MAX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_bm</span><span class="p">,</span> <span class="n">UWB_RC_CTX_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">UWB_RC_CTX_MAX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_bm</span><span class="p">);</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Releases @neh&#39;s context ID back to @rc (@rc-&gt;neh_lock is locked). */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">__uwb_rc_ctx_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_bm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;context %u not set in bitmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_bm</span><span class="p">);</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_rc_neh_add - add a neh for a radio controller command</span>
<span class="cm"> * @rc:             the radio controller</span>
<span class="cm"> * @cmd:            the radio controller command</span>
<span class="cm"> * @expected_type:  the type of the expected response event</span>
<span class="cm"> * @expected_event: the expected event ID</span>
<span class="cm"> * @cb:             callback for when the event is received</span>
<span class="cm"> * @arg:            argument for the callback</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a neh and adds it to the list of those waiting for an</span>
<span class="cm"> * event.  A context ID will be assigned to the command.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="nf">uwb_rc_neh_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="n">expected_type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">expected_event</span><span class="p">,</span>
				  <span class="n">uwb_rc_cmd_cb_f</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">;</span>

	<span class="n">neh</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">neh</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_kzalloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">uwb_rc_neh_timer</span><span class="p">;</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span>     <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">neh</span><span class="p">;</span>

	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">rc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">evt_type</span> <span class="o">=</span> <span class="n">expected_type</span><span class="p">;</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">evt</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">expected_event</span><span class="p">);</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__uwb_rc_ctx_get</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">bCommandContext</span> <span class="o">=</span> <span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_list</span><span class="p">);</span>
		<span class="n">uwb_rc_neh_get</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_ctx_get</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">neh</span><span class="p">;</span>

<span class="nl">error_ctx_get:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
<span class="nl">error_kzalloc:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot open handle to radio controller: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__uwb_rc_neh_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__uwb_rc_ctx_put</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_rc_neh_rm - remove a neh.</span>
<span class="cm"> * @rc:  the radio controller</span>
<span class="cm"> * @neh: the neh to remove</span>
<span class="cm"> *</span>
<span class="cm"> * Remove an active neh immediately instead of waiting for the event</span>
<span class="cm"> * (or a time out).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uwb_rc_neh_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__uwb_rc_neh_rm</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">uwb_rc_neh_put</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_rc_neh_arm - arm an event handler timeout timer</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:     UWB Radio Controller</span>
<span class="cm"> * @neh:    Notification/event handler for @rc</span>
<span class="cm"> *</span>
<span class="cm"> * The timer is only armed if the neh is active.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uwb_rc_neh_arm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">UWB_RC_CMD_TIMEOUT_MS</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uwb_rc_neh_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">)(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">uwb_rc_neh_put</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">uwb_rc_neh_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">neh</span><span class="o">-&gt;</span><span class="n">evt_type</span> <span class="o">==</span> <span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span>
		<span class="o">&amp;&amp;</span> <span class="n">neh</span><span class="o">-&gt;</span><span class="n">evt</span> <span class="o">==</span> <span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span>
		<span class="o">&amp;&amp;</span> <span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">==</span> <span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Find the handle waiting for a RC Radio Control Event</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:         UWB Radio Controller</span>
<span class="cm"> * @rceb:       Pointer to the RCEB buffer</span>
<span class="cm"> * @event_size: Pointer to the size of the RCEB buffer. Might be</span>
<span class="cm"> *              adjusted to take into account the @neh-&gt;extra_size</span>
<span class="cm"> *              settings.</span>
<span class="cm"> *</span>
<span class="cm"> * If the listener has no buffer (NULL buffer), one is allocated for</span>
<span class="cm"> * the right size (the amount of data received). @neh-&gt;ptr will point</span>
<span class="cm"> * to the event payload, which always starts with a &#39;struct</span>
<span class="cm"> * uwb_rceb&#39;. kfree() it when done.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="nf">uwb_rc_neh_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_list</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uwb_rc_neh_match</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">rceb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">neh</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="p">)</span>
		<span class="n">__uwb_rc_neh_rm</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">neh</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Process notifications coming from the radio control interface</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:    UWB Radio Control Interface descriptor</span>
<span class="cm"> * @neh:   Notification/Event Handler @neh-&gt;ptr points to</span>
<span class="cm"> *         @uwb_evt-&gt;buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the event/notif handling subsystem when</span>
<span class="cm"> * notifications arrive (hwarc_probe() arms a notification/event handle</span>
<span class="cm"> * that calls back this function for every received notification; this</span>
<span class="cm"> * function then will rearm itself).</span>
<span class="cm"> *</span>
<span class="cm"> * Notification data buffers are dynamically allocated by the NEH</span>
<span class="cm"> * handling code in neh.c [uwb_rc_neh_lookup()]. What is actually</span>
<span class="cm"> * allocated is space to contain the notification data.</span>
<span class="cm"> *</span>
<span class="cm"> * Buffers are prefixed with a Radio Control Event Block (RCEB) as</span>
<span class="cm"> * defined by the WUSB Wired-Adapter Radio Control interface. We</span>
<span class="cm"> * just use it for the notification code.</span>
<span class="cm"> *</span>
<span class="cm"> * On each case statement we just transcode endianess of the different</span>
<span class="cm"> * fields. We declare a pointer to a RCI definition of an event, and</span>
<span class="cm"> * then to a UWB definition of the same event (which are the same,</span>
<span class="cm"> * remember). Event if we use different pointers</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">uwb_rc_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_event</span> <span class="o">*</span><span class="n">uwb_evt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ignoring event with error code %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">size</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uwb_evt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uwb_evt</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">uwb_evt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no memory to queue event 0x%02x/%04x/%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span><span class="p">),</span>
			<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uwb_evt</span><span class="o">-&gt;</span><span class="n">rc</span> <span class="o">=</span> <span class="n">__uwb_rc_get</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>	<span class="cm">/* will be put by uwbd&#39;s uwbd_event_handle() */</span>
	<span class="n">uwb_evt</span><span class="o">-&gt;</span><span class="n">ts_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">uwb_evt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">UWB_EVT_TYPE_NOTIF</span><span class="p">;</span>
	<span class="n">uwb_evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">uwb_evt</span><span class="o">-&gt;</span><span class="n">notif</span><span class="p">.</span><span class="n">rceb</span> <span class="o">=</span> <span class="n">rceb</span><span class="p">;</span>

	<span class="n">uwbd_event_queue</span><span class="p">(</span><span class="n">uwb_evt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uwb_rc_neh_grok_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">notif</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">notif</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">notif</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">notif</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">uwb_rc_notif</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">notif</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;event 0x%02x/%04x/%02x (%zu bytes): no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span><span class="p">),</span>
				<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">neh</span> <span class="o">=</span> <span class="n">uwb_rc_neh_lookup</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">rceb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="cm">/* to guard against a timeout */</span>
			<span class="n">neh</span><span class="o">-&gt;</span><span class="n">completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">uwb_rc_neh_cb</span><span class="p">(</span><span class="n">neh</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;event 0x%02x/%04x/%02x (%zu bytes): nobody cared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span><span class="p">),</span>
				 <span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Given a buffer with one or more UWB RC events/notifications, break</span>
<span class="cm"> * them up and dispatch them.</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:	      UWB Radio Controller</span>
<span class="cm"> * @buf:      Buffer with the stream of notifications/events</span>
<span class="cm"> * @buf_size: Amount of data in the buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Note each notification/event starts always with a &#39;struct</span>
<span class="cm"> * uwb_rceb&#39;, so the minimum size if 4 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * The device may pass us events formatted differently than expected.</span>
<span class="cm"> * These are first filtered, potentially creating a new event in a new</span>
<span class="cm"> * memory location. If a new event is created by the filter it is also</span>
<span class="cm"> * freed here.</span>
<span class="cm"> *</span>
<span class="cm"> * For each notif/event, tries to guess the size looking at the EST</span>
<span class="cm"> * tables, then looks for a neh that is waiting for that event and if</span>
<span class="cm"> * found, copies the payload to the neh&#39;s buffer and calls it back. If</span>
<span class="cm"> * not, the data is ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if we can&#39;t find a size description in the EST tables, we</span>
<span class="cm"> * still might find a size in the &#39;neh&#39; handle in uwb_rc_neh_lookup().</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *</span>
<span class="cm"> *   @rc-&gt;neh_lock is NOT taken</span>
<span class="cm"> *</span>
<span class="cm"> * We keep track of various sizes here:</span>
<span class="cm"> * size:      contains the size of the buffer that is processed for the</span>
<span class="cm"> *            incoming event. this buffer may contain events that are not</span>
<span class="cm"> *            formatted as WHCI.</span>
<span class="cm"> * real_size: the actual space taken by this event in the buffer.</span>
<span class="cm"> *            We need to keep track of the real size of an event to be able to</span>
<span class="cm"> *            advance the buffer correctly.</span>
<span class="cm"> * event_size: the size of the event as expected by the core layer</span>
<span class="cm"> *            [OR] the size of the event after filtering. if the filtering</span>
<span class="cm"> *            created a new event in a new memory location then this is</span>
<span class="cm"> *            effectively the size of a new event buffer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uwb_rc_neh_grok</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">itr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">real_size</span><span class="p">,</span> <span class="n">event_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needtofree</span><span class="p">;</span>

	<span class="n">itr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rceb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;not enough data in event buffer to &quot;</span>
				<span class="s">&quot;process incoming events (%zu left, minimum is &quot;</span>
				<span class="s">&quot;%zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rceb</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rceb</span> <span class="o">=</span> <span class="n">itr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">filter_event</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">needtofree</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">filter_event</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rceb</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">real_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">needtofree</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">needtofree</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOANO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG: Unable to filter event &quot;</span>
					<span class="s">&quot;(0x%02x/%04x/%02x) from &quot;</span>
					<span class="s">&quot;device. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span><span class="p">,</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span><span class="p">),</span>
					<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">needtofree</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOANO</span><span class="p">;</span>
		<span class="cm">/* do real processing if there was no filtering or the</span>
<span class="cm">		 * filtering didn&#39;t act */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">needtofree</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOANO</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">uwb_est_find_size</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG: hw sent incomplete event &quot;</span>
					<span class="s">&quot;0x%02x/%04x/%02x (%zd bytes), only got &quot;</span>
					<span class="s">&quot;%zu bytes. We don&#39;t handle that.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventType</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rceb</span><span class="o">-&gt;</span><span class="n">wEvent</span><span class="p">),</span>
					<span class="n">rceb</span><span class="o">-&gt;</span><span class="n">bEventContext</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">real_size</span> <span class="o">=</span> <span class="n">event_size</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">uwb_rc_neh_grok_event</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">rceb</span><span class="p">,</span> <span class="n">event_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">needtofree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rceb</span><span class="p">);</span>

		<span class="n">itr</span> <span class="o">+=</span> <span class="n">real_size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">real_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uwb_rc_neh_grok</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * The entity that reads from the device notification/event channel has</span>
<span class="cm"> * detected an error.</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:    UWB Radio Controller</span>
<span class="cm"> * @error: Errno error code</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uwb_rc_neh_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">neh</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span><span class="p">,</span> <span class="n">list_node</span><span class="p">);</span>
		<span class="n">__uwb_rc_neh_rm</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">uwb_rc_neh_cb</span><span class="p">(</span><span class="n">neh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uwb_rc_neh_error</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">uwb_rc_neh_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">neh</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">)</span>
		<span class="n">__uwb_rc_neh_rm</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">neh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="p">)</span>
		<span class="n">uwb_rc_neh_cb</span><span class="p">(</span><span class="n">neh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/** Initializes the @rc&#39;s neh subsystem</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uwb_rc_neh_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_list</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_bm</span><span class="p">);</span>		<span class="cm">/* 0 is reserved (see [WUSB] table 8-65) */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_bm</span><span class="p">);</span>	<span class="cm">/* and 0xff is invalid */</span>
	<span class="n">rc</span><span class="o">-&gt;</span><span class="n">ctx_roll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Release&#39;s the @rc&#39;s neh subsystem */</span>
<span class="kt">void</span> <span class="nf">uwb_rc_neh_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_neh</span> <span class="o">*</span><span class="n">neh</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">neh</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc_neh</span><span class="p">,</span> <span class="n">list_node</span><span class="p">);</span>
		<span class="n">__uwb_rc_neh_rm</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">neh_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">uwb_rc_neh_put</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
