<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › memory › emif.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>emif.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * EMIF driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2012 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Aneesh V &lt;aneesh@ti.com&gt;</span>
<span class="cm"> * Santosh Shilimkar &lt;santosh.shilimkar@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/platform_data/emif_plat.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;memory/jedec_ddr.h&gt;</span>
<span class="cp">#include &quot;emif.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * struct emif_data - Per device static data for driver&#39;s use</span>
<span class="cm"> * @duplicate:			Whether the DDR devices attached to this EMIF</span>
<span class="cm"> *				instance are exactly same as that on EMIF1. In</span>
<span class="cm"> *				this case we can save some memory and processing</span>
<span class="cm"> * @temperature_level:		Maximum temperature of LPDDR2 devices attached</span>
<span class="cm"> *				to this EMIF - read from MR4 register. If there</span>
<span class="cm"> *				are two devices attached to this EMIF, this</span>
<span class="cm"> *				value is the maximum of the two temperature</span>
<span class="cm"> *				levels.</span>
<span class="cm"> * @node:			node in the device list</span>
<span class="cm"> * @base:			base address of memory-mapped IO registers.</span>
<span class="cm"> * @dev:			device pointer.</span>
<span class="cm"> * @addressing			table with addressing information from the spec</span>
<span class="cm"> * @regs_cache:			An array of &#39;struct emif_regs&#39; that stores</span>
<span class="cm"> *				calculated register values for different</span>
<span class="cm"> *				frequencies, to avoid re-calculating them on</span>
<span class="cm"> *				each DVFS transition.</span>
<span class="cm"> * @curr_regs:			The set of register values used in the last</span>
<span class="cm"> *				frequency change (i.e. corresponding to the</span>
<span class="cm"> *				frequency in effect at the moment)</span>
<span class="cm"> * @plat_data:			Pointer to saved platform data.</span>
<span class="cm"> * @debugfs_root:		dentry to the root folder for EMIF in debugfs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">emif_data</span> <span class="p">{</span>
	<span class="n">u8</span>				<span class="n">duplicate</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">temperature_level</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">lpmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">irq_state</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>			<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span>	<span class="o">*</span><span class="n">addressing</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_regs</span>		<span class="o">*</span><span class="n">regs_cache</span><span class="p">[</span><span class="n">EMIF_MAX_NUM_FREQUENCIES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">emif_regs</span>		<span class="o">*</span><span class="n">curr_regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_platform_data</span>	<span class="o">*</span><span class="n">plat_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>			<span class="o">*</span><span class="n">debugfs_root</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif1</span><span class="p">;</span>
<span class="k">static</span> <span class="n">spinlock_t</span>	<span class="n">emif_lock</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">irq_state</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span>		<span class="n">t_ck</span><span class="p">;</span> <span class="cm">/* DDR clock period in ps */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">device_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_emif_regdump_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">emif_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">type</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ip_rev</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">ip_rev</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;EMIF register cache dump for %dMHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">freq</span><span class="o">/</span><span class="mi">1000000</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;ref_ctrl_shdw</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ref_ctrl_shdw</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;sdram_tim1_shdw</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim1_shdw</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;sdram_tim2_shdw</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim2_shdw</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;sdram_tim3_shdw</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim3_shdw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_rev</span> <span class="o">==</span> <span class="n">EMIF_4D</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;read_idle_ctrl_shdw_normal</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">read_idle_ctrl_shdw_normal</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;read_idle_ctrl_shdw_volt_ramp</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">read_idle_ctrl_shdw_volt_ramp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ip_rev</span> <span class="o">==</span> <span class="n">EMIF_4D5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;dll_calib_ctrl_shdw_normal</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dll_calib_ctrl_shdw_normal</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;dll_calib_ctrl_shdw_volt_ramp</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dll_calib_ctrl_shdw_volt_ramp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S2</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;ref_ctrl_shdw_derated</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ref_ctrl_shdw_derated</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;sdram_tim1_shdw_derated</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim1_shdw_derated</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;sdram_tim3_shdw_derated</span><span class="se">\t</span><span class="s">: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim3_shdw_derated</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emif_regdump_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span>	<span class="o">*</span><span class="n">emif</span>	<span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_regs</span>	<span class="o">**</span><span class="n">regs_cache</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">duplicate</span><span class="p">)</span>
		<span class="n">regs_cache</span> <span class="o">=</span> <span class="n">emif1</span><span class="o">-&gt;</span><span class="n">regs_cache</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">regs_cache</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">regs_cache</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EMIF_MAX_NUM_FREQUENCIES</span> <span class="o">&amp;&amp;</span> <span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_emif_regdump_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">emif</span><span class="p">,</span> <span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emif_regdump_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">emif_regdump_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">emif_regdump_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>			<span class="o">=</span> <span class="n">emif_regdump_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emif_mr4_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;MR4=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emif_mr4_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">emif_mr4_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">emif_mr4_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>			<span class="o">=</span> <span class="n">emif_mr4_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">emif_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ret</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">debugfs_root</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;regcache_dump&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			<span class="n">emif</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">,</span> <span class="n">emif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emif_regdump_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;mr4&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			<span class="n">emif</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">,</span> <span class="n">emif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emif_mr4_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err1:</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">);</span>
<span class="nl">err0:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">emif_debugfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">);</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">debugfs_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the period of DDR clock from frequency value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ddr_clk_period</span><span class="p">(</span><span class="n">u32</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Divide 10^12 by frequency to get period in ps */</span>
	<span class="n">t_ck</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">DIV_ROUND_UP_ULL</span><span class="p">(</span><span class="mi">1000000000000ull</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get bus width used by EMIF. Note that this may be different from the</span>
<span class="cm"> * bus width of the DDR devices used. For instance two 16-bit DDR devices</span>
<span class="cm"> * may be connected to a given CS of EMIF. In this case bus width as far</span>
<span class="cm"> * as EMIF is concerned is 32, where as the DDR bus width is 16 bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_emif_bus_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">width</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SDRAM_CONFIG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NARROW_MODE_MASK</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">NARROW_MODE_SHIFT</span><span class="p">;</span>
	<span class="n">width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">32</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">width</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the CL from SDRAM_CONFIG register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_cl</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">cl</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SDRAM_CONFIG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CL_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CL_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_lpmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="n">u8</span> <span class="n">lpmode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_POWER_MANAGEMENT_CONTROL</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LP_MODE_MASK</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">lpmode</span> <span class="o">&lt;&lt;</span> <span class="n">LP_MODE_SHIFT</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_POWER_MANAGEMENT_CONTROL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_freq_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Workaround for errata i728: Disable LPMODE during FREQ_UPDATE</span>
<span class="cm">	 *</span>
<span class="cm">	 * i728 DESCRIPTION:</span>
<span class="cm">	 * The EMIF automatically puts the SDRAM into self-refresh mode</span>
<span class="cm">	 * after the EMIF has not performed accesses during</span>
<span class="cm">	 * EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM number of DDR clock cycles</span>
<span class="cm">	 * and the EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE bit field is set</span>
<span class="cm">	 * to 0x2. If during a small window the following three events</span>
<span class="cm">	 * occur:</span>
<span class="cm">	 * - The SR_TIMING counter expires</span>
<span class="cm">	 * - And frequency change is requested</span>
<span class="cm">	 * - And OCP access is requested</span>
<span class="cm">	 * Then it causes instable clock on the DDR interface.</span>
<span class="cm">	 *</span>
<span class="cm">	 * WORKAROUND</span>
<span class="cm">	 * To avoid the occurrence of the three events, the workaround</span>
<span class="cm">	 * is to disable the self-refresh when requesting a frequency</span>
<span class="cm">	 * change. Before requesting a frequency change the software must</span>
<span class="cm">	 * program EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x0. When the</span>
<span class="cm">	 * frequency change has been done, the software can reprogram</span>
<span class="cm">	 * EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x2</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">lpmode</span> <span class="o">==</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span><span class="p">)</span>
			<span class="n">set_lpmode</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">EMIF_LP_MODE_DISABLE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: Do FREQ_UPDATE here when an API</span>
<span class="cm">	 * is available for this as part of the new</span>
<span class="cm">	 * clock framework</span>
<span class="cm">	 */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">lpmode</span> <span class="o">==</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span><span class="p">)</span>
			<span class="n">set_lpmode</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Find addressing table entry based on the device&#39;s type and density */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="nf">get_addressing_table</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ddr_device_info</span> <span class="o">*</span><span class="n">device_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">index</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">density</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">device_info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">density</span> <span class="o">=</span> <span class="n">device_info</span><span class="o">-&gt;</span><span class="n">density</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DDR_TYPE_LPDDR2_S4</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">density</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DDR_TYPE_LPDDR2_S2</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">density</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DDR_DENSITY_1Gb</span>:
		<span class="k">case</span> <span class="n">DDR_DENSITY_2Gb</span>:
			<span class="n">index</span> <span class="o">=</span> <span class="n">density</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">density</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">lpddr2_jedec_addressing_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the the right timing table from the array of timing</span>
<span class="cm"> * tables of the device using DDR clock frequency</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span> <span class="o">*</span><span class="nf">get_timings_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>				<span class="n">i</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">freq_nearest</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span>	<span class="o">*</span><span class="n">timings</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span>	<span class="o">*</span><span class="n">timings_arr</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">timings</span><span class="p">;</span>
	<span class="k">struct</span>				<span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Start with a very high frequency - 1GHz */</span>
	<span class="n">freq_nearest</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the timings table such that:</span>
<span class="cm">	 *  1. the frequency range covers the required frequency(safe) AND</span>
<span class="cm">	 *  2. the max_freq is closest to the required frequency(optimal)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">timings_arr_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">timings_arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">max_freq</span><span class="p">;</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">timings_arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min_freq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">freq_nearest</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">freq_nearest</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
			<span class="n">timings</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timings_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timings</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: couldn&#39;t find timings for - %dHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: timings table: freq %d, speed bin freq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">freq_nearest</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">timings</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_sdram_ref_ctrl_shdw</span><span class="p">(</span><span class="n">u32</span> <span class="n">freq</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="n">addressing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ref_ctrl_shdw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">freq_khz</span><span class="p">,</span> <span class="n">t_refi</span><span class="p">;</span>

	<span class="cm">/* Scale down frequency and t_refi to avoid overflow */</span>
	<span class="n">freq_khz</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">t_refi</span> <span class="o">=</span> <span class="n">addressing</span><span class="o">-&gt;</span><span class="n">tREFI_ns</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * refresh rate to be set is &#39;tREFI(in us) * freq in MHz</span>
<span class="cm">	 * division by 10000 to account for change in units</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">t_refi</span> <span class="o">*</span> <span class="n">freq_khz</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="n">ref_ctrl_shdw</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">REFRESH_RATE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ref_ctrl_shdw</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_sdram_tim_1_shdw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_min_tck</span> <span class="o">*</span><span class="n">min_tck</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="n">addressing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tWTR</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tWTR</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_WTR_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addressing</span><span class="o">-&gt;</span><span class="n">num_banks</span> <span class="o">==</span> <span class="n">B8</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tFAW</span><span class="p">,</span> <span class="n">t_ck</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRRD</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRRD</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">));</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">T_RRD_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRAS_min</span> <span class="o">+</span> <span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRPab</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RC_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRASmin</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRAS_min</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">));</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">T_RAS_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tWR</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tWR</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_WR_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRCD</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRCD</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RCD_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRPab</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRPab</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RP_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tim1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_sdram_tim_1_shdw_derated</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_min_tck</span> <span class="o">*</span><span class="n">min_tck</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="n">addressing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tWTR</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tWTR</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_WTR_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * tFAW is approximately 4 times tRRD. So add 1875*4 = 7500ps</span>
<span class="cm">	 * to tFAW for de-rating</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addressing</span><span class="o">-&gt;</span><span class="n">num_banks</span> <span class="o">==</span> <span class="n">B8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tFAW</span> <span class="o">+</span> <span class="mi">7500</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRRD</span> <span class="o">+</span> <span class="mi">1875</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRRD</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RRD_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRAS_min</span> <span class="o">+</span> <span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRPab</span> <span class="o">+</span> <span class="mi">1875</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">);</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">T_RC_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRAS_min</span> <span class="o">+</span> <span class="mi">1875</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRASmin</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RAS_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tWR</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tWR</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_WR_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRCD</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRCD</span> <span class="o">+</span> <span class="mi">1875</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">));</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">T_RCD_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRPab</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRPab</span> <span class="o">+</span> <span class="mi">1875</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">));</span>
	<span class="n">tim1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">T_RP_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tim1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_sdram_tim_2_shdw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_min_tck</span> <span class="o">*</span><span class="n">min_tck</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="n">addressing</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tim2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tCKE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim2</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_CKE_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tRTP</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRTP</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim2</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RTP_SHIFT</span><span class="p">;</span>

	<span class="cm">/* tXSNR = tRFCab_ps + 10 ns(tRFCab_ps for LPDDR2). */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">addressing</span><span class="o">-&gt;</span><span class="n">tRFCab_ps</span> <span class="o">+</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim2</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_XSNR_SHIFT</span><span class="p">;</span>

	<span class="cm">/* XSRD same as XSNR for LPDDR2 */</span>
	<span class="n">tim2</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_XSRD_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tXP</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tXP</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim2</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_XP_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tim2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_sdram_tim_3_shdw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_min_tck</span> <span class="o">*</span><span class="n">min_tck</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="n">addressing</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ip_rev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">derated</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tim3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t_dqsck</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">timings</span><span class="o">-&gt;</span><span class="n">tRAS_max_ns</span> <span class="o">/</span> <span class="n">addressing</span><span class="o">-&gt;</span><span class="n">tREFI_ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mh">0xF</span> <span class="o">?</span> <span class="mh">0xF</span> <span class="o">:</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">tim3</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RAS_MAX_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">addressing</span><span class="o">-&gt;</span><span class="n">tRFCab_ps</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim3</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_RFC_SHIFT</span><span class="p">;</span>

	<span class="n">t_dqsck</span> <span class="o">=</span> <span class="p">(</span><span class="n">derated</span> <span class="o">==</span> <span class="n">EMIF_DERATED_TIMINGS</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">timings</span><span class="o">-&gt;</span><span class="n">tDQSCK_max_derated</span> <span class="o">:</span> <span class="n">timings</span><span class="o">-&gt;</span><span class="n">tDQSCK_max</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_rev</span> <span class="o">==</span> <span class="n">EMIF_4D5</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">t_dqsck</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">t_dqsck</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tim3</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_TDQSCKMAX_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tZQCS</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim3</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_ZQCS_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tCKESR</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_tck</span><span class="o">-&gt;</span><span class="n">tCKESR</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tim3</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_CKESR_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_rev</span> <span class="o">==</span> <span class="n">EMIF_4D5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tim3</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EMIF_T_CSTA</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">T_CSTA_SHIFT</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">EMIF_T_PDLL_UL</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tim3</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">T_PDLL_UL_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tim3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_zq_config_reg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="n">addressing</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">cs1_used</span><span class="p">,</span> <span class="n">bool</span> <span class="n">cal_resistors_per_cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">zq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">EMIF_ZQCS_INTERVAL_US</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">addressing</span><span class="o">-&gt;</span><span class="n">tREFI_ns</span><span class="p">;</span>
	<span class="n">zq</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_REFINTERVAL_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">T_ZQCL_DEFAULT_NS</span><span class="p">,</span> <span class="n">T_ZQCS_DEFAULT_NS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">zq</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_ZQCL_MULT_SHIFT</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">T_ZQINIT_DEFAULT_NS</span><span class="p">,</span> <span class="n">T_ZQCL_DEFAULT_NS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">zq</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_ZQINIT_MULT_SHIFT</span><span class="p">;</span>

	<span class="n">zq</span> <span class="o">|=</span> <span class="n">ZQ_SFEXITEN_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_SFEXITEN_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cal_resistors_per_cs</span><span class="p">)</span>
		<span class="n">zq</span> <span class="o">|=</span> <span class="n">ZQ_DUALCALEN_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_DUALCALEN_SHIFT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">zq</span> <span class="o">|=</span> <span class="n">ZQ_DUALCALEN_DISABLE</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_DUALCALEN_SHIFT</span><span class="p">;</span>

	<span class="n">zq</span> <span class="o">|=</span> <span class="n">ZQ_CS0EN_MASK</span><span class="p">;</span> <span class="cm">/* CS0 is used for sure */</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">cs1_used</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">zq</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">ZQ_CS1EN_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">zq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_temp_alert_config</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span> <span class="o">*</span><span class="n">addressing</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">emif_custom_configs</span> <span class="o">*</span><span class="n">custom_configs</span><span class="p">,</span> <span class="n">bool</span> <span class="n">cs1_used</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">sdram_io_width</span><span class="p">,</span> <span class="n">u32</span> <span class="n">emif_bus_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">alert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">devcnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">custom_configs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">custom_configs</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span>
				<span class="n">EMIF_CUSTOM_CONFIG_TEMP_ALERT_POLL_INTERVAL</span><span class="p">))</span>
		<span class="n">interval</span> <span class="o">=</span> <span class="n">custom_configs</span><span class="o">-&gt;</span><span class="n">temp_alert_poll_interval_ms</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">interval</span> <span class="o">=</span> <span class="n">TEMP_ALERT_POLL_INTERVAL_DEFAULT_MS</span><span class="p">;</span>

	<span class="n">interval</span> <span class="o">*=</span> <span class="mi">1000000</span><span class="p">;</span>			<span class="cm">/* Convert to ns */</span>
	<span class="n">interval</span> <span class="o">/=</span> <span class="n">addressing</span><span class="o">-&gt;</span><span class="n">tREFI_ns</span><span class="p">;</span>	<span class="cm">/* Convert to refresh cycles */</span>
	<span class="n">alert</span> <span class="o">|=</span> <span class="p">(</span><span class="n">interval</span> <span class="o">&lt;&lt;</span> <span class="n">TA_REFINTERVAL_SHIFT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * sdram_io_width is in &#39;log2(x) - 1&#39; form. Convert emif_bus_width</span>
<span class="cm">	 * also to this form and subtract to get TA_DEVCNT, which is</span>
<span class="cm">	 * in log2(x) form.</span>
<span class="cm">	 */</span>
	<span class="n">emif_bus_width</span> <span class="o">=</span> <span class="n">__fls</span><span class="p">(</span><span class="n">emif_bus_width</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">devcnt</span> <span class="o">=</span> <span class="n">emif_bus_width</span> <span class="o">-</span> <span class="n">sdram_io_width</span><span class="p">;</span>
	<span class="n">alert</span> <span class="o">|=</span> <span class="n">devcnt</span> <span class="o">&lt;&lt;</span> <span class="n">TA_DEVCNT_SHIFT</span><span class="p">;</span>

	<span class="cm">/* DEVWDT is in &#39;log2(x) - 3&#39; form */</span>
	<span class="n">alert</span> <span class="o">|=</span> <span class="p">(</span><span class="n">sdram_io_width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">TA_DEVWDT_SHIFT</span><span class="p">;</span>

	<span class="n">alert</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TA_SFEXITEN_SHIFT</span><span class="p">;</span>
	<span class="n">alert</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TA_CS0EN_SHIFT</span><span class="p">;</span>
	<span class="n">alert</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cs1_used</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">TA_CS1EN_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">alert</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_read_idle_ctrl_shdw</span><span class="p">(</span><span class="n">u8</span> <span class="n">volt_ramp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum value in normal conditions and increased frequency</span>
<span class="cm">	 * when voltage is ramping</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">volt_ramp</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">READ_IDLE_INTERVAL_DVFS</span> <span class="o">/</span> <span class="n">t_ck</span> <span class="o">/</span> <span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mh">0x1FF</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * READ_IDLE_CTRL register in EMIF4D has same offset and fields</span>
<span class="cm">	 * as DLL_CALIB_CTRL in EMIF4D5, so use the same shifts</span>
<span class="cm">	 */</span>
	<span class="n">idle</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">DLL_CALIB_INTERVAL_SHIFT</span><span class="p">;</span>
	<span class="n">idle</span> <span class="o">|=</span> <span class="n">EMIF_READ_IDLE_LEN_VAL</span> <span class="o">&lt;&lt;</span> <span class="n">ACK_WAIT_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">idle</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_dll_calib_ctrl_shdw</span><span class="p">(</span><span class="n">u8</span> <span class="n">volt_ramp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">calib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">volt_ramp</span> <span class="o">==</span> <span class="n">DDR_VOLTAGE_RAMPING</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">DLL_CALIB_INTERVAL_DVFS</span> <span class="o">/</span> <span class="n">t_ck</span> <span class="o">/</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Disabled when voltage is stable */</span>

	<span class="n">calib</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">DLL_CALIB_INTERVAL_SHIFT</span><span class="p">;</span>
	<span class="n">calib</span> <span class="o">|=</span> <span class="n">DLL_CALIB_ACK_WAIT_VAL</span> <span class="o">&lt;&lt;</span> <span class="n">ACK_WAIT_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">calib</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_ddr_phy_ctrl_1_attilaphy_4d</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">freq</span><span class="p">,</span> <span class="n">u8</span> <span class="n">RL</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy</span> <span class="o">=</span> <span class="n">EMIF_DDR_PHY_CTRL_1_BASE_VAL_ATTILAPHY</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">RL</span> <span class="o">+</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">timings</span><span class="o">-&gt;</span><span class="n">tDQSCK_max</span><span class="p">,</span> <span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">phy</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">READ_LATENCY_SHIFT_4D</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="mi">100000000</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">EMIF_DLL_SLAVE_DLY_CTRL_100_MHZ_AND_LESS_ATTILAPHY</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="mi">200000000</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">EMIF_DLL_SLAVE_DLY_CTRL_200_MHZ_ATTILAPHY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">EMIF_DLL_SLAVE_DLY_CTRL_400_MHZ_ATTILAPHY</span><span class="p">;</span>

	<span class="n">phy</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">DLL_SLAVE_DLY_CTRL_SHIFT_4D</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_phy_ctrl_1_intelliphy_4d5</span><span class="p">(</span><span class="n">u32</span> <span class="n">freq</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy</span> <span class="o">=</span> <span class="n">EMIF_DDR_PHY_CTRL_1_BASE_VAL_INTELLIPHY</span><span class="p">,</span> <span class="n">half_delay</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * DLL operates at 266 MHz. If DDR frequency is near 266 MHz,</span>
<span class="cm">	 * half-delay is not needed else set half-delay</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="mi">265000000</span> <span class="o">&amp;&amp;</span> <span class="n">freq</span> <span class="o">&lt;</span> <span class="mi">267000000</span><span class="p">)</span>
		<span class="n">half_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">half_delay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">phy</span> <span class="o">|=</span> <span class="n">half_delay</span> <span class="o">&lt;&lt;</span> <span class="n">DLL_HALF_DELAY_SHIFT_4D5</span><span class="p">;</span>
	<span class="n">phy</span> <span class="o">|=</span> <span class="p">((</span><span class="n">cl</span> <span class="o">+</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">EMIF_PHY_TOTAL_READ_LATENCY_INTELLIPHY_PS</span><span class="p">,</span>
			<span class="n">t_ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">READ_LATENCY_SHIFT_4D5</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">phy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_ext_phy_ctrl_2_intelliphy_4d5</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fifo_we_slave_ratio</span><span class="p">;</span>

	<span class="n">fifo_we_slave_ratio</span> <span class="o">=</span>  <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span>
		<span class="n">EMIF_INTELLI_PHY_DQS_GATE_OPENING_DELAY_PS</span> <span class="o">*</span> <span class="mi">256</span> <span class="p">,</span> <span class="n">t_ck</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fifo_we_slave_ratio</span> <span class="o">|</span> <span class="n">fifo_we_slave_ratio</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span> <span class="o">|</span>
		<span class="n">fifo_we_slave_ratio</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_ext_phy_ctrl_3_intelliphy_4d5</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fifo_we_slave_ratio</span><span class="p">;</span>

	<span class="n">fifo_we_slave_ratio</span> <span class="o">=</span>  <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span>
		<span class="n">EMIF_INTELLI_PHY_DQS_GATE_OPENING_DELAY_PS</span> <span class="o">*</span> <span class="mi">256</span> <span class="p">,</span> <span class="n">t_ck</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fifo_we_slave_ratio</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span> <span class="o">|</span> <span class="n">fifo_we_slave_ratio</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span>
		<span class="n">fifo_we_slave_ratio</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="n">fifo_we_slave_ratio</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_ext_phy_ctrl_4_intelliphy_4d5</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fifo_we_slave_ratio</span><span class="p">;</span>

	<span class="n">fifo_we_slave_ratio</span> <span class="o">=</span>  <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span>
		<span class="n">EMIF_INTELLI_PHY_DQS_GATE_OPENING_DELAY_PS</span> <span class="o">*</span> <span class="mi">256</span> <span class="p">,</span> <span class="n">t_ck</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fifo_we_slave_ratio</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span> <span class="o">|</span> <span class="n">fifo_we_slave_ratio</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">|</span>
		<span class="n">fifo_we_slave_ratio</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_pwr_mgmt_ctrl</span><span class="p">(</span><span class="n">u32</span> <span class="n">freq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ip_rev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pwr_mgmt_ctrl</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lpmode</span>		<span class="o">=</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timeout_perf</span>	<span class="o">=</span> <span class="n">EMIF_LP_MODE_TIMEOUT_PERFORMANCE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timeout_pwr</span>		<span class="o">=</span> <span class="n">EMIF_LP_MODE_TIMEOUT_POWER</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">freq_threshold</span>	<span class="o">=</span> <span class="n">EMIF_LP_MODE_FREQ_THRESHOLD</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">emif_custom_configs</span> <span class="o">*</span><span class="n">cust_cfgs</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">custom_configs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cust_cfgs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">EMIF_CUSTOM_CONFIG_LPMODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpmode</span>		<span class="o">=</span> <span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode</span><span class="p">;</span>
		<span class="n">timeout_perf</span>	<span class="o">=</span> <span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode_timeout_performance</span><span class="p">;</span>
		<span class="n">timeout_pwr</span>	<span class="o">=</span> <span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode_timeout_power</span><span class="p">;</span>
		<span class="n">freq_threshold</span>  <span class="o">=</span> <span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode_freq_threshold</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Timeout based on DDR frequency */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">freq_threshold</span> <span class="o">?</span> <span class="n">timeout_perf</span> <span class="o">:</span> <span class="n">timeout_pwr</span><span class="p">;</span>

	<span class="cm">/* The value to be set in register is &quot;log2(timeout) - 3&quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">__fls</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">timeout</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lpmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EMIF_LP_MODE_CLOCK_STOP</span>:
		<span class="n">pwr_mgmt_ctrl</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;&lt;</span> <span class="n">CS_TIM_SHIFT</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">SR_TIM_MASK</span> <span class="o">|</span> <span class="n">PD_TIM_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span>:
		<span class="cm">/* Workaround for errata i735 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

		<span class="n">pwr_mgmt_ctrl</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;&lt;</span> <span class="n">SR_TIM_SHIFT</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">CS_TIM_MASK</span> <span class="o">|</span> <span class="n">PD_TIM_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EMIF_LP_MODE_PWR_DN</span>:
		<span class="n">pwr_mgmt_ctrl</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;&lt;</span> <span class="n">PD_TIM_SHIFT</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">CS_TIM_MASK</span> <span class="o">|</span> <span class="n">SR_TIM_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EMIF_LP_MODE_DISABLE</span>:
	<span class="nl">default:</span>
		<span class="n">pwr_mgmt_ctrl</span> <span class="o">=</span> <span class="n">CS_TIM_MASK</span> <span class="o">|</span>
					<span class="n">PD_TIM_MASK</span> <span class="o">|</span> <span class="n">SR_TIM_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* No CS_TIM in EMIF_4D5 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_rev</span> <span class="o">==</span> <span class="n">EMIF_4D5</span><span class="p">)</span>
		<span class="n">pwr_mgmt_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CS_TIM_MASK</span><span class="p">;</span>

	<span class="n">pwr_mgmt_ctrl</span> <span class="o">|=</span> <span class="n">lpmode</span> <span class="o">&lt;&lt;</span> <span class="n">LP_MODE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pwr_mgmt_ctrl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the temperature level of the EMIF instance:</span>
<span class="cm"> * Reads the MR4 register of attached SDRAM parts to find out the temperature</span>
<span class="cm"> * level. If there are two parts attached(one on each CS), then the temperature</span>
<span class="cm"> * level for the EMIF instance is the higher of the two temperatures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_temperature_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">temp</span><span class="p">,</span> <span class="n">temperature_level</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* Read mode register 4 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">DDR_MR4</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LPDDR2_MODE_REG_CONFIG</span><span class="p">);</span>
	<span class="n">temperature_level</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LPDDR2_MODE_REG_DATA</span><span class="p">);</span>
	<span class="n">temperature_level</span> <span class="o">=</span> <span class="p">(</span><span class="n">temperature_level</span> <span class="o">&amp;</span> <span class="n">MR4_SDRAM_REF_RATE_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				<span class="n">MR4_SDRAM_REF_RATE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="o">-&gt;</span><span class="n">cs1_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">DDR_MR4</span> <span class="o">|</span> <span class="n">CS_MASK</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LPDDR2_MODE_REG_CONFIG</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LPDDR2_MODE_REG_DATA</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">MR4_SDRAM_REF_RATE_MASK</span><span class="p">)</span>
				<span class="o">&gt;&gt;</span> <span class="n">MR4_SDRAM_REF_RATE_SHIFT</span><span class="p">;</span>
		<span class="n">temperature_level</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temperature_level</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* treat everything less than nominal(3) in MR4 as nominal */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">temperature_level</span> <span class="o">&lt;</span> <span class="n">SDRAM_TEMP_NOMINAL</span><span class="p">))</span>
		<span class="n">temperature_level</span> <span class="o">=</span> <span class="n">SDRAM_TEMP_NOMINAL</span><span class="p">;</span>

	<span class="cm">/* if we get reserved value in MR4 persist with the existing value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">temperature_level</span> <span class="o">!=</span> <span class="n">SDRAM_TEMP_RESERVED_4</span><span class="p">))</span>
		<span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span> <span class="o">=</span> <span class="n">temperature_level</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Program EMIF shadow registers that are not dependent on temperature</span>
<span class="cm"> * or voltage</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="k">struct</span> <span class="n">emif_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim2_shdw</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SDRAM_TIMING_2_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">phy_ctrl_1_shdw</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_DDR_PHY_CTRL_1_SHDW</span><span class="p">);</span>

	<span class="cm">/* Settings specific for EMIF4D5 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">ip_rev</span> <span class="o">!=</span> <span class="n">EMIF_4D5</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ext_phy_ctrl_2_shdw</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_2_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ext_phy_ctrl_3_shdw</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_3_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ext_phy_ctrl_4_shdw</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_4_SHDW</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When voltage ramps dll calibration and forced read idle should</span>
<span class="cm"> * happen more often</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_volt_sensitive_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">emif_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">volt_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">calib_ctrl</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * EMIF_READ_IDLE_CTRL in EMIF4D refers to the same register as</span>
<span class="cm">	 * EMIF_DLL_CALIB_CTRL in EMIF4D5 and dll_calib_ctrl_shadow_*</span>
<span class="cm">	 * is an alias of the respective read_idle_ctrl_shdw_* (members of</span>
<span class="cm">	 * a union). So, the below code takes care of both cases</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">volt_state</span> <span class="o">==</span> <span class="n">DDR_VOLTAGE_RAMPING</span><span class="p">)</span>
		<span class="n">calib_ctrl</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dll_calib_ctrl_shdw_volt_ramp</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">calib_ctrl</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dll_calib_ctrl_shdw_normal</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">calib_ctrl</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_DLL_CALIB_CTRL_SHDW</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setup_temperature_sensitive_regs() - set the timings for temperature</span>
<span class="cm"> * sensitive registers. This happens once at initialisation time based</span>
<span class="cm"> * on the temperature at boot time and subsequently based on the temperature</span>
<span class="cm"> * alert interrupt. Temperature alert can happen when the temperature</span>
<span class="cm"> * increases or drops. So this function can have the effect of either</span>
<span class="cm"> * derating the timings or going back to nominal values.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_temperature_sensitive_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">emif_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">tim1</span><span class="p">,</span> <span class="n">tim3</span><span class="p">,</span> <span class="n">ref_ctrl</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">temperature</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">tim1</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim1_shdw</span><span class="p">;</span>
	<span class="n">tim3</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim3_shdw</span><span class="p">;</span>
	<span class="n">ref_ctrl</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ref_ctrl_shdw</span><span class="p">;</span>

	<span class="cm">/* No de-rating for non-lpddr2 devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DDR_TYPE_LPDDR2_S2</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">DDR_TYPE_LPDDR2_S4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">temperature</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temperature</span> <span class="o">==</span> <span class="n">SDRAM_TEMP_HIGH_DERATE_REFRESH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref_ctrl</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ref_ctrl_shdw_derated</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">temperature</span> <span class="o">==</span> <span class="n">SDRAM_TEMP_HIGH_DERATE_REFRESH_AND_TIMINGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tim1</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim1_shdw_derated</span><span class="p">;</span>
		<span class="n">tim3</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim3_shdw_derated</span><span class="p">;</span>
		<span class="n">ref_ctrl</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ref_ctrl_shdw_derated</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tim1</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SDRAM_TIMING_1_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tim3</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SDRAM_TIMING_3_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ref_ctrl</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SDRAM_REFRESH_CTRL_SHDW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">handle_temp_alert</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">old_temp_level</span><span class="p">;</span>
	<span class="n">irqreturn_t</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>
	<span class="n">old_temp_level</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span><span class="p">;</span>
	<span class="n">get_temperature_level</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span> <span class="o">==</span> <span class="n">old_temp_level</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;temperature alert before registers are calculated, not de-rating timings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span> <span class="o">&lt;</span> <span class="n">old_temp_level</span> <span class="o">||</span>
		<span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span> <span class="o">==</span> <span class="n">SDRAM_TEMP_VERY_HIGH_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Temperature coming down - defer handling to thread OR</span>
<span class="cm">		 * Temperature far too high - do kernel_power_off() from</span>
<span class="cm">		 * thread context</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_WAKE_THREAD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Temperature is going up - handle immediately */</span>
		<span class="n">setup_temperature_sensitive_regs</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="p">);</span>
		<span class="n">do_freq_update</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">emif_interrupt_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">interrupts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_data</span>	<span class="o">*</span><span class="n">emif</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">irqreturn_t</span>		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="cm">/* Save the status and clear it */</span>
	<span class="n">interrupts</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SYSTEM_OCP_INTERRUPT_STATUS</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">interrupts</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SYSTEM_OCP_INTERRUPT_STATUS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle temperature alert</span>
<span class="cm">	 * Temperature alert should be same for all ports</span>
<span class="cm">	 * So, it&#39;s enough to process it only for one of the ports</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interrupts</span> <span class="o">&amp;</span> <span class="n">TA_SYS_MASK</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_temp_alert</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">emif</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interrupts</span> <span class="o">&amp;</span> <span class="n">ERR_SYS_MASK</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Access error from SYS port - %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">interrupts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">hw_caps</span> <span class="o">&amp;</span> <span class="n">EMIF_HW_CAPS_LL_INTERFACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save the status and clear it */</span>
		<span class="n">interrupts</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LL_OCP_INTERRUPT_STATUS</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">interrupts</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LL_OCP_INTERRUPT_STATUS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">interrupts</span> <span class="o">&amp;</span> <span class="n">ERR_LL_MASK</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Access error from LL port - %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">interrupts</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">emif_threaded_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span>	<span class="o">*</span><span class="n">emif</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span> <span class="o">==</span> <span class="n">SDRAM_TEMP_VERY_HIGH_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_emerg</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SDRAM temperature exceeds operating limit.. Needs shut down!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kernel_power_off</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">setup_temperature_sensitive_regs</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="p">);</span>
		<span class="n">do_freq_update</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;temperature alert before registers are calculated, not de-rating timings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_all_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SYSTEM_OCP_INTERRUPT_STATUS</span><span class="p">),</span>
		<span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SYSTEM_OCP_INTERRUPT_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">hw_caps</span> <span class="o">&amp;</span> <span class="n">EMIF_HW_CAPS_LL_INTERFACE</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LL_OCP_INTERRUPT_STATUS</span><span class="p">),</span>
			<span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LL_OCP_INTERRUPT_STATUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_and_clear_all_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* Disable all interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SYSTEM_OCP_INTERRUPT_ENABLE_SET</span><span class="p">),</span>
		<span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SYSTEM_OCP_INTERRUPT_ENABLE_CLEAR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">hw_caps</span> <span class="o">&amp;</span> <span class="n">EMIF_HW_CAPS_LL_INTERFACE</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LL_OCP_INTERRUPT_ENABLE_SET</span><span class="p">),</span>
			<span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LL_OCP_INTERRUPT_ENABLE_CLEAR</span><span class="p">);</span>

	<span class="cm">/* Clear all interrupts */</span>
	<span class="n">clear_all_interrupts</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">setup_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="n">u32</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">interrupts</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">clear_all_interrupts</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>

	<span class="cm">/* Enable interrupts for SYS interface */</span>
	<span class="n">interrupts</span> <span class="o">=</span> <span class="n">EN_ERR_SYS_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S2</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S4</span><span class="p">)</span>
		<span class="n">interrupts</span> <span class="o">|=</span> <span class="n">EN_TA_SYS_MASK</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">interrupts</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SYSTEM_OCP_INTERRUPT_ENABLE_SET</span><span class="p">);</span>

	<span class="cm">/* Enable interrupts for LL interface */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">hw_caps</span> <span class="o">&amp;</span> <span class="n">EMIF_HW_CAPS_LL_INTERFACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TA need not be enabled for LL */</span>
		<span class="n">interrupts</span> <span class="o">=</span> <span class="n">EN_ERR_LL_MASK</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">interrupts</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_LL_OCP_INTERRUPT_ENABLE_SET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* setup IRQ handlers */</span>
	<span class="k">return</span> <span class="n">devm_request_threaded_irq</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span>
				    <span class="n">emif_interrupt_handler</span><span class="p">,</span>
				    <span class="n">emif_threaded_isr</span><span class="p">,</span>
				    <span class="mi">0</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
				    <span class="n">emif</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init_or_module</span> <span class="nf">emif_onetime_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>				<span class="n">pwr_mgmt_ctrl</span><span class="p">,</span> <span class="n">zq</span><span class="p">,</span> <span class="n">temp_alert_cfg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span>	<span class="o">*</span><span class="n">addressing</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ddr_device_info</span>	<span class="o">*</span><span class="n">device_info</span><span class="p">;</span>

	<span class="n">device_info</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="p">;</span>
	<span class="n">addressing</span> <span class="o">=</span> <span class="n">get_addressing_table</span><span class="p">(</span><span class="n">device_info</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Init power management settings</span>
<span class="cm">	 * We don&#39;t know the frequency yet. Use a high frequency</span>
<span class="cm">	 * value for a conservative timeout setting</span>
<span class="cm">	 */</span>
	<span class="n">pwr_mgmt_ctrl</span> <span class="o">=</span> <span class="n">get_pwr_mgmt_ctrl</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">,</span> <span class="n">emif</span><span class="p">,</span>
			<span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">ip_rev</span><span class="p">);</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">lpmode</span> <span class="o">=</span> <span class="p">(</span><span class="n">pwr_mgmt_ctrl</span> <span class="o">&amp;</span> <span class="n">LP_MODE_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LP_MODE_SHIFT</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pwr_mgmt_ctrl</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_POWER_MANAGEMENT_CONTROL</span><span class="p">);</span>

	<span class="cm">/* Init ZQ calibration settings */</span>
	<span class="n">zq</span> <span class="o">=</span> <span class="n">get_zq_config_reg</span><span class="p">(</span><span class="n">addressing</span><span class="p">,</span> <span class="n">device_info</span><span class="o">-&gt;</span><span class="n">cs1_used</span><span class="p">,</span>
		<span class="n">device_info</span><span class="o">-&gt;</span><span class="n">cal_resistors_per_cs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">zq</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_SDRAM_OUTPUT_IMPEDANCE_CALIBRATION_CONFIG</span><span class="p">);</span>

	<span class="cm">/* Check temperature level temperature level*/</span>
	<span class="n">get_temperature_level</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span> <span class="o">==</span> <span class="n">SDRAM_TEMP_VERY_HIGH_SHUTDOWN</span><span class="p">)</span>
		<span class="n">dev_emerg</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SDRAM temperature exceeds operating limit.. Needs shut down!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Init temperature polling */</span>
	<span class="n">temp_alert_cfg</span> <span class="o">=</span> <span class="n">get_temp_alert_config</span><span class="p">(</span><span class="n">addressing</span><span class="p">,</span>
		<span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">custom_configs</span><span class="p">,</span> <span class="n">device_info</span><span class="o">-&gt;</span><span class="n">cs1_used</span><span class="p">,</span>
		<span class="n">device_info</span><span class="o">-&gt;</span><span class="n">io_width</span><span class="p">,</span> <span class="n">get_emif_bus_width</span><span class="p">(</span><span class="n">emif</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">temp_alert_cfg</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_TEMPERATURE_ALERT_CONFIG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program external PHY control registers that are not frequency</span>
<span class="cm">	 * dependent</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">!=</span> <span class="n">EMIF_PHY_TYPE_INTELLIPHY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_1_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_1_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_5_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_5_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_6_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_6_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_7_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_7_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_8_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_8_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_9_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_9_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_10_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_10_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_11_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_11_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_12_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_12_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_13_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_13_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_14_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_14_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_15_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_15_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_16_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_16_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_17_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_17_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_18_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_18_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_19_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_19_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_20_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_20_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_21_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_21_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_22_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_22_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_23_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_23_SHDW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">EMIF_EXT_PHY_CTRL_24_VAL</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">EMIF_EXT_PHY_CTRL_24_SHDW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_default_timings</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_platform_data</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="p">;</span>

	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings</span>		<span class="o">=</span> <span class="n">lpddr2_jedec_timings</span><span class="p">;</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings_arr_size</span>	<span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">lpddr2_jedec_timings</span><span class="p">);</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: using default timings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_dev_data_valid</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">density</span><span class="p">,</span> <span class="n">u32</span> <span class="n">io_width</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phy_type</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">ip_rev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>

	<span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S4</span> <span class="o">||</span>
			<span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S2</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">density</span> <span class="o">&gt;=</span> <span class="n">DDR_DENSITY_64Mb</span>
			<span class="o">&amp;&amp;</span> <span class="n">density</span> <span class="o">&lt;=</span> <span class="n">DDR_DENSITY_8Gb</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">io_width</span> <span class="o">&gt;=</span> <span class="n">DDR_IO_WIDTH_8</span>
			<span class="o">&amp;&amp;</span> <span class="n">io_width</span> <span class="o">&lt;=</span> <span class="n">DDR_IO_WIDTH_32</span><span class="p">);</span>

	<span class="cm">/* Combinations of EMIF and PHY revisions that we support today */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ip_rev</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EMIF_4D</span>:
		<span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">EMIF_PHY_TYPE_ATTILAPHY</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EMIF_4D5</span>:
		<span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">EMIF_PHY_TYPE_INTELLIPHY</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: invalid DDR details</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_custom_config_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_custom_configs</span> <span class="o">*</span><span class="n">cust_cfgs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">EMIF_CUSTOM_CONFIG_LPMODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode</span> <span class="o">!=</span> <span class="n">EMIF_LP_MODE_DISABLE</span><span class="p">))</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode_freq_threshold</span> <span class="o">&amp;&amp;</span>
			<span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode_timeout_performance</span> <span class="o">&amp;&amp;</span>
			<span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">lpmode_timeout_power</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">EMIF_CUSTOM_CONFIG_TEMP_ALERT_POLL_INTERVAL</span><span class="p">)</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">cust_cfgs</span><span class="o">-&gt;</span><span class="n">temp_alert_poll_interval_ms</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: invalid custom configs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">__init_or_module</span> <span class="nf">get_device_details</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>				<span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_data</span>		<span class="o">*</span><span class="n">emif</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ddr_device_info</span>		<span class="o">*</span><span class="n">dev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_custom_configs</span>	<span class="o">*</span><span class="n">cust_cfgs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_platform_data</span>	<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>			<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pd</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">device_info</span> <span class="o">&amp;&amp;</span> <span class="n">is_dev_data_valid</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="o">-&gt;</span><span class="n">density</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="o">-&gt;</span><span class="n">io_width</span><span class="p">,</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">ip_rev</span><span class="p">,</span> <span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: invalid device data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">emif</span>	<span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">emif</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">temp</span>	<span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">dev_info</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emif</span> <span class="o">||</span> <span class="o">!</span><span class="n">pd</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:%d: allocation error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pd</span><span class="p">));</span>
	<span class="n">pd</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev_info</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev_info</span><span class="p">));</span>

	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">device_info</span>		<span class="o">=</span> <span class="n">dev_info</span><span class="p">;</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span>		<span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span>		<span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">temperature_level</span>	<span class="o">=</span> <span class="n">SDRAM_TEMP_NOMINAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For EMIF instances other than EMIF1 see if the devices connected</span>
<span class="cm">	 * are exactly same as on EMIF1(which is typically the case). If so,</span>
<span class="cm">	 * mark it as a duplicate of EMIF1 and skip copying timings data.</span>
<span class="cm">	 * This will save some memory and some computation later.</span>
<span class="cm">	 */</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">duplicate</span> <span class="o">=</span> <span class="n">emif1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dev_info</span><span class="p">,</span>
		<span class="n">emif1</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddr_device_info</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">duplicate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">emif1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Non-symmetric DDR geometry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy custom configs - ignore allocation error, if any, as</span>
<span class="cm">	 * custom_configs is not very critical</span>
<span class="cm">	 */</span>
	<span class="n">cust_cfgs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">custom_configs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cust_cfgs</span> <span class="o">&amp;&amp;</span> <span class="n">is_custom_config_valid</span><span class="p">(</span><span class="n">cust_cfgs</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cust_cfgs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">cust_cfgs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cust_cfgs</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:%d: allocation error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">custom_configs</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy timings and min-tck values from platform data. If it is not</span>
<span class="cm">	 * available or if memory allocation fails, use JEDEC defaults</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpddr2_timings</span><span class="p">)</span> <span class="o">*</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings_arr_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings</span><span class="p">));</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">timings</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:%d: allocation error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">__LINE__</span><span class="p">);</span>
			<span class="n">get_default_timings</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">get_default_timings</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span><span class="p">));</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s:%d: allocation error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">__LINE__</span><span class="p">);</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr2_jedec_min_tck</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">min_tck</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr2_jedec_min_tck</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">emif</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">emif_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span>	<span class="o">*</span><span class="n">emif</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span>		<span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>

	<span class="n">emif</span> <span class="o">=</span> <span class="n">get_device_details</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emif</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: error getting device data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_list</span><span class="p">);</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">addressing</span> <span class="o">=</span> <span class="n">get_addressing_table</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="p">);</span>

	<span class="cm">/* Save pointers to each other in emif and device structures */</span>
	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">emif</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: error getting memory resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">devm_request_and_ioremap</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: devm_request_and_ioremap() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: error getting IRQ resource - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">emif_onetime_settings</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
	<span class="n">emif_debugfs_init</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
	<span class="n">disable_and_clear_all_interrupts</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
	<span class="n">setup_interrupts</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* One-time actions taken on probing the first device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emif1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">emif1</span> <span class="o">=</span> <span class="n">emif</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * TODO: register notifiers for frequency and voltage</span>
<span class="cm">		 * change here once the respective frameworks are</span>
<span class="cm">		 * available</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: device configured with addr = %p and IRQ%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">emif_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">emif_debugfs_exit</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emif_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span>	<span class="o">*</span><span class="n">emif</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">disable_and_clear_all_interrupts</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_emif_reg_values</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">emif_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>				<span class="n">cs1_used</span><span class="p">,</span> <span class="n">ip_rev</span><span class="p">,</span> <span class="n">phy_type</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">cl</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_timings</span>	<span class="o">*</span><span class="n">timings</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_min_tck</span>	<span class="o">*</span><span class="n">min_tck</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ddr_device_info</span>	<span class="o">*</span><span class="n">device_info</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lpddr2_addressing</span>	<span class="o">*</span><span class="n">addressing</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_data</span>		<span class="o">*</span><span class="n">emif_for_calc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>			<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">emif_custom_configs</span> <span class="o">*</span><span class="n">custom_configs</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the devices on this EMIF instance is duplicate of EMIF1,</span>
<span class="cm">	 * use EMIF1 details for the calculation</span>
<span class="cm">	 */</span>
	<span class="n">emif_for_calc</span>	<span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">duplicate</span> <span class="o">?</span> <span class="n">emif1</span> <span class="o">:</span> <span class="n">emif</span><span class="p">;</span>
	<span class="n">timings</span>		<span class="o">=</span> <span class="n">get_timings_table</span><span class="p">(</span><span class="n">emif_for_calc</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
	<span class="n">addressing</span>	<span class="o">=</span> <span class="n">emif_for_calc</span><span class="o">-&gt;</span><span class="n">addressing</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timings</span> <span class="o">||</span> <span class="o">!</span><span class="n">addressing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: not enough data available for %dHz&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device_info</span>	<span class="o">=</span> <span class="n">emif_for_calc</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">device_info</span><span class="p">;</span>
	<span class="n">type</span>		<span class="o">=</span> <span class="n">device_info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">cs1_used</span>	<span class="o">=</span> <span class="n">device_info</span><span class="o">-&gt;</span><span class="n">cs1_used</span><span class="p">;</span>
	<span class="n">ip_rev</span>		<span class="o">=</span> <span class="n">emif_for_calc</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">ip_rev</span><span class="p">;</span>
	<span class="n">phy_type</span>	<span class="o">=</span> <span class="n">emif_for_calc</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">;</span>

	<span class="n">min_tck</span>		<span class="o">=</span> <span class="n">emif_for_calc</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">min_tck</span><span class="p">;</span>
	<span class="n">custom_configs</span>	<span class="o">=</span> <span class="n">emif_for_calc</span><span class="o">-&gt;</span><span class="n">plat_data</span><span class="o">-&gt;</span><span class="n">custom_configs</span><span class="p">;</span>

	<span class="n">set_ddr_clk_period</span><span class="p">(</span><span class="n">freq</span><span class="p">);</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ref_ctrl_shdw</span> <span class="o">=</span> <span class="n">get_sdram_ref_ctrl_shdw</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">addressing</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim1_shdw</span> <span class="o">=</span> <span class="n">get_sdram_tim_1_shdw</span><span class="p">(</span><span class="n">timings</span><span class="p">,</span> <span class="n">min_tck</span><span class="p">,</span>
			<span class="n">addressing</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim2_shdw</span> <span class="o">=</span> <span class="n">get_sdram_tim_2_shdw</span><span class="p">(</span><span class="n">timings</span><span class="p">,</span> <span class="n">min_tck</span><span class="p">,</span>
			<span class="n">addressing</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim3_shdw</span> <span class="o">=</span> <span class="n">get_sdram_tim_3_shdw</span><span class="p">(</span><span class="n">timings</span><span class="p">,</span> <span class="n">min_tck</span><span class="p">,</span>
		<span class="n">addressing</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">ip_rev</span><span class="p">,</span> <span class="n">EMIF_NORMAL_TIMINGS</span><span class="p">);</span>

	<span class="n">cl</span> <span class="o">=</span> <span class="n">get_cl</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">EMIF_PHY_TYPE_ATTILAPHY</span> <span class="o">&amp;&amp;</span> <span class="n">ip_rev</span> <span class="o">==</span> <span class="n">EMIF_4D</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">phy_ctrl_1_shdw</span> <span class="o">=</span> <span class="n">get_ddr_phy_ctrl_1_attilaphy_4d</span><span class="p">(</span>
			<span class="n">timings</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">EMIF_PHY_TYPE_INTELLIPHY</span> <span class="o">&amp;&amp;</span> <span class="n">ip_rev</span> <span class="o">==</span> <span class="n">EMIF_4D5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">phy_ctrl_1_shdw</span> <span class="o">=</span> <span class="n">get_phy_ctrl_1_intelliphy_4d5</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ext_phy_ctrl_2_shdw</span> <span class="o">=</span> <span class="n">get_ext_phy_ctrl_2_intelliphy_4d5</span><span class="p">();</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ext_phy_ctrl_3_shdw</span> <span class="o">=</span> <span class="n">get_ext_phy_ctrl_3_intelliphy_4d5</span><span class="p">();</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ext_phy_ctrl_4_shdw</span> <span class="o">=</span> <span class="n">get_ext_phy_ctrl_4_intelliphy_4d5</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Only timeout values in pwr_mgmt_ctrl_shdw register */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pwr_mgmt_ctrl_shdw</span> <span class="o">=</span>
		<span class="n">get_pwr_mgmt_ctrl</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">emif_for_calc</span><span class="p">,</span> <span class="n">ip_rev</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">CS_TIM_MASK</span> <span class="o">|</span> <span class="n">SR_TIM_MASK</span> <span class="o">|</span> <span class="n">PD_TIM_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_rev</span> <span class="o">&amp;</span> <span class="n">EMIF_4D</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">read_idle_ctrl_shdw_normal</span> <span class="o">=</span>
			<span class="n">get_read_idle_ctrl_shdw</span><span class="p">(</span><span class="n">DDR_VOLTAGE_STABLE</span><span class="p">);</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">read_idle_ctrl_shdw_volt_ramp</span> <span class="o">=</span>
			<span class="n">get_read_idle_ctrl_shdw</span><span class="p">(</span><span class="n">DDR_VOLTAGE_RAMPING</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ip_rev</span> <span class="o">&amp;</span> <span class="n">EMIF_4D5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dll_calib_ctrl_shdw_normal</span> <span class="o">=</span>
			<span class="n">get_dll_calib_ctrl_shdw</span><span class="p">(</span><span class="n">DDR_VOLTAGE_STABLE</span><span class="p">);</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dll_calib_ctrl_shdw_volt_ramp</span> <span class="o">=</span>
			<span class="n">get_dll_calib_ctrl_shdw</span><span class="p">(</span><span class="n">DDR_VOLTAGE_RAMPING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S2</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">DDR_TYPE_LPDDR2_S4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ref_ctrl_shdw_derated</span> <span class="o">=</span> <span class="n">get_sdram_ref_ctrl_shdw</span><span class="p">(</span><span class="n">freq</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
			<span class="n">addressing</span><span class="p">);</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim1_shdw_derated</span> <span class="o">=</span>
			<span class="n">get_sdram_tim_1_shdw_derated</span><span class="p">(</span><span class="n">timings</span><span class="p">,</span> <span class="n">min_tck</span><span class="p">,</span>
				<span class="n">addressing</span><span class="p">);</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sdram_tim3_shdw_derated</span> <span class="o">=</span> <span class="n">get_sdram_tim_3_shdw</span><span class="p">(</span><span class="n">timings</span><span class="p">,</span>
			<span class="n">min_tck</span><span class="p">,</span> <span class="n">addressing</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">ip_rev</span><span class="p">,</span>
			<span class="n">EMIF_DERATED_TIMINGS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_regs() - gets the cached emif_regs structure for a given EMIF instance</span>
<span class="cm"> * given frequency(freq):</span>
<span class="cm"> *</span>
<span class="cm"> * As an optimisation, every EMIF instance other than EMIF1 shares the</span>
<span class="cm"> * register cache with EMIF1 if the devices connected on this instance</span>
<span class="cm"> * are same as that on EMIF1(indicated by the duplicate flag)</span>
<span class="cm"> *</span>
<span class="cm"> * If we do not have an entry corresponding to the frequency given, we</span>
<span class="cm"> * allocate a new entry and calculate the values</span>
<span class="cm"> *</span>
<span class="cm"> * Upon finding the right reg dump, save it in curr_regs. It can be</span>
<span class="cm"> * directly used for thermal de-rating and voltage ramping changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">emif_regs</span> <span class="o">*</span><span class="nf">get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_regs</span>	<span class="o">**</span><span class="n">regs_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">emif_regs</span>	<span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span> <span class="o">&amp;&amp;</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">==</span> <span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: using curr_regs - %u Hz&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">duplicate</span><span class="p">)</span>
		<span class="n">regs_cache</span> <span class="o">=</span> <span class="n">emif1</span><span class="o">-&gt;</span><span class="n">regs_cache</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">regs_cache</span> <span class="o">=</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">regs_cache</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EMIF_MAX_NUM_FREQUENCIES</span> <span class="o">&amp;&amp;</span> <span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">==</span> <span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">regs</span> <span class="o">=</span> <span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: reg dump found in reg cache for %u Hz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have an entry for this frequency in the cache create one</span>
<span class="cm">	 * and calculate the values</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">regs</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_emif_reg_values</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">devm_kfree</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now look for an un-used entry in the cache and save the</span>
<span class="cm">		 * newly created struct. If there are no free entries</span>
<span class="cm">		 * over-write the last entry</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EMIF_MAX_NUM_FREQUENCIES</span> <span class="o">&amp;&amp;</span> <span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">EMIF_MAX_NUM_FREQUENCIES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: regs_cache full - reusing a slot!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">EMIF_MAX_NUM_FREQUENCIES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">devm_kfree</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">regs_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">regs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_volt_notify_handling</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="n">u32</span> <span class="n">volt_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: voltage notification : %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">volt_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: volt-notify before registers are ready: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">volt_state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setup_volt_sensitive_regs</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span><span class="p">,</span> <span class="n">volt_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TODO: voltage notify handling should be hooked up to</span>
<span class="cm"> * regulator framework as soon as the necessary support</span>
<span class="cm"> * is available in mainline kernel. This function is un-used</span>
<span class="cm"> * right now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span> <span class="n">volt_notify_handling</span><span class="p">(</span><span class="n">u32</span> <span class="n">volt_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">do_volt_notify_handling</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">volt_state</span><span class="p">);</span>
	<span class="n">do_freq_update</span><span class="p">();</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_freq_pre_notify_handling</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">get_regs</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">new_freq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">emif</span><span class="o">-&gt;</span><span class="n">curr_regs</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the shadow registers:</span>
<span class="cm">	 * Temperature and voltage-ramp sensitive settings are also configured</span>
<span class="cm">	 * in terms of DDR cycles. So, we need to update them too when there</span>
<span class="cm">	 * is a freq change</span>
<span class="cm">	 */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: setting up shadow registers for %uHz&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">new_freq</span><span class="p">);</span>
	<span class="n">setup_registers</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">setup_temperature_sensitive_regs</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">setup_volt_sensitive_regs</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">DDR_VOLTAGE_STABLE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Part of workaround for errata i728. See do_freq_update()</span>
<span class="cm">	 * for more details</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">lpmode</span> <span class="o">==</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span><span class="p">)</span>
		<span class="n">set_lpmode</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">EMIF_LP_MODE_DISABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TODO: frequency notify handling should be hooked up to</span>
<span class="cm"> * clock framework as soon as the necessary support is</span>
<span class="cm"> * available in mainline kernel. This function is un-used</span>
<span class="cm"> * right now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span> <span class="n">freq_pre_notify_handling</span><span class="p">(</span><span class="n">u32</span> <span class="n">new_freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: we are taking the spin-lock here and releases it</span>
<span class="cm">	 * only in post-notifier. This doesn&#39;t look good and</span>
<span class="cm">	 * Sparse complains about it, but this seems to be</span>
<span class="cm">	 * un-avoidable. We need to lock a sequence of events</span>
<span class="cm">	 * that is split between EMIF and clock framework.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1. EMIF driver updates EMIF timings in shadow registers in the</span>
<span class="cm">	 *    frequency pre-notify callback from clock framework</span>
<span class="cm">	 * 2. clock framework sets up the registers for the new frequency</span>
<span class="cm">	 * 3. clock framework initiates a hw-sequence that updates</span>
<span class="cm">	 *    the frequency EMIF timings synchronously.</span>
<span class="cm">	 *</span>
<span class="cm">	 * All these 3 steps should be performed as an atomic operation</span>
<span class="cm">	 * vis-a-vis similar sequence in the EMIF interrupt handler</span>
<span class="cm">	 * for temperature events. Otherwise, there could be race</span>
<span class="cm">	 * conditions that could result in incorrect EMIF timings for</span>
<span class="cm">	 * a given frequency</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">do_freq_pre_notify_handling</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">new_freq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_freq_post_notify_handling</span><span class="p">(</span><span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Part of workaround for errata i728. See do_freq_update()</span>
<span class="cm">	 * for more details</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emif</span><span class="o">-&gt;</span><span class="n">lpmode</span> <span class="o">==</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span><span class="p">)</span>
		<span class="n">set_lpmode</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="n">EMIF_LP_MODE_SELF_REFRESH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TODO: frequency notify handling should be hooked up to</span>
<span class="cm"> * clock framework as soon as the necessary support is</span>
<span class="cm"> * available in mainline kernel. This function is un-used</span>
<span class="cm"> * right now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span> <span class="n">freq_post_notify_handling</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">emif_data</span> <span class="o">*</span><span class="n">emif</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">emif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">do_freq_post_notify_handling</span><span class="p">(</span><span class="n">emif</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lock is done in pre-notify handler. See freq_pre_notify_handling()</span>
<span class="cm">	 * for more details</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_lock</span><span class="p">,</span> <span class="n">irq_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">emif_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">emif_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">emif_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;emif&quot;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">emif_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_driver</span><span class="p">,</span> <span class="n">emif_probe</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">emif_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emif_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">emif_register</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">emif_unregister</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;TI EMIF SDRAM Controller Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:emif&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Texas Instruments Inc&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
