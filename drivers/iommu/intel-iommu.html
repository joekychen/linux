<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › iommu › intel-iommu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>intel-iommu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, Intel Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Intel Corporation</span>
<span class="cm"> * Author: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
<span class="cm"> * Author: Shaohua Li &lt;shaohua.li@intel.com&gt;</span>
<span class="cm"> * Author: Anil S Keshavamurthy &lt;anil.s.keshavamurthy@intel.com&gt;</span>
<span class="cm"> * Author: Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dmar.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/iova.h&gt;</span>
<span class="cp">#include &lt;linux/iommu.h&gt;</span>
<span class="cp">#include &lt;linux/intel-iommu.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/tboot.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/pci-ats.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;asm/irq_remapping.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/iommu.h&gt;</span>

<span class="cp">#define ROOT_SIZE		VTD_PAGE_SIZE</span>
<span class="cp">#define CONTEXT_SIZE		VTD_PAGE_SIZE</span>

<span class="cp">#define IS_GFX_DEVICE(pdev) ((pdev-&gt;class &gt;&gt; 16) == PCI_BASE_CLASS_DISPLAY)</span>
<span class="cp">#define IS_ISA_DEVICE(pdev) ((pdev-&gt;class &gt;&gt; 8) == PCI_CLASS_BRIDGE_ISA)</span>
<span class="cp">#define IS_AZALIA(pdev) ((pdev)-&gt;vendor == 0x8086 &amp;&amp; (pdev)-&gt;device == 0x3a3e)</span>

<span class="cp">#define IOAPIC_RANGE_START	(0xfee00000)</span>
<span class="cp">#define IOAPIC_RANGE_END	(0xfeefffff)</span>
<span class="cp">#define IOVA_START_ADDR		(0x1000)</span>

<span class="cp">#define DEFAULT_DOMAIN_ADDRESS_WIDTH 48</span>

<span class="cp">#define MAX_AGAW_WIDTH 64</span>

<span class="cp">#define __DOMAIN_MAX_PFN(gaw)  ((((uint64_t)1) &lt;&lt; (gaw-VTD_PAGE_SHIFT)) - 1)</span>
<span class="cp">#define __DOMAIN_MAX_ADDR(gaw) ((((uint64_t)1) &lt;&lt; gaw) - 1)</span>

<span class="cm">/* We limit DOMAIN_MAX_PFN to fit in an unsigned long, and DOMAIN_MAX_ADDR</span>
<span class="cm">   to match. That way, we can use &#39;unsigned long&#39; for PFNs with impunity. */</span>
<span class="cp">#define DOMAIN_MAX_PFN(gaw)	((unsigned long) min_t(uint64_t, \</span>
<span class="cp">				__DOMAIN_MAX_PFN(gaw), (unsigned long)-1))</span>
<span class="cp">#define DOMAIN_MAX_ADDR(gaw)	(((uint64_t)__DOMAIN_MAX_PFN(gaw)) &lt;&lt; VTD_PAGE_SHIFT)</span>

<span class="cp">#define IOVA_PFN(addr)		((addr) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define DMA_32BIT_PFN		IOVA_PFN(DMA_BIT_MASK(32))</span>
<span class="cp">#define DMA_64BIT_PFN		IOVA_PFN(DMA_BIT_MASK(64))</span>

<span class="cm">/* page table handling */</span>
<span class="cp">#define LEVEL_STRIDE		(9)</span>
<span class="cp">#define LEVEL_MASK		(((u64)1 &lt;&lt; LEVEL_STRIDE) - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * This bitmap is used to advertise the page sizes our hardware support</span>
<span class="cm"> * to the IOMMU core, which will then use this information to split</span>
<span class="cm"> * physically contiguous memory regions it is mapping into page sizes</span>
<span class="cm"> * that we support.</span>
<span class="cm"> *</span>
<span class="cm"> * Traditionally the IOMMU core just handed us the mappings directly,</span>
<span class="cm"> * after making sure the size is an order of a 4KiB page and that the</span>
<span class="cm"> * mapping has natural alignment.</span>
<span class="cm"> *</span>
<span class="cm"> * To retain this behavior, we currently advertise that we support</span>
<span class="cm"> * all page sizes that are an order of 4KiB.</span>
<span class="cm"> *</span>
<span class="cm"> * If at some point we&#39;d like to utilize the IOMMU core&#39;s new behavior,</span>
<span class="cm"> * we could change this to advertise the real page sizes we support.</span>
<span class="cm"> */</span>
<span class="cp">#define INTEL_IOMMU_PGSIZES	(~0xFFFUL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">agaw_to_level</span><span class="p">(</span><span class="kt">int</span> <span class="n">agaw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">agaw</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">agaw_to_width</span><span class="p">(</span><span class="kt">int</span> <span class="n">agaw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">30</span> <span class="o">+</span> <span class="n">agaw</span> <span class="o">*</span> <span class="n">LEVEL_STRIDE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">width_to_agaw</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">30</span><span class="p">)</span> <span class="o">/</span> <span class="n">LEVEL_STRIDE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">level_to_offset_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">LEVEL_STRIDE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pfn_level_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;&gt;</span> <span class="n">level_to_offset_bits</span><span class="p">(</span><span class="n">level</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">LEVEL_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">level_mask</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">level_to_offset_bits</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">level_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">level_to_offset_bits</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">align_to_level</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">+</span> <span class="n">level_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">level_mask</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lvl_to_nr_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lvl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">lvl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">LEVEL_STRIDE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* VT-d pages must always be _smaller_ than MM pages. Otherwise things</span>
<span class="cm">   are never going to work. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">dma_to_mm_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_pfn</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mm_to_dma_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mm_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mm_pfn</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">page_to_dma_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pg</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">virt_to_dma_pfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page_to_dma_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* global iommu list, set NULL for ignored DMAR units */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">**</span><span class="n">g_iommus</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">check_tylersburg_isoch</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rwbf_quirk</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * set to 1 to panic kernel if can&#39;t successfully enable VT-d</span>
<span class="cm"> * (used when kernel is launched w/ TXT)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">force_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * 0: Present</span>
<span class="cm"> * 1-11: Reserved</span>
<span class="cm"> * 12-63: Context Ptr (12 - (haw-1))</span>
<span class="cm"> * 64-127: Reserved</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">root_entry</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">val</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">rsvd1</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define ROOT_ENTRY_NR (VTD_PAGE_SIZE/sizeof(struct root_entry))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">root_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_root_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_root_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">|=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="n">VTD_PAGE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span>
<span class="nf">get_context_addr_from_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">root_present</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="o">?</span><span class="n">phys_to_virt</span><span class="p">(</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">VTD_PAGE_MASK</span><span class="p">)</span> <span class="o">:</span>
		<span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * low 64 bits:</span>
<span class="cm"> * 0: present</span>
<span class="cm"> * 1: fault processing disable</span>
<span class="cm"> * 2-3: translation type</span>
<span class="cm"> * 12-63: address space root</span>
<span class="cm"> * high 64 bits:</span>
<span class="cm"> * 0-2: address width</span>
<span class="cm"> * 3-6: aval</span>
<span class="cm"> * 8-23: domain id</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">context_entry</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">context_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">context_set_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">context_set_fault_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">&amp;=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">context_set_translation_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">&amp;=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">|=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">context_set_address_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">|=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="n">VTD_PAGE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">context_set_address_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">hi</span> <span class="o">|=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">context_set_domain_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">hi</span> <span class="o">|=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">context_clear_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 0: readable</span>
<span class="cm"> * 1: writable</span>
<span class="cm"> * 2-6: reserved</span>
<span class="cm"> * 7: super page</span>
<span class="cm"> * 8-10: available</span>
<span class="cm"> * 11: snoop behavior</span>
<span class="cm"> * 12-63: Host physcial address</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_pte</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_clear_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_set_pte_readable</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">|=</span> <span class="n">DMA_PTE_READ</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_set_pte_writable</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">|=</span> <span class="n">DMA_PTE_WRITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_set_pte_snp</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">|=</span> <span class="n">DMA_PTE_SNP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_set_pte_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">dma_pte_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">return</span> <span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">VTD_PAGE_MASK</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* Must have a full atomic 64-bit read */</span>
	<span class="k">return</span>  <span class="n">__cmpxchg64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VTD_PAGE_MASK</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_set_pte_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dma_pte_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dma_pte_superpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">first_pte_in_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VTD_PAGE_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This domain is a statically identity mapping domain.</span>
<span class="cm"> *	1. This domain creats a static 1:1 mapping to all usable memory.</span>
<span class="cm"> * 	2. It maps to each iommu if successful.</span>
<span class="cm"> *	3. Each iommu mapps to this domain if successful.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">si_domain</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hw_pass_through</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* devices under the same p2p bridge are owned in one domain */</span>
<span class="cp">#define DOMAIN_FLAG_P2P_MULTIPLE_DEVICES (1 &lt;&lt; 0)</span>

<span class="cm">/* domain represents a virtual machine, more than one devices</span>
<span class="cm"> * across iommus may be owned in one domain, e.g. kvm guest.</span>
<span class="cm"> */</span>
<span class="cp">#define DOMAIN_FLAG_VIRTUAL_MACHINE	(1 &lt;&lt; 1)</span>

<span class="cm">/* si_domain contains mulitple devices */</span>
<span class="cp">#define DOMAIN_FLAG_STATIC_IDENTITY	(1 &lt;&lt; 2)</span>

<span class="cm">/* define the limit of IOMMUs supported in each domain */</span>
<span class="cp">#ifdef	CONFIG_X86</span>
<span class="cp"># define	IOMMU_UNITS_SUPPORTED	MAX_IO_APICS</span>
<span class="cp">#else</span>
<span class="cp"># define	IOMMU_UNITS_SUPPORTED	64</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">id</span><span class="p">;</span>			<span class="cm">/* domain id */</span>
	<span class="kt">int</span>	<span class="n">nid</span><span class="p">;</span>			<span class="cm">/* node id */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">iommu_bmp</span><span class="p">,</span> <span class="n">IOMMU_UNITS_SUPPORTED</span><span class="p">);</span>
					<span class="cm">/* bitmap of iommus this domain uses*/</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">devices</span><span class="p">;</span> 	<span class="cm">/* all devices&#39; list */</span>
	<span class="k">struct</span> <span class="n">iova_domain</span> <span class="n">iovad</span><span class="p">;</span>	<span class="cm">/* iova&#39;s that belong to this domain */</span>

	<span class="k">struct</span> <span class="n">dma_pte</span>	<span class="o">*</span><span class="n">pgd</span><span class="p">;</span>		<span class="cm">/* virtual address */</span>
	<span class="kt">int</span>		<span class="n">gaw</span><span class="p">;</span>		<span class="cm">/* max guest address width */</span>

	<span class="cm">/* adjusted guest address width, 0 is level 2 30-bit */</span>
	<span class="kt">int</span>		<span class="n">agaw</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* flags to find out type of domain */</span>

	<span class="kt">int</span>		<span class="n">iommu_coherency</span><span class="p">;</span><span class="cm">/* indicate coherency of iommu access */</span>
	<span class="kt">int</span>		<span class="n">iommu_snooping</span><span class="p">;</span> <span class="cm">/* indicate snooping control feature*/</span>
	<span class="kt">int</span>		<span class="n">iommu_count</span><span class="p">;</span>	<span class="cm">/* reference count of iommu */</span>
	<span class="kt">int</span>		<span class="n">iommu_superpage</span><span class="p">;</span><span class="cm">/* Level of superpages supported:</span>
<span class="cm">					   0 == 4KiB (no superpages), 1 == 2MiB,</span>
<span class="cm">					   2 == 1GiB, 3 == 512GiB, 4 == 1TiB */</span>
	<span class="n">spinlock_t</span>	<span class="n">iommu_lock</span><span class="p">;</span>	<span class="cm">/* protect iommu set in domain */</span>
	<span class="n">u64</span>		<span class="n">max_addr</span><span class="p">;</span>	<span class="cm">/* maximum mapped address */</span>
<span class="p">};</span>

<span class="cm">/* PCI domain-device relationship */</span>
<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>	<span class="cm">/* link to domain siblings */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">global</span><span class="p">;</span> <span class="cm">/* link to global list */</span>
	<span class="kt">int</span> <span class="n">segment</span><span class="p">;</span>		<span class="cm">/* PCI domain */</span>
	<span class="n">u8</span> <span class="n">bus</span><span class="p">;</span>			<span class="cm">/* PCI bus number */</span>
	<span class="n">u8</span> <span class="n">devfn</span><span class="p">;</span>		<span class="cm">/* PCI devfn number */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* it&#39;s NULL for PCIe-to-PCI bridge */</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span> <span class="cm">/* IOMMU used by this device */</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span> <span class="cm">/* pointer to domain */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">flush_unmaps_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="n">DEFINE_TIMER</span><span class="p">(</span><span class="n">unmap_timer</span><span class="p">,</span>  <span class="n">flush_unmaps_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#define HIGH_WATER_MARK 250</span>
<span class="k">struct</span> <span class="n">deferred_flush_tables</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span><span class="p">[</span><span class="n">HIGH_WATER_MARK</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">[</span><span class="n">HIGH_WATER_MARK</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">deferred_flush_tables</span> <span class="o">*</span><span class="n">deferred_flush</span><span class="p">;</span>

<span class="cm">/* bitmap for indexing intel_iommus */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">g_num_of_iommus</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">async_umap_flush_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">unmaps_to_do</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">timer_on</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">list_size</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">domain_remove_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_INTEL_IOMMU_DEFAULT_ON</span>
<span class="kt">int</span> <span class="n">dmar_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="n">dmar_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/*CONFIG_INTEL_IOMMU_DEFAULT_ON*/</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">intel_iommu_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">intel_iommu_enabled</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dmar_map_gfx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dmar_forcedac</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">intel_iommu_strict</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">intel_iommu_superpage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">intel_iommu_gfx_mapped</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">intel_iommu_gfx_mapped</span><span class="p">);</span>

<span class="cp">#define DUMMY_DEVICE_DOMAIN_INFO ((struct device_domain_info *)(-1))</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">device_domain_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">device_domain_list</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iommu_ops</span> <span class="n">intel_iommu_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">intel_iommu_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dmar_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Intel-IOMMU: enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dmar_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Intel-IOMMU: disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;igfx_off&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dmar_map_gfx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;Intel-IOMMU: disable GFX device mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;forcedac&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;Intel-IOMMU: Forcing DAC for PCI devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dmar_forcedac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;strict&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;Intel-IOMMU: disable batched IOTLB flush</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">intel_iommu_strict</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;sp_off&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;Intel-IOMMU: disable supported super page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">intel_iommu_superpage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">str</span> <span class="o">+=</span> <span class="n">strcspn</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
			<span class="n">str</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;intel_iommu=&quot;</span><span class="p">,</span> <span class="n">intel_iommu_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">iommu_domain_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">iommu_devinfo_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">iommu_iova_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_pgtable_page</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_pgtable_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_domain_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">iommu_domain_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_domain_mem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">iommu_domain_cache</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">alloc_devinfo_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">iommu_devinfo_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_devinfo_mem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">iommu_devinfo_cache</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="nf">alloc_iova_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">iommu_iova_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_iova_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">iommu_iova_cache</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">__iommu_calculate_agaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_gaw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sagaw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agaw</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">sagaw</span> <span class="o">=</span> <span class="n">cap_sagaw</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">agaw</span> <span class="o">=</span> <span class="n">width_to_agaw</span><span class="p">(</span><span class="n">max_gaw</span><span class="p">);</span>
	     <span class="n">agaw</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">agaw</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">agaw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sagaw</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">agaw</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate max SAGAW for each iommu.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iommu_calculate_max_sagaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__iommu_calculate_agaw</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">MAX_AGAW_WIDTH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * calculate agaw for each iommu.</span>
<span class="cm"> * &quot;SAGAW&quot; may be different across iommus, use a default agaw, and</span>
<span class="cm"> * get a supported less agaw for iommus that don&#39;t support the default agaw.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iommu_calculate_agaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__iommu_calculate_agaw</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">DEFAULT_DOMAIN_ADDRESS_WIDTH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This functionin only returns single iommu in a domain */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="nf">domain_get_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iommu_id</span><span class="p">;</span>

	<span class="cm">/* si_domain and vm domain should not get here. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_VIRTUAL_MACHINE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_STATIC_IDENTITY</span><span class="p">);</span>

	<span class="n">iommu_id</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">,</span> <span class="n">g_num_of_iommus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">iommu_id</span> <span class="o">&gt;=</span> <span class="n">g_num_of_iommus</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">g_iommus</span><span class="p">[</span><span class="n">iommu_id</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_update_iommu_coherency</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_coherency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">,</span> <span class="n">g_num_of_iommus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecap_coherent</span><span class="p">(</span><span class="n">g_iommus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_coherency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_update_iommu_snooping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_snooping</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">,</span> <span class="n">g_num_of_iommus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecap_sc_support</span><span class="p">(</span><span class="n">g_iommus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_snooping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_update_iommu_superpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_iommu_superpage</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_superpage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set iommu_superpage to the smallest common denominator */</span>
	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">cap_super_page_val</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_superpage</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Some capabilities may be different across iommus */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_update_iommu_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">domain_update_iommu_coherency</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">domain_update_iommu_snooping</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">domain_update_iommu_superpage</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="nf">device_to_iommu</span><span class="p">(</span><span class="kt">int</span> <span class="n">segment</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segment</span> <span class="o">!=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			    <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="n">bus</span> <span class="o">&amp;&amp;</span>
			    <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">devfn</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			    <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">subordinate</span> <span class="o">&amp;&amp;</span>
			    <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="n">bus</span> <span class="o">&amp;&amp;</span>
			    <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">subordinate</span> <span class="o">&gt;=</span> <span class="n">bus</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">include_all</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_flush_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_coherency</span><span class="p">)</span>
		<span class="n">clflush_cache_range</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Gets context entry for a given bus and devfn */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span> <span class="nf">device_to_context_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phy_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span><span class="p">[</span><span class="n">bus</span><span class="p">];</span>
	<span class="n">context</span> <span class="o">=</span> <span class="n">get_context_addr_from_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">alloc_pgtable_page</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__iommu_flush_cache</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">,</span> <span class="n">CONTEXT_SIZE</span><span class="p">);</span>
		<span class="n">phy_addr</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">);</span>
		<span class="n">set_root_value</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">);</span>
		<span class="n">set_root_present</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="n">__iommu_flush_cache</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">root</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">[</span><span class="n">devfn</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_context_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span><span class="p">[</span><span class="n">bus</span><span class="p">];</span>
	<span class="n">context</span> <span class="o">=</span> <span class="n">get_context_addr_from_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">context_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">[</span><span class="n">devfn</span><span class="p">]);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_context_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span><span class="p">[</span><span class="n">bus</span><span class="p">];</span>
	<span class="n">context</span> <span class="o">=</span> <span class="n">get_context_addr_from_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context_clear_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">[</span><span class="n">devfn</span><span class="p">]);</span>
		<span class="n">__iommu_flush_cache</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">[</span><span class="n">devfn</span><span class="p">],</span> \
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_context_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ROOT_ENTRY_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">get_context_addr_from_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">)</span>
			<span class="n">free_pgtable_page</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">free_pgtable_page</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="nf">pfn_to_dma_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">addr_width</span> <span class="o">=</span> <span class="n">agaw_to_width</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">)</span> <span class="o">-</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">agaw_to_level</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr_width</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span> <span class="o">&amp;&amp;</span> <span class="n">pfn</span> <span class="o">&gt;&gt;</span> <span class="n">addr_width</span><span class="p">);</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">tmp_page</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">pfn_level_offset</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_level</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dma_pte_superpage</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">dma_pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">target_level</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="n">pteval</span><span class="p">;</span>

			<span class="n">tmp_page</span> <span class="o">=</span> <span class="n">alloc_pgtable_page</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_page</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">domain_flush_cache</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">tmp_page</span><span class="p">,</span> <span class="n">VTD_PAGE_SIZE</span><span class="p">);</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">virt_to_dma_pfn</span><span class="p">(</span><span class="n">tmp_page</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">DMA_PTE_READ</span> <span class="o">|</span> <span class="n">DMA_PTE_WRITE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">,</span> <span class="n">pteval</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Someone else set it while we were thinking; use theirs. */</span>
				<span class="n">free_pgtable_page</span><span class="p">(</span><span class="n">tmp_page</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dma_pte_addr</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
				<span class="n">domain_flush_cache</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_pte_addr</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
		<span class="n">level</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* return address&#39;s pte at specific level */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="nf">dma_pfn_level_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">large_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">agaw_to_level</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">total</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">pfn_level_offset</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">total</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">large_page</span> <span class="o">=</span> <span class="n">total</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DMA_PTE_LARGE_PAGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">large_page</span> <span class="o">=</span> <span class="n">total</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_pte_addr</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
		<span class="n">total</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* clear last level pte, a tlb flush should be followed */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_pte_clear_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">addr_width</span> <span class="o">=</span> <span class="n">agaw_to_width</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">)</span> <span class="o">-</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">large_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">first_pte</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr_width</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span> <span class="o">&amp;&amp;</span> <span class="n">start_pfn</span> <span class="o">&gt;&gt;</span> <span class="n">addr_width</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr_width</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span> <span class="o">&amp;&amp;</span> <span class="n">last_pfn</span> <span class="o">&gt;&gt;</span> <span class="n">addr_width</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start_pfn</span> <span class="o">&gt;</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="cm">/* we don&#39;t need lock here; nobody else touches the iova range */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">large_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">first_pte</span> <span class="o">=</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">dma_pfn_level_pte</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">large_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">align_to_level</span><span class="p">(</span><span class="n">start_pfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">large_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">dma_clear_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
			<span class="n">start_pfn</span> <span class="o">+=</span> <span class="n">lvl_to_nr_pages</span><span class="p">(</span><span class="n">large_page</span><span class="p">);</span>
			<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;=</span> <span class="n">last_pfn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">first_pte_in_page</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>

		<span class="n">domain_flush_cache</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">first_pte</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pte</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">first_pte</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&amp;&amp;</span> <span class="n">start_pfn</span> <span class="o">&lt;=</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="n">order</span> <span class="o">=</span> <span class="p">(</span><span class="n">large_page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* free page table pages. last level pte should already be cleared */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_pte_free_pagetable</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">addr_width</span> <span class="o">=</span> <span class="n">agaw_to_width</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">)</span> <span class="o">-</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">first_pte</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">agaw_to_level</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">large_page</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr_width</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span> <span class="o">&amp;&amp;</span> <span class="n">start_pfn</span> <span class="o">&gt;&gt;</span> <span class="n">addr_width</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr_width</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span> <span class="o">&amp;&amp;</span> <span class="n">last_pfn</span> <span class="o">&gt;&gt;</span> <span class="n">addr_width</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start_pfn</span> <span class="o">&gt;</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t need lock here; nobody else touches the iova range */</span>
	<span class="n">level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">total</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">align_to_level</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

		<span class="cm">/* If we can&#39;t even clear one PTE at this level, we&#39;re done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">level_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">last_pfn</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">large_page</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
			<span class="n">first_pte</span> <span class="o">=</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">dma_pfn_level_pte</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">large_page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">large_page</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">)</span>
				<span class="n">level</span> <span class="o">=</span> <span class="n">large_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">align_to_level</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dma_pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">free_pgtable_page</span><span class="p">(</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_pte_addr</span><span class="p">(</span><span class="n">pte</span><span class="p">)));</span>
					<span class="n">dma_clear_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">+=</span> <span class="n">level_size</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">first_pte_in_page</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="n">tmp</span> <span class="o">+</span> <span class="n">level_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">last_pfn</span><span class="p">);</span>

			<span class="n">domain_flush_cache</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">first_pte</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pte</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">first_pte</span><span class="p">);</span>
			
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">level_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">last_pfn</span><span class="p">);</span>
		<span class="n">level</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* free pgd */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">last_pfn</span> <span class="o">==</span> <span class="n">DOMAIN_MAX_PFN</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_pgtable_page</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* iommu handling */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_alloc_root_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">alloc_pgtable_page</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">__iommu_flush_cache</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ROOT_SIZE</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_set_root_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">root_entry</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">dmar_writeq</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_RTADDR_REG</span><span class="p">,</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">gcmd</span> <span class="o">|</span> <span class="n">DMA_GCMD_SRTP</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_GCMD_REG</span><span class="p">);</span>

	<span class="cm">/* Make sure hardware complete it */</span>
	<span class="n">IOMMU_WAIT_OP</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">DMAR_GSTS_REG</span><span class="p">,</span>
		      <span class="n">readl</span><span class="p">,</span> <span class="p">(</span><span class="n">sts</span> <span class="o">&amp;</span> <span class="n">DMA_GSTS_RTPS</span><span class="p">),</span> <span class="n">sts</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_flush_write_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rwbf_quirk</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cap_rwbf</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">gcmd</span> <span class="o">|</span> <span class="n">DMA_GCMD_WBF</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_GCMD_REG</span><span class="p">);</span>

	<span class="cm">/* Make sure hardware complete it */</span>
	<span class="n">IOMMU_WAIT_OP</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">DMAR_GSTS_REG</span><span class="p">,</span>
		      <span class="n">readl</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DMA_GSTS_WBFS</span><span class="p">)),</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* return value determine if we need a write buffer flush */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__iommu_flush_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">did</span><span class="p">,</span> <span class="n">u16</span> <span class="n">source_id</span><span class="p">,</span> <span class="n">u8</span> <span class="n">function_mask</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_CCMD_GLOBAL_INVL</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">DMA_CCMD_GLOBAL_INVL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_CCMD_DOMAIN_INVL</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">DMA_CCMD_DOMAIN_INVL</span><span class="o">|</span><span class="n">DMA_CCMD_DID</span><span class="p">(</span><span class="n">did</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_CCMD_DEVICE_INVL</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">DMA_CCMD_DEVICE_INVL</span><span class="o">|</span><span class="n">DMA_CCMD_DID</span><span class="p">(</span><span class="n">did</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">DMA_CCMD_SID</span><span class="p">(</span><span class="n">source_id</span><span class="p">)</span> <span class="o">|</span> <span class="n">DMA_CCMD_FM</span><span class="p">(</span><span class="n">function_mask</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">DMA_CCMD_ICC</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">dmar_writeq</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_CCMD_REG</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Make sure hardware complete it */</span>
	<span class="n">IOMMU_WAIT_OP</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">DMAR_CCMD_REG</span><span class="p">,</span>
		<span class="n">dmar_readq</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DMA_CCMD_ICC</span><span class="p">)),</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* return value determine if we need a write buffer flush */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__iommu_flush_iotlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">did</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_order</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tlb_offset</span> <span class="o">=</span> <span class="n">ecap_iotlb_offset</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val_iva</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_TLB_GLOBAL_FLUSH</span>:
		<span class="cm">/* global flush doesn&#39;t need set IVA_REG */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">DMA_TLB_GLOBAL_FLUSH</span><span class="o">|</span><span class="n">DMA_TLB_IVT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_TLB_DSI_FLUSH</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">DMA_TLB_DSI_FLUSH</span><span class="o">|</span><span class="n">DMA_TLB_IVT</span><span class="o">|</span><span class="n">DMA_TLB_DID</span><span class="p">(</span><span class="n">did</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_TLB_PSI_FLUSH</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">DMA_TLB_PSI_FLUSH</span><span class="o">|</span><span class="n">DMA_TLB_IVT</span><span class="o">|</span><span class="n">DMA_TLB_DID</span><span class="p">(</span><span class="n">did</span><span class="p">);</span>
		<span class="cm">/* Note: always flush non-leaf currently */</span>
		<span class="n">val_iva</span> <span class="o">=</span> <span class="n">size_order</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/* Note: set drain read/write */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/*</span>
<span class="c">	 * This is probably to be super secure.. Looks like we can</span>
<span class="c">	 * ignore it without any impact.</span>
<span class="c">	 */</span>
<span class="c">	if (cap_read_drain(iommu-&gt;cap))</span>
<span class="c">		val |= DMA_TLB_READ_DRAIN;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap_write_drain</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">DMA_TLB_WRITE_DRAIN</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="cm">/* Note: Only uses first TLB reg currently */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val_iva</span><span class="p">)</span>
		<span class="n">dmar_writeq</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">tlb_offset</span><span class="p">,</span> <span class="n">val_iva</span><span class="p">);</span>
	<span class="n">dmar_writeq</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">tlb_offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Make sure hardware complete it */</span>
	<span class="n">IOMMU_WAIT_OP</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">tlb_offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
		<span class="n">dmar_readq</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DMA_TLB_IVT</span><span class="p">)),</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

	<span class="cm">/* check IOTLB invalidation granularity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DMA_TLB_IAIG</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;IOMMU: flush IOTLB failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DMA_TLB_IAIG</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DMA_TLB_IIRG</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;IOMMU: tlb flush request %Lx, actual %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">DMA_TLB_IIRG</span><span class="p">(</span><span class="n">type</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">DMA_TLB_IAIG</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="nf">iommu_support_dev_iotlb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">segment</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecap_dev_iotlb_support</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">qi</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">devfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_ATS</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmar_find_matched_atsr_unit</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">iommu</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_enable_dev_iotlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_enable_ats</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_disable_dev_iotlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">pci_ats_enabled</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_disable_ats</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_flush_dev_iotlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">sid</span><span class="p">,</span> <span class="n">qdep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">pci_ats_enabled</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sid</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
		<span class="n">qdep</span> <span class="o">=</span> <span class="n">pci_ats_queue_depth</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">qi_flush_dev_iotlb</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">qdep</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_flush_iotlb_psi</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">did</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">__roundup_pow_of_two</span><span class="p">(</span><span class="n">pages</span><span class="p">));</span>
	<span class="kt">uint64_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fallback to domain selective flush if no PSI support or the size is</span>
<span class="cm">	 * too big.</span>
<span class="cm">	 * PSI requires page size to be 2 ^ x, and the base address is naturally</span>
<span class="cm">	 * aligned to the size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_pgsel_inv</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">)</span> <span class="o">||</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="n">cap_max_amask_val</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">DMA_TLB_DSI_FLUSH</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
						<span class="n">DMA_TLB_PSI_FLUSH</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In caching mode, changes of pages from non-present to present require</span>
<span class="cm">	 * flush. However, device IOTLB doesn&#39;t need to be flushed in this case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_caching_mode</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="n">iommu_flush_dev_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">did</span><span class="p">],</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_disable_protect_mem_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pmen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pmen</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_PMEN_REG</span><span class="p">);</span>
	<span class="n">pmen</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_PMEN_EPM</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pmen</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_PMEN_REG</span><span class="p">);</span>

	<span class="cm">/* wait for the protected region status bit to clear */</span>
	<span class="n">IOMMU_WAIT_OP</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">DMAR_PMEN_REG</span><span class="p">,</span>
		<span class="n">readl</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">pmen</span> <span class="o">&amp;</span> <span class="n">DMA_PMEN_PRS</span><span class="p">),</span> <span class="n">pmen</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_enable_translation</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">gcmd</span> <span class="o">|=</span> <span class="n">DMA_GCMD_TE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">gcmd</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_GCMD_REG</span><span class="p">);</span>

	<span class="cm">/* Make sure hardware complete it */</span>
	<span class="n">IOMMU_WAIT_OP</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">DMAR_GSTS_REG</span><span class="p">,</span>
		      <span class="n">readl</span><span class="p">,</span> <span class="p">(</span><span class="n">sts</span> <span class="o">&amp;</span> <span class="n">DMA_GSTS_TES</span><span class="p">),</span> <span class="n">sts</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_disable_translation</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">gcmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_GCMD_TE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">gcmd</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_GCMD_REG</span><span class="p">);</span>

	<span class="cm">/* Make sure hardware complete it */</span>
	<span class="n">IOMMU_WAIT_OP</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">DMAR_GSTS_REG</span><span class="p">,</span>
		      <span class="n">readl</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sts</span> <span class="o">&amp;</span> <span class="n">DMA_GSTS_TES</span><span class="p">)),</span> <span class="n">sts</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_init_domains</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ndomains</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nlongs</span><span class="p">;</span>

	<span class="n">ndomains</span> <span class="o">=</span> <span class="n">cap_ndoms</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;IOMMU %d: Number of Domains supported &lt;%ld&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span>
			<span class="n">ndomains</span><span class="p">);</span>
	<span class="n">nlongs</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">ndomains</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* TBD: there might be 64K domains,</span>
<span class="cm">	 * consider other allocation for future chip</span>
<span class="cm">	 */</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">nlongs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Allocating domain id array failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">ndomains</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Allocating domain array failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if Caching mode is set, then invalid translations are tagged</span>
<span class="cm">	 * with domainid 0. Hence we need to pre-allocate it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap_caching_mode</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">domain_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">vm_domain_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">free_dmar_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">,</span> <span class="n">cap_ndoms</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">domain</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_VIRTUAL_MACHINE</span><span class="p">)</span>
					<span class="n">vm_domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">gcmd</span> <span class="o">&amp;</span> <span class="n">DMA_GCMD_TE</span><span class="p">)</span>
		<span class="n">iommu_disable_translation</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_set_handler_data</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* This will mask the irq */</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">iommu</span><span class="p">);</span>
		<span class="n">destroy_irq</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>

	<span class="n">g_iommus</span><span class="p">[</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* if all iommus are freed, free g_iommus */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_num_of_iommus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">g_iommus</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">g_num_of_iommus</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">g_iommus</span><span class="p">);</span>

	<span class="cm">/* free context mapping */</span>
	<span class="n">free_context_table</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="nf">alloc_domain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">alloc_domain_mem</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">));</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">domain</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_attach_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ndomains</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ndomains</span> <span class="o">=</span> <span class="n">cap_ndoms</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">,</span> <span class="n">ndomains</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">ndomains</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOMMU: no free domain ids</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_detach_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">ndomains</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ndomains</span> <span class="o">=</span> <span class="n">cap_ndoms</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">,</span> <span class="n">ndomains</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iova_domain</span> <span class="n">reserved_iova_list</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">reserved_rbtree_key</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dmar_init_reserved_ranges</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">init_iova_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reserved_iova_list</span><span class="p">,</span> <span class="n">DMA_32BIT_PFN</span><span class="p">);</span>

	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reserved_iova_list</span><span class="p">.</span><span class="n">iova_rbtree_lock</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">reserved_rbtree_key</span><span class="p">);</span>

	<span class="cm">/* IOAPIC ranges shouldn&#39;t be accessed by DMA */</span>
	<span class="n">iova</span> <span class="o">=</span> <span class="n">reserve_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reserved_iova_list</span><span class="p">,</span> <span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">IOAPIC_RANGE_START</span><span class="p">),</span>
		<span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">IOAPIC_RANGE_END</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Reserve IOAPIC range failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve all PCI MMIO to avoid peer-to-peer access */</span>
	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_NUM_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">iova</span> <span class="o">=</span> <span class="n">reserve_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reserved_iova_list</span><span class="p">,</span>
					    <span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">),</span>
					    <span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Reserve iova failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_reserve_special_ranges</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">copy_reserved_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reserved_iova_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">guestwidth_to_adjustwidth</span><span class="p">(</span><span class="kt">int</span> <span class="n">gaw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">agaw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">gaw</span> <span class="o">-</span> <span class="mi">12</span><span class="p">)</span> <span class="o">%</span> <span class="mi">9</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">agaw</span> <span class="o">=</span> <span class="n">gaw</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">agaw</span> <span class="o">=</span> <span class="n">gaw</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">-</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agaw</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">agaw</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">agaw</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">domain_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">guest_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">adjust_width</span><span class="p">,</span> <span class="n">agaw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sagaw</span><span class="p">;</span>

	<span class="n">init_iova_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">DMA_32BIT_PFN</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">);</span>

	<span class="n">domain_reserve_special_ranges</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>

	<span class="cm">/* calculate AGAW */</span>
	<span class="n">iommu</span> <span class="o">=</span> <span class="n">domain_get_iommu</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">guest_width</span> <span class="o">&gt;</span> <span class="n">cap_mgaw</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">guest_width</span> <span class="o">=</span> <span class="n">cap_mgaw</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span> <span class="o">=</span> <span class="n">guest_width</span><span class="p">;</span>
	<span class="n">adjust_width</span> <span class="o">=</span> <span class="n">guestwidth_to_adjustwidth</span><span class="p">(</span><span class="n">guest_width</span><span class="p">);</span>
	<span class="n">agaw</span> <span class="o">=</span> <span class="n">width_to_agaw</span><span class="p">(</span><span class="n">adjust_width</span><span class="p">);</span>
	<span class="n">sagaw</span> <span class="o">=</span> <span class="n">cap_sagaw</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">agaw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sagaw</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* hardware doesn&#39;t support it, choose a bigger one */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;IOMMU: hardware doesn&#39;t support agaw %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">agaw</span><span class="p">);</span>
		<span class="n">agaw</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sagaw</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">agaw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agaw</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span> <span class="o">=</span> <span class="n">agaw</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecap_coherent</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">))</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_coherency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_coherency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecap_sc_support</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">))</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_snooping</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_snooping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_superpage</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">cap_super_page_val</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">));</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

	<span class="cm">/* always allocate the top pgd */</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="p">)</span><span class="n">alloc_pgtable_page</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">__iommu_flush_cache</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="cm">/* Domain 0 is reserved, so dont process it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Flush any lazy unmaps that may reference this domain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_iommu_strict</span><span class="p">)</span>
		<span class="n">flush_unmaps_timeout</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">domain_remove_dev_info</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="cm">/* destroy iovas */</span>
	<span class="n">put_iova_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">);</span>

	<span class="cm">/* clear ptes */</span>
	<span class="n">dma_pte_clear_range</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DOMAIN_MAX_PFN</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">));</span>

	<span class="cm">/* free page tables */</span>
	<span class="n">dma_pte_free_pagetable</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DOMAIN_MAX_PFN</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">));</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">))</span>
			<span class="n">iommu_detach_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iommu</span><span class="p">);</span>

	<span class="n">free_domain_mem</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">domain_context_mapping_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">segment</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">translation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">context_entry</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ndomains</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agaw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Set context mapping for %02x:%02x.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bus</span><span class="p">,</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">devfn</span><span class="p">));</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">translation</span> <span class="o">!=</span> <span class="n">CONTEXT_TT_PASS_THROUGH</span> <span class="o">&amp;&amp;</span>
	       <span class="n">translation</span> <span class="o">!=</span> <span class="n">CONTEXT_TT_MULTI_LEVEL</span><span class="p">);</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">context</span> <span class="o">=</span> <span class="n">device_to_context_entry</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context_present</span><span class="p">(</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_VIRTUAL_MACHINE</span> <span class="o">||</span>
	    <span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_STATIC_IDENTITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* find an available domain id for this device in iommu */</span>
		<span class="n">ndomains</span> <span class="o">=</span> <span class="n">cap_ndoms</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">,</span> <span class="n">ndomains</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">==</span> <span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">id</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">,</span> <span class="n">ndomains</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">ndomains</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOMMU: no free domain ids</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">set_bit</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">;</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Skip top levels of page tables for</span>
<span class="cm">		 * iommu which has less agaw than default.</span>
<span class="cm">		 * Unnecessary for PT mode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">translation</span> <span class="o">!=</span> <span class="n">CONTEXT_TT_PASS_THROUGH</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">agaw</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">;</span> <span class="n">agaw</span> <span class="o">!=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">;</span> <span class="n">agaw</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pgd</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_pte_addr</span><span class="p">(</span><span class="n">pgd</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_pte_present</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">context_set_domain_id</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">translation</span> <span class="o">!=</span> <span class="n">CONTEXT_TT_PASS_THROUGH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">iommu_support_dev_iotlb</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
		<span class="n">translation</span> <span class="o">=</span> <span class="n">info</span> <span class="o">?</span> <span class="n">CONTEXT_TT_DEV_IOTLB</span> <span class="o">:</span>
				     <span class="n">CONTEXT_TT_MULTI_LEVEL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * In pass through mode, AW must be programmed to indicate the largest</span>
<span class="cm">	 * AGAW value supported by hardware. And ASR is ignored by hardware.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">translation</span> <span class="o">==</span> <span class="n">CONTEXT_TT_PASS_THROUGH</span><span class="p">))</span>
		<span class="n">context_set_address_width</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">msagaw</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">context_set_address_root</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">pgd</span><span class="p">));</span>
		<span class="n">context_set_address_width</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">context_set_translation_type</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">translation</span><span class="p">);</span>
	<span class="n">context_set_fault_enable</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="n">context_set_present</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="n">domain_flush_cache</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s a non-present to present mapping. If hardware doesn&#39;t cache</span>
<span class="cm">	 * non-present entry we only need to flush the write-buffer. If the</span>
<span class="cm">	 * _does_ cache non-present entries, then it does so in the special</span>
<span class="cm">	 * domain #0, which we have to flush:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap_caching_mode</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_context</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">bus</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">devfn</span><span class="p">,</span>
					   <span class="n">DMA_CCMD_MASK_NOBIT</span><span class="p">,</span>
					   <span class="n">DMA_CCMD_DEVICE_INVL</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DMA_TLB_DSI_FLUSH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iommu_flush_write_buffer</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iommu_enable_dev_iotlb</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="n">domain_update_iommu_cap</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">domain_context_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">translation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_context_mapping_one</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span>
					 <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span>
					 <span class="n">translation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* dependent device mapping */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">pci_find_upstream_pcie_bridge</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Secondary interface&#39;s bus number and devfn 0 */</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_context_mapping_one</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span>
						 <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span>
						 <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
						 <span class="n">parent</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">translation</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="cm">/* this is a PCIe-to-PCI bridge */</span>
		<span class="k">return</span> <span class="n">domain_context_mapping_one</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span>
					<span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">),</span>
					<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">translation</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* this is a legacy PCI bridge */</span>
		<span class="k">return</span> <span class="n">domain_context_mapping_one</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span>
						  <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span>
						  <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
						  <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span>
						  <span class="n">translation</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">domain_context_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
				<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">device_context_mapped</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* dependent device mapping */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">pci_find_upstream_pcie_bridge</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Secondary interface&#39;s bus number and devfn 0 */</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">device_context_mapped</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					    <span class="n">parent</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">device_context_mapped</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">device_context_mapped</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					     <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns a number of VTD pages, but aligned to MM page size */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">aligned_nrpages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_addr</span><span class="p">,</span>
					    <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">host_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">host_addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return largest possible superpage level for a given mapping */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hardware_largepage_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iov_pfn</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phy_pfn</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">support</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfnmerge</span><span class="p">;</span>

	<span class="n">support</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_superpage</span><span class="p">;</span>

	<span class="cm">/* To use a large page, the virtual *and* physical addresses</span>
<span class="cm">	   must be aligned to 2MiB/1GiB/etc. Lower bits set in either</span>
<span class="cm">	   of them will mean we have to use smaller pages. So just</span>
<span class="cm">	   merge them and check both at once. */</span>
	<span class="n">pfnmerge</span> <span class="o">=</span> <span class="n">iov_pfn</span> <span class="o">|</span> <span class="n">phy_pfn</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">support</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pfnmerge</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VTD_STRIDE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pages</span> <span class="o">&gt;&gt;=</span> <span class="n">VTD_STRIDE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pfnmerge</span> <span class="o">&gt;&gt;=</span> <span class="n">VTD_STRIDE_SHIFT</span><span class="p">;</span>
		<span class="n">level</span><span class="o">++</span><span class="p">;</span>
		<span class="n">support</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__domain_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iov_pfn</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_pfn</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">first_pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">addr_width</span> <span class="o">=</span> <span class="n">agaw_to_width</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">)</span> <span class="o">-</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sg_res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">largepage_lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lvl_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr_width</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iov_pfn</span> <span class="o">+</span> <span class="n">nr_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">addr_width</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DMA_PTE_READ</span><span class="o">|</span><span class="n">DMA_PTE_WRITE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">prot</span> <span class="o">&amp;=</span> <span class="n">DMA_PTE_READ</span> <span class="o">|</span> <span class="n">DMA_PTE_WRITE</span> <span class="o">|</span> <span class="n">DMA_PTE_SNP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg</span><span class="p">)</span>
		<span class="n">sg_res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sg_res</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pteval</span> <span class="o">=</span> <span class="p">((</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">phys_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">prot</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_res</span> <span class="o">=</span> <span class="n">aligned_nrpages</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="p">((</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">iov_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="o">|</span> <span class="n">prot</span><span class="p">;</span>
			<span class="n">phys_pfn</span> <span class="o">=</span> <span class="n">pteval</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">largepage_lvl</span> <span class="o">=</span> <span class="n">hardware_largepage_caps</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iov_pfn</span><span class="p">,</span> <span class="n">phys_pfn</span><span class="p">,</span> <span class="n">sg_res</span><span class="p">);</span>

			<span class="n">first_pte</span> <span class="o">=</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pfn_to_dma_pte</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iov_pfn</span><span class="p">,</span> <span class="n">largepage_lvl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="cm">/* It is large page*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">largepage_lvl</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">pteval</span> <span class="o">|=</span> <span class="n">DMA_PTE_LARGE_PAGE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">pteval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">DMA_PTE_LARGE_PAGE</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="cm">/* We don&#39;t need lock here, nobody else</span>
<span class="cm">		 * touches the iova range</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmpxchg64_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">dumps</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;ERROR: DMA PTE for vPFN 0x%lx already set (to %llx not %llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">iov_pfn</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pteval</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dumps</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dumps</span><span class="o">--</span><span class="p">;</span>
				<span class="n">debug_dma_dump_mappings</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">lvl_pages</span> <span class="o">=</span> <span class="n">lvl_to_nr_pages</span><span class="p">(</span><span class="n">largepage_lvl</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nr_pages</span> <span class="o">&lt;</span> <span class="n">lvl_pages</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sg_res</span> <span class="o">&lt;</span> <span class="n">lvl_pages</span><span class="p">);</span>

		<span class="n">nr_pages</span> <span class="o">-=</span> <span class="n">lvl_pages</span><span class="p">;</span>
		<span class="n">iov_pfn</span> <span class="o">+=</span> <span class="n">lvl_pages</span><span class="p">;</span>
		<span class="n">phys_pfn</span> <span class="o">+=</span> <span class="n">lvl_pages</span><span class="p">;</span>
		<span class="n">pteval</span> <span class="o">+=</span> <span class="n">lvl_pages</span> <span class="o">*</span> <span class="n">VTD_PAGE_SIZE</span><span class="p">;</span>
		<span class="n">sg_res</span> <span class="o">-=</span> <span class="n">lvl_pages</span><span class="p">;</span>

		<span class="cm">/* If the next PTE would be the first in a new page, then we</span>
<span class="cm">		   need to flush the cache on the entries we&#39;ve just written.</span>
<span class="cm">		   And then we&#39;ll need to recalculate &#39;pte&#39;, so clear it and</span>
<span class="cm">		   let it get set again in the if (!pte) block above.</span>

<span class="cm">		   If we&#39;re done (!nr_pages) we need to flush the cache too.</span>

<span class="cm">		   Also if we&#39;ve been setting superpages, we may need to</span>
<span class="cm">		   recalculate &#39;pte&#39; and switch back to smaller pages for the</span>
<span class="cm">		   end of the mapping, if the trailing size is not enough to</span>
<span class="cm">		   use another superpage (i.e. sg_res &lt; lvl_pages). */</span>
		<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span> <span class="o">||</span> <span class="n">first_pte_in_page</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">largepage_lvl</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sg_res</span> <span class="o">&lt;</span> <span class="n">lvl_pages</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">domain_flush_cache</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">first_pte</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pte</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">first_pte</span><span class="p">);</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_res</span> <span class="o">&amp;&amp;</span> <span class="n">nr_pages</span><span class="p">)</span>
			<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">domain_sg_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iov_pfn</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__domain_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iov_pfn</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">domain_pfn_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iov_pfn</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__domain_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iov_pfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">phys_pfn</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_detach_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">clear_context_table</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_context</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">DMA_CCMD_GLOBAL_INVL</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DMA_TLB_GLOBAL_FLUSH</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlink_domain_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_remove_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_domain_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">unlink_domain_info</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">iommu_disable_dev_iotlb</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">iommu</span> <span class="o">=</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">iommu_detach_dev</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">free_devinfo_mem</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_domain</span>
<span class="cm"> * Note: we use struct pci_dev-&gt;dev.archdata.iommu stores the info</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span>
<span class="nf">find_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/* No lock here, assumes no domain exit in normal case */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* domain is initialized */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="nf">get_domain_for_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gaw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev_tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">devfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">segment</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">find_domain</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">domain</span><span class="p">;</span>

	<span class="n">segment</span> <span class="o">=</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">dev_tmp</span> <span class="o">=</span> <span class="n">pci_find_upstream_pcie_bridge</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">dev_tmp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bus</span> <span class="o">=</span> <span class="n">dev_tmp</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
			<span class="n">devfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bus</span> <span class="o">=</span> <span class="n">dev_tmp</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
			<span class="n">devfn</span> <span class="o">=</span> <span class="n">dev_tmp</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_domain_list</span><span class="p">,</span> <span class="n">global</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">==</span> <span class="n">segment</span> <span class="o">&amp;&amp;</span>
			    <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">devfn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* pcie-pci bridge already has a domain, uses it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">domain</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">found_domain</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">alloc_domain</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Allocate new domain for the device */</span>
	<span class="n">drhd</span> <span class="o">=</span> <span class="n">dmar_find_matched_drhd_unit</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOMMU: can&#39;t find DMAR for device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iommu</span> <span class="o">=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_attach_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iommu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_domain_mem</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">domain_init</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">gaw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register pcie-to-pci device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">alloc_devinfo_mem</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">=</span> <span class="n">devfn</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="p">;</span>
		<span class="cm">/* This domain is shared by devices under p2p bridge */</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DOMAIN_FLAG_P2P_MULTIPLE_DEVICES</span><span class="p">;</span>

		<span class="cm">/* pcie-to-pci bridge already has a domain, uses it */</span>
		<span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_domain_list</span><span class="p">,</span> <span class="n">global</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">==</span> <span class="n">segment</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">devfn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">free_devinfo_mem</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
			<span class="n">domain</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_domain_list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">found_domain:</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">alloc_devinfo_mem</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* somebody is fast */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">find_domain</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">!=</span> <span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
			<span class="n">domain</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free_devinfo_mem</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">domain</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_domain_list</span><span class="p">);</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">domain</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="cm">/* recheck it here, maybe others set it */</span>
	<span class="k">return</span> <span class="n">find_domain</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">iommu_identity_mapping</span><span class="p">;</span>
<span class="cp">#define IDENTMAP_ALL		1</span>
<span class="cp">#define IDENTMAP_GFX		2</span>
<span class="cp">#define IDENTMAP_AZALIA		4</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_domain_identity_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_vpfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_vpfn</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reserve_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">dma_to_mm_pfn</span><span class="p">(</span><span class="n">first_vpfn</span><span class="p">),</span>
			  <span class="n">dma_to_mm_pfn</span><span class="p">(</span><span class="n">last_vpfn</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOMMU: reserve iova failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Mapping reserved region %llx-%llx for domain %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * RMRR range might have overlap with physical memory range,</span>
<span class="cm">	 * clear it first</span>
<span class="cm">	 */</span>
	<span class="n">dma_pte_clear_range</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">first_vpfn</span><span class="p">,</span> <span class="n">last_vpfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">domain_pfn_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">first_vpfn</span><span class="p">,</span> <span class="n">first_vpfn</span><span class="p">,</span>
				  <span class="n">last_vpfn</span> <span class="o">-</span> <span class="n">first_vpfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				  <span class="n">DMA_PTE_READ</span><span class="o">|</span><span class="n">DMA_PTE_WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_prepare_identity_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">get_domain_for_dev</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DEFAULT_DOMAIN_ADDRESS_WIDTH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* For _hardware_ passthrough, don&#39;t bother. But for software</span>
<span class="cm">	   passthrough, we do it anyway -- it may indicate a memory</span>
<span class="cm">	   range which is reserved in E820, so which didn&#39;t get set</span>
<span class="cm">	   up to start with in si_domain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span> <span class="o">==</span> <span class="n">si_domain</span> <span class="o">&amp;&amp;</span> <span class="n">hw_pass_through</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Ignoring identity map for HW passthrough device %s [0x%Lx - 0x%Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;IOMMU: Setting identity map for device %s [0x%Lx - 0x%Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Your BIOS is broken; RMRR ends before it starts!</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;BIOS vendor: %s; Ver: %s; Product Version: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">),</span>
			<span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">),</span>
		     <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_PRODUCT_VERSION</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">agaw_to_width</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Your BIOS is broken; RMRR exceeds permitted address width (%d bits)</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;BIOS vendor: %s; Ver: %s; Product Version: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">agaw_to_width</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">),</span>
		     <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">),</span>
		     <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">),</span>
		     <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_PRODUCT_VERSION</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_domain_identity_map</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* context entry init */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_context_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="n">CONTEXT_TT_MULTI_LEVEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error:</span>
	<span class="n">domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iommu_prepare_rmrr_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_rmrr_unit</span> <span class="o">*</span><span class="n">rmrr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span> <span class="o">==</span> <span class="n">DUMMY_DEVICE_DOMAIN_INFO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">iommu_prepare_identity_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">base_address</span><span class="p">,</span>
		<span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">end_address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_INTEL_IOMMU_FLOPPY_WA</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iommu_prepare_isa</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_class</span><span class="p">(</span><span class="n">PCI_CLASS_BRIDGE_ISA</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;IOMMU: Prepare 0-16MiB unity mapping for LPC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_prepare_identity_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOMMU: Failed to create 0-16MiB identity map; &quot;</span>
		       <span class="s">&quot;floppy might not work</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iommu_prepare_isa</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_INTEL_IOMMU_FLPY_WA */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">md_domain_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">guest_width</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">si_domain_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">si_domain</span> <span class="o">=</span> <span class="n">alloc_domain</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si_domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identity mapping domain is domain %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">si_domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_attach_domain</span><span class="p">(</span><span class="n">si_domain</span><span class="p">,</span> <span class="n">iommu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">domain_exit</span><span class="p">(</span><span class="n">si_domain</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">md_domain_init</span><span class="p">(</span><span class="n">si_domain</span><span class="p">,</span> <span class="n">DEFAULT_DOMAIN_ADDRESS_WIDTH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">domain_exit</span><span class="p">(</span><span class="n">si_domain</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">si_domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">DOMAIN_FLAG_STATIC_IDENTITY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">for_each_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_domain_identity_map</span><span class="p">(</span><span class="n">si_domain</span><span class="p">,</span>
					<span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">),</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">end_pfn</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">domain_remove_one_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">identity_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">iommu_identity_mapping</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="n">info</span> <span class="o">!=</span> <span class="n">DUMMY_DEVICE_DOMAIN_INFO</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">==</span> <span class="n">si_domain</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">domain_add_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">translation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">alloc_devinfo_mem</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">=</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_domain_list</span><span class="p">);</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_context_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="n">translation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">unlink_domain_info</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">free_devinfo_mem</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_should_identity_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iommu_identity_mapping</span> <span class="o">&amp;</span> <span class="n">IDENTMAP_AZALIA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_AZALIA</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">iommu_identity_mapping</span> <span class="o">&amp;</span> <span class="n">IDENTMAP_GFX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_GFX_DEVICE</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iommu_identity_mapping</span> <span class="o">&amp;</span> <span class="n">IDENTMAP_ALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to start off with all devices in the 1:1 domain, and</span>
<span class="cm">	 * take them out later if we find they can&#39;t access all of memory.</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, we can&#39;t do this for PCI devices behind bridges,</span>
<span class="cm">	 * because all PCI devices behind the same bridge will end up</span>
<span class="cm">	 * with the same source-id on their transactions.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Practically speaking, we can&#39;t change things around for these</span>
<span class="cm">	 * devices at run-time, because we can&#39;t be sure there&#39;ll be no</span>
<span class="cm">	 * DMA transactions in flight for any of their siblings.</span>
<span class="cm">	 * </span>
<span class="cm">	 * So PCI devices (unless they&#39;re on the root bus) as well as</span>
<span class="cm">	 * their parent PCI-PCI or PCIe-PCI bridges must be left _out_ of</span>
<span class="cm">	 * the 1:1 domain, just in _case_ one of their siblings turns out</span>
<span class="cm">	 * not to be able to map all of memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_root_bus</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">PCI_CLASS_BRIDGE_PCI</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">pcie_type</span> <span class="o">==</span> <span class="n">PCI_EXP_TYPE_PCI_BRIDGE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * At boot time, we don&#39;t yet know if devices will be 64-bit capable.</span>
<span class="cm">	 * Assume that they will -- if they turn out not to be, then we can </span>
<span class="cm">	 * take them out of the 1:1 domain later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">startup</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the device&#39;s dma_mask is less than the system&#39;s memory</span>
<span class="cm">		 * size then this is not a candidate for identity mapping.</span>
<span class="cm">		 */</span>
		<span class="n">u64</span> <span class="n">dma_mask</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">&lt;</span> <span class="n">dma_mask</span><span class="p">)</span>
			<span class="n">dma_mask</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">dma_mask</span> <span class="o">&gt;=</span> <span class="n">dma_get_required_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">iommu_prepare_static_identity_mapping</span><span class="p">(</span><span class="kt">int</span> <span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">si_domain_init</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu_should_identity_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_add_dev_info</span><span class="p">(</span><span class="n">si_domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span>
					     <span class="n">hw</span> <span class="o">?</span> <span class="n">CONTEXT_TT_PASS_THROUGH</span> <span class="o">:</span>
						  <span class="n">CONTEXT_TT_MULTI_LEVEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* device not associated with an iommu */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IOMMU: %s identity mapping for device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hw</span> <span class="o">?</span> <span class="s">&quot;hardware&quot;</span> <span class="o">:</span> <span class="s">&quot;software&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_dmars</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmar_rmrr_unit</span> <span class="o">*</span><span class="n">rmrr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for each drhd</span>
<span class="cm">	 *    allocate root</span>
<span class="cm">	 *    initialize and program root entry to not present</span>
<span class="cm">	 * endfor</span>
<span class="cm">	 */</span>
	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * lock not needed as this is only incremented in the single</span>
<span class="cm">		 * threaded kernel __init code path all other access are read</span>
<span class="cm">		 * only</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">g_num_of_iommus</span> <span class="o">&lt;</span> <span class="n">IOMMU_UNITS_SUPPORTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">g_num_of_iommus</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;intel-iommu: exceeded %d IOMMUs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">IOMMU_UNITS_SUPPORTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">g_iommus</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">g_num_of_iommus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">g_iommus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Allocating global iommu array failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">deferred_flush</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">g_num_of_iommus</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">deferred_flush_tables</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deferred_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">iommu</span> <span class="o">=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>
		<span class="n">g_iommus</span><span class="p">[</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">iommu</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_init_domains</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * TBD:</span>
<span class="cm">		 * we could share the same root &amp; context tables</span>
<span class="cm">		 * among all IOMMU&#39;s. Need to Split it later.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_alloc_root_entry</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOMMU: allocate root entry failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecap_pass_through</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">))</span>
			<span class="n">hw_pass_through</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start from the sane iommu hardware state.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">iommu</span> <span class="o">=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the queued invalidation is already initialized by us</span>
<span class="cm">		 * (for example, while enabling interrupt-remapping) then</span>
<span class="cm">		 * we got the things already rolling from a sane state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">qi</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear any previous faults.</span>
<span class="cm">		 */</span>
		<span class="n">dmar_fault</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">iommu</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Disable queued invalidation if supported and already enabled</span>
<span class="cm">		 * before OS handover.</span>
<span class="cm">		 */</span>
		<span class="n">dmar_disable_qi</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">iommu</span> <span class="o">=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dmar_enable_qi</span><span class="p">(</span><span class="n">iommu</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Queued Invalidate not enabled, use Register Based</span>
<span class="cm">			 * Invalidate</span>
<span class="cm">			 */</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_context</span> <span class="o">=</span> <span class="n">__iommu_flush_context</span><span class="p">;</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span> <span class="o">=</span> <span class="n">__iommu_flush_iotlb</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;IOMMU %d 0x%Lx: using Register based &quot;</span>
			       <span class="s">&quot;invalidation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">reg_base_addr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_context</span> <span class="o">=</span> <span class="n">qi_flush_context</span><span class="p">;</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span> <span class="o">=</span> <span class="n">qi_flush_iotlb</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;IOMMU %d 0x%Lx: using Queued &quot;</span>
			       <span class="s">&quot;invalidation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">reg_base_addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_pass_through</span><span class="p">)</span>
		<span class="n">iommu_identity_mapping</span> <span class="o">|=</span> <span class="n">IDENTMAP_ALL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_INTEL_IOMMU_BROKEN_GFX_WA</span>
	<span class="n">iommu_identity_mapping</span> <span class="o">|=</span> <span class="n">IDENTMAP_GFX</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">check_tylersburg_isoch</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If pass through is not set or not enabled, setup context entries for</span>
<span class="cm">	 * identity mappings for rmrr, gfx, and isa and may fall back to static</span>
<span class="cm">	 * identity mapping if iommu_identity_mapping is set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_identity_mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_prepare_static_identity_mapping</span><span class="p">(</span><span class="n">hw_pass_through</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;Failed to setup IOMMU pass-through</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * For each rmrr</span>
<span class="cm">	 *   for each dev attached to rmrr</span>
<span class="cm">	 *   do</span>
<span class="cm">	 *     locate drhd for dev, alloc domain for dev</span>
<span class="cm">	 *     allocate free domain</span>
<span class="cm">	 *     allocate page table entries for rmrr</span>
<span class="cm">	 *     if context not allocated for bus</span>
<span class="cm">	 *           allocate and init context</span>
<span class="cm">	 *           set present in root table for this bus</span>
<span class="cm">	 *     init context with domain, translation etc</span>
<span class="cm">	 *    endfor</span>
<span class="cm">	 * endfor</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;IOMMU: Setting RMRR:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_rmrr_units</span><span class="p">(</span><span class="n">rmrr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pdev</span> <span class="o">=</span> <span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * some BIOS lists non-exist devices in DMAR</span>
<span class="cm">			 * table.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_prepare_rmrr_dev</span><span class="p">(</span><span class="n">rmrr</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;IOMMU: mapping reserved region failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">iommu_prepare_isa</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * for each drhd</span>
<span class="cm">	 *   enable fault log</span>
<span class="cm">	 *   global invalidate context cache</span>
<span class="cm">	 *   global invalidate iotlb</span>
<span class="cm">	 *   enable translation</span>
<span class="cm">	 */</span>
	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we always have to disable PMRs or DMA may fail on</span>
<span class="cm">			 * this device</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
				<span class="n">iommu_disable_protect_mem_regions</span><span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iommu</span> <span class="o">=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>

		<span class="n">iommu_flush_write_buffer</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dmar_set_interrupt</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">iommu_set_root_entry</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_context</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DMA_CCMD_GLOBAL_INVL</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DMA_TLB_GLOBAL_FLUSH</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_enable_translation</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">iommu_disable_protect_mem_regions</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">iommu</span> <span class="o">=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>
		<span class="n">free_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">g_iommus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This takes a number of _MM_ pages, not VTD pages */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="nf">intel_alloc_iova</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nrpages</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Restrict dma_mask to the width that the iommu can handle */</span>
	<span class="n">dma_mask</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">DOMAIN_MAX_ADDR</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">),</span> <span class="n">dma_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmar_forcedac</span> <span class="o">&amp;&amp;</span> <span class="n">dma_mask</span> <span class="o">&gt;</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First try to allocate an io virtual address in</span>
<span class="cm">		 * DMA_BIT_MASK(32) and if that fails then try allocating</span>
<span class="cm">		 * from higher range</span>
<span class="cm">		 */</span>
		<span class="n">iova</span> <span class="o">=</span> <span class="n">alloc_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">nrpages</span><span class="p">,</span>
				  <span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iova</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">iova</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iova</span> <span class="o">=</span> <span class="n">alloc_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">nrpages</span><span class="p">,</span> <span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">dma_mask</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Allocating %ld-page iova for %s failed&quot;</span><span class="p">,</span>
		       <span class="n">nrpages</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">iova</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="nf">__get_valid_domain_for_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">get_domain_for_dev</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
			<span class="n">DEFAULT_DOMAIN_ADDRESS_WIDTH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;Allocating domain for %s failed&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure context mapping is ok */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">domain_context_mapped</span><span class="p">(</span><span class="n">pdev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_context_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span>
					     <span class="n">CONTEXT_TT_MULTI_LEVEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;Domain context map for %s failed&quot;</span><span class="p">,</span>
				<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">domain</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="nf">get_valid_domain_for_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/* No lock here, assumes no domain exit in normal case */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__get_valid_domain_for_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_dummy</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span> <span class="o">==</span> <span class="n">DUMMY_DEVICE_DOMAIN_INFO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check if the pdev needs to go through non-identity map and unmap process.*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_no_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_dummy</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_identity_mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">identity_mapping</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu_should_identity_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * 32 bit DMA is removed from si_domain and fall back</span>
<span class="cm">			 * to non-identity mapping.</span>
<span class="cm">			 */</span>
			<span class="n">domain_remove_one_dev_info</span><span class="p">(</span><span class="n">si_domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;32bit %s uses non-identity mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In case of a detached 64 bit DMA device from vm, the device</span>
<span class="cm">		 * is put into si_domain for identity mapping.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu_should_identity_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_add_dev_info</span><span class="p">(</span><span class="n">si_domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span>
						  <span class="n">hw_pass_through</span> <span class="o">?</span>
						  <span class="n">CONTEXT_TT_PASS_THROUGH</span> <span class="o">:</span>
						  <span class="n">CONTEXT_TT_MULTI_LEVEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;64bit %s uses identity mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">__intel_map_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">hwdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">start_paddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr_pfn</span> <span class="o">=</span> <span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_no_mapping</span><span class="p">(</span><span class="n">hwdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">paddr</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">get_valid_domain_for_dev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">domain_get_iommu</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">aligned_nrpages</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">iova</span> <span class="o">=</span> <span class="n">intel_alloc_iova</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">dma_to_mm_pfn</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">dma_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if DMAR supports zero-length reads on write only</span>
<span class="cm">	 * mappings..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span> <span class="o">||</span> \
			<span class="o">!</span><span class="n">cap_zlr</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">prot</span> <span class="o">|=</span> <span class="n">DMA_PTE_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">|=</span> <span class="n">DMA_PTE_WRITE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * paddr - (paddr + size) might be partial page, we should map the whole</span>
<span class="cm">	 * page.  Note: if two part of one page are separately mapped, we</span>
<span class="cm">	 * might have two guest_addr mapping to the same host paddr, but this</span>
<span class="cm">	 * is not a big problem</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_pfn_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span><span class="p">),</span>
				 <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">paddr_pfn</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* it&#39;s a non-present to present mapping. Only flush if caching mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap_caching_mode</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">iommu_flush_iotlb_psi</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iommu_flush_write_buffer</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

	<span class="n">start_paddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">start_paddr</span> <span class="o">+=</span> <span class="n">paddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">start_paddr</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iova</span><span class="p">)</span>
		<span class="n">__free_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;Device %s request: %zx@%llx dir %d --- failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">paddr</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">intel_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__intel_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				  <span class="n">dir</span><span class="p">,</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_unmaps</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">timer_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* just flush them all */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_num_of_iommus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">g_iommus</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deferred_flush</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* In caching mode, global flushes turn emulation expensive */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_caching_mode</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">DMA_TLB_GLOBAL_FLUSH</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">deferred_flush</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span> <span class="o">=</span> <span class="n">deferred_flush</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iova</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span> <span class="o">=</span> <span class="n">deferred_flush</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">domain</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="cm">/* On real hardware multiple invalidations are expensive */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cap_caching_mode</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
				<span class="n">iommu_flush_iotlb_psi</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
				<span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span><span class="p">,</span> <span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_hi</span> <span class="o">-</span> <span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mask</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_hi</span> <span class="o">-</span> <span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
				<span class="n">iommu_flush_dev_iotlb</span><span class="p">(</span><span class="n">deferred_flush</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">domain</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
						<span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">__free_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deferred_flush</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">domain</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">deferred_flush</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_unmaps_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_umap_flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">flush_unmaps</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_umap_flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dom</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">,</span> <span class="n">iommu_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_umap_flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_size</span> <span class="o">==</span> <span class="n">HIGH_WATER_MARK</span><span class="p">)</span>
		<span class="n">flush_unmaps</span><span class="p">();</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">domain_get_iommu</span><span class="p">(</span><span class="n">dom</span><span class="p">);</span>
	<span class="n">iommu_id</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">deferred_flush</span><span class="p">[</span><span class="n">iommu_id</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="n">deferred_flush</span><span class="p">[</span><span class="n">iommu_id</span><span class="p">].</span><span class="n">domain</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">dom</span><span class="p">;</span>
	<span class="n">deferred_flush</span><span class="p">[</span><span class="n">iommu_id</span><span class="p">].</span><span class="n">iova</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">iova</span><span class="p">;</span>
	<span class="n">deferred_flush</span><span class="p">[</span><span class="n">iommu_id</span><span class="p">].</span><span class="n">next</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unmap_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
		<span class="n">timer_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_size</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_umap_flush_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dev_addr</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_no_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">find_domain</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">);</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">domain_get_iommu</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>

	<span class="n">iova</span> <span class="o">=</span> <span class="n">find_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">,</span> <span class="s">&quot;Driver unmaps unmatched page at PFN %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span><span class="p">);</span>
	<span class="n">last_pfn</span> <span class="o">=</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Device %s unmapping: pfn %lx-%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="cm">/*  clear the whole page */</span>
	<span class="n">dma_pte_clear_range</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="cm">/* free page tables */</span>
	<span class="n">dma_pte_free_pagetable</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intel_iommu_strict</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iommu_flush_iotlb_psi</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span>
				      <span class="n">last_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* free iova */</span>
		<span class="n">__free_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">add_unmap</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * queue up the release of the unmap to save the 1/6th of the</span>
<span class="cm">		 * cpu used up by the iotlb flush operation...</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">intel_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				  <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_no_mapping</span><span class="p">(</span><span class="n">hwdev</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">GFP_DMA</span> <span class="o">|</span> <span class="n">GFP_DMA32</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hwdev</span><span class="o">-&gt;</span><span class="n">coherent_dma_mask</span> <span class="o">&lt;</span> <span class="n">dma_get_required_mask</span><span class="p">(</span><span class="n">hwdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwdev</span><span class="o">-&gt;</span><span class="n">coherent_dma_mask</span> <span class="o">&lt;</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">GFP_DMA</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">GFP_DMA32</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">__intel_map_single</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">virt_to_bus</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span>
					 <span class="n">DMA_BIDIRECTIONAL</span><span class="p">,</span>
					 <span class="n">hwdev</span><span class="o">-&gt;</span><span class="n">coherent_dma_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
				<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="n">intel_unmap_page</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">hwdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_no_mapping</span><span class="p">(</span><span class="n">hwdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">find_domain</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">);</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">domain_get_iommu</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>

	<span class="n">iova</span> <span class="o">=</span> <span class="n">find_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">IOVA_PFN</span><span class="p">(</span><span class="n">sglist</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dma_address</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">,</span> <span class="s">&quot;Driver unmaps unmatched sglist at PFN %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sglist</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dma_address</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span><span class="p">);</span>
	<span class="n">last_pfn</span> <span class="o">=</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_hi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*  clear the whole page */</span>
	<span class="n">dma_pte_clear_range</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="cm">/* free page tables */</span>
	<span class="n">dma_pte_free_pagetable</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intel_iommu_strict</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iommu_flush_iotlb_psi</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span>
				      <span class="n">last_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* free iova */</span>
		<span class="n">__free_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">add_unmap</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * queue up the release of the unmap to save the 1/6th of the</span>
<span class="cm">		 * cpu used up by the iotlb flush operation...</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_nontranslate_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hddev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sglist</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nelems</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">hwdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iova</span> <span class="o">*</span><span class="n">iova</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_vpfn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_no_mapping</span><span class="p">(</span><span class="n">hwdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">intel_nontranslate_map_sg</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">get_valid_domain_for_dev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">domain_get_iommu</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sglist</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">aligned_nrpages</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">iova</span> <span class="o">=</span> <span class="n">intel_alloc_iova</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">dma_to_mm_pfn</span><span class="p">(</span><span class="n">size</span><span class="p">),</span>
				<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if DMAR supports zero-length reads on write only</span>
<span class="cm">	 * mappings..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span> <span class="o">||</span> \
			<span class="o">!</span><span class="n">cap_zlr</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">prot</span> <span class="o">|=</span> <span class="n">DMA_PTE_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">|=</span> <span class="n">DMA_PTE_WRITE</span><span class="p">;</span>

	<span class="n">start_vpfn</span> <span class="o">=</span> <span class="n">mm_to_dma_pfn</span><span class="p">(</span><span class="n">iova</span><span class="o">-&gt;</span><span class="n">pfn_lo</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_sg_mapping</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_vpfn</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*  clear the page */</span>
		<span class="n">dma_pte_clear_range</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_vpfn</span><span class="p">,</span>
				    <span class="n">start_vpfn</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* free page tables */</span>
		<span class="n">dma_pte_free_pagetable</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">start_vpfn</span><span class="p">,</span>
				       <span class="n">start_vpfn</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* free iova */</span>
		<span class="n">__free_iova</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* it&#39;s a non-present to present mapping. Only flush if caching mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap_caching_mode</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">iommu_flush_iotlb_psi</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">start_vpfn</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iommu_flush_write_buffer</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nelems</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_mapping_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">dma_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">intel_dma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">intel_alloc_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">intel_free_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span> <span class="o">=</span> <span class="n">intel_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span> <span class="o">=</span> <span class="n">intel_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_page</span> <span class="o">=</span> <span class="n">intel_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span> <span class="o">=</span> <span class="n">intel_unmap_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mapping_error</span> <span class="o">=</span> <span class="n">intel_mapping_error</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iommu_domain_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iommu_domain_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;iommu_domain&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span><span class="p">),</span>
					 <span class="mi">0</span><span class="p">,</span>
					 <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>

					 <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_domain_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Couldn&#39;t create iommu_domain cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iommu_devinfo_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iommu_devinfo_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;iommu_devinfo&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_domain_info</span><span class="p">),</span>
					 <span class="mi">0</span><span class="p">,</span>
					 <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_devinfo_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Couldn&#39;t create devinfo cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iommu_iova_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iommu_iova_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;iommu_iova&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iova</span><span class="p">),</span>
					 <span class="mi">0</span><span class="p">,</span>
					 <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_iova_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Couldn&#39;t create iova cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">iommu_init_mempool</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_iova_cache_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_domain_cache_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">domain_error</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_devinfo_cache_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">iommu_domain_cache</span><span class="p">);</span>
<span class="nl">domain_error:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">iommu_iova_cache</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">iommu_exit_mempool</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">iommu_devinfo_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">iommu_domain_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">iommu_iova_cache</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_ioat_snb_local_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vtbar</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* We know that this device on this chipset has its own IOMMU.</span>
<span class="cm">	 * If we find it under a different IOMMU, then the BIOS is lying</span>
<span class="cm">	 * to us. Hope that the IOMMU for this device is actually</span>
<span class="cm">	 * disabled, and it needs no translation...</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_bus_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vtbar</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &quot;can&#39;t&quot; happen */</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to run vt-d quirk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vtbar</span> <span class="o">&amp;=</span> <span class="mh">0xffff0000</span><span class="p">;</span>

	<span class="cm">/* we know that the this iommu should be at offset 0xa000 from vtbar */</span>
	<span class="n">drhd</span> <span class="o">=</span> <span class="n">dmar_find_matched_drhd_unit</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_TAINT_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">drhd</span> <span class="o">||</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">reg_base_addr</span> <span class="o">-</span> <span class="n">vtbar</span> <span class="o">!=</span> <span class="mh">0xa000</span><span class="p">,</span>
			    <span class="n">TAINT_FIRMWARE_WORKAROUND</span><span class="p">,</span>
			    <span class="s">&quot;BIOS assigned incorrect VT-d unit for Intel(R) QuickData Technology device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">DUMMY_DEVICE_DOMAIN_INFO</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_ENABLE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_IOAT_SNB</span><span class="p">,</span> <span class="n">quirk_ioat_snb_local_iommu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_no_remapping_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>

	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">include_all</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* ignore DMAR unit if no pci devices exist */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">)</span>
				<span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span> <span class="o">||</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">include_all</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">IS_GFX_DEVICE</span><span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* This IOMMU has *only* gfx devices. Either bypass it or</span>
<span class="cm">		   set the gfx_mapped flag, as appropriate */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dmar_map_gfx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intel_iommu_gfx_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">drhd</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">DUMMY_DEVICE_DOMAIN_INFO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_iommu_hw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">qi</span><span class="p">)</span>
			<span class="n">dmar_reenable_qi</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

	<span class="n">for_each_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we always have to disable PMRs or DMA may fail on</span>
<span class="cm">			 * this device</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
				<span class="n">iommu_disable_protect_mem_regions</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	
		<span class="n">iommu_flush_write_buffer</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

		<span class="n">iommu_set_root_entry</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_context</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">DMA_CCMD_GLOBAL_INVL</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">DMA_TLB_GLOBAL_FLUSH</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu_enable_translation</span><span class="p">(</span><span class="n">iommu</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">iommu_disable_protect_mem_regions</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_flush_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_context</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">DMA_CCMD_GLOBAL_INVL</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">.</span><span class="n">flush_iotlb</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">DMA_TLB_GLOBAL_FLUSH</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_SR_DMAR_REGS</span><span class="p">,</span>
						 <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iommu_flush_all</span><span class="p">();</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iommu_disable_translation</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FECTL_REG</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FECTL_REG</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FEDATA_REG</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FEDATA_REG</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FEADDR_REG</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FEADDR_REG</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FEUADDR_REG</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FEUADDR_REG</span><span class="p">);</span>

		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_iommu_hw</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tboot: IOMMU setup failed, DMAR can not resume!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;IOMMU setup failed, DMAR can not resume!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FECTL_REG</span><span class="p">],</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FECTL_REG</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FEDATA_REG</span><span class="p">],</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FEDATA_REG</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FEADDR_REG</span><span class="p">],</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FEADDR_REG</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">[</span><span class="n">SR_DMAR_FEUADDR_REG</span><span class="p">],</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">+</span> <span class="n">DMAR_FEUADDR_REG</span><span class="p">);</span>

		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">for_each_active_iommu</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">drhd</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">iommu_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">syscore_ops</span> <span class="n">iommu_syscore_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">iommu_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">iommu_suspend</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_iommu_pm_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu_syscore_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_iommu_pm_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dmar_rmrr_units</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">dmar_register_rmrr_unit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_rmrr_unit</span> <span class="o">*</span><span class="n">rmrr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmar_rmrr_units</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">__init</span> <span class="nf">dmar_parse_one_rmrr</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_dmar_header</span> <span class="o">*</span><span class="n">header</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_dmar_reserved_memory</span> <span class="o">*</span><span class="n">rmrr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmar_rmrr_unit</span> <span class="o">*</span><span class="n">rmrru</span><span class="p">;</span>

	<span class="n">rmrru</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rmrru</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmrru</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">rmrr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_dmar_reserved_memory</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>
	<span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">base_address</span> <span class="o">=</span> <span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">base_address</span><span class="p">;</span>
	<span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">end_address</span> <span class="o">=</span> <span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">end_address</span><span class="p">;</span>

	<span class="n">dmar_register_rmrr_unit</span><span class="p">(</span><span class="n">rmrru</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">rmrr_parse_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_rmrr_unit</span> <span class="o">*</span><span class="n">rmrru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_dmar_reserved_memory</span> <span class="o">*</span><span class="n">rmrr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rmrr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_dmar_reserved_memory</span> <span class="o">*</span><span class="p">)</span> <span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dmar_parse_dev_scope</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">rmrr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
		<span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rmrr</span><span class="p">)</span> <span class="o">+</span> <span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">rmrr</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="p">(</span><span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">devices_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmrru</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rmrru</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dmar_atsr_units</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">dmar_parse_one_atsr</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_dmar_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_dmar_atsr</span> <span class="o">*</span><span class="n">atsr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmar_atsr_unit</span> <span class="o">*</span><span class="n">atsru</span><span class="p">;</span>

	<span class="n">atsr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">acpi_dmar_atsr</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
	<span class="n">atsru</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">atsru</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atsru</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">atsru</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">atsru</span><span class="o">-&gt;</span><span class="n">include_all</span> <span class="o">=</span> <span class="n">atsr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmar_atsr_units</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">atsr_parse_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_atsr_unit</span> <span class="o">*</span><span class="n">atsru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_dmar_atsr</span> <span class="o">*</span><span class="n">atsr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">include_all</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">atsr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">acpi_dmar_atsr</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dmar_parse_dev_scope</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">atsr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">atsr</span> <span class="o">+</span> <span class="n">atsr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span>
				<span class="n">atsr</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="o">!</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">atsru</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dmar_find_matched_atsr_unit</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_dmar_atsr</span> <span class="o">*</span><span class="n">atsr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmar_atsr_unit</span> <span class="o">*</span><span class="n">atsru</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_physfn</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">atsru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmar_atsr_units</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atsr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">acpi_dmar_atsr</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atsr</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">==</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span> <span class="n">bus</span><span class="p">;</span> <span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bridge</span> <span class="o">||</span> <span class="o">!</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">pcie_type</span> <span class="o">==</span> <span class="n">PCI_EXP_TYPE_PCI_BRIDGE</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">pcie_type</span> <span class="o">==</span> <span class="n">PCI_EXP_TYPE_ROOT_PORT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">atsru</span><span class="o">-&gt;</span><span class="n">devices_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">bridge</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atsru</span><span class="o">-&gt;</span><span class="n">include_all</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">dmar_parse_rmrr_atsr_dev</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_rmrr_unit</span> <span class="o">*</span><span class="n">rmrr</span><span class="p">,</span> <span class="o">*</span><span class="n">rmrr_n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmar_atsr_unit</span> <span class="o">*</span><span class="n">atsr</span><span class="p">,</span> <span class="o">*</span><span class="n">atsr_n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rmrr</span><span class="p">,</span> <span class="n">rmrr_n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmar_rmrr_units</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rmrr_parse_dev</span><span class="p">(</span><span class="n">rmrr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">atsr</span><span class="p">,</span> <span class="n">atsr_n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmar_atsr_units</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">atsr_parse_dev</span><span class="p">(</span><span class="n">atsr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Here we only respond to action of unbound device from driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Added device is not attached to its DMAR domain here yet. That will happen</span>
<span class="cm"> * when mapping the device to iova.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_no_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">find_domain</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">BUS_NOTIFY_UNBOUND_DRIVER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">iommu_pass_through</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">domain_remove_one_dev_info</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_VIRTUAL_MACHINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_STATIC_IDENTITY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">))</span>
			<span class="n">domain_exit</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">device_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">device_notifier</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">intel_iommu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* VT-d is required for a TXT/tboot launch, so enforce that */</span>
	<span class="n">force_on</span> <span class="o">=</span> <span class="n">tboot_force_iommu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmar_table_init</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tboot: Failed to initialize DMAR table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> 	<span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmar_dev_scope_init</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tboot: Failed to initialize DMAR device scope</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> 	<span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">no_iommu</span> <span class="o">||</span> <span class="n">dmar_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_init_mempool</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tboot: Failed to initialize iommu memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> 	<span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmar_rmrr_units</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMAR: No RMRR found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmar_atsr_units</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMAR: No ATSR found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmar_init_reserved_ranges</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tboot: Failed to reserve iommu ranges</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> 	<span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_no_remapping_devices</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">init_dmars</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_on</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tboot: Failed to initialize DMARs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOMMU: dmar init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">put_iova_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reserved_iova_list</span><span class="p">);</span>
		<span class="n">iommu_exit_mempool</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	<span class="s">&quot;PCI-DMA: Intel(R) Virtualization Technology for Directed I/O</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unmap_timer</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SWIOTLB</span>
	<span class="n">swiotlb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_dma_ops</span><span class="p">;</span>

	<span class="n">init_iommu_pm_ops</span><span class="p">();</span>

	<span class="n">bus_set_iommu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_iommu_ops</span><span class="p">);</span>

	<span class="n">bus_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_nb</span><span class="p">);</span>

	<span class="n">intel_iommu_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_detach_dependent_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span> <span class="o">||</span> <span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* dependent device detach */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">pci_find_upstream_pcie_bridge</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="cm">/* Secondary interface&#39;s bus number and devfn 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iommu_detach_dev</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					 <span class="n">parent</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="cm">/* this is a PCIe-to-PCI bridge */</span>
			<span class="n">iommu_detach_dev</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span>
				<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span> <span class="cm">/* this is a legacy PCI bridge */</span>
			<span class="n">iommu_detach_dev</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					 <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">domain_remove_one_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
				<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_domain_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">==</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&amp;&amp;</span>
		    <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlink_domain_info</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">iommu_disable_dev_iotlb</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">iommu_detach_dev</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
			<span class="n">iommu_detach_dependent_devices</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
			<span class="n">free_devinfo_mem</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if there is no other devices under the same iommu</span>
<span class="cm">		 * owned by this domain, clear this iommu in iommu_bmp</span>
<span class="cm">		 * update iommu count and coherency</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span> <span class="o">==</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
					    <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">))</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp_flags</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">tmp_flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">);</span>
		<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">domain_update_iommu_cap</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">tmp_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_VIRTUAL_MACHINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_STATIC_IDENTITY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">tmp_flags</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">tmp_flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vm_domain_remove_all_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_domain_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags1</span><span class="p">,</span> <span class="n">flags2</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_domain_info</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">unlink_domain_info</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>

		<span class="n">iommu_disable_dev_iotlb</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">iommu</span> <span class="o">=</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">iommu_detach_dev</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">iommu_detach_dependent_devices</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* clear this iommu in iommu_bmp, update iommu count</span>
<span class="cm">		 * and capabilities</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">seq_id</span><span class="p">,</span>
				       <span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">domain_update_iommu_cap</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>

		<span class="n">free_devinfo_mem</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_domain_lock</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* domain id for virtual machine, it won&#39;t be set in context */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_domid</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="nf">iommu_alloc_vm_domain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">alloc_domain_mem</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">vm_domid</span><span class="o">++</span><span class="p">;</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_bmp</span><span class="p">));</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">DOMAIN_FLAG_VIRTUAL_MACHINE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">domain</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">md_domain_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">guest_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">adjust_width</span><span class="p">;</span>

	<span class="n">init_iova_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">,</span> <span class="n">DMA_32BIT_PFN</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_lock</span><span class="p">);</span>

	<span class="n">domain_reserve_special_ranges</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>

	<span class="cm">/* calculate AGAW */</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span> <span class="o">=</span> <span class="n">guest_width</span><span class="p">;</span>
	<span class="n">adjust_width</span> <span class="o">=</span> <span class="n">guestwidth_to_adjustwidth</span><span class="p">(</span><span class="n">guest_width</span><span class="p">);</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">agaw</span> <span class="o">=</span> <span class="n">width_to_agaw</span><span class="p">(</span><span class="n">adjust_width</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_coherency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_snooping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">iommu_superpage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">max_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* always allocate the top pgd */</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="p">)</span><span class="n">alloc_pgtable_page</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">domain_flush_cache</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_free_vm_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ndomains</span><span class="p">;</span>

	<span class="n">for_each_drhd_unit</span><span class="p">(</span><span class="n">drhd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drhd</span><span class="o">-&gt;</span><span class="n">ignored</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">iommu</span> <span class="o">=</span> <span class="n">drhd</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">;</span>

		<span class="n">ndomains</span> <span class="o">=</span> <span class="n">cap_ndoms</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>
		<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">,</span> <span class="n">ndomains</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domain_ids</span><span class="p">);</span>
				<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">domains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vm_domain_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Domain 0 is reserved, so dont process it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vm_domain_remove_all_dev_info</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="cm">/* destroy iovas */</span>
	<span class="n">put_iova_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">iovad</span><span class="p">);</span>

	<span class="cm">/* clear ptes */</span>
	<span class="n">dma_pte_clear_range</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DOMAIN_MAX_PFN</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">));</span>

	<span class="cm">/* free page tables */</span>
	<span class="n">dma_pte_free_pagetable</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DOMAIN_MAX_PFN</span><span class="p">(</span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">));</span>

	<span class="n">iommu_free_vm_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">free_domain_mem</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_iommu_domain_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span><span class="p">;</span>

	<span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">iommu_alloc_vm_domain</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmar_domain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;intel_iommu_domain_init: dmar_domain == NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">md_domain_init</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">,</span> <span class="n">DEFAULT_DOMAIN_ADDRESS_WIDTH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;intel_iommu_domain_init() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">vm_domain_exit</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">domain_update_iommu_cap</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">);</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dmar_domain</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_iommu_domain_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vm_domain_exit</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_iommu_attach_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr_width</span><span class="p">;</span>

	<span class="cm">/* normally pdev is not mapped */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">domain_context_mapped</span><span class="p">(</span><span class="n">pdev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">old_domain</span><span class="p">;</span>

		<span class="n">old_domain</span> <span class="o">=</span> <span class="n">find_domain</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_domain</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_VIRTUAL_MACHINE</span> <span class="o">||</span>
			    <span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DOMAIN_FLAG_STATIC_IDENTITY</span><span class="p">)</span>
				<span class="n">domain_remove_one_dev_info</span><span class="p">(</span><span class="n">old_domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">domain_remove_dev_info</span><span class="p">(</span><span class="n">old_domain</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">device_to_iommu</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
				<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* check if this iommu agaw is sufficient for max mapped address */</span>
	<span class="n">addr_width</span> <span class="o">=</span> <span class="n">agaw_to_width</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr_width</span> <span class="o">&gt;</span> <span class="n">cap_mgaw</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">))</span>
		<span class="n">addr_width</span> <span class="o">=</span> <span class="n">cap_mgaw</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">max_addr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">addr_width</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: iommu width (%d) is not &quot;</span>
		       <span class="s">&quot;sufficient for the mapped address (%llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">addr_width</span><span class="p">,</span> <span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">max_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">gaw</span> <span class="o">=</span> <span class="n">addr_width</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Knock out extra levels of page tables if necessary</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">agaw</span> <span class="o">&lt;</span> <span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_pte_addr</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
			<span class="n">free_pgtable_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">agaw</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">domain_add_dev_info</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="n">CONTEXT_TT_MULTI_LEVEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_iommu_detach_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">domain_remove_one_dev_info</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_iommu_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">hpa</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iommu_prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">max_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_prot</span> <span class="o">&amp;</span> <span class="n">IOMMU_READ</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">|=</span> <span class="n">DMA_PTE_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_prot</span> <span class="o">&amp;</span> <span class="n">IOMMU_WRITE</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">|=</span> <span class="n">DMA_PTE_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iommu_prot</span> <span class="o">&amp;</span> <span class="n">IOMMU_CACHE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">iommu_snooping</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">|=</span> <span class="n">DMA_PTE_SNP</span><span class="p">;</span>

	<span class="n">max_addr</span> <span class="o">=</span> <span class="n">iova</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">max_addr</span> <span class="o">&lt;</span> <span class="n">max_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>

		<span class="cm">/* check if minimum agaw is sufficient for mapped address */</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__DOMAIN_MAX_ADDR</span><span class="p">(</span><span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">max_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: iommu width (%d) is not &quot;</span>
			       <span class="s">&quot;sufficient for the mapped address (%llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">gaw</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">max_addr</span> <span class="o">=</span> <span class="n">max_addr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Round up size to next multiple of PAGE_SIZE, if it and</span>
<span class="cm">	   the low bits of hpa would take us onto the next page */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">aligned_nrpages</span><span class="p">(</span><span class="n">hpa</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">domain_pfn_mapping</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">,</span> <span class="n">iova</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">,</span>
				 <span class="n">hpa</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">intel_iommu_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">dma_pte_clear_range</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">,</span> <span class="n">iova</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">iova</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">max_addr</span> <span class="o">==</span> <span class="n">iova</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">max_addr</span> <span class="o">=</span> <span class="n">iova</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">phys_addr_t</span> <span class="nf">intel_iommu_iova_to_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pte</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pfn_to_dma_pte</span><span class="p">(</span><span class="n">dmar_domain</span><span class="p">,</span> <span class="n">iova</span> <span class="o">&gt;&gt;</span> <span class="n">VTD_PAGE_SHIFT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte</span><span class="p">)</span>
		<span class="n">phys</span> <span class="o">=</span> <span class="n">dma_pte_addr</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">phys</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_iommu_domain_has_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">*</span><span class="n">dmar_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">IOMMU_CAP_CACHE_COHERENCY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dmar_domain</span><span class="o">-&gt;</span><span class="n">iommu_snooping</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">IOMMU_CAP_INTR_REMAP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">irq_remapping_enabled</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Group numbers are arbitrary.  Device with the same group number</span>
<span class="cm"> * indicate the iommu cannot differentiate between them.  To avoid</span>
<span class="cm"> * tracking used groups we just use the seg|bus|devfn of the lowest</span>
<span class="cm"> * level we&#39;re able to differentiate devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_iommu_device_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">groupid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">devfn</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">bus</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">segment</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">pci</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">group</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_no_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">devfn</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device_to_iommu</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">segment</span><span class="p">,</span> <span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">bus</span><span class="p">,</span> <span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">devfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">bridge</span> <span class="o">=</span> <span class="n">pci_find_upstream_pcie_bridge</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_is_pcie</span><span class="p">(</span><span class="n">bridge</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
			<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">devfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
			<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">devfn</span> <span class="o">=</span> <span class="n">bridge</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_virtfn</span> <span class="o">&amp;&amp;</span> <span class="n">iommu_group_mf</span><span class="p">)</span>
		<span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">devfn</span> <span class="o">=</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">pci</span><span class="p">.</span><span class="n">devfn</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="o">*</span><span class="n">groupid</span> <span class="o">=</span> <span class="n">id</span><span class="p">.</span><span class="n">group</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iommu_ops</span> <span class="n">intel_iommu_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">domain_init</span>	<span class="o">=</span> <span class="n">intel_iommu_domain_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">domain_destroy</span> <span class="o">=</span> <span class="n">intel_iommu_domain_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach_dev</span>	<span class="o">=</span> <span class="n">intel_iommu_attach_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach_dev</span>	<span class="o">=</span> <span class="n">intel_iommu_detach_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>		<span class="o">=</span> <span class="n">intel_iommu_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap</span>		<span class="o">=</span> <span class="n">intel_iommu_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iova_to_phys</span>	<span class="o">=</span> <span class="n">intel_iommu_iova_to_phys</span><span class="p">,</span>
	<span class="p">.</span><span class="n">domain_has_cap</span> <span class="o">=</span> <span class="n">intel_iommu_domain_has_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device_group</span>	<span class="o">=</span> <span class="n">intel_iommu_device_group</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pgsize_bitmap</span>	<span class="o">=</span> <span class="n">INTEL_IOMMU_PGSIZES</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_iommu_rwbf</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mobile 4 Series Chipset neglects to set RWBF capability,</span>
<span class="cm">	 * but needs it:</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMAR: Forcing write-buffer flush capability</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rwbf_quirk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* https://bugzilla.redhat.com/show_bug.cgi?id=538163 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="mh">0x07</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMAR: Disabling IOMMU for graphics on this chipset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dmar_map_gfx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x2a40</span><span class="p">,</span> <span class="n">quirk_iommu_rwbf</span><span class="p">);</span>

<span class="cp">#define GGC 0x52</span>
<span class="cp">#define GGC_MEMORY_SIZE_MASK	(0xf &lt;&lt; 8)</span>
<span class="cp">#define GGC_MEMORY_SIZE_NONE	(0x0 &lt;&lt; 8)</span>
<span class="cp">#define GGC_MEMORY_SIZE_1M	(0x1 &lt;&lt; 8)</span>
<span class="cp">#define GGC_MEMORY_SIZE_2M	(0x3 &lt;&lt; 8)</span>
<span class="cp">#define GGC_MEMORY_VT_ENABLED	(0x8 &lt;&lt; 8)</span>
<span class="cp">#define GGC_MEMORY_SIZE_2M_VT	(0x9 &lt;&lt; 8)</span>
<span class="cp">#define GGC_MEMORY_SIZE_3M_VT	(0xa &lt;&lt; 8)</span>
<span class="cp">#define GGC_MEMORY_SIZE_4M_VT	(0xb &lt;&lt; 8)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_calpella_no_shadow_gtt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ggc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GGC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ggc</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ggc</span> <span class="o">&amp;</span> <span class="n">GGC_MEMORY_VT_ENABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMAR: BIOS has allocated no shadow GTT; disabling IOMMU for graphics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dmar_map_gfx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dmar_map_gfx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we have to ensure the gfx device is idle before we flush */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMAR: Disabling batched IOTLB flush on Ironlake</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">intel_iommu_strict</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
       <span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0040</span><span class="p">,</span> <span class="n">quirk_calpella_no_shadow_gtt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0044</span><span class="p">,</span> <span class="n">quirk_calpella_no_shadow_gtt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0062</span><span class="p">,</span> <span class="n">quirk_calpella_no_shadow_gtt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x006a</span><span class="p">,</span> <span class="n">quirk_calpella_no_shadow_gtt</span><span class="p">);</span>

<span class="cm">/* On Tylersburg chipsets, some BIOSes have been known to enable the</span>
<span class="cm">   ISOCH DMAR unit for the Azalia sound device, but not give it any</span>
<span class="cm">   TLB entries, which causes it to deadlock. Check for that.  We do</span>
<span class="cm">   this in a function called from init_dmars(), instead of in a PCI</span>
<span class="cm">   quirk, because we don&#39;t want to print the obnoxious &quot;BIOS broken&quot;</span>
<span class="cm">   message if VT-d is actually disabled.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">check_tylersburg_isoch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">vtisochctrl</span><span class="p">;</span>

	<span class="cm">/* If there&#39;s no Azalia in the system anyway, forget it. */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x3a3e</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* System Management Registers. Might be hidden, in which case</span>
<span class="cm">	   we can&#39;t do the sanity check. But that&#39;s OK, because the</span>
<span class="cm">	   known-broken BIOSes _don&#39;t_ actually hide it, so far. */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x342e</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x188</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vtisochctrl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* If Azalia DMA is routed to the non-isoch DMAR unit, fine. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vtisochctrl</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Drop all bits other than the number of TLB entries */</span>
	<span class="n">vtisochctrl</span> <span class="o">&amp;=</span> <span class="mh">0x1c</span><span class="p">;</span>

	<span class="cm">/* If we have the recommended number of TLB entries (16), fine. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vtisochctrl</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Zero TLB entries? You get to ride the short bus to school. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vtisochctrl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Your BIOS is broken; DMA routed to ISOCH DMAR unit but no TLB space.</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;BIOS vendor: %s; Ver: %s; Product Version: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">),</span>
		     <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">),</span>
		     <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_PRODUCT_VERSION</span><span class="p">));</span>
		<span class="n">iommu_identity_mapping</span> <span class="o">|=</span> <span class="n">IDENTMAP_AZALIA</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;DMAR: Recommended TLB entries for ISOCH unit is 16; your BIOS set %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vtisochctrl</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
