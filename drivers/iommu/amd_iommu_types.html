<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › iommu › amd_iommu_types.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>amd_iommu_types.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007-2010 Advanced Micro Devices, Inc.</span>
<span class="cm"> * Author: Joerg Roedel &lt;joerg.roedel@amd.com&gt;</span>
<span class="cm"> *         Leo Duran &lt;leo.duran@amd.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_X86_AMD_IOMMU_TYPES_H</span>
<span class="cp">#define _ASM_X86_AMD_IOMMU_TYPES_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of IOMMUs supported</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_IOMMUS	32</span>

<span class="cm">/*</span>
<span class="cm"> * some size calculation constants</span>
<span class="cm"> */</span>
<span class="cp">#define DEV_TABLE_ENTRY_SIZE		32</span>
<span class="cp">#define ALIAS_TABLE_ENTRY_SIZE		2</span>
<span class="cp">#define RLOOKUP_TABLE_ENTRY_SIZE	(sizeof(void *))</span>

<span class="cm">/* Length of the MMIO region for the AMD IOMMU */</span>
<span class="cp">#define MMIO_REGION_LENGTH       0x4000</span>

<span class="cm">/* Capability offsets used by the driver */</span>
<span class="cp">#define MMIO_CAP_HDR_OFFSET	0x00</span>
<span class="cp">#define MMIO_RANGE_OFFSET	0x0c</span>
<span class="cp">#define MMIO_MISC_OFFSET	0x10</span>

<span class="cm">/* Masks, shifts and macros to parse the device range capability */</span>
<span class="cp">#define MMIO_RANGE_LD_MASK	0xff000000</span>
<span class="cp">#define MMIO_RANGE_FD_MASK	0x00ff0000</span>
<span class="cp">#define MMIO_RANGE_BUS_MASK	0x0000ff00</span>
<span class="cp">#define MMIO_RANGE_LD_SHIFT	24</span>
<span class="cp">#define MMIO_RANGE_FD_SHIFT	16</span>
<span class="cp">#define MMIO_RANGE_BUS_SHIFT	8</span>
<span class="cp">#define MMIO_GET_LD(x)  (((x) &amp; MMIO_RANGE_LD_MASK) &gt;&gt; MMIO_RANGE_LD_SHIFT)</span>
<span class="cp">#define MMIO_GET_FD(x)  (((x) &amp; MMIO_RANGE_FD_MASK) &gt;&gt; MMIO_RANGE_FD_SHIFT)</span>
<span class="cp">#define MMIO_GET_BUS(x) (((x) &amp; MMIO_RANGE_BUS_MASK) &gt;&gt; MMIO_RANGE_BUS_SHIFT)</span>
<span class="cp">#define MMIO_MSI_NUM(x)	((x) &amp; 0x1f)</span>

<span class="cm">/* Flag masks for the AMD IOMMU exclusion range */</span>
<span class="cp">#define MMIO_EXCL_ENABLE_MASK 0x01ULL</span>
<span class="cp">#define MMIO_EXCL_ALLOW_MASK  0x02ULL</span>

<span class="cm">/* Used offsets into the MMIO space */</span>
<span class="cp">#define MMIO_DEV_TABLE_OFFSET   0x0000</span>
<span class="cp">#define MMIO_CMD_BUF_OFFSET     0x0008</span>
<span class="cp">#define MMIO_EVT_BUF_OFFSET     0x0010</span>
<span class="cp">#define MMIO_CONTROL_OFFSET     0x0018</span>
<span class="cp">#define MMIO_EXCL_BASE_OFFSET   0x0020</span>
<span class="cp">#define MMIO_EXCL_LIMIT_OFFSET  0x0028</span>
<span class="cp">#define MMIO_EXT_FEATURES	0x0030</span>
<span class="cp">#define MMIO_PPR_LOG_OFFSET	0x0038</span>
<span class="cp">#define MMIO_CMD_HEAD_OFFSET	0x2000</span>
<span class="cp">#define MMIO_CMD_TAIL_OFFSET	0x2008</span>
<span class="cp">#define MMIO_EVT_HEAD_OFFSET	0x2010</span>
<span class="cp">#define MMIO_EVT_TAIL_OFFSET	0x2018</span>
<span class="cp">#define MMIO_STATUS_OFFSET	0x2020</span>
<span class="cp">#define MMIO_PPR_HEAD_OFFSET	0x2030</span>
<span class="cp">#define MMIO_PPR_TAIL_OFFSET	0x2038</span>


<span class="cm">/* Extended Feature Bits */</span>
<span class="cp">#define FEATURE_PREFETCH	(1ULL&lt;&lt;0)</span>
<span class="cp">#define FEATURE_PPR		(1ULL&lt;&lt;1)</span>
<span class="cp">#define FEATURE_X2APIC		(1ULL&lt;&lt;2)</span>
<span class="cp">#define FEATURE_NX		(1ULL&lt;&lt;3)</span>
<span class="cp">#define FEATURE_GT		(1ULL&lt;&lt;4)</span>
<span class="cp">#define FEATURE_IA		(1ULL&lt;&lt;6)</span>
<span class="cp">#define FEATURE_GA		(1ULL&lt;&lt;7)</span>
<span class="cp">#define FEATURE_HE		(1ULL&lt;&lt;8)</span>
<span class="cp">#define FEATURE_PC		(1ULL&lt;&lt;9)</span>

<span class="cp">#define FEATURE_PASID_SHIFT	32</span>
<span class="cp">#define FEATURE_PASID_MASK	(0x1fULL &lt;&lt; FEATURE_PASID_SHIFT)</span>

<span class="cp">#define FEATURE_GLXVAL_SHIFT	14</span>
<span class="cp">#define FEATURE_GLXVAL_MASK	(0x03ULL &lt;&lt; FEATURE_GLXVAL_SHIFT)</span>

<span class="cp">#define PASID_MASK		0x000fffff</span>

<span class="cm">/* MMIO status bits */</span>
<span class="cp">#define MMIO_STATUS_COM_WAIT_INT_MASK	(1 &lt;&lt; 2)</span>
<span class="cp">#define MMIO_STATUS_PPR_INT_MASK	(1 &lt;&lt; 6)</span>

<span class="cm">/* event logging constants */</span>
<span class="cp">#define EVENT_ENTRY_SIZE	0x10</span>
<span class="cp">#define EVENT_TYPE_SHIFT	28</span>
<span class="cp">#define EVENT_TYPE_MASK		0xf</span>
<span class="cp">#define EVENT_TYPE_ILL_DEV	0x1</span>
<span class="cp">#define EVENT_TYPE_IO_FAULT	0x2</span>
<span class="cp">#define EVENT_TYPE_DEV_TAB_ERR	0x3</span>
<span class="cp">#define EVENT_TYPE_PAGE_TAB_ERR	0x4</span>
<span class="cp">#define EVENT_TYPE_ILL_CMD	0x5</span>
<span class="cp">#define EVENT_TYPE_CMD_HARD_ERR	0x6</span>
<span class="cp">#define EVENT_TYPE_IOTLB_INV_TO	0x7</span>
<span class="cp">#define EVENT_TYPE_INV_DEV_REQ	0x8</span>
<span class="cp">#define EVENT_DEVID_MASK	0xffff</span>
<span class="cp">#define EVENT_DEVID_SHIFT	0</span>
<span class="cp">#define EVENT_DOMID_MASK	0xffff</span>
<span class="cp">#define EVENT_DOMID_SHIFT	0</span>
<span class="cp">#define EVENT_FLAGS_MASK	0xfff</span>
<span class="cp">#define EVENT_FLAGS_SHIFT	0x10</span>

<span class="cm">/* feature control bits */</span>
<span class="cp">#define CONTROL_IOMMU_EN        0x00ULL</span>
<span class="cp">#define CONTROL_HT_TUN_EN       0x01ULL</span>
<span class="cp">#define CONTROL_EVT_LOG_EN      0x02ULL</span>
<span class="cp">#define CONTROL_EVT_INT_EN      0x03ULL</span>
<span class="cp">#define CONTROL_COMWAIT_EN      0x04ULL</span>
<span class="cp">#define CONTROL_INV_TIMEOUT	0x05ULL</span>
<span class="cp">#define CONTROL_PASSPW_EN       0x08ULL</span>
<span class="cp">#define CONTROL_RESPASSPW_EN    0x09ULL</span>
<span class="cp">#define CONTROL_COHERENT_EN     0x0aULL</span>
<span class="cp">#define CONTROL_ISOC_EN         0x0bULL</span>
<span class="cp">#define CONTROL_CMDBUF_EN       0x0cULL</span>
<span class="cp">#define CONTROL_PPFLOG_EN       0x0dULL</span>
<span class="cp">#define CONTROL_PPFINT_EN       0x0eULL</span>
<span class="cp">#define CONTROL_PPR_EN          0x0fULL</span>
<span class="cp">#define CONTROL_GT_EN           0x10ULL</span>

<span class="cp">#define CTRL_INV_TO_MASK	(7 &lt;&lt; CONTROL_INV_TIMEOUT)</span>
<span class="cp">#define CTRL_INV_TO_NONE	0</span>
<span class="cp">#define CTRL_INV_TO_1MS		1</span>
<span class="cp">#define CTRL_INV_TO_10MS	2</span>
<span class="cp">#define CTRL_INV_TO_100MS	3</span>
<span class="cp">#define CTRL_INV_TO_1S		4</span>
<span class="cp">#define CTRL_INV_TO_10S		5</span>
<span class="cp">#define CTRL_INV_TO_100S	6</span>

<span class="cm">/* command specific defines */</span>
<span class="cp">#define CMD_COMPL_WAIT          0x01</span>
<span class="cp">#define CMD_INV_DEV_ENTRY       0x02</span>
<span class="cp">#define CMD_INV_IOMMU_PAGES	0x03</span>
<span class="cp">#define CMD_INV_IOTLB_PAGES	0x04</span>
<span class="cp">#define CMD_COMPLETE_PPR	0x07</span>
<span class="cp">#define CMD_INV_ALL		0x08</span>

<span class="cp">#define CMD_COMPL_WAIT_STORE_MASK	0x01</span>
<span class="cp">#define CMD_COMPL_WAIT_INT_MASK		0x02</span>
<span class="cp">#define CMD_INV_IOMMU_PAGES_SIZE_MASK	0x01</span>
<span class="cp">#define CMD_INV_IOMMU_PAGES_PDE_MASK	0x02</span>
<span class="cp">#define CMD_INV_IOMMU_PAGES_GN_MASK	0x04</span>

<span class="cp">#define PPR_STATUS_MASK			0xf</span>
<span class="cp">#define PPR_STATUS_SHIFT		12</span>

<span class="cp">#define CMD_INV_IOMMU_ALL_PAGES_ADDRESS	0x7fffffffffffffffULL</span>

<span class="cm">/* macros and definitions for device table entries */</span>
<span class="cp">#define DEV_ENTRY_VALID         0x00</span>
<span class="cp">#define DEV_ENTRY_TRANSLATION   0x01</span>
<span class="cp">#define DEV_ENTRY_IR            0x3d</span>
<span class="cp">#define DEV_ENTRY_IW            0x3e</span>
<span class="cp">#define DEV_ENTRY_NO_PAGE_FAULT	0x62</span>
<span class="cp">#define DEV_ENTRY_EX            0x67</span>
<span class="cp">#define DEV_ENTRY_SYSMGT1       0x68</span>
<span class="cp">#define DEV_ENTRY_SYSMGT2       0x69</span>
<span class="cp">#define DEV_ENTRY_INIT_PASS     0xb8</span>
<span class="cp">#define DEV_ENTRY_EINT_PASS     0xb9</span>
<span class="cp">#define DEV_ENTRY_NMI_PASS      0xba</span>
<span class="cp">#define DEV_ENTRY_LINT0_PASS    0xbe</span>
<span class="cp">#define DEV_ENTRY_LINT1_PASS    0xbf</span>
<span class="cp">#define DEV_ENTRY_MODE_MASK	0x07</span>
<span class="cp">#define DEV_ENTRY_MODE_SHIFT	0x09</span>

<span class="cm">/* constants to configure the command buffer */</span>
<span class="cp">#define CMD_BUFFER_SIZE    8192</span>
<span class="cp">#define CMD_BUFFER_UNINITIALIZED 1</span>
<span class="cp">#define CMD_BUFFER_ENTRIES 512</span>
<span class="cp">#define MMIO_CMD_SIZE_SHIFT 56</span>
<span class="cp">#define MMIO_CMD_SIZE_512 (0x9ULL &lt;&lt; MMIO_CMD_SIZE_SHIFT)</span>

<span class="cm">/* constants for event buffer handling */</span>
<span class="cp">#define EVT_BUFFER_SIZE		8192 </span><span class="cm">/* 512 entries */</span><span class="cp"></span>
<span class="cp">#define EVT_LEN_MASK		(0x9ULL &lt;&lt; 56)</span>

<span class="cm">/* Constants for PPR Log handling */</span>
<span class="cp">#define PPR_LOG_ENTRIES		512</span>
<span class="cp">#define PPR_LOG_SIZE_SHIFT	56</span>
<span class="cp">#define PPR_LOG_SIZE_512	(0x9ULL &lt;&lt; PPR_LOG_SIZE_SHIFT)</span>
<span class="cp">#define PPR_ENTRY_SIZE		16</span>
<span class="cp">#define PPR_LOG_SIZE		(PPR_ENTRY_SIZE * PPR_LOG_ENTRIES)</span>

<span class="cp">#define PPR_REQ_TYPE(x)		(((x) &gt;&gt; 60) &amp; 0xfULL)</span>
<span class="cp">#define PPR_FLAGS(x)		(((x) &gt;&gt; 48) &amp; 0xfffULL)</span>
<span class="cp">#define PPR_DEVID(x)		((x) &amp; 0xffffULL)</span>
<span class="cp">#define PPR_TAG(x)		(((x) &gt;&gt; 32) &amp; 0x3ffULL)</span>
<span class="cp">#define PPR_PASID1(x)		(((x) &gt;&gt; 16) &amp; 0xffffULL)</span>
<span class="cp">#define PPR_PASID2(x)		(((x) &gt;&gt; 42) &amp; 0xfULL)</span>
<span class="cp">#define PPR_PASID(x)		((PPR_PASID2(x) &lt;&lt; 16) | PPR_PASID1(x))</span>

<span class="cp">#define PPR_REQ_FAULT		0x01</span>

<span class="cp">#define PAGE_MODE_NONE    0x00</span>
<span class="cp">#define PAGE_MODE_1_LEVEL 0x01</span>
<span class="cp">#define PAGE_MODE_2_LEVEL 0x02</span>
<span class="cp">#define PAGE_MODE_3_LEVEL 0x03</span>
<span class="cp">#define PAGE_MODE_4_LEVEL 0x04</span>
<span class="cp">#define PAGE_MODE_5_LEVEL 0x05</span>
<span class="cp">#define PAGE_MODE_6_LEVEL 0x06</span>

<span class="cp">#define PM_LEVEL_SHIFT(x)	(12 + ((x) * 9))</span>
<span class="cp">#define PM_LEVEL_SIZE(x)	(((x) &lt; 6) ? \</span>
<span class="cp">				  ((1ULL &lt;&lt; PM_LEVEL_SHIFT((x))) - 1): \</span>
<span class="cp">				   (0xffffffffffffffffULL))</span>
<span class="cp">#define PM_LEVEL_INDEX(x, a)	(((a) &gt;&gt; PM_LEVEL_SHIFT((x))) &amp; 0x1ffULL)</span>
<span class="cp">#define PM_LEVEL_ENC(x)		(((x) &lt;&lt; 9) &amp; 0xe00ULL)</span>
<span class="cp">#define PM_LEVEL_PDE(x, a)	((a) | PM_LEVEL_ENC((x)) | \</span>
<span class="cp">				 IOMMU_PTE_P | IOMMU_PTE_IR | IOMMU_PTE_IW)</span>
<span class="cp">#define PM_PTE_LEVEL(pte)	(((pte) &gt;&gt; 9) &amp; 0x7ULL)</span>

<span class="cp">#define PM_MAP_4k		0</span>
<span class="cp">#define PM_ADDR_MASK		0x000ffffffffff000ULL</span>
<span class="cp">#define PM_MAP_MASK(lvl)	(PM_ADDR_MASK &amp; \</span>
<span class="cp">				(~((1ULL &lt;&lt; (12 + ((lvl) * 9))) - 1)))</span>
<span class="cp">#define PM_ALIGNED(lvl, addr)	((PM_MAP_MASK(lvl) &amp; (addr)) == (addr))</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the page table level to use for a given page size</span>
<span class="cm"> * Pagesize is expected to be a power-of-two</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_SIZE_LEVEL(pagesize) \</span>
<span class="cp">		((__ffs(pagesize) - 12) / 9)</span>
<span class="cm">/*</span>
<span class="cm"> * Returns the number of ptes to use for a given page size</span>
<span class="cm"> * Pagesize is expected to be a power-of-two</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_SIZE_PTE_COUNT(pagesize) \</span>
<span class="cp">		(1ULL &lt;&lt; ((__ffs(pagesize) - 12) % 9))</span>

<span class="cm">/*</span>
<span class="cm"> * Aligns a given io-virtual address to a given page size</span>
<span class="cm"> * Pagesize is expected to be a power-of-two</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_SIZE_ALIGN(address, pagesize) \</span>
<span class="cp">		((address) &amp; ~((pagesize) - 1))</span>
<span class="cm">/*</span>
<span class="cm"> * Creates an IOMMU PTE for an address an a given pagesize</span>
<span class="cm"> * The PTE has no permission bits set</span>
<span class="cm"> * Pagesize is expected to be a power-of-two larger than 4096</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_SIZE_PTE(address, pagesize)		\</span>
<span class="cp">		(((address) | ((pagesize) - 1)) &amp;	\</span>
<span class="cp">		 (~(pagesize &gt;&gt; 1)) &amp; PM_ADDR_MASK)</span>

<span class="cm">/*</span>
<span class="cm"> * Takes a PTE value with mode=0x07 and returns the page size it maps</span>
<span class="cm"> */</span>
<span class="cp">#define PTE_PAGE_SIZE(pte) \</span>
<span class="cp">	(1ULL &lt;&lt; (1 + ffz(((pte) | 0xfffULL))))</span>

<span class="cp">#define IOMMU_PTE_P  (1ULL &lt;&lt; 0)</span>
<span class="cp">#define IOMMU_PTE_TV (1ULL &lt;&lt; 1)</span>
<span class="cp">#define IOMMU_PTE_U  (1ULL &lt;&lt; 59)</span>
<span class="cp">#define IOMMU_PTE_FC (1ULL &lt;&lt; 60)</span>
<span class="cp">#define IOMMU_PTE_IR (1ULL &lt;&lt; 61)</span>
<span class="cp">#define IOMMU_PTE_IW (1ULL &lt;&lt; 62)</span>

<span class="cp">#define DTE_FLAG_IOTLB	(0x01UL &lt;&lt; 32)</span>
<span class="cp">#define DTE_FLAG_GV	(0x01ULL &lt;&lt; 55)</span>
<span class="cp">#define DTE_GLX_SHIFT	(56)</span>
<span class="cp">#define DTE_GLX_MASK	(3)</span>

<span class="cp">#define DTE_GCR3_VAL_A(x)	(((x) &gt;&gt; 12) &amp; 0x00007ULL)</span>
<span class="cp">#define DTE_GCR3_VAL_B(x)	(((x) &gt;&gt; 15) &amp; 0x0ffffULL)</span>
<span class="cp">#define DTE_GCR3_VAL_C(x)	(((x) &gt;&gt; 31) &amp; 0xfffffULL)</span>

<span class="cp">#define DTE_GCR3_INDEX_A	0</span>
<span class="cp">#define DTE_GCR3_INDEX_B	1</span>
<span class="cp">#define DTE_GCR3_INDEX_C	1</span>

<span class="cp">#define DTE_GCR3_SHIFT_A	58</span>
<span class="cp">#define DTE_GCR3_SHIFT_B	16</span>
<span class="cp">#define DTE_GCR3_SHIFT_C	43</span>

<span class="cp">#define GCR3_VALID		0x01ULL</span>

<span class="cp">#define IOMMU_PAGE_MASK (((1ULL &lt;&lt; 52) - 1) &amp; ~0xfffULL)</span>
<span class="cp">#define IOMMU_PTE_PRESENT(pte) ((pte) &amp; IOMMU_PTE_P)</span>
<span class="cp">#define IOMMU_PTE_PAGE(pte) (phys_to_virt((pte) &amp; IOMMU_PAGE_MASK))</span>
<span class="cp">#define IOMMU_PTE_MODE(pte) (((pte) &gt;&gt; 9) &amp; 0x07)</span>

<span class="cp">#define IOMMU_PROT_MASK 0x03</span>
<span class="cp">#define IOMMU_PROT_IR 0x01</span>
<span class="cp">#define IOMMU_PROT_IW 0x02</span>

<span class="cm">/* IOMMU capabilities */</span>
<span class="cp">#define IOMMU_CAP_IOTLB   24</span>
<span class="cp">#define IOMMU_CAP_NPCACHE 26</span>
<span class="cp">#define IOMMU_CAP_EFR     27</span>

<span class="cp">#define MAX_DOMAIN_ID 65536</span>

<span class="cm">/* FIXME: move this macro to &lt;linux/pci.h&gt; */</span>
<span class="cp">#define PCI_BUS(x) (((x) &gt;&gt; 8) &amp; 0xff)</span>

<span class="cm">/* Protection domain flags */</span>
<span class="cp">#define PD_DMA_OPS_MASK		(1UL &lt;&lt; 0) </span><span class="cm">/* domain used for dma_ops */</span><span class="cp"></span>
<span class="cp">#define PD_DEFAULT_MASK		(1UL &lt;&lt; 1) </span><span class="cm">/* domain is a default dma_ops</span>
<span class="cm">					      domain for an IOMMU */</span><span class="cp"></span>
<span class="cp">#define PD_PASSTHROUGH_MASK	(1UL &lt;&lt; 2) </span><span class="cm">/* domain has no page</span>
<span class="cm">					      translation */</span><span class="cp"></span>
<span class="cp">#define PD_IOMMUV2_MASK		(1UL &lt;&lt; 3) </span><span class="cm">/* domain has gcr3 table */</span><span class="cp"></span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">amd_iommu_dump</span><span class="p">;</span>
<span class="cp">#define DUMP_printk(format, arg...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (amd_iommu_dump)						\</span>
<span class="cp">			printk(KERN_INFO &quot;AMD-Vi: &quot; format, ## arg);	\</span>
<span class="cp">	} while(0);</span>

<span class="cm">/* global flag if IOMMUs cache non-present entries */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">amd_iommu_np_cache</span><span class="p">;</span>
<span class="cm">/* Only true if all IOMMUs support device IOTLBs */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">amd_iommu_iotlb_sup</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Make iterating over all IOMMUs easier</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_iommu(iommu) \</span>
<span class="cp">	list_for_each_entry((iommu), &amp;amd_iommu_list, list)</span>
<span class="cp">#define for_each_iommu_safe(iommu, next) \</span>
<span class="cp">	list_for_each_entry_safe((iommu), (next), &amp;amd_iommu_list, list)</span>

<span class="cp">#define APERTURE_RANGE_SHIFT	27	</span><span class="cm">/* 128 MB */</span><span class="cp"></span>
<span class="cp">#define APERTURE_RANGE_SIZE	(1ULL &lt;&lt; APERTURE_RANGE_SHIFT)</span>
<span class="cp">#define APERTURE_RANGE_PAGES	(APERTURE_RANGE_SIZE &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define APERTURE_MAX_RANGES	32	</span><span class="cm">/* allows 4GB of DMA address space */</span><span class="cp"></span>
<span class="cp">#define APERTURE_RANGE_INDEX(a)	((a) &gt;&gt; APERTURE_RANGE_SHIFT)</span>
<span class="cp">#define APERTURE_PAGE_INDEX(a)	(((a) &gt;&gt; 21) &amp; 0x3fULL)</span>


<span class="cm">/*</span>
<span class="cm"> * This struct is used to pass information about</span>
<span class="cm"> * incoming PPR faults around.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">amd_iommu_fault</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">address</span><span class="p">;</span>    <span class="cm">/* IO virtual address of the fault*/</span>
	<span class="n">u32</span> <span class="n">pasid</span><span class="p">;</span>      <span class="cm">/* Address space identifier */</span>
	<span class="n">u16</span> <span class="n">device_id</span><span class="p">;</span>  <span class="cm">/* Originating PCI device id */</span>
	<span class="n">u16</span> <span class="n">tag</span><span class="p">;</span>        <span class="cm">/* PPR tag */</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>      <span class="cm">/* Fault flags */</span>

<span class="p">};</span>

<span class="cp">#define PPR_FAULT_EXEC	(1 &lt;&lt; 1)</span>
<span class="cp">#define PPR_FAULT_READ  (1 &lt;&lt; 2)</span>
<span class="cp">#define PPR_FAULT_WRITE (1 &lt;&lt; 5)</span>
<span class="cp">#define PPR_FAULT_USER  (1 &lt;&lt; 6)</span>
<span class="cp">#define PPR_FAULT_RSVD  (1 &lt;&lt; 7)</span>
<span class="cp">#define PPR_FAULT_GN    (1 &lt;&lt; 8)</span>

<span class="k">struct</span> <span class="n">iommu_domain</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This structure contains generic data for  IOMMU protection domains</span>
<span class="cm"> * independent of their use.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">protection_domain</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>  <span class="cm">/* for list of all protection domains */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dev_list</span><span class="p">;</span> <span class="cm">/* List of all devices in this domain */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* mostly used to lock the page table*/</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">api_lock</span><span class="p">;</span>	<span class="cm">/* protect page tables in the iommu-api path */</span>
	<span class="n">u16</span> <span class="n">id</span><span class="p">;</span>			<span class="cm">/* the domain id written to the device table */</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>		<span class="cm">/* paging mode (0-6 levels) */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pt_root</span><span class="p">;</span>		<span class="cm">/* page table root pointer */</span>
	<span class="kt">int</span> <span class="n">glx</span><span class="p">;</span>		<span class="cm">/* Number of levels for GCR3 table */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">gcr3_tbl</span><span class="p">;</span>		<span class="cm">/* Guest CR3 table */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* flags to find out type of domain */</span>
	<span class="n">bool</span> <span class="n">updated</span><span class="p">;</span>		<span class="cm">/* complete domain flush required */</span>
	<span class="kt">unsigned</span> <span class="n">dev_cnt</span><span class="p">;</span>	<span class="cm">/* devices assigned to this domain */</span>
	<span class="kt">unsigned</span> <span class="n">dev_iommu</span><span class="p">[</span><span class="n">MAX_IOMMUS</span><span class="p">];</span> <span class="cm">/* per-IOMMU reference count */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>		<span class="cm">/* private data */</span>
	<span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">iommu_domain</span><span class="p">;</span> <span class="cm">/* Pointer to generic</span>
<span class="cm">					      domain structure */</span>

<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This struct contains device specific data for the IOMMU</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iommu_dev_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>		  <span class="cm">/* For domain-&gt;dev_list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dev_data_list</span><span class="p">;</span>	  <span class="cm">/* For global dev_data_list */</span>
	<span class="k">struct</span> <span class="n">iommu_dev_data</span> <span class="o">*</span><span class="n">alias_data</span><span class="p">;</span><span class="cm">/* The alias dev_data */</span>
	<span class="k">struct</span> <span class="n">protection_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span> <span class="cm">/* Domain the device is bound to */</span>
	<span class="n">atomic_t</span> <span class="n">bind</span><span class="p">;</span>			  <span class="cm">/* Domain attach reverent count */</span>
	<span class="n">u16</span> <span class="n">devid</span><span class="p">;</span>			  <span class="cm">/* PCI Device ID */</span>
	<span class="n">bool</span> <span class="n">iommu_v2</span><span class="p">;</span>			  <span class="cm">/* Device can make use of IOMMUv2 */</span>
	<span class="n">bool</span> <span class="n">passthrough</span><span class="p">;</span>		  <span class="cm">/* Default for device is pt_domain */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">enabled</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">qdep</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ats</span><span class="p">;</span>				  <span class="cm">/* ATS state */</span>
	<span class="n">bool</span> <span class="n">pri_tlp</span><span class="p">;</span>			  <span class="cm">/* PASID TLB required for</span>
<span class="cm">					     PPR completions */</span>
	<span class="n">u32</span> <span class="n">errata</span><span class="p">;</span>			  <span class="cm">/* Bitmap for errata to apply */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * For dynamic growth the aperture size is split into ranges of 128MB of</span>
<span class="cm"> * DMA address space each. This struct represents one such range.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">aperture_range</span> <span class="p">{</span>

	<span class="cm">/* address allocation bitmap */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Array of PTE pages for the aperture. In this array we save all the</span>
<span class="cm">	 * leaf pages of the domain page table used for the aperture. This way</span>
<span class="cm">	 * we don&#39;t need to walk the page table to find a specific PTE. We can</span>
<span class="cm">	 * just calculate its address in constant time.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pte_pages</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Data container for a dma_ops specific protection domain</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_ops_domain</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* generic protection domain information */</span>
	<span class="k">struct</span> <span class="n">protection_domain</span> <span class="n">domain</span><span class="p">;</span>

	<span class="cm">/* size of the aperture for the mappings */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aperture_size</span><span class="p">;</span>

	<span class="cm">/* address we start to search for free addresses */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_address</span><span class="p">;</span>

	<span class="cm">/* address space relevant data */</span>
	<span class="k">struct</span> <span class="n">aperture_range</span> <span class="o">*</span><span class="n">aperture</span><span class="p">[</span><span class="n">APERTURE_MAX_RANGES</span><span class="p">];</span>

	<span class="cm">/* This will be set to true when TLB needs to be flushed */</span>
	<span class="n">bool</span> <span class="n">need_flush</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if this is a preallocated domain, keep the device for which it was</span>
<span class="cm">	 * preallocated in this variable</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">target_dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure where we save information about one hardware AMD IOMMU in the</span>
<span class="cm"> * system.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">amd_iommu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* Index within the IOMMU array */</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* locks the accesses to the hardware */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* Pointer to PCI device of this IOMMU */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Cache pdev to root device for resume quirks */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">root_pdev</span><span class="p">;</span>

	<span class="cm">/* physical address of MMIO space */</span>
	<span class="n">u64</span> <span class="n">mmio_phys</span><span class="p">;</span>
	<span class="cm">/* virtual address of MMIO space */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mmio_base</span><span class="p">;</span>

	<span class="cm">/* capabilities of that IOMMU read from ACPI */</span>
	<span class="n">u32</span> <span class="n">cap</span><span class="p">;</span>

	<span class="cm">/* flags read from acpi table */</span>
	<span class="n">u8</span> <span class="n">acpi_flags</span><span class="p">;</span>

	<span class="cm">/* Extended features */</span>
	<span class="n">u64</span> <span class="n">features</span><span class="p">;</span>

	<span class="cm">/* IOMMUv2 */</span>
	<span class="n">bool</span> <span class="n">is_iommu_v2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Capability pointer. There could be more than one IOMMU per PCI</span>
<span class="cm">	 * device function if there are more than one AMD IOMMU capability</span>
<span class="cm">	 * pointers.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">cap_ptr</span><span class="p">;</span>

	<span class="cm">/* pci domain of this IOMMU */</span>
	<span class="n">u16</span> <span class="n">pci_seg</span><span class="p">;</span>

	<span class="cm">/* first device this IOMMU handles. read from PCI */</span>
	<span class="n">u16</span> <span class="n">first_device</span><span class="p">;</span>
	<span class="cm">/* last device this IOMMU handles. read from PCI */</span>
	<span class="n">u16</span> <span class="n">last_device</span><span class="p">;</span>

	<span class="cm">/* start of exclusion range of that IOMMU */</span>
	<span class="n">u64</span> <span class="n">exclusion_start</span><span class="p">;</span>
	<span class="cm">/* length of exclusion range of that IOMMU */</span>
	<span class="n">u64</span> <span class="n">exclusion_length</span><span class="p">;</span>

	<span class="cm">/* command buffer virtual address */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cmd_buf</span><span class="p">;</span>
	<span class="cm">/* size of command buffer */</span>
	<span class="n">u32</span> <span class="n">cmd_buf_size</span><span class="p">;</span>

	<span class="cm">/* size of event buffer */</span>
	<span class="n">u32</span> <span class="n">evt_buf_size</span><span class="p">;</span>
	<span class="cm">/* event buffer virtual address */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">evt_buf</span><span class="p">;</span>
	<span class="cm">/* MSI number for event interrupt */</span>
	<span class="n">u16</span> <span class="n">evt_msi_num</span><span class="p">;</span>

	<span class="cm">/* Base of the PPR log, if present */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ppr_log</span><span class="p">;</span>

	<span class="cm">/* true if interrupts for this IOMMU are already enabled */</span>
	<span class="n">bool</span> <span class="n">int_enabled</span><span class="p">;</span>

	<span class="cm">/* if one, we need to send a completion wait command */</span>
	<span class="n">bool</span> <span class="n">need_sync</span><span class="p">;</span>

	<span class="cm">/* default dma_ops domain for that IOMMU */</span>
	<span class="k">struct</span> <span class="n">dma_ops_domain</span> <span class="o">*</span><span class="n">default_dom</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t rely on the BIOS to restore all values on reinit, so we</span>
<span class="cm">	 * need to stash them</span>
<span class="cm">	 */</span>

	<span class="cm">/* The iommu BAR */</span>
	<span class="n">u32</span> <span class="n">stored_addr_lo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">stored_addr_hi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each iommu has 6 l1s, each of which is documented as having 0x12</span>
<span class="cm">	 * registers</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">stored_l1</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mh">0x12</span><span class="p">];</span>

	<span class="cm">/* The l2 indirect registers */</span>
	<span class="n">u32</span> <span class="n">stored_l2</span><span class="p">[</span><span class="mh">0x83</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * List with all IOMMUs in the system. This list is not locked because it is</span>
<span class="cm"> * only written and read at driver initialization or suspend time</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">amd_iommu_list</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Array with pointers to each IOMMU struct</span>
<span class="cm"> * The indices are referenced in the protection domains</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">amd_iommu</span> <span class="o">*</span><span class="n">amd_iommus</span><span class="p">[</span><span class="n">MAX_IOMMUS</span><span class="p">];</span>

<span class="cm">/* Number of IOMMUs present in the system */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">amd_iommus_present</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Declarations for the global list of all protection domains</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">amd_iommu_pd_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">amd_iommu_pd_list</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Structure defining one entry in the device table</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dev_table_entry</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * One entry for unity mappings parsed out of the ACPI table.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">unity_map_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* starting device id this entry is used for (including) */</span>
	<span class="n">u16</span> <span class="n">devid_start</span><span class="p">;</span>
	<span class="cm">/* end device id this entry is used for (including) */</span>
	<span class="n">u16</span> <span class="n">devid_end</span><span class="p">;</span>

	<span class="cm">/* start address to unity map (including) */</span>
	<span class="n">u64</span> <span class="n">address_start</span><span class="p">;</span>
	<span class="cm">/* end address to unity map (including) */</span>
	<span class="n">u64</span> <span class="n">address_end</span><span class="p">;</span>

	<span class="cm">/* required protection */</span>
	<span class="kt">int</span> <span class="n">prot</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * List of all unity mappings. It is not locked because as runtime it is only</span>
<span class="cm"> * read. It is created at ACPI table parsing time.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">amd_iommu_unity_map</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Data structures for device handling</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Device table used by hardware. Read and write accesses by software are</span>
<span class="cm"> * locked with the amd_iommu_pd_table lock.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dev_table_entry</span> <span class="o">*</span><span class="n">amd_iommu_dev_table</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Alias table to find requestor ids to device ids. Not locked because only</span>
<span class="cm"> * read on runtime.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u16</span> <span class="o">*</span><span class="n">amd_iommu_alias_table</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Reverse lookup table to find the IOMMU which translates a specific device.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">amd_iommu</span> <span class="o">**</span><span class="n">amd_iommu_rlookup_table</span><span class="p">;</span>

<span class="cm">/* size of the dma_ops aperture as power of 2 */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">amd_iommu_aperture_order</span><span class="p">;</span>

<span class="cm">/* largest PCI device id we expect translation requests for */</span>
<span class="k">extern</span> <span class="n">u16</span> <span class="n">amd_iommu_last_bdf</span><span class="p">;</span>

<span class="cm">/* allocation bitmap for domain ids */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">amd_iommu_pd_alloc_bitmap</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If true, the addresses will be flushed on unmap time, not when</span>
<span class="cm"> * they are reused</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">amd_iommu_unmap_flush</span><span class="p">;</span>

<span class="cm">/* Smallest number of PASIDs supported by any IOMMU in the system */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">amd_iommu_max_pasids</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">amd_iommu_v2_present</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">amd_iommu_force_isolation</span><span class="p">;</span>

<span class="cm">/* Max levels of glxval supported */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">amd_iommu_max_glx_val</span><span class="p">;</span>

<span class="cm">/* takes bus and device/function and returns the device id</span>
<span class="cm"> * FIXME: should that be in generic PCI code? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">calc_devid</span><span class="p">(</span><span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">bus</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">devfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_AMD_IOMMU_STATS</span>

<span class="k">struct</span> <span class="n">__iommu_counter</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DECLARE_STATS_COUNTER(nm) \</span>
<span class="cp">	static struct __iommu_counter nm = {	\</span>
<span class="cp">		.name = #nm,			\</span>
<span class="cp">	}</span>

<span class="cp">#define INC_STATS_COUNTER(name)		name.value += 1</span>
<span class="cp">#define ADD_STATS_COUNTER(name, x)	name.value += (x)</span>
<span class="cp">#define SUB_STATS_COUNTER(name, x)	name.value -= (x)</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_AMD_IOMMU_STATS */</span><span class="cp"></span>

<span class="cp">#define DECLARE_STATS_COUNTER(name)</span>
<span class="cp">#define INC_STATS_COUNTER(name)</span>
<span class="cp">#define ADD_STATS_COUNTER(name, x)</span>
<span class="cp">#define SUB_STATS_COUNTER(name, x)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_AMD_IOMMU_STATS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_AMD_IOMMU_TYPES_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
