<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › iommu › tegra-smmu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tegra-smmu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IOMMU API for SMMU in Tegra30</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2011-2012, NVIDIA CORPORATION.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt)	&quot;%s(): &quot; fmt, __func__</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/iommu.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>

<span class="cp">#include &lt;mach/iomap.h&gt;</span>
<span class="cp">#include &lt;mach/smmu.h&gt;</span>

<span class="cm">/* bitmap of the page sizes currently supported */</span>
<span class="cp">#define SMMU_IOMMU_PGSIZES	(SZ_4K)</span>

<span class="cp">#define SMMU_CONFIG				0x10</span>
<span class="cp">#define SMMU_CONFIG_DISABLE			0</span>
<span class="cp">#define SMMU_CONFIG_ENABLE			1</span>

<span class="cp">#define SMMU_TLB_CONFIG				0x14</span>
<span class="cp">#define SMMU_TLB_CONFIG_STATS__MASK		(1 &lt;&lt; 31)</span>
<span class="cp">#define SMMU_TLB_CONFIG_STATS__ENABLE		(1 &lt;&lt; 31)</span>
<span class="cp">#define SMMU_TLB_CONFIG_HIT_UNDER_MISS__ENABLE	(1 &lt;&lt; 29)</span>
<span class="cp">#define SMMU_TLB_CONFIG_ACTIVE_LINES__VALUE	0x10</span>
<span class="cp">#define SMMU_TLB_CONFIG_RESET_VAL		0x20000010</span>

<span class="cp">#define SMMU_PTC_CONFIG				0x18</span>
<span class="cp">#define SMMU_PTC_CONFIG_STATS__MASK		(1 &lt;&lt; 31)</span>
<span class="cp">#define SMMU_PTC_CONFIG_STATS__ENABLE		(1 &lt;&lt; 31)</span>
<span class="cp">#define SMMU_PTC_CONFIG_CACHE__ENABLE		(1 &lt;&lt; 29)</span>
<span class="cp">#define SMMU_PTC_CONFIG_INDEX_MAP__PATTERN	0x3f</span>
<span class="cp">#define SMMU_PTC_CONFIG_RESET_VAL		0x2000003f</span>

<span class="cp">#define SMMU_PTB_ASID				0x1c</span>
<span class="cp">#define SMMU_PTB_ASID_CURRENT_SHIFT		0</span>

<span class="cp">#define SMMU_PTB_DATA				0x20</span>
<span class="cp">#define SMMU_PTB_DATA_RESET_VAL			0</span>
<span class="cp">#define SMMU_PTB_DATA_ASID_NONSECURE_SHIFT	29</span>
<span class="cp">#define SMMU_PTB_DATA_ASID_WRITABLE_SHIFT	30</span>
<span class="cp">#define SMMU_PTB_DATA_ASID_READABLE_SHIFT	31</span>

<span class="cp">#define SMMU_TLB_FLUSH				0x30</span>
<span class="cp">#define SMMU_TLB_FLUSH_VA_MATCH_ALL		0</span>
<span class="cp">#define SMMU_TLB_FLUSH_VA_MATCH_SECTION		2</span>
<span class="cp">#define SMMU_TLB_FLUSH_VA_MATCH_GROUP		3</span>
<span class="cp">#define SMMU_TLB_FLUSH_ASID_SHIFT		29</span>
<span class="cp">#define SMMU_TLB_FLUSH_ASID_MATCH_DISABLE	0</span>
<span class="cp">#define SMMU_TLB_FLUSH_ASID_MATCH_ENABLE	1</span>
<span class="cp">#define SMMU_TLB_FLUSH_ASID_MATCH_SHIFT		31</span>

<span class="cp">#define SMMU_PTC_FLUSH				0x34</span>
<span class="cp">#define SMMU_PTC_FLUSH_TYPE_ALL			0</span>
<span class="cp">#define SMMU_PTC_FLUSH_TYPE_ADR			1</span>
<span class="cp">#define SMMU_PTC_FLUSH_ADR_SHIFT		4</span>

<span class="cp">#define SMMU_ASID_SECURITY			0x38</span>

<span class="cp">#define SMMU_STATS_TLB_HIT_COUNT		0x1f0</span>
<span class="cp">#define SMMU_STATS_TLB_MISS_COUNT		0x1f4</span>
<span class="cp">#define SMMU_STATS_PTC_HIT_COUNT		0x1f8</span>
<span class="cp">#define SMMU_STATS_PTC_MISS_COUNT		0x1fc</span>

<span class="cp">#define SMMU_TRANSLATION_ENABLE_0		0x228</span>
<span class="cp">#define SMMU_TRANSLATION_ENABLE_1		0x22c</span>
<span class="cp">#define SMMU_TRANSLATION_ENABLE_2		0x230</span>

<span class="cp">#define SMMU_AFI_ASID	0x238   </span><span class="cm">/* PCIE */</span><span class="cp"></span>
<span class="cp">#define SMMU_AVPC_ASID	0x23c   </span><span class="cm">/* AVP */</span><span class="cp"></span>
<span class="cp">#define SMMU_DC_ASID	0x240   </span><span class="cm">/* Display controller */</span><span class="cp"></span>
<span class="cp">#define SMMU_DCB_ASID	0x244   </span><span class="cm">/* Display controller B */</span><span class="cp"></span>
<span class="cp">#define SMMU_EPP_ASID	0x248   </span><span class="cm">/* Encoder pre-processor */</span><span class="cp"></span>
<span class="cp">#define SMMU_G2_ASID	0x24c   </span><span class="cm">/* 2D engine */</span><span class="cp"></span>
<span class="cp">#define SMMU_HC_ASID	0x250   </span><span class="cm">/* Host1x */</span><span class="cp"></span>
<span class="cp">#define SMMU_HDA_ASID	0x254   </span><span class="cm">/* High-def audio */</span><span class="cp"></span>
<span class="cp">#define SMMU_ISP_ASID	0x258   </span><span class="cm">/* Image signal processor */</span><span class="cp"></span>
<span class="cp">#define SMMU_MPE_ASID	0x264   </span><span class="cm">/* MPEG encoder */</span><span class="cp"></span>
<span class="cp">#define SMMU_NV_ASID	0x268   </span><span class="cm">/* (3D) */</span><span class="cp"></span>
<span class="cp">#define SMMU_NV2_ASID	0x26c   </span><span class="cm">/* (3D) */</span><span class="cp"></span>
<span class="cp">#define SMMU_PPCS_ASID	0x270   </span><span class="cm">/* AHB */</span><span class="cp"></span>
<span class="cp">#define SMMU_SATA_ASID	0x278   </span><span class="cm">/* SATA */</span><span class="cp"></span>
<span class="cp">#define SMMU_VDE_ASID	0x27c   </span><span class="cm">/* Video decoder */</span><span class="cp"></span>
<span class="cp">#define SMMU_VI_ASID	0x280   </span><span class="cm">/* Video input */</span><span class="cp"></span>

<span class="cp">#define SMMU_PDE_NEXT_SHIFT		28</span>

<span class="cm">/* AHB Arbiter Registers */</span>
<span class="cp">#define AHB_XBAR_CTRL				0xe0</span>
<span class="cp">#define AHB_XBAR_CTRL_SMMU_INIT_DONE_DONE	1</span>
<span class="cp">#define AHB_XBAR_CTRL_SMMU_INIT_DONE_SHIFT	17</span>

<span class="cp">#define SMMU_NUM_ASIDS				4</span>
<span class="cp">#define SMMU_TLB_FLUSH_VA_SECTION__MASK		0xffc00000</span>
<span class="cp">#define SMMU_TLB_FLUSH_VA_SECTION__SHIFT	12 </span><span class="cm">/* right shift */</span><span class="cp"></span>
<span class="cp">#define SMMU_TLB_FLUSH_VA_GROUP__MASK		0xffffc000</span>
<span class="cp">#define SMMU_TLB_FLUSH_VA_GROUP__SHIFT		12 </span><span class="cm">/* right shift */</span><span class="cp"></span>
<span class="cp">#define SMMU_TLB_FLUSH_VA(iova, which)	\</span>
<span class="cp">	((((iova) &amp; SMMU_TLB_FLUSH_VA_##which##__MASK) &gt;&gt; \</span>
<span class="cp">		SMMU_TLB_FLUSH_VA_##which##__SHIFT) |	\</span>
<span class="cp">	SMMU_TLB_FLUSH_VA_MATCH_##which)</span>
<span class="cp">#define SMMU_PTB_ASID_CUR(n)	\</span>
<span class="cp">		((n) &lt;&lt; SMMU_PTB_ASID_CURRENT_SHIFT)</span>
<span class="cp">#define SMMU_TLB_FLUSH_ASID_MATCH_disable		\</span>
<span class="cp">		(SMMU_TLB_FLUSH_ASID_MATCH_DISABLE &lt;&lt;	\</span>
<span class="cp">			SMMU_TLB_FLUSH_ASID_MATCH_SHIFT)</span>
<span class="cp">#define SMMU_TLB_FLUSH_ASID_MATCH__ENABLE		\</span>
<span class="cp">		(SMMU_TLB_FLUSH_ASID_MATCH_ENABLE &lt;&lt;	\</span>
<span class="cp">			SMMU_TLB_FLUSH_ASID_MATCH_SHIFT)</span>

<span class="cp">#define SMMU_PAGE_SHIFT 12</span>
<span class="cp">#define SMMU_PAGE_SIZE	(1 &lt;&lt; SMMU_PAGE_SHIFT)</span>

<span class="cp">#define SMMU_PDIR_COUNT	1024</span>
<span class="cp">#define SMMU_PDIR_SIZE	(sizeof(unsigned long) * SMMU_PDIR_COUNT)</span>
<span class="cp">#define SMMU_PTBL_COUNT	1024</span>
<span class="cp">#define SMMU_PTBL_SIZE	(sizeof(unsigned long) * SMMU_PTBL_COUNT)</span>
<span class="cp">#define SMMU_PDIR_SHIFT	12</span>
<span class="cp">#define SMMU_PDE_SHIFT	12</span>
<span class="cp">#define SMMU_PTE_SHIFT	12</span>
<span class="cp">#define SMMU_PFN_MASK	0x000fffff</span>

<span class="cp">#define SMMU_ADDR_TO_PFN(addr)	((addr) &gt;&gt; 12)</span>
<span class="cp">#define SMMU_ADDR_TO_PDN(addr)	((addr) &gt;&gt; 22)</span>
<span class="cp">#define SMMU_PDN_TO_ADDR(addr)	((pdn) &lt;&lt; 22)</span>

<span class="cp">#define _READABLE	(1 &lt;&lt; SMMU_PTB_DATA_ASID_READABLE_SHIFT)</span>
<span class="cp">#define _WRITABLE	(1 &lt;&lt; SMMU_PTB_DATA_ASID_WRITABLE_SHIFT)</span>
<span class="cp">#define _NONSECURE	(1 &lt;&lt; SMMU_PTB_DATA_ASID_NONSECURE_SHIFT)</span>
<span class="cp">#define _PDE_NEXT	(1 &lt;&lt; SMMU_PDE_NEXT_SHIFT)</span>
<span class="cp">#define _MASK_ATTR	(_READABLE | _WRITABLE | _NONSECURE)</span>

<span class="cp">#define _PDIR_ATTR	(_READABLE | _WRITABLE | _NONSECURE)</span>

<span class="cp">#define _PDE_ATTR	(_READABLE | _WRITABLE | _NONSECURE)</span>
<span class="cp">#define _PDE_ATTR_N	(_PDE_ATTR | _PDE_NEXT)</span>
<span class="cp">#define _PDE_VACANT(pdn)	(((pdn) &lt;&lt; 10) | _PDE_ATTR)</span>

<span class="cp">#define _PTE_ATTR	(_READABLE | _WRITABLE | _NONSECURE)</span>
<span class="cp">#define _PTE_VACANT(addr)	(((addr) &gt;&gt; SMMU_PAGE_SHIFT) | _PTE_ATTR)</span>

<span class="cp">#define SMMU_MK_PDIR(page, attr)	\</span>
<span class="cp">		((page_to_phys(page) &gt;&gt; SMMU_PDIR_SHIFT) | (attr))</span>
<span class="cp">#define SMMU_MK_PDE(page, attr)		\</span>
<span class="cp">		(unsigned long)((page_to_phys(page) &gt;&gt; SMMU_PDE_SHIFT) | (attr))</span>
<span class="cp">#define SMMU_EX_PTBL_PAGE(pde)		\</span>
<span class="cp">		pfn_to_page((unsigned long)(pde) &amp; SMMU_PFN_MASK)</span>
<span class="cp">#define SMMU_PFN_TO_PTE(pfn, attr)	(unsigned long)((pfn) | (attr))</span>

<span class="cp">#define SMMU_ASID_ENABLE(asid)	((asid) | (1 &lt;&lt; 31))</span>
<span class="cp">#define SMMU_ASID_DISABLE	0</span>
<span class="cp">#define SMMU_ASID_ASID(n)	((n) &amp; ~SMMU_ASID_ENABLE(0))</span>

<span class="cp">#define smmu_client_enable_hwgrp(c, m)	smmu_client_set_hwgrp(c, m, 1)</span>
<span class="cp">#define smmu_client_disable_hwgrp(c)	smmu_client_set_hwgrp(c, 0, 0)</span>
<span class="cp">#define __smmu_client_enable_hwgrp(c, m) __smmu_client_set_hwgrp(c, m, 1)</span>
<span class="cp">#define __smmu_client_disable_hwgrp(c)	__smmu_client_set_hwgrp(c, 0, 0)</span>

<span class="cp">#define HWGRP_INIT(client) [HWGRP_##client] = SMMU_##client##_ASID</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">smmu_hwgrp_asid_reg</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">AFI</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">AVPC</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">DC</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">DCB</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">EPP</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">G2</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">HC</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">HDA</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">ISP</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">MPE</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">NV</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">NV2</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">PPCS</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">SATA</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">VDE</span><span class="p">),</span>
	<span class="n">HWGRP_INIT</span><span class="p">(</span><span class="n">VI</span><span class="p">),</span>
<span class="p">};</span>
<span class="cp">#define HWGRP_ASID_REG(x) (smmu_hwgrp_asid_reg[x])</span>

<span class="cm">/*</span>
<span class="cm"> * Per client for address space</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smmu_client</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_as</span>		<span class="o">*</span><span class="n">as</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">hwgrp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per address space</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smmu_as</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_device</span>	<span class="o">*</span><span class="n">smmu</span><span class="p">;</span>	<span class="cm">/* back pointer to container */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">asid</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>	<span class="cm">/* for pagetable */</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">pdir_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pdir_attr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pde_attr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pte_attr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="o">*</span><span class="n">pte_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">client</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">client_lock</span><span class="p">;</span> <span class="cm">/* for client list */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per SMMU device - IOMMU device</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smmu_device</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="o">*</span><span class="n">regs_ahbarb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">iovmm_base</span><span class="p">;</span>	<span class="cm">/* remappable base address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">page_count</span><span class="p">;</span>	<span class="cm">/* total remappable size */</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">num_as</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_as</span>	<span class="o">*</span><span class="n">as</span><span class="p">;</span>		<span class="cm">/* Run-time allocated array */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">avp_vector_page</span><span class="p">;</span>	<span class="cm">/* dummy page shared by all AS&#39;s */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register image savers for suspend/resume</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">translation_enable_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">translation_enable_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">translation_enable_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">asid_security</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu_handle</span><span class="p">;</span> <span class="cm">/* unique for a system */</span>

<span class="cm">/*</span>
<span class="cm"> *	SMMU/AHB register accessors</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">smmu_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">offs</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">smmu_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ahb_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span> <span class="o">+</span> <span class="n">offs</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ahb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span> <span class="o">+</span> <span class="n">offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define VA_PAGE_TO_PA(va, page)	\</span>
<span class="cp">	(page_to_phys(page) + ((unsigned long)(va) &amp; ~PAGE_MASK))</span>

<span class="cp">#define FLUSH_CPU_DCACHE(va, page, size)	\</span>
<span class="cp">	do {	\</span>
<span class="cp">		unsigned long _pa_ = VA_PAGE_TO_PA(va, page);		\</span>
<span class="cp">		__cpuc_flush_dcache_area((void *)(va), (size_t)(size));	\</span>
<span class="cp">		outer_flush_range(_pa_, _pa_+(size_t)(size));		\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Any interaction between any block on PPSB and a block on APB or AHB</span>
<span class="cm"> * must have these read-back barriers to ensure the APB/AHB bus</span>
<span class="cm"> * transaction is complete before initiating activity on the PPSB</span>
<span class="cm"> * block.</span>
<span class="cm"> */</span>
<span class="cp">#define FLUSH_SMMU_REGS(smmu)	smmu_read(smmu, SMMU_CONFIG)</span>

<span class="cp">#define smmu_client_hwgrp(c) (u32)((c)-&gt;dev-&gt;platform_data)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__smmu_client_set_hwgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_client</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">SMMU_ASID_ENABLE</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">on</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on</span><span class="p">)</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">smmu_client_hwgrp</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">HWGRP_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">HWGRP_ASID_REG</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">smmu_read</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">err_hw_busy</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">hwgrp</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_hw_busy:</span>
	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">HWGRP_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">HWGRP_ASID_REG</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">smmu_read</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smmu_client_set_hwgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_client</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">__smmu_client_set_hwgrp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush all TLB entries and all PTC entries</span>
<span class="cm"> * Caller must lock smmu</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smmu_flush_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_PTC_FLUSH_TYPE_ALL</span><span class="p">,</span> <span class="n">SMMU_PTC_FLUSH</span><span class="p">);</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">SMMU_TLB_FLUSH_VA_MATCH_ALL</span> <span class="o">|</span>
		<span class="n">SMMU_TLB_FLUSH_ASID_MATCH_disable</span><span class="p">;</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">SMMU_TLB_FLUSH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_CONFIG_ENABLE</span><span class="p">,</span> <span class="n">SMMU_CONFIG</span><span class="p">);</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smmu_setup_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">num_as</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">smmu_client</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

		<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_PTB_ASID_CUR</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">),</span> <span class="n">SMMU_PTB_ASID</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span> <span class="o">?</span>
			<span class="n">SMMU_MK_PDIR</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_attr</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">SMMU_PTB_DATA_RESET_VAL</span><span class="p">;</span>
		<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">SMMU_PTB_DATA</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">__smmu_client_set_hwgrp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">hwgrp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_0</span><span class="p">,</span> <span class="n">SMMU_TRANSLATION_ENABLE_0</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_1</span><span class="p">,</span> <span class="n">SMMU_TRANSLATION_ENABLE_1</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_2</span><span class="p">,</span> <span class="n">SMMU_TRANSLATION_ENABLE_2</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">asid_security</span><span class="p">,</span> <span class="n">SMMU_ASID_SECURITY</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_TLB_CONFIG_RESET_VAL</span><span class="p">,</span> <span class="n">SMMU_TLB_CONFIG</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_PTC_CONFIG_RESET_VAL</span><span class="p">,</span> <span class="n">SMMU_PTC_CONFIG</span><span class="p">);</span>

	<span class="n">smmu_flush_regs</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">ahb_read</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">AHB_XBAR_CTRL</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">AHB_XBAR_CTRL_SMMU_INIT_DONE_DONE</span> <span class="o">&lt;&lt;</span>
		<span class="n">AHB_XBAR_CTRL_SMMU_INIT_DONE_SHIFT</span><span class="p">;</span>
	<span class="n">ahb_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">AHB_XBAR_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_ptc_and_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_pde</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tlb_flush_va</span> <span class="o">=</span> <span class="n">is_pde</span>
		<span class="o">?</span>  <span class="n">SMMU_TLB_FLUSH_VA</span><span class="p">(</span><span class="n">iova</span><span class="p">,</span> <span class="n">SECTION</span><span class="p">)</span>
		<span class="o">:</span>  <span class="n">SMMU_TLB_FLUSH_VA</span><span class="p">(</span><span class="n">iova</span><span class="p">,</span> <span class="n">GROUP</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">SMMU_PTC_FLUSH_TYPE_ADR</span> <span class="o">|</span> <span class="n">VA_PAGE_TO_PA</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">SMMU_PTC_FLUSH</span><span class="p">);</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">tlb_flush_va</span> <span class="o">|</span>
		<span class="n">SMMU_TLB_FLUSH_ASID_MATCH__ENABLE</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span> <span class="o">&lt;&lt;</span> <span class="n">SMMU_TLB_FLUSH_ASID_SHIFT</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">SMMU_TLB_FLUSH</span><span class="p">);</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_ptbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdn</span> <span class="o">=</span> <span class="n">SMMU_ADDR_TO_PDN</span><span class="p">(</span><span class="n">iova</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdir</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_PDE_VACANT</span><span class="p">(</span><span class="n">pdn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pdn: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdn</span><span class="p">);</span>

		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">SMMU_EX_PTBL_PAGE</span><span class="p">(</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]));</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">SMMU_EX_PTBL_PAGE</span><span class="p">(</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]));</span>
		<span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_PDE_VACANT</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>
		<span class="n">FLUSH_CPU_DCACHE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">],</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]);</span>
		<span class="n">flush_ptc_and_tlb</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">],</span>
				  <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_pdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">iovmm_base</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_ptbl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">SMMU_PAGE_SIZE</span> <span class="o">*</span> <span class="n">SMMU_PTBL_COUNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">);</span>
	<span class="n">__free_page</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">);</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">devm_kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span><span class="p">);</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Maps PTBL for given iova and returns the PTE address</span>
<span class="cm"> * Caller must unmap the mapped PTBL returned in *ptbl_page_p</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">locate_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span>
				 <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="n">bool</span> <span class="n">allocate</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ptbl_page_p</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">**</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptn</span> <span class="o">=</span> <span class="n">SMMU_ADDR_TO_PFN</span><span class="p">(</span><span class="n">iova</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdn</span> <span class="o">=</span> <span class="n">SMMU_ADDR_TO_PDN</span><span class="p">(</span><span class="n">iova</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdir</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptbl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_PDE_VACANT</span><span class="p">(</span><span class="n">pdn</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Mapped entry table already exists */</span>
		<span class="o">*</span><span class="n">ptbl_page_p</span> <span class="o">=</span> <span class="n">SMMU_EX_PTBL_PAGE</span><span class="p">(</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]);</span>
		<span class="n">ptbl</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="o">*</span><span class="n">ptbl_page_p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allocate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pn</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">SMMU_PDN_TO_ADDR</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>

		<span class="cm">/* Vacant - allocate a new page table */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;New PTBL pdn: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdn</span><span class="p">);</span>

		<span class="o">*</span><span class="n">ptbl_page_p</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">ptbl_page_p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;failed to allocate smmu_device page table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">SetPageReserved</span><span class="p">(</span><span class="o">*</span><span class="n">ptbl_page_p</span><span class="p">);</span>
		<span class="n">ptbl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="o">*</span><span class="n">ptbl_page_p</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pn</span> <span class="o">&lt;</span> <span class="n">SMMU_PTBL_COUNT</span><span class="p">;</span>
		     <span class="n">pn</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">SMMU_PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptbl</span><span class="p">[</span><span class="n">pn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_PTE_VACANT</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">FLUSH_CPU_DCACHE</span><span class="p">(</span><span class="n">ptbl</span><span class="p">,</span> <span class="o">*</span><span class="n">ptbl_page_p</span><span class="p">,</span> <span class="n">SMMU_PTBL_SIZE</span><span class="p">);</span>
		<span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]</span> <span class="o">=</span> <span class="n">SMMU_MK_PDE</span><span class="p">(</span><span class="o">*</span><span class="n">ptbl_page_p</span><span class="p">,</span>
					<span class="n">as</span><span class="o">-&gt;</span><span class="n">pde_attr</span> <span class="o">|</span> <span class="n">_PDE_NEXT</span><span class="p">);</span>
		<span class="n">FLUSH_CPU_DCACHE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">],</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]);</span>
		<span class="n">flush_ptc_and_tlb</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">],</span>
				  <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span><span class="p">[</span><span class="n">pdn</span><span class="p">];</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ptbl</span><span class="p">[</span><span class="n">ptn</span> <span class="o">%</span> <span class="n">SMMU_PTBL_COUNT</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMMU_SIG_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_signature</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span>
			  <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">iova</span><span class="p">;</span>
	<span class="n">vaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">FLUSH_CPU_DCACHE</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_signature</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Caller must lock/unlock as</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_pdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pdn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">SMMU_PDIR_COUNT</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed to allocate smmu_device PTE cunters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed to allocate smmu_device page directory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">devm_kfree</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span><span class="p">);</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_count</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SetPageReserved</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">);</span>
	<span class="n">pdir</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pdn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pdn</span> <span class="o">&lt;</span> <span class="n">SMMU_PDIR_COUNT</span><span class="p">;</span> <span class="n">pdn</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pdir</span><span class="p">[</span><span class="n">pdn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_PDE_VACANT</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>
	<span class="n">FLUSH_CPU_DCACHE</span><span class="p">(</span><span class="n">pdir</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">,</span> <span class="n">SMMU_PDIR_SIZE</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">SMMU_PTC_FLUSH_TYPE_ADR</span> <span class="o">|</span> <span class="n">VA_PAGE_TO_PA</span><span class="p">(</span><span class="n">pdir</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">SMMU_PTC_FLUSH</span><span class="p">);</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">SMMU_TLB_FLUSH_VA_MATCH_ALL</span> <span class="o">|</span>
		<span class="n">SMMU_TLB_FLUSH_ASID_MATCH__ENABLE</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span> <span class="o">&lt;&lt;</span> <span class="n">SMMU_TLB_FLUSH_ASID_SHIFT</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">SMMU_TLB_FLUSH</span><span class="p">);</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__smmu_iommu_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">locate_pte</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">==</span> <span class="n">_PTE_VACANT</span><span class="p">(</span><span class="n">iova</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">_PTE_VACANT</span><span class="p">(</span><span class="n">iova</span><span class="p">);</span>
	<span class="n">FLUSH_CPU_DCACHE</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
	<span class="n">flush_ptc_and_tlb</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_ptbl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
		<span class="n">smmu_flush_regs</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__smmu_iommu_map_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">locate_pte</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">==</span> <span class="n">_PTE_VACANT</span><span class="p">(</span><span class="n">iova</span><span class="p">))</span>
		<span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">SMMU_PFN_TO_PTE</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">==</span> <span class="n">_PTE_VACANT</span><span class="p">(</span><span class="n">iova</span><span class="p">))))</span>
		<span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="n">FLUSH_CPU_DCACHE</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
	<span class="n">flush_ptc_and_tlb</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">put_signature</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smmu_iommu_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">,</span>
			  <span class="n">phys_addr_t</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">pa</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[%d] %08lx:%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__smmu_iommu_map_pfn</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">smmu_iommu_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[%d] %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__smmu_iommu_unmap</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SMMU_PAGE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">phys_addr_t</span> <span class="nf">smmu_iommu_iova_to_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">locate_pte</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">SMMU_PFN_MASK</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;iova:%08lx pfn:%08lx asid:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smmu_iommu_domain_has_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smmu_iommu_attach_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">client</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">as</span> <span class="o">=</span> <span class="n">as</span><span class="p">;</span>
	<span class="n">map</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">smmu_client_enable_hwgrp</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_hwgrp</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s is already attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_client</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reserve &quot;page zero&quot; for AVP vectors using a common dummy</span>
<span class="cm">	 * page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="n">HWG_AVPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">avp_vector_page</span><span class="p">;</span>
		<span class="n">__smmu_iommu_map_pfn</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Reserve </span><span class="se">\&quot;</span><span class="s">page zero</span><span class="se">\&quot;</span><span class="s"> for AVP vectors using a common dummy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s is attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_client:</span>
	<span class="n">smmu_client_disable_hwgrp</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client_lock</span><span class="p">);</span>
<span class="nl">err_hwgrp:</span>
	<span class="n">devm_kfree</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smmu_iommu_detach_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_client</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smmu_client_disable_hwgrp</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">devm_kfree</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">as</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s is detached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t find %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smmu_iommu_domain_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">smmu_handle</span><span class="p">;</span>

	<span class="cm">/* Look for a free AS with lock held */</span>
	<span class="k">for</span>  <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">num_as</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">as</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no free AS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_pdir</span><span class="p">(</span><span class="n">as</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_pdir</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Update PDIR register */</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_PTB_ASID_CUR</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">),</span> <span class="n">SMMU_PTB_ASID</span><span class="p">);</span>
	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span>
		   <span class="n">SMMU_MK_PDIR</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_attr</span><span class="p">),</span> <span class="n">SMMU_PTB_DATA</span><span class="p">);</span>
	<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">as</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;smmu_as@%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">as</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_alloc_pdir:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smmu_iommu_domain_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_PTB_ASID_CUR</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span><span class="p">),</span> <span class="n">SMMU_PTB_ASID</span><span class="p">);</span>
		<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_PTB_DATA_RESET_VAL</span><span class="p">,</span> <span class="n">SMMU_PTB_DATA</span><span class="p">);</span>
		<span class="n">FLUSH_SMMU_REGS</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">free_pdir</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smmu_client</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">smmu_iommu_detach_dev</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">domain</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;smmu_as@%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">as</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iommu_ops</span> <span class="n">smmu_iommu_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">domain_init</span>	<span class="o">=</span> <span class="n">smmu_iommu_domain_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">domain_destroy</span>	<span class="o">=</span> <span class="n">smmu_iommu_domain_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach_dev</span>	<span class="o">=</span> <span class="n">smmu_iommu_attach_dev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detach_dev</span>	<span class="o">=</span> <span class="n">smmu_iommu_detach_dev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span>		<span class="o">=</span> <span class="n">smmu_iommu_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap</span>		<span class="o">=</span> <span class="n">smmu_iommu_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iova_to_phys</span>	<span class="o">=</span> <span class="n">smmu_iommu_iova_to_phys</span><span class="p">,</span>
	<span class="p">.</span><span class="n">domain_has_cap</span>	<span class="o">=</span> <span class="n">smmu_iommu_domain_has_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pgsize_bitmap</span>	<span class="o">=</span> <span class="n">SMMU_IOMMU_PGSIZES</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_smmu_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_0</span> <span class="o">=</span> <span class="n">smmu_read</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_TRANSLATION_ENABLE_0</span><span class="p">);</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_1</span> <span class="o">=</span> <span class="n">smmu_read</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_TRANSLATION_ENABLE_1</span><span class="p">);</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_2</span> <span class="o">=</span> <span class="n">smmu_read</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_TRANSLATION_ENABLE_2</span><span class="p">);</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">asid_security</span> <span class="o">=</span> <span class="n">smmu_read</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_ASID_SECURITY</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_smmu_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">smmu_setup_regs</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_smmu_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="o">*</span><span class="n">regs2</span><span class="p">,</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smmu_handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">!=</span> <span class="n">SMMU_PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">regs2</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">window</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span> <span class="o">||</span> <span class="o">!</span><span class="n">regs2</span> <span class="o">||</span> <span class="o">!</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No SMMU resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smmu</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">smmu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smmu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to allocate smmu_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">num_as</span> <span class="o">=</span> <span class="n">SMMU_NUM_ASIDS</span><span class="p">;</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">iovmm_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SMMU_PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">devm_ioremap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span> <span class="o">=</span> <span class="n">devm_ioremap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">regs2</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					 <span class="n">resource_size</span><span class="p">(</span><span class="n">regs2</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">||</span> <span class="o">!</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to remap SMMU registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_0</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_1</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">translation_enable_2</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">asid_security</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">num_as</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to allocate smmu_as</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">num_as</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smmu_as</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">as</span><span class="o">-&gt;</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">smmu</span><span class="p">;</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">asid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">pdir_attr</span> <span class="o">=</span> <span class="n">_PDIR_ATTR</span><span class="p">;</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">pde_attr</span> <span class="o">=</span> <span class="n">_PDE_ATTR</span><span class="p">;</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">pte_attr</span> <span class="o">=</span> <span class="n">_PTE_ATTR</span><span class="p">;</span>

		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">smmu_setup_regs</span><span class="p">(</span><span class="n">smmu</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">smmu</span><span class="p">);</span>

	<span class="n">smmu</span><span class="o">-&gt;</span><span class="n">avp_vector_page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">avp_vector_page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">smmu_handle</span> <span class="o">=</span> <span class="n">smmu</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">avp_vector_page</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">avp_vector_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span>
		<span class="n">devm_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span><span class="p">)</span>
		<span class="n">devm_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span> <span class="o">&amp;&amp;</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">num_as</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdir_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdir_page</span><span class="p">);</span>
				<span class="n">__free_page</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdir_page</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">devm_kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">devm_kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tegra_smmu_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smmu_device</span> <span class="o">*</span><span class="n">smmu</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">smmu_write</span><span class="p">(</span><span class="n">smmu</span><span class="p">,</span> <span class="n">SMMU_CONFIG_DISABLE</span><span class="p">,</span> <span class="n">SMMU_CONFIG</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">num_as</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_pdir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">devm_kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">avp_vector_page</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">avp_vector_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span>
		<span class="n">devm_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span><span class="p">)</span>
		<span class="n">devm_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="o">-&gt;</span><span class="n">regs_ahbarb</span><span class="p">);</span>
	<span class="n">devm_kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smmu</span><span class="p">);</span>
	<span class="n">smmu_handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">tegra_smmu_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">tegra_smmu_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">tegra_smmu_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">tegra_smmu_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">tegra_smmu_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">tegra_smmu_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;tegra-smmu&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">tegra_smmu_pm_ops</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">tegra_smmu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_set_iommu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smmu_iommu_ops</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tegra_smmu_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">tegra_smmu_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tegra_smmu_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">tegra_smmu_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">tegra_smmu_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;IOMMU API for SMMU in Tegra30&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Hiroshi DOYU &lt;hdoyu@nvidia.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
