<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › atm › horizon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>horizon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  Madge Horizon ATM Adapter driver.</span>
<span class="cm">  Copyright (C) 1995-1999  Madge Networks Ltd.</span>
<span class="cm">  </span>
<span class="cm">  This program is free software; you can redistribute it and/or modify</span>
<span class="cm">  it under the terms of the GNU General Public License as published by</span>
<span class="cm">  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">  (at your option) any later version.</span>
<span class="cm">  </span>
<span class="cm">  This program is distributed in the hope that it will be useful,</span>
<span class="cm">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">  GNU General Public License for more details.</span>
<span class="cm">  </span>
<span class="cm">  You should have received a copy of the GNU General Public License</span>
<span class="cm">  along with this program; if not, write to the Free Software</span>
<span class="cm">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm">  </span>
<span class="cm">  The GNU GPL is contained in /usr/doc/copyright/GPL on a Debian</span>
<span class="cm">  system and in the file COPYING in the Linux kernel source.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  IMPORTANT NOTE: Madge Networks no longer makes the adapters</span>
<span class="cm">  supported by this driver and makes no commitment to maintain it.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/atm.h&gt;</span>
<span class="cp">#include &lt;linux/atmdev.h&gt;</span>
<span class="cp">#include &lt;linux/sonet.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/string.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;horizon.h&quot;</span>

<span class="cp">#define maintainer_string &quot;Giuliano Procida at Madge Networks &lt;gprocida@madge.com&gt;&quot;</span>
<span class="cp">#define description_string &quot;Madge ATM Horizon [Ultra] driver&quot;</span>
<span class="cp">#define version_string &quot;1.2.1&quot;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">show_version</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%s version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">description_string</span><span class="p">,</span> <span class="n">version_string</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  </span>
<span class="cm">  CREDITS</span>
<span class="cm">  </span>
<span class="cm">  Driver and documentation by:</span>
<span class="cm">  </span>
<span class="cm">  Chris Aston        Madge Networks</span>
<span class="cm">  Giuliano Procida   Madge Networks</span>
<span class="cm">  Simon Benham       Madge Networks</span>
<span class="cm">  Simon Johnson      Madge Networks</span>
<span class="cm">  Various Others     Madge Networks</span>
<span class="cm">  </span>
<span class="cm">  Some inspiration taken from other drivers by:</span>
<span class="cm">  </span>
<span class="cm">  Alexandru Cucos    UTBv</span>
<span class="cm">  Kari Mettinen      University of Helsinki</span>
<span class="cm">  Werner Almesberger EPFL LRC</span>
<span class="cm">  </span>
<span class="cm">  Theory of Operation</span>
<span class="cm">  </span>
<span class="cm">  I Hardware, detection, initialisation and shutdown.</span>
<span class="cm">  </span>
<span class="cm">  1. Supported Hardware</span>
<span class="cm">  </span>
<span class="cm">  This driver should handle all variants of the PCI Madge ATM adapters</span>
<span class="cm">  with the Horizon chipset. These are all PCI cards supporting PIO, BM</span>
<span class="cm">  DMA and a form of MMIO (registers only, not internal RAM).</span>
<span class="cm">  </span>
<span class="cm">  The driver is only known to work with SONET and UTP Horizon Ultra</span>
<span class="cm">  cards at 155Mb/s. However, code is in place to deal with both the</span>
<span class="cm">  original Horizon and 25Mb/s operation.</span>
<span class="cm">  </span>
<span class="cm">  There are two revisions of the Horizon ASIC: the original and the</span>
<span class="cm">  Ultra. Details of hardware bugs are in section III.</span>
<span class="cm">  </span>
<span class="cm">  The ASIC version can be distinguished by chip markings but is NOT</span>
<span class="cm">  indicated by the PCI revision (all adapters seem to have PCI rev 1).</span>
<span class="cm">  </span>
<span class="cm">  I believe that:</span>
<span class="cm">  </span>
<span class="cm">  Horizon       =&gt; Collage  25 PCI Adapter (UTP and STP)</span>
<span class="cm">  Horizon Ultra =&gt; Collage 155 PCI Client (UTP or SONET)</span>
<span class="cm">  Ambassador x  =&gt; Collage 155 PCI Server (completely different)</span>
<span class="cm">  </span>
<span class="cm">  Horizon (25Mb/s) is fitted with UTP and STP connectors. It seems to</span>
<span class="cm">  have a Madge B154 plus glue logic serializer. I have also found a</span>
<span class="cm">  really ancient version of this with slightly different glue. It</span>
<span class="cm">  comes with the revision 0 (140-025-01) ASIC.</span>
<span class="cm">  </span>
<span class="cm">  Horizon Ultra (155Mb/s) is fitted with either a Pulse Medialink</span>
<span class="cm">  output (UTP) or an HP HFBR 5205 output (SONET). It has either</span>
<span class="cm">  Madge&#39;s SAMBA framer or a SUNI-lite device (early versions). It</span>
<span class="cm">  comes with the revision 1 (140-027-01) ASIC.</span>
<span class="cm">  </span>
<span class="cm">  2. Detection</span>
<span class="cm">  </span>
<span class="cm">  All Horizon-based cards present with the same PCI Vendor and Device</span>
<span class="cm">  IDs. The standard Linux 2.2 PCI API is used to locate any cards and</span>
<span class="cm">  to enable bus-mastering (with appropriate latency).</span>
<span class="cm">  </span>
<span class="cm">  ATM_LAYER_STATUS in the control register distinguishes between the</span>
<span class="cm">  two possible physical layers (25 and 155). It is not clear whether</span>
<span class="cm">  the 155 cards can also operate at 25Mbps. We rely on the fact that a</span>
<span class="cm">  card operates at 155 if and only if it has the newer Horizon Ultra</span>
<span class="cm">  ASIC.</span>
<span class="cm">  </span>
<span class="cm">  For 155 cards the two possible framers are probed for and then set</span>
<span class="cm">  up for loop-timing.</span>
<span class="cm">  </span>
<span class="cm">  3. Initialisation</span>
<span class="cm">  </span>
<span class="cm">  The card is reset and then put into a known state. The physical</span>
<span class="cm">  layer is configured for normal operation at the appropriate speed;</span>
<span class="cm">  in the case of the 155 cards, the framer is initialised with</span>
<span class="cm">  line-based timing; the internal RAM is zeroed and the allocation of</span>
<span class="cm">  buffers for RX and TX is made; the Burnt In Address is read and</span>
<span class="cm">  copied to the ATM ESI; various policy settings for RX (VPI bits,</span>
<span class="cm">  unknown VCs, oam cells) are made. Ideally all policy items should be</span>
<span class="cm">  configurable at module load (if not actually on-demand), however,</span>
<span class="cm">  only the vpi vs vci bit allocation can be specified at insmod.</span>
<span class="cm">  </span>
<span class="cm">  4. Shutdown</span>
<span class="cm">  </span>
<span class="cm">  This is in response to module_cleaup. No VCs are in use and the card</span>
<span class="cm">  should be idle; it is reset.</span>
<span class="cm">  </span>
<span class="cm">  II Driver software (as it should be)</span>
<span class="cm">  </span>
<span class="cm">  0. Traffic Parameters</span>
<span class="cm">  </span>
<span class="cm">  The traffic classes (not an enumeration) are currently: ATM_NONE (no</span>
<span class="cm">  traffic), ATM_UBR, ATM_CBR, ATM_VBR and ATM_ABR, ATM_ANYCLASS</span>
<span class="cm">  (compatible with everything). Together with (perhaps only some of)</span>
<span class="cm">  the following items they make up the traffic specification.</span>
<span class="cm">  </span>
<span class="cm">  struct atm_trafprm {</span>
<span class="cm">    unsigned char traffic_class; traffic class (ATM_UBR, ...)</span>
<span class="cm">    int           max_pcr;       maximum PCR in cells per second</span>
<span class="cm">    int           pcr;           desired PCR in cells per second</span>
<span class="cm">    int           min_pcr;       minimum PCR in cells per second</span>
<span class="cm">    int           max_cdv;       maximum CDV in microseconds</span>
<span class="cm">    int           max_sdu;       maximum SDU in bytes</span>
<span class="cm">  };</span>
<span class="cm">  </span>
<span class="cm">  Note that these denote bandwidth available not bandwidth used; the</span>
<span class="cm">  possibilities according to ATMF are:</span>
<span class="cm">  </span>
<span class="cm">  Real Time (cdv and max CDT given)</span>
<span class="cm">  </span>
<span class="cm">  CBR(pcr)             pcr bandwidth always available</span>
<span class="cm">  rtVBR(pcr,scr,mbs)   scr bandwidth always available, up to pcr at mbs too</span>
<span class="cm">  </span>
<span class="cm">  Non Real Time</span>
<span class="cm">  </span>
<span class="cm">  nrtVBR(pcr,scr,mbs)  scr bandwidth always available, up to pcr at mbs too</span>
<span class="cm">  UBR()</span>
<span class="cm">  ABR(mcr,pcr)         mcr bandwidth always available, up to pcr (depending) too</span>
<span class="cm">  </span>
<span class="cm">  mbs is max burst size (bucket)</span>
<span class="cm">  pcr and scr have associated cdvt values</span>
<span class="cm">  mcr is like scr but has no cdtv</span>
<span class="cm">  cdtv may differ at each hop</span>
<span class="cm">  </span>
<span class="cm">  Some of the above items are qos items (as opposed to traffic</span>
<span class="cm">  parameters). We have nothing to do with qos. All except ABR can have</span>
<span class="cm">  their traffic parameters converted to GCRA parameters. The GCRA may</span>
<span class="cm">  be implemented as a (real-number) leaky bucket. The GCRA can be used</span>
<span class="cm">  in complicated ways by switches and in simpler ways by end-stations.</span>
<span class="cm">  It can be used both to filter incoming cells and shape out-going</span>
<span class="cm">  cells.</span>
<span class="cm">  </span>
<span class="cm">  ATM Linux actually supports:</span>
<span class="cm">  </span>
<span class="cm">  ATM_NONE() (no traffic in this direction)</span>
<span class="cm">  ATM_UBR(max_frame_size)</span>
<span class="cm">  ATM_CBR(max/min_pcr, max_cdv, max_frame_size)</span>
<span class="cm">  </span>
<span class="cm">  0 or ATM_MAX_PCR are used to indicate maximum available PCR</span>
<span class="cm">  </span>
<span class="cm">  A traffic specification consists of the AAL type and separate</span>
<span class="cm">  traffic specifications for either direction. In ATM Linux it is:</span>
<span class="cm">  </span>
<span class="cm">  struct atm_qos {</span>
<span class="cm">  struct atm_trafprm txtp;</span>
<span class="cm">  struct atm_trafprm rxtp;</span>
<span class="cm">  unsigned char aal;</span>
<span class="cm">  };</span>
<span class="cm">  </span>
<span class="cm">  AAL types are:</span>
<span class="cm">  </span>
<span class="cm">  ATM_NO_AAL    AAL not specified</span>
<span class="cm">  ATM_AAL0      &quot;raw&quot; ATM cells</span>
<span class="cm">  ATM_AAL1      AAL1 (CBR)</span>
<span class="cm">  ATM_AAL2      AAL2 (VBR)</span>
<span class="cm">  ATM_AAL34     AAL3/4 (data)</span>
<span class="cm">  ATM_AAL5      AAL5 (data)</span>
<span class="cm">  ATM_SAAL      signaling AAL</span>
<span class="cm">  </span>
<span class="cm">  The Horizon has support for AAL frame types: 0, 3/4 and 5. However,</span>
<span class="cm">  it does not implement AAL 3/4 SAR and it has a different notion of</span>
<span class="cm">  &quot;raw cell&quot; to ATM Linux&#39;s (48 bytes vs. 52 bytes) so neither are</span>
<span class="cm">  supported by this driver.</span>
<span class="cm">  </span>
<span class="cm">  The Horizon has limited support for ABR (including UBR), VBR and</span>
<span class="cm">  CBR. Each TX channel has a bucket (containing up to 31 cell units)</span>
<span class="cm">  and two timers (PCR and SCR) associated with it that can be used to</span>
<span class="cm">  govern cell emissions and host notification (in the case of ABR this</span>
<span class="cm">  is presumably so that RM cells may be emitted at appropriate times).</span>
<span class="cm">  The timers may either be disabled or may be set to any of 240 values</span>
<span class="cm">  (determined by the clock crystal, a fixed (?) per-device divider, a</span>
<span class="cm">  configurable divider and a configurable timer preload value).</span>
<span class="cm">  </span>
<span class="cm">  At the moment only UBR and CBR are supported by the driver. VBR will</span>
<span class="cm">  be supported as soon as ATM for Linux supports it. ABR support is</span>
<span class="cm">  very unlikely as RM cell handling is completely up to the driver.</span>
<span class="cm">  </span>
<span class="cm">  1. TX (TX channel setup and TX transfer)</span>
<span class="cm">  </span>
<span class="cm">  The TX half of the driver owns the TX Horizon registers. The TX</span>
<span class="cm">  component in the IRQ handler is the BM completion handler. This can</span>
<span class="cm">  only be entered when tx_busy is true (enforced by hardware). The</span>
<span class="cm">  other TX component can only be entered when tx_busy is false</span>
<span class="cm">  (enforced by driver). So TX is single-threaded.</span>
<span class="cm">  </span>
<span class="cm">  Apart from a minor optimisation to not re-select the last channel,</span>
<span class="cm">  the TX send component works as follows:</span>
<span class="cm">  </span>
<span class="cm">  Atomic test and set tx_busy until we succeed; we should implement</span>
<span class="cm">  some sort of timeout so that tx_busy will never be stuck at true.</span>
<span class="cm">  </span>
<span class="cm">  If no TX channel is set up for this VC we wait for an idle one (if</span>
<span class="cm">  necessary) and set it up.</span>
<span class="cm">  </span>
<span class="cm">  At this point we have a TX channel ready for use. We wait for enough</span>
<span class="cm">  buffers to become available then start a TX transmit (set the TX</span>
<span class="cm">  descriptor, schedule transfer, exit).</span>
<span class="cm">  </span>
<span class="cm">  The IRQ component handles TX completion (stats, free buffer, tx_busy</span>
<span class="cm">  unset, exit). We also re-schedule further transfers for the same</span>
<span class="cm">  frame if needed.</span>
<span class="cm">  </span>
<span class="cm">  TX setup in more detail:</span>
<span class="cm">  </span>
<span class="cm">  TX open is a nop, the relevant information is held in the hrz_vcc</span>
<span class="cm">  (vcc-&gt;dev_data) structure and is &quot;cached&quot; on the card.</span>
<span class="cm">  </span>
<span class="cm">  TX close gets the TX lock and clears the channel from the &quot;cache&quot;.</span>
<span class="cm">  </span>
<span class="cm">  2. RX (Data Available and RX transfer)</span>
<span class="cm">  </span>
<span class="cm">  The RX half of the driver owns the RX registers. There are two RX</span>
<span class="cm">  components in the IRQ handler: the data available handler deals with</span>
<span class="cm">  fresh data that has arrived on the card, the BM completion handler</span>
<span class="cm">  is very similar to the TX completion handler. The data available</span>
<span class="cm">  handler grabs the rx_lock and it is only released once the data has</span>
<span class="cm">  been discarded or completely transferred to the host. The BM</span>
<span class="cm">  completion handler only runs when the lock is held; the data</span>
<span class="cm">  available handler is locked out over the same period.</span>
<span class="cm">  </span>
<span class="cm">  Data available on the card triggers an interrupt. If the data is not</span>
<span class="cm">  suitable for our existing RX channels or we cannot allocate a buffer</span>
<span class="cm">  it is flushed. Otherwise an RX receive is scheduled. Multiple RX</span>
<span class="cm">  transfers may be scheduled for the same frame.</span>
<span class="cm">  </span>
<span class="cm">  RX setup in more detail:</span>
<span class="cm">  </span>
<span class="cm">  RX open...</span>
<span class="cm">  RX close...</span>
<span class="cm">  </span>
<span class="cm">  III Hardware Bugs</span>
<span class="cm">  </span>
<span class="cm">  0. Byte vs Word addressing of adapter RAM.</span>
<span class="cm">  </span>
<span class="cm">  A design feature; see the .h file (especially the memory map).</span>
<span class="cm">  </span>
<span class="cm">  1. Bus Master Data Transfers (original Horizon only, fixed in Ultra)</span>
<span class="cm">  </span>
<span class="cm">  The host must not start a transmit direction transfer at a</span>
<span class="cm">  non-four-byte boundary in host memory. Instead the host should</span>
<span class="cm">  perform a byte, or a two byte, or one byte followed by two byte</span>
<span class="cm">  transfer in order to start the rest of the transfer on a four byte</span>
<span class="cm">  boundary. RX is OK.</span>
<span class="cm">  </span>
<span class="cm">  Simultaneous transmit and receive direction bus master transfers are</span>
<span class="cm">  not allowed.</span>
<span class="cm">  </span>
<span class="cm">  The simplest solution to these two is to always do PIO (never DMA)</span>
<span class="cm">  in the TX direction on the original Horizon. More complicated</span>
<span class="cm">  solutions are likely to hurt my brain.</span>
<span class="cm">  </span>
<span class="cm">  2. Loss of buffer on close VC</span>
<span class="cm">  </span>
<span class="cm">  When a VC is being closed, the buffer associated with it is not</span>
<span class="cm">  returned to the pool. The host must store the reference to this</span>
<span class="cm">  buffer and when opening a new VC then give it to that new VC.</span>
<span class="cm">  </span>
<span class="cm">  The host intervention currently consists of stacking such a buffer</span>
<span class="cm">  pointer at VC close and checking the stack at VC open.</span>
<span class="cm">  </span>
<span class="cm">  3. Failure to close a VC</span>
<span class="cm">  </span>
<span class="cm">  If a VC is currently receiving a frame then closing the VC may fail</span>
<span class="cm">  and the frame continues to be received.</span>
<span class="cm">  </span>
<span class="cm">  The solution is to make sure any received frames are flushed when</span>
<span class="cm">  ready. This is currently done just before the solution to 2.</span>
<span class="cm">  </span>
<span class="cm">  4. PCI bus (original Horizon only, fixed in Ultra)</span>
<span class="cm">  </span>
<span class="cm">  Reading from the data port prior to initialisation will hang the PCI</span>
<span class="cm">  bus. Just don&#39;t do that then! We don&#39;t.</span>
<span class="cm">  </span>
<span class="cm">  IV To Do List</span>
<span class="cm">  </span>
<span class="cm">  . Timer code may be broken.</span>
<span class="cm">  </span>
<span class="cm">  . Allow users to specify buffer allocation split for TX and RX.</span>
<span class="cm">  </span>
<span class="cm">  . Deal once and for all with buggy VC close.</span>
<span class="cm">  </span>
<span class="cm">  . Handle interrupted and/or non-blocking operations.</span>
<span class="cm">  </span>
<span class="cm">  . Change some macros to functions and move from .h to .c.</span>
<span class="cm">  </span>
<span class="cm">  . Try to limit the number of TX frames each VC may have queued, in</span>
<span class="cm">    order to reduce the chances of TX buffer exhaustion.</span>
<span class="cm">  </span>
<span class="cm">  . Implement VBR (bucket and timers not understood) and ABR (need to</span>
<span class="cm">    do RM cells manually); also no Linux support for either.</span>
<span class="cm">  </span>
<span class="cm">  . Implement QoS changes on open VCs (involves extracting parts of VC open</span>
<span class="cm">    and close into separate functions and using them to make changes).</span>
<span class="cm">  </span>
<span class="cm">*/</span>

<span class="cm">/********** globals **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">do_housekeeping</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vpi_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_tx_size</span> <span class="o">=</span> <span class="mi">9000</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_rx_size</span> <span class="o">=</span> <span class="mi">9000</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pci_lat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/********** access functions **********/</span>

<span class="cm">/* Read / Write Horizon registers */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wr_regl</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">outl</span> <span class="p">(</span><span class="n">cpu_to_le32</span> <span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">rd_regl</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">le32_to_cpu</span> <span class="p">(</span><span class="n">inl</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wr_regw</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">outw</span> <span class="p">(</span><span class="n">cpu_to_le16</span> <span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">rd_regw</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">le16_to_cpu</span> <span class="p">(</span><span class="n">inw</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wrs_regb</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">outsb</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rds_regb</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">insb</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">reg</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Read / Write to a given address in Horizon buffer memory.</span>
<span class="cm">   Interrupts must be disabled between the address register and data</span>
<span class="cm">   port accesses as these must form an atomic operation. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wr_mem</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">HDW</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>wr<em>regl (dev, MEM</em>WR<em>ADDR</em>REG_OFF, (u32) addr);</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEM_WR_ADDR_REG_OFF</span><span class="p">,</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">HDW</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HDW</span><span class="p">));</span>
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEMORY_PORT_OFF</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">rd_mem</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">HDW</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>wr<em>regl (dev, MEM</em>RD<em>ADDR</em>REG_OFF, (u32) addr);</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEM_RD_ADDR_REG_OFF</span><span class="p">,</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">HDW</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HDW</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEMORY_PORT_OFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wr_framer</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEM_WR_ADDR_REG_OFF</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span> <span class="o">|</span> <span class="mh">0x80000000</span><span class="p">);</span>
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEMORY_PORT_OFF</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">rd_framer</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEM_RD_ADDR_REG_OFF</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span> <span class="o">|</span> <span class="mh">0x80000000</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEMORY_PORT_OFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********** specialised access functions **********/</span>

<span class="cm">/* RX */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">FLUSH_RX_CHANNEL</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CHANNEL_PORT_OFF</span><span class="p">,</span> <span class="n">FLUSH_CHANNEL</span> <span class="o">|</span> <span class="n">channel</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">WAIT_FLUSH_RX_COMPLETE</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CHANNEL_PORT_OFF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FLUSH_CHANNEL</span><span class="p">)</span>
    <span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">SELECT_RX_CHANNEL</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CHANNEL_PORT_OFF</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">WAIT_UPDATE_COMPLETE</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CHANNEL_PORT_OFF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RX_CHANNEL_UPDATE_IN_PROGRESS</span><span class="p">)</span>
    <span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* TX */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">SELECT_TX_CHANNEL</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tx_channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CHANNEL_PORT_OFF</span><span class="p">,</span> <span class="n">tx_channel</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update or query one configuration parameter of a particular channel. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_tx_channel_config</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">chan</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CHANNEL_CONFIG_COMMAND_OFF</span><span class="p">,</span>
	   <span class="n">chan</span> <span class="o">*</span> <span class="n">TX_CHANNEL_CONFIG_MULT</span> <span class="o">|</span> <span class="n">mode</span><span class="p">);</span>
    <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CHANNEL_CONFIG_DATA_OFF</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">query_tx_channel_config</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">chan</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CHANNEL_CONFIG_COMMAND_OFF</span><span class="p">,</span>
	   <span class="n">chan</span> <span class="o">*</span> <span class="n">TX_CHANNEL_CONFIG_MULT</span> <span class="o">|</span> <span class="n">mode</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CHANNEL_CONFIG_DATA_OFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********** dump functions **********/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_skb</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">prefix</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_HORIZON</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
  <span class="n">PRINTDB</span> <span class="p">(</span><span class="n">DBG_DATA</span><span class="p">,</span> <span class="s">&quot;%s(%u) &quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">vc</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">PRINTDM</span> <span class="p">(</span><span class="n">DBG_DATA</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">PRINTDE</span> <span class="p">(</span><span class="n">DBG_DATA</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">prefix</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">vc</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">skb</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_regs</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_HORIZON</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot;CONTROL 0: %#x&quot;</span><span class="p">,</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">));</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot;RX CONFIG: %#x&quot;</span><span class="p">,</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CONFIG_OFF</span><span class="p">));</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot;TX CONFIG: %#x&quot;</span><span class="p">,</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CONFIG_OFF</span><span class="p">));</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot;TX STATUS: %#x&quot;</span><span class="p">,</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_STATUS_OFF</span><span class="p">));</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot;IRQ ENBLE: %#x&quot;</span><span class="p">,</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">INT_ENABLE_REG_OFF</span><span class="p">));</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot;IRQ SORCE: %#x&quot;</span><span class="p">,</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">INT_SOURCE_REG_OFF</span><span class="p">));</span>
<span class="cp">#else</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dev</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_framer</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_HORIZON</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">PRINTDB</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot;framer registers:&quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">PRINTDM</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span> <span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="n">rd_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
  <span class="n">PRINTDE</span> <span class="p">(</span><span class="n">DBG_REGS</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dev</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** VPI/VCI &lt;-&gt; (RX) channel conversions **********/</span>

<span class="cm">/* RX channels are 10 bit integers, these fns are quite paranoid */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">channel_to_vpivci</span> <span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span> <span class="n">vpi</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">vci</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vci_bits</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">vpi_bits</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="n">RX_CHANNEL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">vci</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">~</span><span class="mi">0</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">vci_bits</span><span class="p">);</span>
    <span class="o">*</span><span class="n">vpi</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="n">vci_bits</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">channel</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vpivci_to_channel</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span> <span class="n">channel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">short</span> <span class="n">vpi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">vci</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vci_bits</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">vpi_bits</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">vpi</span> <span class="o">&amp;&amp;</span> <span class="n">vpi</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">vpi_bits</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">vci</span> <span class="o">&amp;&amp;</span> <span class="n">vci</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">vci_bits</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">vpi</span><span class="o">&lt;&lt;</span><span class="n">vci_bits</span> <span class="o">|</span> <span class="n">vci</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">channel</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** decode RX queue entries **********/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">rx_q_entry_to_length</span> <span class="p">(</span><span class="n">u32</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">RX_Q_ENTRY_LENGTH_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">rx_q_entry_to_rx_channel</span> <span class="p">(</span><span class="n">u32</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">RX_Q_ENTRY_CHANNEL_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RX_CHANNEL_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cell Transmit Rate Values</span>
<span class="cm"> *</span>
<span class="cm"> * the cell transmit rate (cells per sec) can be set to a variety of</span>
<span class="cm"> * different values by specifying two parameters: a timer preload from</span>
<span class="cm"> * 1 to 16 (stored as 0 to 15) and a clock divider (2 to the power of</span>
<span class="cm"> * an exponent from 0 to 14; the special value 15 disables the timer).</span>
<span class="cm"> *</span>
<span class="cm"> * cellrate = baserate / (preload * 2^divider)</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum cell rate that can be specified is therefore just the</span>
<span class="cm"> * base rate. Halving the preload is equivalent to adding 1 to the</span>
<span class="cm"> * divider and so values 1 to 8 of the preload are redundant except</span>
<span class="cm"> * in the case of a maximal divider (14).</span>
<span class="cm"> *</span>
<span class="cm"> * Given a desired cell rate, an algorithm to determine the preload</span>
<span class="cm"> * and divider is:</span>
<span class="cm"> * </span>
<span class="cm"> * a) x = baserate / cellrate, want p * 2^d = x (as far as possible)</span>
<span class="cm"> * b) if x &gt; 16 * 2^14 then set p = 16, d = 14 (min rate), done</span>
<span class="cm"> *    if x &lt;= 16 then set p = x, d = 0 (high rates), done</span>
<span class="cm"> * c) now have 16 &lt; x &lt;= 2^18, or 1 &lt; x/16 &lt;= 2^14 and we want to</span>
<span class="cm"> *    know n such that 2^(n-1) &lt; x/16 &lt;= 2^n, so slide a bit until</span>
<span class="cm"> *    we find the range (n will be between 1 and 14), set d = n</span>
<span class="cm"> * d) Also have 8 &lt; x/2^n &lt;= 16, so set p nearest x/2^n</span>
<span class="cm"> *</span>
<span class="cm"> * The algorithm used below is a minor variant of the above.</span>
<span class="cm"> *</span>
<span class="cm"> * The base rate is derived from the oscillator frequency (Hz) using a</span>
<span class="cm"> * fixed divider:</span>
<span class="cm"> *</span>
<span class="cm"> * baserate = freq / 32 in the case of some Unknown Card</span>
<span class="cm"> * baserate = freq / 8  in the case of the Horizon        25</span>
<span class="cm"> * baserate = freq / 8  in the case of the Horizon Ultra 155</span>
<span class="cm"> *</span>
<span class="cm"> * The Horizon cards have oscillators and base rates as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * Card               Oscillator  Base Rate</span>
<span class="cm"> * Unknown Card       33 MHz      1.03125 MHz (33 MHz = PCI freq)</span>
<span class="cm"> * Horizon        25  32 MHz      4       MHz</span>
<span class="cm"> * Horizon Ultra 155  40 MHz      5       MHz</span>
<span class="cm"> *</span>
<span class="cm"> * The following defines give the base rates in Hz. These were</span>
<span class="cm"> * previously a factor of 100 larger, no doubt someone was using</span>
<span class="cm"> * cps*100.</span>
<span class="cm"> */</span>

<span class="cp">#define BR_UKN 1031250l</span>
<span class="cp">#define BR_HRZ 4000000l</span>
<span class="cp">#define BR_ULT 5000000l</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>d is an exponent</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define CR_MIND 0</span>
<span class="cp">#define CR_MAXD 14</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>p ranges from 1 to a power of 2</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define CR_MAXPEXP 4</span>
 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_rate</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">c</span><span class="p">,</span> <span class="n">rounding</span> <span class="n">r</span><span class="p">,</span>
		      <span class="n">u16</span> <span class="o">*</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">actual</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>note: rounding the rate down means rounding 'p' up</p></td><td class="code"><div class="highlight"><pre>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">br</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">ultra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">?</span> <span class="n">BR_ULT</span> <span class="o">:</span> <span class="n">BR_HRZ</span><span class="p">;</span>
  
	<span class="n">u32</span> <span class="n">div</span> <span class="o">=</span> <span class="n">CR_MIND</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pre</span><span class="p">;</span>
  </pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>br<em>exp and br</em>man are used to avoid overflowing (c<em>maxp</em>2^d) in
the tests below. We could think harder about exact possibilities
of failure...</p></td><td class="code"><div class="highlight"><pre>  
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">br_man</span> <span class="o">=</span> <span class="n">br</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">br_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;make_rate b=%lu, c=%u, %s&quot;</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
		<span class="n">r</span> <span class="o">==</span> <span class="n">round_up</span> <span class="o">?</span> <span class="s">&quot;up&quot;</span> <span class="o">:</span> <span class="n">r</span> <span class="o">==</span> <span class="n">round_down</span> <span class="o">?</span> <span class="s">&quot;down&quot;</span> <span class="o">:</span> <span class="s">&quot;nearest&quot;</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>avoid div by zero</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;zero rate is not allowed!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
  
	<span class="k">while</span> <span class="p">(</span><span class="n">br_exp</span> <span class="o">&lt;</span> <span class="n">CR_MAXPEXP</span> <span class="o">+</span> <span class="n">CR_MIND</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">br_man</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">br_man</span> <span class="o">=</span> <span class="n">br_man</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">++</span><span class="n">br_exp</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>(br >>br<em>exp) &lt;<br</em>exp == br and
br<em>exp &lt;= CR</em>MAXPEXP+CR_MIND</p></td><td class="code"><div class="highlight"><pre>  
	<span class="k">if</span> <span class="p">(</span><span class="n">br_man</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CR_MAXPEXP</span><span class="o">+</span><span class="n">CR_MIND</span><span class="o">-</span><span class="n">br_exp</span><span class="p">)))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Equivalent to: B &lt;= (c &lt;&lt; (MAXPEXP+MIND))
take care of rounding</p></td><td class="code"><div class="highlight"><pre>		<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">round_down</span>:
				<span class="n">pre</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">div</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>but p must be non-zero</p></td><td class="code"><div class="highlight"><pre>				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">)</span>
					<span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">round_nearest</span>:
				<span class="n">pre</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">div</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>but p must be non-zero</p></td><td class="code"><div class="highlight"><pre>				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">)</span>
					<span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>	<span class="cm">/* round_up */</span>
				<span class="n">pre</span> <span class="o">=</span> <span class="n">br</span><span class="o">/</span><span class="p">(</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">div</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>but p must be non-zero</p></td><td class="code"><div class="highlight"><pre>				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;A: p=%u, d=%u&quot;</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">div</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">got_it</span><span class="p">;</span>
	<span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>at this point we have
d == MIND and (c &lt;&lt; (MAXPEXP+MIND)) &lt; B</p></td><td class="code"><div class="highlight"><pre>	<span class="k">while</span> <span class="p">(</span><span class="n">div</span> <span class="o">&lt;</span> <span class="n">CR_MAXD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">div</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">br_man</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CR_MAXPEXP</span><span class="o">+</span><span class="n">div</span><span class="o">-</span><span class="n">br_exp</span><span class="p">)))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>Equivalent to: B &lt;= (c &lt;&lt; (MAXPEXP+d))
c &lt;&lt; (MAXPEXP+d-1) &lt; B &lt;= c &lt;&lt; (MAXPEXP+d)
1 &lt;&lt; (MAXPEXP-1) &lt; B/2^d/c &lt;= 1 &lt;&lt; MAXPEXP
MAXP/2 &lt; B/c2^d &lt;= MAXP
take care of rounding</p></td><td class="code"><div class="highlight"><pre>			<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">round_down</span>:
					<span class="n">pre</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">div</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">round_nearest</span>:
					<span class="n">pre</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">div</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span> <span class="cm">/* round_up */</span>
					<span class="n">pre</span> <span class="o">=</span> <span class="n">br</span><span class="o">/</span><span class="p">(</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">div</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;B: p=%u, d=%u&quot;</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">div</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">got_it</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>at this point we have
d == MAXD and (c &lt;&lt; (MAXPEXP+MAXD)) &lt; B
but we cannot go any higher
take care of rounding</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">round_down</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CR_MAXPEXP</span><span class="p">;</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;C: p=%u, d=%u&quot;</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">div</span><span class="p">);</span>
<span class="nl">got_it:</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>paranoia</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">div</span> <span class="o">&gt;</span> <span class="n">CR_MAXD</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">)</span> <span class="o">||</span> <span class="n">pre</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">CR_MAXPEXP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;set_cr internal failure: d=%u p=%u&quot;</span><span class="p">,</span>
			<span class="n">div</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span><span class="p">)</span>
			<span class="o">*</span><span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">div</span><span class="o">&lt;&lt;</span><span class="n">CLOCK_SELECT_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">pre</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">actual</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">actual</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">pre</span><span class="o">&lt;&lt;</span><span class="n">div</span><span class="p">);</span>
			<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;actual rate: %u&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">actual</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_rate_with_tolerance</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">c</span><span class="p">,</span> <span class="n">rounding</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tol</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="o">*</span> <span class="n">bit_pattern</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">actual</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">my_actual</span><span class="p">;</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;make_rate_with_tolerance c=%u, %s, tol=%u&quot;</span><span class="p">,</span>
	  <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">round_up</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;up&quot;</span> <span class="o">:</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">round_down</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;down&quot;</span> <span class="o">:</span> <span class="s">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">actual</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>actual rate is not returned</p></td><td class="code"><div class="highlight"><pre>    <span class="n">actual</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_actual</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">make_rate</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">round_nearest</span><span class="p">,</span> <span class="n">bit_pattern</span><span class="p">,</span> <span class="n">actual</span><span class="p">))</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>should never happen as round_nearest always succeeds</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">tol</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">actual</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">actual</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>within tolerance</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>intolerant, try rounding instead</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="n">make_rate</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">bit_pattern</span><span class="p">,</span> <span class="n">actual</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********** Listen on a VC **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrz_open_rx</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>is there any guarantee that we don't get two simulataneous
identical calls of this function from different processes? yes
rate_lock</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">u32</span> <span class="n">channel_type</span><span class="p">;</span> <span class="c1">// u16?</span>
  
  <span class="n">u16</span> <span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">RX_CHANNEL_IDLE</span><span class="p">;</span>
  
  <span class="n">rx_ch_desc</span> <span class="o">*</span> <span class="n">rx_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">rx_descs</span><span class="p">[</span><span class="n">channel</span><span class="p">];</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;hrz_open_rx %x&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
  
  <span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  <span class="n">channel_type</span> <span class="o">=</span> <span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BUFFER_PTR_MASK</span><span class="p">;</span>
  <span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>very serious error, should never occur</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">channel_type</span> <span class="o">!=</span> <span class="n">RX_CHANNEL_DISABLED</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_ERR</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;RX channel for VC already open&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span> <span class="c1">// clean up?</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Give back spare buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">noof_spare_buffers</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">spare_buffers</span><span class="p">[</span><span class="o">--</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">noof_spare_buffers</span><span class="p">];</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;using a spare buffer: %u&quot;</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>should never occur</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">buf_ptr</span> <span class="o">==</span> <span class="n">RX_CHANNEL_DISABLED</span> <span class="o">||</span> <span class="n">buf_ptr</span> <span class="o">==</span> <span class="n">RX_CHANNEL_IDLE</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>but easy to recover from</p></td><td class="code"><div class="highlight"><pre>      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_ERR</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;bad spare buffer pointer, using IDLE&quot;</span><span class="p">);</span>
      <span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">RX_CHANNEL_IDLE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;using IDLE buffer pointer&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>Channel is currently disabled so change its status to idle</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>do we really need to save the flags again?</p></td><td class="code"><div class="highlight"><pre>  <span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  
  <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">,</span>
	  <span class="n">buf_ptr</span> <span class="o">|</span> <span class="n">CHANNEL_TYPE_AAL5</span> <span class="o">|</span> <span class="n">FIRST_CELL_OF_AAL5_FRAME</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buf_ptr</span> <span class="o">!=</span> <span class="n">RX_CHANNEL_IDLE</span><span class="p">)</span>
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">rd_buf_type</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="p">);</span>
  
  <span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>rxer->rate = make<em>rate (qos->peak</em>cells);</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;hrz_open_rx ok&quot;</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/********** change vc rate for a given vc **********/</span>

<span class="c">static void hrz_change_vc_qos (ATM_RXER * rxer, MAAL_QOS * qos) {</span>
<span class="c">  rxer-&gt;rate = make_rate (qos-&gt;peak_cells);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/********** free an skb (as per ATM device driver documentation) **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrz_kfree_skb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">pop</span> <span class="p">(</span><span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">dev_kfree_skb_any</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/********** cancel listen on a VC **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrz_close_rx</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vc</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  
  <span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
  
  <span class="n">u32</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">;</span>
  
  <span class="n">rx_ch_desc</span> <span class="o">*</span> <span class="n">rx_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">rx_descs</span><span class="p">[</span><span class="n">vc</span><span class="p">];</span>
  
  <span class="kt">int</span> <span class="n">was_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BUFFER_PTR_MASK</span><span class="p">;</span>
  <span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">RX_CHANNEL_DISABLED</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>I suppose this could happen once we deal with _NONE traffic properly</p></td><td class="code"><div class="highlight"><pre>    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;closing VC: RX channel %u already disabled&quot;</span><span class="p">,</span> <span class="n">vc</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">RX_CHANNEL_IDLE</span><span class="p">)</span>
    <span class="n">was_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  
  <span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">,</span> <span class="n">RX_CHANNEL_DISABLED</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BUFFER_PTR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">RX_CHANNEL_DISABLED</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    
    <span class="n">was_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">was_idle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">WAIT_FLUSH_RX_COMPLETE</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>XXX Is this all really necessary? We can rely on the rx<em>data</em>av
handler to discard frames that remain queued for delivery. If the
worry is that immediately reopening the channel (perhaps by a
different process) may cause some data to be mis-delivered then
there may still be a simpler solution (such as busy-waiting on
rx<em>busy once the channel is disabled or before a new one is
opened - does this leave any holes?). Arguably setting up and
tearing down the TX and RX halves of each virtual circuit could
most safely be done within ?x</em>busy protected regions.</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>OK, current changes are that Simon's marker is disabled and we DO
look for NULL rxer elsewhere. The code here seems flush frames
and then remember the last dead cell belonging to the channel
just disabled - the cell gets relinked at the next vc_open.
However, when all VCs are closed or only a few opened there are a
handful of buffers that are unusable.</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Does anyone feel like documenting spare_buffers properly?
Does anyone feel like fixing this in a nicer way?</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>Flush any data which is left in the channel</p></td><td class="code"><div class="highlight"><pre>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>Change the rx channel port to something different to the RX
channel we are trying to close to force Horizon to flush the rx
channel read and write pointers.</p></td><td class="code"><div class="highlight"><pre>    
    <span class="n">u16</span> <span class="n">other</span> <span class="o">=</span> <span class="n">vc</span><span class="o">^</span><span class="p">(</span><span class="n">RX_CHANS</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    
    <span class="n">SELECT_RX_CHANNEL</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
    <span class="n">WAIT_UPDATE_COMPLETE</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    
    <span class="n">r1</span> <span class="o">=</span> <span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">rd_buf_type</span><span class="p">);</span>
    </pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>Select this RX channel. Flush doesn't seem to work unless we
select an RX channel before hand</p></td><td class="code"><div class="highlight"><pre>    
    <span class="n">SELECT_RX_CHANNEL</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vc</span><span class="p">);</span>
    <span class="n">WAIT_UPDATE_COMPLETE</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    </pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>Attempt to flush a frame on this RX channel</p></td><td class="code"><div class="highlight"><pre>    
    <span class="n">FLUSH_RX_CHANNEL</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vc</span><span class="p">);</span>
    <span class="n">WAIT_FLUSH_RX_COMPLETE</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    </pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>Force Horizon to flush rx channel read and write pointers as before</p></td><td class="code"><div class="highlight"><pre>    
    <span class="n">SELECT_RX_CHANNEL</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
    <span class="n">WAIT_UPDATE_COMPLETE</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    
    <span class="n">r2</span> <span class="o">=</span> <span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">rd_buf_type</span><span class="p">);</span>
    
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_VCC</span><span class="o">|</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;r1 = %u, r2 = %u&quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">spare_buffers</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">noof_spare_buffers</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">r1</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  {</span>
<span class="c">    rx_q_entry * wr_ptr = &amp;memmap-&gt;rx_q_entries[rd_regw (dev, RX_QUEUE_WR_PTR_OFF)];</span>
<span class="c">    rx_q_entry * rd_ptr = dev-&gt;rx_q_entry;</span>
<span class="c">    </span>
<span class="c">    PRINTD (DBG_VCC|DBG_RX, &quot;rd_ptr = %u, wr_ptr = %u&quot;, rd_ptr, wr_ptr);</span>
<span class="c">    </span>
<span class="c">    while (rd_ptr != wr_ptr) {</span>
<span class="c">      u32 x = rd_mem (dev, (HDW *) rd_ptr);</span>
<span class="c">      </span>
<span class="c">      if (vc == rx_q_entry_to_rx_channel (x)) {</span>
<span class="c">	x |= SIMONS_DODGEY_MARKER;</span>
<span class="c">	</span>
<span class="c">	PRINTD (DBG_RX|DBG_VCC|DBG_WARN, &quot;marking a frame as dodgey&quot;);</span>
<span class="c">	</span>
<span class="c">	wr_mem (dev, (HDW *) rd_ptr, x);</span>
<span class="c">      }</span>
<span class="c">      </span>
<span class="c">      if (rd_ptr == dev-&gt;rx_q_wrap)</span>
<span class="c">	rd_ptr = dev-&gt;rx_q_reset;</span>
<span class="c">      else</span>
<span class="c">	rd_ptr++;</span>
<span class="c">    }</span>
<span class="c">  }</span>
<span class="cp">#endif</span>
  
  <span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** schedule RX transfers **********/</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>Note on tail recursion: a GCC developer said that it is not likely
to be fixed soon, so do not define TAILRECUSRIONWORKS unless you
are sure it does as you may otherwise overflow the kernel stack.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>giving this fn a return value would help GCC, allegedly</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_schedule</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_bytes</span><span class="p">;</span>
  
  <span class="kt">int</span> <span class="n">pio_instead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifndef TAILRECURSIONWORKS</span>
  <span class="n">pio_instead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">pio_instead</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>bytes waiting for RX transfer</p></td><td class="code"><div class="highlight"><pre>    <span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_bytes</span><span class="p">;</span>
    
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    spin_count = 0;</span>
<span class="c">    while (rd_regl (dev, MASTER_RX_COUNT_REG_OFF)) {</span>
<span class="c">      PRINTD (DBG_RX|DBG_WARN, &quot;RX error: other PCI Bus Master RX still in progress!&quot;);</span>
<span class="c">      if (++spin_count &gt; 10) {</span>
<span class="c">	PRINTD (DBG_RX|DBG_ERR, &quot;spun out waiting PCI Bus Master RX completion&quot;);</span>
<span class="c">	wr_regl (dev, MASTER_RX_COUNT_REG_OFF, 0);</span>
<span class="c">	clear_bit (rx_busy, &amp;dev-&gt;flags);</span>
<span class="c">	hrz_kfree_skb (dev-&gt;rx_skb);</span>
<span class="c">	return;</span>
<span class="c">      }</span>
<span class="c">    }</span>
<span class="cp">#endif</span>
    </pre></div></td></tr>


<tr id="section-42"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-42">&#182;</a></div><p>this code follows the TX code but (at the moment) there is only
one region - the skb itself. I don't know if this will change,
but it doesn't hurt to have the code here, disabled.</p></td><td class="code"><div class="highlight"><pre>    
    <span class="k">if</span> <span class="p">(</span><span class="n">rx_bytes</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-43"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-43">&#182;</a></div><p>start next transfer within same region</p></td><td class="code"><div class="highlight"><pre>      <span class="k">if</span> <span class="p">(</span><span class="n">rx_bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_PIO_COUNT</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(pio)&quot;</span><span class="p">);</span>
	<span class="n">pio_instead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rx_bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(simple or last multi)&quot;</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(continuing multi)&quot;</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">rx_bytes</span> <span class="o">-</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">;</span>
	<span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-44"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-44">&#182;</a></div><p>rx_bytes == 0 -- we're between regions
regions remaining to transfer</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if 0</span><span class="c"></span>
<span class="c">      unsigned int rx_regions = dev-&gt;rx_regions;</span>
<span class="cp">#else</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_regions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="n">rx_regions</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span></pre></div></td></tr>


<tr id="section-45"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-45">&#182;</a></div><p>start a new region</p></td><td class="code"><div class="highlight"><pre><span class="c">	dev-&gt;rx_addr = dev-&gt;rx_iovec-&gt;iov_base;</span>
<span class="c">	rx_bytes = dev-&gt;rx_iovec-&gt;iov_len;</span>
<span class="c">	++dev-&gt;rx_iovec;</span>
<span class="c">	dev-&gt;rx_regions = rx_regions - 1;</span>
<span class="c">	</span>
<span class="c">	if (rx_bytes &lt;= MAX_PIO_COUNT) {</span>
<span class="c">	  PRINTD (DBG_RX|DBG_BUS, &quot;(pio)&quot;);</span>
<span class="c">	  pio_instead = 1;</span>
<span class="c">	}</span>
<span class="c">	if (rx_bytes &lt;= MAX_TRANSFER_COUNT) {</span>
<span class="c">	  PRINTD (DBG_RX|DBG_BUS, &quot;(full region)&quot;);</span>
<span class="c">	  dev-&gt;rx_bytes = 0;</span>
<span class="c">	} else {</span>
<span class="c">	  PRINTD (DBG_RX|DBG_BUS, &quot;(start multi region)&quot;);</span>
<span class="c">	  dev-&gt;rx_bytes = rx_bytes - MAX_TRANSFER_COUNT;</span>
<span class="c">	  rx_bytes = MAX_TRANSFER_COUNT;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-46"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-46">&#182;</a></div><p>rx_regions == 0
that's all folks - end of frame</p></td><td class="code"><div class="highlight"><pre>	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_skb</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-47"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-47">&#182;</a></div><p>dev->rx_iovec = 0;</p></td><td class="code"><div class="highlight"><pre>	
	<span class="n">FLUSH_RX_CHANNEL</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">);</span>
	
	<span class="n">dump_skb</span> <span class="p">(</span><span class="s">&quot;&lt;&lt;&lt;&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="o">|</span><span class="n">DBG_SKB</span><span class="p">,</span> <span class="s">&quot;push %p %u&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	
	<span class="p">{</span>
	  <span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span> <span class="n">vcc</span> <span class="o">=</span> <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-48"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-48">&#182;</a></div><p>VC layer stats</p></td><td class="code"><div class="highlight"><pre>	  <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>
	  <span class="n">__net_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-49"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-49">&#182;</a></div><p>end of our responsibility</p></td><td class="code"><div class="highlight"><pre>	  <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push</span> <span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    </pre></div></td></tr>


<tr id="section-50"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-50">&#182;</a></div><p>note: writing RX_COUNT clears any interrupt condition</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">rx_bytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pio_instead</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span>
	  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_RX_COUNT_REG_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rds_regb</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DATA_PORT_OFF</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_addr</span><span class="p">,</span> <span class="n">rx_bytes</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_RX_ADDR_REG_OFF</span><span class="p">,</span> <span class="n">virt_to_bus</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_addr</span><span class="p">));</span>
	<span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_RX_COUNT_REG_OFF</span><span class="p">,</span> <span class="n">rx_bytes</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_addr</span> <span class="o">+=</span> <span class="n">rx_bytes</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span>
	<span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_RX_COUNT_REG_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-51"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-51">&#182;</a></div><p>allow another RX thread to start</p></td><td class="code"><div class="highlight"><pre>      <span class="n">YELLOW_LED_ON</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
      <span class="n">clear_bit</span> <span class="p">(</span><span class="n">rx_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;cleared rx_busy for dev %p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
    <span class="p">}</span>
    
<span class="cp">#ifdef TAILRECURSIONWORKS</span></pre></div></td></tr>


<tr id="section-52"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-52">&#182;</a></div><p>and we all bless optimised tail calls</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">pio_instead</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">rx_schedule</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="cp">#else</span></pre></div></td></tr>


<tr id="section-53"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-53">&#182;</a></div><p>grrrrrrr!</p></td><td class="code"><div class="highlight"><pre>    <span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/********** handle RX bus master complete events **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_bus_master_complete_handler</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">rx_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">rx_schedule</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;unexpected RX bus master completion&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-54"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-54">&#182;</a></div><p>clear interrupt condition on adapter</p></td><td class="code"><div class="highlight"><pre>    <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_RX_COUNT_REG_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** (queue to) become the next TX thread **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tx_hold</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;sleeping at tx lock %p %lu&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
  <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">tx_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)));</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;woken at tx lock %p %lu&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span> <span class="p">(</span><span class="n">current</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;set tx_busy for dev %p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** allow another TX thread to start **********/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tx_release</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">clear_bit</span> <span class="p">(</span><span class="n">tx_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;cleared tx_busy for dev %p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
  <span class="n">wake_up_interruptible</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********** schedule TX transfers **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tx_schedule</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="k">const</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_bytes</span><span class="p">;</span>
  
  <span class="kt">int</span> <span class="n">append_desc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="kt">int</span> <span class="n">pio_instead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifndef TAILRECURSIONWORKS</span>
  <span class="n">pio_instead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">pio_instead</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif</span></pre></div></td></tr>


<tr id="section-55"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-55">&#182;</a></div><p>bytes in current region waiting for TX transfer</p></td><td class="code"><div class="highlight"><pre>    <span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span><span class="p">;</span>
    
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    spin_count = 0;</span>
<span class="c">    while (rd_regl (dev, MASTER_TX_COUNT_REG_OFF)) {</span>
<span class="c">      PRINTD (DBG_TX|DBG_WARN, &quot;TX error: other PCI Bus Master TX still in progress!&quot;);</span>
<span class="c">      if (++spin_count &gt; 10) {</span>
<span class="c">	PRINTD (DBG_TX|DBG_ERR, &quot;spun out waiting PCI Bus Master TX completion&quot;);</span>
<span class="c">	wr_regl (dev, MASTER_TX_COUNT_REG_OFF, 0);</span>
<span class="c">	tx_release (dev);</span>
<span class="c">	hrz_kfree_skb (dev-&gt;tx_skb);</span>
<span class="c">	return;</span>
<span class="c">      }</span>
<span class="c">    }</span>
<span class="cp">#endif</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">tx_bytes</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-56"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-56">&#182;</a></div><p>start next transfer within same region</p></td><td class="code"><div class="highlight"><pre>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">ultra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span> <span class="n">tx_bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_PIO_COUNT</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(pio)&quot;</span><span class="p">);</span>
	<span class="n">pio_instead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tx_bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(simple or last multi)&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-57"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-57">&#182;</a></div><p>end of last region</p></td><td class="code"><div class="highlight"><pre>	  <span class="n">append_desc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(continuing multi)&quot;</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">tx_bytes</span> <span class="o">-</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">;</span>
	<span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-58"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-58">&#182;</a></div><p>tx_bytes == 0 -- we're between regions
regions remaining to transfer</p></td><td class="code"><div class="highlight"><pre>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_regions</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_regions</span><span class="p">;</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="n">tx_regions</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-59"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-59">&#182;</a></div><p>start a new region</p></td><td class="code"><div class="highlight"><pre>	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_addr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="o">++</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_regions</span> <span class="o">=</span> <span class="n">tx_regions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">ultra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span> <span class="n">tx_bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_PIO_COUNT</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(pio)&quot;</span><span class="p">);</span>
	  <span class="n">pio_instead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(full region)&quot;</span><span class="p">);</span>
	  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;(start multi region)&quot;</span><span class="p">);</span>
	  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">tx_bytes</span> <span class="o">-</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">;</span>
	  <span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">MAX_TRANSFER_COUNT</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-60"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-60">&#182;</a></div><p>tx_regions == 0
that's all folks - end of frame</p></td><td class="code"><div class="highlight"><pre>	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	</pre></div></td></tr>


<tr id="section-61"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-61">&#182;</a></div><p>VC layer stats</p></td><td class="code"><div class="highlight"><pre>	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span>
	</pre></div></td></tr>


<tr id="section-62"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-62">&#182;</a></div><p>free the skb</p></td><td class="code"><div class="highlight"><pre>	<span class="n">hrz_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    </pre></div></td></tr>


<tr id="section-63"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-63">&#182;</a></div><p>note: writing TX_COUNT clears any interrupt condition</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">tx_bytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pio_instead</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span>
	  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_TX_COUNT_REG_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wrs_regb</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DATA_PORT_OFF</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_addr</span><span class="p">,</span> <span class="n">tx_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">append_desc</span><span class="p">)</span>
	  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_DESCRIPTOR_PORT_OFF</span><span class="p">,</span> <span class="n">cpu_to_be32</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_TX_ADDR_REG_OFF</span><span class="p">,</span> <span class="n">virt_to_bus</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_addr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">append_desc</span><span class="p">)</span>
	  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_DESCRIPTOR_REG_OFF</span><span class="p">,</span> <span class="n">cpu_to_be32</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
	<span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_TX_COUNT_REG_OFF</span><span class="p">,</span>
		 <span class="n">append_desc</span>
		 <span class="o">?</span> <span class="n">tx_bytes</span> <span class="o">|</span> <span class="n">MASTER_TX_AUTO_APPEND_DESC</span>
		 <span class="o">:</span> <span class="n">tx_bytes</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_addr</span> <span class="o">+=</span> <span class="n">tx_bytes</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">)</span>
	<span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_TX_COUNT_REG_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">YELLOW_LED_ON</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
      <span class="n">tx_release</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    <span class="p">}</span>
    
<span class="cp">#ifdef TAILRECURSIONWORKS</span></pre></div></td></tr>


<tr id="section-64"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-64">&#182;</a></div><p>and we all bless optimised tail calls</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">pio_instead</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tx_schedule</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="cp">#else</span></pre></div></td></tr>


<tr id="section-65"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-65">&#182;</a></div><p>grrrrrrr!</p></td><td class="code"><div class="highlight"><pre>    <span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/********** handle TX bus master complete events **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tx_bus_master_complete_handler</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">tx_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">tx_schedule</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;unexpected TX bus master completion&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-66"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-66">&#182;</a></div><p>clear interrupt condition on adapter</p></td><td class="code"><div class="highlight"><pre>    <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MASTER_TX_COUNT_REG_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** move RX Q pointer to next item in circular buffer **********/</span></pre></div></td></tr>


<tr id="section-67"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-67">&#182;</a></div><p>called only from IRQ sub-handler</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">u32</span> <span class="nf">rx_queue_entry_next</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">u32</span> <span class="n">rx_queue_entry</span><span class="p">;</span>
  <span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
  <span class="n">rx_queue_entry</span> <span class="o">=</span> <span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_entry</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_wrap</span><span class="p">)</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_entry</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_reset</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_entry</span><span class="o">++</span><span class="p">;</span>
  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_QUEUE_RD_PTR_OFF</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_entry</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_reset</span><span class="p">);</span>
  <span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">rx_queue_entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** handle RX disabled by device **********/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rx_disabled_handler</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CONFIG_OFF</span><span class="p">,</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CONFIG_OFF</span><span class="p">)</span> <span class="o">|</span> <span class="n">RX_ENABLE</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-68"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-68">&#182;</a></div><p>count me please</p></td><td class="code"><div class="highlight"><pre>  <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="s">&quot;RX was disabled!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********** handle RX data received by device **********/</span></pre></div></td></tr>


<tr id="section-69"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-69">&#182;</a></div><p>called from IRQ handler</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">rx_data_av_handler</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">u32</span> <span class="n">rx_queue_entry</span><span class="p">;</span>
  <span class="n">u32</span> <span class="n">rx_queue_entry_flags</span><span class="p">;</span>
  <span class="n">u16</span> <span class="n">rx_len</span><span class="p">;</span>
  <span class="n">u16</span> <span class="n">rx_channel</span><span class="p">;</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;hrz_data_av_handler&quot;</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-70"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-70">&#182;</a></div><p>try to grab rx lock (not possible during RX bus mastering)</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span> <span class="p">(</span><span class="n">rx_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;locked out of rx lock&quot;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;set rx_busy for dev %p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-71"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-71">&#182;</a></div><p>lock is cleared if we fail now, o/w after bus master completion</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">YELLOW_LED_OFF</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  
  <span class="n">rx_queue_entry</span> <span class="o">=</span> <span class="n">rx_queue_entry_next</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  
  <span class="n">rx_len</span> <span class="o">=</span> <span class="n">rx_q_entry_to_length</span> <span class="p">(</span><span class="n">rx_queue_entry</span><span class="p">);</span>
  <span class="n">rx_channel</span> <span class="o">=</span> <span class="n">rx_q_entry_to_rx_channel</span> <span class="p">(</span><span class="n">rx_queue_entry</span><span class="p">);</span>
  
  <span class="n">WAIT_FLUSH_RX_COMPLETE</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  
  <span class="n">SELECT_RX_CHANNEL</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_channel</span><span class="p">);</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;rx_queue_entry is: %#x&quot;</span><span class="p">,</span> <span class="n">rx_queue_entry</span><span class="p">);</span>
  <span class="n">rx_queue_entry_flags</span> <span class="o">=</span> <span class="n">rx_queue_entry</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RX_CRC_32_OK</span><span class="o">|</span><span class="n">RX_COMPLETE_FRAME</span><span class="o">|</span><span class="n">SIMONS_DODGEY_MARKER</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_len</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-72"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-72">&#182;</a></div><p>(at least) bus-mastering breaks if we try to handle a
zero-length frame, besides AAL5 does not support them</p></td><td class="code"><div class="highlight"><pre>    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;zero-length frame!&quot;</span><span class="p">);</span>
    <span class="n">rx_queue_entry_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RX_COMPLETE_FRAME</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">rx_queue_entry_flags</span> <span class="o">&amp;</span> <span class="n">SIMONS_DODGEY_MARKER</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;Simon&#39;s marker detected!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rx_queue_entry_flags</span> <span class="o">==</span> <span class="p">(</span><span class="n">RX_CRC_32_OK</span> <span class="o">|</span> <span class="n">RX_COMPLETE_FRAME</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span> <span class="n">atm_vcc</span><span class="p">;</span>
    
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;got a frame on rx_channel %x len %u&quot;</span><span class="p">,</span> <span class="n">rx_channel</span><span class="p">,</span> <span class="n">rx_len</span><span class="p">);</span>
    
    <span class="n">atm_vcc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxer</span><span class="p">[</span><span class="n">rx_channel</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-73"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-73">&#182;</a></div><p>if no vcc is assigned to this channel, we should drop the frame
(is this what SIMONS etc. was trying to achieve?)</p></td><td class="code"><div class="highlight"><pre>    
    <span class="k">if</span> <span class="p">(</span><span class="n">atm_vcc</span><span class="p">)</span> <span class="p">{</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">rxtp</span><span class="p">.</span><span class="n">traffic_class</span> <span class="o">!=</span> <span class="n">ATM_NONE</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_len</span> <span class="o">&lt;=</span> <span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">rxtp</span><span class="p">.</span><span class="n">max_sdu</span><span class="p">)</span> <span class="p">{</span>
	    
	  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span> <span class="o">=</span> <span class="n">atm_alloc_charge</span> <span class="p">(</span><span class="n">atm_vcc</span><span class="p">,</span> <span class="n">rx_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-74"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-74">&#182;</a></div><p>remember this so we can push it later</p></td><td class="code"><div class="highlight"><pre>	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-75"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-75">&#182;</a></div><p>remember this so we can flush it later</p></td><td class="code"><div class="highlight"><pre>	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_channel</span> <span class="o">=</span> <span class="n">rx_channel</span><span class="p">;</span>
	    </pre></div></td></tr>


<tr id="section-76"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-76">&#182;</a></div><p>prepare socket buffer</p></td><td class="code"><div class="highlight"><pre>	    <span class="n">skb_put</span> <span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rx_len</span><span class="p">);</span>
	    <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">atm_vcc</span><span class="p">;</span>
	    </pre></div></td></tr>


<tr id="section-77"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-77">&#182;</a></div><p>simple transfer
dev->rx<em>regions = 0;
dev->rx</em>iovec = 0;</p></td><td class="code"><div class="highlight"><pre>	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">rx_len</span><span class="p">;</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_addr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;RX start simple transfer (addr %p, len %d)&quot;</span><span class="p">,</span>
		    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rx_len</span><span class="p">);</span>
	    </pre></div></td></tr>


<tr id="section-78"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-78">&#182;</a></div><p>do the business</p></td><td class="code"><div class="highlight"><pre>	    <span class="n">rx_schedule</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	    <span class="k">return</span><span class="p">;</span>
	    
	  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_SKB</span><span class="o">|</span><span class="n">DBG_WARN</span><span class="p">,</span> <span class="s">&quot;failed to get skb&quot;</span><span class="p">);</span>
	  <span class="p">}</span>
	  
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	  <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;frame received on TX-only VC %x&quot;</span><span class="p">,</span> <span class="n">rx_channel</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-79"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-79">&#182;</a></div><p>do we count this?</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span>
	
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="s">&quot;dropped over-size frame&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-80"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-80">&#182;</a></div><p>do we count this?</p></td><td class="code"><div class="highlight"><pre>      <span class="p">}</span>
      
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_WARN</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="o">|</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;no VCC for this frame (VC closed)&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-81"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-81">&#182;</a></div><p>do we count this?</p></td><td class="code"><div class="highlight"><pre>    <span class="p">}</span>
    
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-82"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-82">&#182;</a></div><p>Wait update complete ? SPONG</p></td><td class="code"><div class="highlight"><pre>  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-83"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-83">&#182;</a></div><p>RX was aborted</p></td><td class="code"><div class="highlight"><pre>  <span class="n">YELLOW_LED_ON</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  
  <span class="n">FLUSH_RX_CHANNEL</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="n">rx_channel</span><span class="p">);</span>
  <span class="n">clear_bit</span> <span class="p">(</span><span class="n">rx_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
  
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** interrupt handler **********/</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">interrupt_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">hrz_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
  <span class="n">u32</span> <span class="n">int_source</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_ok</span><span class="p">;</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;interrupt_handler: %p&quot;</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-84"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-84">&#182;</a></div><p>definitely for us</p></td><td class="code"><div class="highlight"><pre>  <span class="n">irq_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">int_source</span> <span class="o">=</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">INT_SOURCE_REG_OFF</span><span class="p">)</span>
	  <span class="o">&amp;</span> <span class="n">INTERESTING_INTERRUPTS</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-85"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-85">&#182;</a></div><p>In the interests of fairness, the handlers below are
called in sequence and without immediate return to the head of
the while loop. This is only of issue for slow hosts (or when
debugging messages are on). Really slow hosts may find a fast
sender keeps them permanently in the IRQ handler. :(</p></td><td class="code"><div class="highlight"><pre>    </pre></div></td></tr>


<tr id="section-86"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-86">&#182;</a></div><p>(only an issue for slow hosts) RX completion goes before
rx<em>data</em>av as the former implies rx<em>busy and so the latter
would just abort. If it reschedules another transfer
(continuing the same frame) then it will not clear rx</em>busy.</p></td><td class="code"><div class="highlight"><pre>    </pre></div></td></tr>


<tr id="section-87"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-87">&#182;</a></div><p>(only an issue for slow hosts) TX completion goes before RX
data available as it is a much shorter routine - there is the
chance that any further transfers it schedules will be complete
by the time of the return to the head of the while loop</p></td><td class="code"><div class="highlight"><pre>    
    <span class="k">if</span> <span class="p">(</span><span class="n">int_source</span> <span class="o">&amp;</span> <span class="n">RX_BUS_MASTER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">irq_ok</span><span class="p">;</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_IRQ</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="o">|</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;rx_bus_master_complete asserted&quot;</span><span class="p">);</span>
      <span class="n">rx_bus_master_complete_handler</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">int_source</span> <span class="o">&amp;</span> <span class="n">TX_BUS_MASTER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">irq_ok</span><span class="p">;</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_IRQ</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="o">|</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;tx_bus_master_complete asserted&quot;</span><span class="p">);</span>
      <span class="n">tx_bus_master_complete_handler</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">int_source</span> <span class="o">&amp;</span> <span class="n">RX_DATA_AV</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">irq_ok</span><span class="p">;</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_IRQ</span><span class="o">|</span><span class="n">DBG_RX</span><span class="p">,</span> <span class="s">&quot;rx_data_av asserted&quot;</span><span class="p">);</span>
      <span class="n">rx_data_av_handler</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">irq_ok</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_IRQ</span><span class="p">,</span> <span class="s">&quot;work done: %u&quot;</span><span class="p">,</span> <span class="n">irq_ok</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_IRQ</span><span class="o">|</span><span class="n">DBG_WARN</span><span class="p">,</span> <span class="s">&quot;spurious interrupt source: %#x&quot;</span><span class="p">,</span> <span class="n">int_source</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_IRQ</span><span class="o">|</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;interrupt_handler done: %p&quot;</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">irq_ok</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** housekeeping **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_housekeeping</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-88"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-88">&#182;</a></div><p>just stats at the moment</p></td><td class="code"><div class="highlight"><pre>  <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-89"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-89">&#182;</a></div><p>collect device-specific (not driver/atm-linux) stats here</p></td><td class="code"><div class="highlight"><pre>  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_cell_count</span> <span class="o">+=</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CELL_COUNT_OFF</span><span class="p">);</span>
  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_cell_count</span> <span class="o">+=</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CELL_COUNT_OFF</span><span class="p">);</span>
  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hec_error_count</span> <span class="o">+=</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HEC_ERROR_COUNT_OFF</span><span class="p">);</span>
  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">unassigned_cell_count</span> <span class="o">+=</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">UNASSIGNED_CELL_COUNT_OFF</span><span class="p">);</span>

  <span class="n">mod_timer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">housekeeping</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** find an idle channel for TX and set it up **********/</span></pre></div></td></tr>


<tr id="section-90"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-90">&#182;</a></div><p>called with tx_busy set</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">short</span> <span class="nf">setup_idle_tx_channel</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">hrz_vcc</span> <span class="o">*</span> <span class="n">vcc</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">idle_channels</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">tx_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spin_count</span><span class="p">;</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="o">|</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;setup_idle_tx_channel %p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-91"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-91">&#182;</a></div><p>better would be to fail immediately, the caller can then decide whether
to wait or drop (depending on whether this is UBR etc.)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">spin_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">idle_channels</span> <span class="o">=</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_STATUS_OFF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDLE_CHANNELS_MASK</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_WARN</span><span class="p">,</span> <span class="s">&quot;waiting for idle TX channel&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-92"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-92">&#182;</a></div><p>delay a bit here</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">spin_count</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;spun out waiting for idle TX channel&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-93"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-93">&#182;</a></div><p>got an idle channel</p></td><td class="code"><div class="highlight"><pre>  <span class="p">{</span></pre></div></td></tr>


<tr id="section-94"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-94">&#182;</a></div><p>tx_idle ensures we look for idle channels in RR order</p></td><td class="code"><div class="highlight"><pre>    <span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_idle</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">keep_going</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">keep_going</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">idle_channels</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">chan</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">tx_channel</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">keep_going</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="o">++</span><span class="n">chan</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">==</span> <span class="n">TX_CHANS</span><span class="p">)</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_idle</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-95"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-95">&#182;</a></div><p>set up the channel we found</p></td><td class="code"><div class="highlight"><pre>  <span class="p">{</span></pre></div></td></tr>


<tr id="section-96"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-96">&#182;</a></div><p>Initialise the cell header in the transmit channel descriptor
a.k.a. prepare the channel and remember that we have done so.</p></td><td class="code"><div class="highlight"><pre>    
    <span class="n">tx_ch_desc</span> <span class="o">*</span> <span class="n">tx_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">tx_descs</span><span class="p">[</span><span class="n">tx_channel</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">rd_ptr</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">wr_ptr</span><span class="p">;</span>
    <span class="n">u16</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
    
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">spin_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    </pre></div></td></tr>


<tr id="section-97"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-97">&#182;</a></div><p>Update the transmit channel record.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_channel_record</span><span class="p">[</span><span class="n">tx_channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
    </pre></div></td></tr>


<tr id="section-98"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-98">&#182;</a></div><p>xBR channel</p></td><td class="code"><div class="highlight"><pre>    <span class="n">update_tx_channel_config</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_channel</span><span class="p">,</span> <span class="n">RATE_TYPE_ACCESS</span><span class="p">,</span>
			      <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">tx_xbr_bits</span><span class="p">);</span>
    </pre></div></td></tr>


<tr id="section-99"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-99">&#182;</a></div><p>Update the PCR counter preload value etc.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">update_tx_channel_config</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_channel</span><span class="p">,</span> <span class="n">PCR_TIMER_ACCESS</span><span class="p">,</span>
			      <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">tx_pcr_bits</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    if (vcc-&gt;tx_xbr_bits == VBR_RATE_TYPE) {</span></pre></div></td></tr>


<tr id="section-100"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-100">&#182;</a></div><p>SCR timer</p></td><td class="code"><div class="highlight"><pre><span class="c">      update_tx_channel_config (dev, tx_channel, SCR_TIMER_ACCESS,</span>
<span class="c">				vcc-&gt;tx_scr_bits);</span>
<span class="c">      </span></pre></div></td></tr>


<tr id="section-101"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-101">&#182;</a></div><p>Bucket size...</p></td><td class="code"><div class="highlight"><pre><span class="c">      update_tx_channel_config (dev, tx_channel, BUCKET_CAPACITY_ACCESS,</span>
<span class="c">				vcc-&gt;tx_bucket_bits);</span>
<span class="c">      </span></pre></div></td></tr>


<tr id="section-102"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-102">&#182;</a></div><p>... and fullness</p></td><td class="code"><div class="highlight"><pre><span class="c">      update_tx_channel_config (dev, tx_channel, BUCKET_FULLNESS_ACCESS,</span>
<span class="c">				vcc-&gt;tx_bucket_bits);</span>
<span class="c">    }</span>
<span class="cp">#endif</span></pre></div></td></tr>


<tr id="section-103"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-103">&#182;</a></div><p>Initialise the read and write buffer pointers</p></td><td class="code"><div class="highlight"><pre>    <span class="n">rd_ptr</span> <span class="o">=</span> <span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">rd_buf_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BUFFER_PTR_MASK</span><span class="p">;</span>
    <span class="n">wr_ptr</span> <span class="o">=</span> <span class="n">rd_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BUFFER_PTR_MASK</span><span class="p">;</span>
    </pre></div></td></tr>


<tr id="section-104"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-104">&#182;</a></div><p>idle TX channels should have identical pointers</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">rd_ptr</span> <span class="o">!=</span> <span class="n">wr_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;TX buffer pointers are broken!&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-105"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-105">&#182;</a></div><p>spin_unlock... return -E...
I wonder if gcc would get rid of one of the pointer aliases</p></td><td class="code"><div class="highlight"><pre>    <span class="p">}</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;TX buffer pointers are: rd %x, wr %x.&quot;</span><span class="p">,</span>
	    <span class="n">rd_ptr</span><span class="p">,</span> <span class="n">wr_ptr</span><span class="p">);</span>
    
    <span class="k">switch</span> <span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">aal</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">aal0</span>:
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;tx_channel: aal0&quot;</span><span class="p">);</span>
	<span class="n">rd_ptr</span> <span class="o">|=</span> <span class="n">CHANNEL_TYPE_RAW_CELLS</span><span class="p">;</span>
	<span class="n">wr_ptr</span> <span class="o">|=</span> <span class="n">CHANNEL_TYPE_RAW_CELLS</span><span class="p">;</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">aal34</span>:
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;tx_channel: aal34&quot;</span><span class="p">);</span>
	<span class="n">rd_ptr</span> <span class="o">|=</span> <span class="n">CHANNEL_TYPE_AAL3_4</span><span class="p">;</span>
	<span class="n">wr_ptr</span> <span class="o">|=</span> <span class="n">CHANNEL_TYPE_AAL3_4</span><span class="p">;</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">aal5</span>:
	<span class="n">rd_ptr</span> <span class="o">|=</span> <span class="n">CHANNEL_TYPE_AAL5</span><span class="p">;</span>
	<span class="n">wr_ptr</span> <span class="o">|=</span> <span class="n">CHANNEL_TYPE_AAL5</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-106"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-106">&#182;</a></div><p>Initialise the CRC</p></td><td class="code"><div class="highlight"><pre>	<span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">partial_crc</span><span class="p">,</span> <span class="n">INITIAL_CRC</span><span class="p">);</span>
	<span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">rd_buf_type</span><span class="p">,</span> <span class="n">rd_ptr</span><span class="p">);</span>
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">,</span> <span class="n">wr_ptr</span><span class="p">);</span>
    </pre></div></td></tr>


<tr id="section-107"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-107">&#182;</a></div><p>Write the Cell Header
Payload Type, CLP and GFC would go here if non-zero</p></td><td class="code"><div class="highlight"><pre>    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">cell_header</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
    
    <span class="n">spin_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="n">tx_channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** send a frame **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrz_send</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span> <span class="n">atm_vcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spin_count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">free_buffers</span><span class="p">;</span>
  <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">HRZ_DEV</span><span class="p">(</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
  <span class="n">hrz_vcc</span> <span class="o">*</span> <span class="n">vcc</span> <span class="o">=</span> <span class="n">HRZ_VCC</span><span class="p">(</span><span class="n">atm_vcc</span><span class="p">);</span>
  <span class="n">u16</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
  
  <span class="n">u32</span> <span class="n">buffers_required</span><span class="p">;</span>
  
  <span class="cm">/* signed for error return */</span>
  <span class="kt">short</span> <span class="n">tx_channel</span><span class="p">;</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="o">|</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;hrz_send vc %x data %p len %u&quot;</span><span class="p">,</span>
	  <span class="n">channel</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
  
  <span class="n">dump_skb</span> <span class="p">(</span><span class="s">&quot;&gt;&gt;&gt;&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">txtp</span><span class="p">.</span><span class="n">traffic_class</span> <span class="o">==</span> <span class="n">ATM_NONE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;attempt to send on RX-only VC %x&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
    <span class="n">hrz_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-108"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-108">&#182;</a></div><p>don't understand this</p></td><td class="code"><div class="highlight"><pre>  <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">atm_vcc</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">txtp</span><span class="p">.</span><span class="n">max_sdu</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;sk_buff length greater than agreed max_sdu, dropping...&quot;</span><span class="p">);</span>
    <span class="n">hrz_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_ERR</span><span class="o">|</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;attempt to transmit on zero (rx_)channel&quot;</span><span class="p">);</span>
    <span class="n">hrz_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
  <span class="p">}</span>
  
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  {</span></pre></div></td></tr>


<tr id="section-109"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-109">&#182;</a></div><p>where would be a better place for this? housekeeping?</p></td><td class="code"><div class="highlight"><pre><span class="c">    u16 status;</span>
<span class="c">    pci_read_config_word (dev-&gt;pci_dev, PCI_STATUS, &amp;status);</span>
<span class="c">    if (status &amp; PCI_STATUS_REC_MASTER_ABORT) {</span>
<span class="c">      PRINTD (DBG_BUS|DBG_ERR, &quot;Clearing PCI Master Abort (and cleaning up)&quot;);</span>
<span class="c">      status &amp;= ~PCI_STATUS_REC_MASTER_ABORT;</span>
<span class="c">      pci_write_config_word (dev-&gt;pci_dev, PCI_STATUS, status);</span>
<span class="c">      if (test_bit (tx_busy, &amp;dev-&gt;flags)) {</span>
<span class="c">	hrz_kfree_skb (dev-&gt;tx_skb);</span>
<span class="c">	tx_release (dev);</span>
<span class="c">      }</span>
<span class="c">    }</span>
<span class="c">  }</span>
<span class="cp">#endif</span>
  
<span class="cp">#ifdef DEBUG_HORIZON</span>
  <span class="cm">/* wey-hey! */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="mi">1023</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">==</span> <span class="sc">&#39;D&#39;</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">++</span><span class="p">);</span>
      <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;debug bitmap is now %hx&quot;</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="cp">#endif</span>
  </pre></div></td></tr>


<tr id="section-110"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-110">&#182;</a></div><p>wait until TX is free and grab lock</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">tx_hold</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">hrz_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
  <span class="p">}</span>
 </pre></div></td></tr>


<tr id="section-111"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-111">&#182;</a></div><p>Wait for enough space to be available in transmit buffer memory.</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-112"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-112">&#182;</a></div><p>should be number of cells needed + 2 (according to hardware docs)
= ((framelen+8)+47) / 48 + 2
= (framelen+7) / 48 + 3, hmm... faster to put addition inside XXX</p></td><td class="code"><div class="highlight"><pre>  <span class="n">buffers_required</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">+</span><span class="p">(</span><span class="n">ATM_AAL5_TRAILER</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">ATM_CELL_PAYLOAD</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
  </pre></div></td></tr>


<tr id="section-113"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-113">&#182;</a></div><p>replace with timer and sleep, add dev->tx<em>buffers</em>queue (max 1 entry)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">spin_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">free_buffers</span> <span class="o">=</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_FREE_BUFFER_COUNT_OFF</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">buffers_required</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;waiting for free TX buffers, got %d of %d&quot;</span><span class="p">,</span>
	    <span class="n">free_buffers</span><span class="p">,</span> <span class="n">buffers_required</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-114"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-114">&#182;</a></div><p>what is the appropriate delay? implement a timeout? (depending on line speed?)
mdelay (1);
what happens if we kill (current_pid, SIGKILL) ?</p></td><td class="code"><div class="highlight"><pre>    <span class="n">schedule</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">spin_count</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;spun out waiting for tx buffers, got %d of %d&quot;</span><span class="p">,</span>
	      <span class="n">free_buffers</span><span class="p">,</span> <span class="n">buffers_required</span><span class="p">);</span>
      <span class="n">tx_release</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
      <span class="n">hrz_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-115"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-115">&#182;</a></div><p>Select a channel to transmit the frame on.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;last vc hack: hit&quot;</span><span class="p">);</span>
    <span class="n">tx_channel</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_last</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;last vc hack: miss&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-116"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-116">&#182;</a></div><p>Are we currently transmitting this VC on one of the channels?</p></td><td class="code"><div class="highlight"><pre>    <span class="k">for</span> <span class="p">(</span><span class="n">tx_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tx_channel</span> <span class="o">&lt;</span> <span class="n">TX_CHANS</span><span class="p">;</span> <span class="o">++</span><span class="n">tx_channel</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_channel_record</span><span class="p">[</span><span class="n">tx_channel</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;vc already on channel: hit&quot;</span><span class="p">);</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tx_channel</span> <span class="o">==</span> <span class="n">TX_CHANS</span><span class="p">)</span> <span class="p">{</span> 
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;vc already on channel: miss&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-117"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-117">&#182;</a></div><p>Find and set up an idle channel.</p></td><td class="code"><div class="highlight"><pre>      <span class="n">tx_channel</span> <span class="o">=</span> <span class="n">setup_idle_tx_channel</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tx_channel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;failed to get channel&quot;</span><span class="p">);</span>
	<span class="n">tx_release</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tx_channel</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;got channel&quot;</span><span class="p">);</span>
    <span class="n">SELECT_TX_CHANNEL</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_channel</span><span class="p">);</span>
    
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vc</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_last</span> <span class="o">=</span> <span class="n">tx_channel</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="p">,</span> <span class="s">&quot;using channel %u&quot;</span><span class="p">,</span> <span class="n">tx_channel</span><span class="p">);</span>
  
  <span class="n">YELLOW_LED_OFF</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-118"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-118">&#182;</a></div><p>TX start transfer</p></td><td class="code"><div class="highlight"><pre>  
  <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_iovcnt</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-119"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-119">&#182;</a></div><p>remember this so we can free it later</p></td><td class="code"><div class="highlight"><pre>    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">tx_iovcnt</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-120"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-120">&#182;</a></div><p>scatter gather transfer</p></td><td class="code"><div class="highlight"><pre>      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_regions</span> <span class="o">=</span> <span class="n">tx_iovcnt</span><span class="p">;</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>		<span class="cm">/* @@@ needs rewritten */</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;TX start scatter-gather transfer (iovec %p, len %d)&quot;</span><span class="p">,</span>
	      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">tx_len</span><span class="p">);</span>
      <span class="n">tx_release</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
      <span class="n">hrz_kfree_skb</span> <span class="p">(</span><span class="n">skb</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-121"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-121">&#182;</a></div><p>simple transfer</p></td><td class="code"><div class="highlight"><pre>      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_regions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">tx_len</span><span class="p">;</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_addr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_TX</span><span class="o">|</span><span class="n">DBG_BUS</span><span class="p">,</span> <span class="s">&quot;TX start simple transfer (addr %p, len %d)&quot;</span><span class="p">,</span>
	      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">tx_len</span><span class="p">);</span>
    <span class="p">}</span>
    </pre></div></td></tr>


<tr id="section-122"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-122">&#182;</a></div><p>and do the business</p></td><td class="code"><div class="highlight"><pre>    <span class="n">tx_schedule</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** reset a card **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrz_reset</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">u32</span> <span class="n">control_0_reg</span> <span class="o">=</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-123"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-123">&#182;</a></div><p>why not set RESET_HORIZON to one and wait for the card to
reassert that bit as zero? Like so:</p></td><td class="code"><div class="highlight"><pre>  <span class="n">control_0_reg</span> <span class="o">=</span> <span class="n">control_0_reg</span> <span class="o">&amp;</span> <span class="n">RESET_HORIZON</span><span class="p">;</span>
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">,</span> <span class="n">control_0_reg</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">control_0_reg</span> <span class="o">&amp;</span> <span class="n">RESET_HORIZON</span><span class="p">)</span>
    <span class="n">control_0_reg</span> <span class="o">=</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-124"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-124">&#182;</a></div><p>old reset code retained:</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">,</span> <span class="n">control_0_reg</span> <span class="o">|</span>
	   <span class="n">RESET_ATM</span> <span class="o">|</span> <span class="n">RESET_RX</span> <span class="o">|</span> <span class="n">RESET_TX</span> <span class="o">|</span> <span class="n">RESET_HOST</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-125"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-125">&#182;</a></div><p>just guessing here</p></td><td class="code"><div class="highlight"><pre>  <span class="n">udelay</span> <span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">,</span> <span class="n">control_0_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********** read the burnt in address **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">WRITE_IT_WAIT</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">udelay</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
  
<span class="k">static</span> <span class="kt">void</span> <span class="nf">CLOCK_IT</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-126"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-126">&#182;</a></div><p>DI must be valid around rising SK edge</p></td><td class="code"><div class="highlight"><pre>	<span class="n">WRITE_IT_WAIT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SEEPROM_SK</span><span class="p">);</span>
	<span class="n">WRITE_IT_WAIT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">|</span> <span class="n">SEEPROM_SK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">__devinit</span> <span class="nf">read_bia</span> <span class="p">(</span><span class="k">const</span> <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">u32</span> <span class="n">ctrl</span> <span class="o">=</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">);</span>
  
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr_bits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
  
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  
  <span class="n">u16</span> <span class="n">res</span><span class="p">;</span>
  
  <span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SEEPROM_CS</span> <span class="o">|</span> <span class="n">SEEPROM_SK</span> <span class="o">|</span> <span class="n">SEEPROM_DI</span><span class="p">);</span>
  <span class="n">WRITE_IT_WAIT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-127"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-127">&#182;</a></div><p>wake Serial EEPROM and send 110 (READ) command</p></td><td class="code"><div class="highlight"><pre>  <span class="n">ctrl</span> <span class="o">|=</span>  <span class="p">(</span><span class="n">SEEPROM_CS</span> <span class="o">|</span> <span class="n">SEEPROM_DI</span><span class="p">);</span>
  <span class="n">CLOCK_IT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
  
  <span class="n">ctrl</span> <span class="o">|=</span> <span class="n">SEEPROM_DI</span><span class="p">;</span>
  <span class="n">CLOCK_IT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
  
  <span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SEEPROM_DI</span><span class="p">;</span>
  <span class="n">CLOCK_IT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">addr_bits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">addr_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
      <span class="n">ctrl</span> <span class="o">|=</span> <span class="n">SEEPROM_DI</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SEEPROM_DI</span><span class="p">;</span>
    
    <span class="n">CLOCK_IT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
    
    <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-128"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-128">&#182;</a></div><p>we could check that we have DO = 0 here</p></td><td class="code"><div class="highlight"><pre>  <span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SEEPROM_DI</span><span class="p">;</span>
  
  <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data_bits</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="n">CLOCK_IT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SEEPROM_DO</span><span class="p">)</span>
      <span class="n">res</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">data_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
  
  <span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SEEPROM_SK</span> <span class="o">|</span> <span class="n">SEEPROM_CS</span><span class="p">);</span>
  <span class="n">WRITE_IT_WAIT</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** initialise a card **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hrz_init</span> <span class="p">(</span><span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">onefivefive</span><span class="p">;</span>
  
  <span class="n">u16</span> <span class="n">chan</span><span class="p">;</span>
  
  <span class="kt">int</span> <span class="n">buff_count</span><span class="p">;</span>
  
  <span class="n">HDW</span> <span class="o">*</span> <span class="n">mem</span><span class="p">;</span>
  
  <span class="n">cell_buf</span> <span class="o">*</span> <span class="n">tx_desc</span><span class="p">;</span>
  <span class="n">cell_buf</span> <span class="o">*</span> <span class="n">rx_desc</span><span class="p">;</span>
  
  <span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
  
  <span class="n">ctrl</span> <span class="o">=</span> <span class="n">rd_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">);</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_INFO</span><span class="p">,</span> <span class="s">&quot;ctrl0reg is %#x&quot;</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
  <span class="n">onefivefive</span> <span class="o">=</span> <span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">ATM_LAYER_STATUS</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">onefivefive</span><span class="p">)</span>
    <span class="n">printk</span> <span class="p">(</span><span class="n">DEV_LABEL</span> <span class="s">&quot;: Horizon Ultra (at 155.52 MBps)&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printk</span> <span class="p">(</span><span class="n">DEV_LABEL</span> <span class="s">&quot;: Horizon (at 25 MBps)&quot;</span><span class="p">);</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-129"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-129">&#182;</a></div><p>Reset the card to get everything in a known state</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; reset&quot;</span><span class="p">);</span>
  <span class="n">hrz_reset</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-130"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-130">&#182;</a></div><p>Clear all the buffer memory</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; clearing memory&quot;</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">HDW</span> <span class="o">*</span><span class="p">)</span> <span class="n">memmap</span><span class="p">;</span> <span class="n">mem</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">HDW</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">memmap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">mem</span><span class="p">)</span>
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; tx channels&quot;</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-131"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-131">&#182;</a></div><p>All transmit eight channels are set up as AAL5 ABR channels with
a 16us cell spacing. Why?</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-132"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-132">&#182;</a></div><p>Channel 0 gets the free buffer at 100h, channel 1 gets the free
buffer at 110h etc.</p></td><td class="code"><div class="highlight"><pre>  
  <span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">TX_CHANS</span><span class="p">;</span> <span class="o">++</span><span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tx_ch_desc</span> <span class="o">*</span> <span class="n">tx_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">tx_descs</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
    <span class="n">cell_buf</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">inittxbufs</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
    </pre></div></td></tr>


<tr id="section-133"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-133">&#182;</a></div><p>initialise the read and write buffer pointers</p></td><td class="code"><div class="highlight"><pre>    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">rd_buf_type</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    </pre></div></td></tr>


<tr id="section-134"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-134">&#182;</a></div><p>set the status of the initial buffers to empty</p></td><td class="code"><div class="highlight"><pre>    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">BUFF_STATUS_EMPTY</span><span class="p">);</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-135"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-135">&#182;</a></div><p>Use space bufn3 at the moment for tx buffers</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; tx buffers&quot;</span><span class="p">);</span>
  
  <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">memmap</span><span class="o">-&gt;</span><span class="n">bufn3</span><span class="p">;</span>
  
  <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">txfreebufstart</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="n">tx_desc</span><span class="p">)</span> <span class="o">|</span> <span class="n">BUFF_STATUS_EMPTY</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="n">buff_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buff_count</span> <span class="o">&lt;</span> <span class="n">BUFN3_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">buff_count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="n">tx_desc</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">BUFF_STATUS_EMPTY</span><span class="p">);</span>
    <span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">txfreebufend</span><span class="p">)</span> <span class="o">|</span> <span class="n">BUFF_STATUS_EMPTY</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-136"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-136">&#182;</a></div><p>Initialise the transmit free buffer count</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_FREE_BUFFER_COUNT_OFF</span><span class="p">,</span> <span class="n">BUFN3_SIZE</span><span class="p">);</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; rx channels&quot;</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-137"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-137">&#182;</a></div><p>Initialise all of the receive channels to be AAL5 disabled with
an interrupt threshold of 0</p></td><td class="code"><div class="highlight"><pre>  
  <span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">RX_CHANS</span><span class="p">;</span> <span class="o">++</span><span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rx_ch_desc</span> <span class="o">*</span> <span class="n">rx_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">rx_descs</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
    
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wr_buf_type</span><span class="p">,</span> <span class="n">CHANNEL_TYPE_AAL5</span> <span class="o">|</span> <span class="n">RX_CHANNEL_DISABLED</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; rx buffers&quot;</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-138"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-138">&#182;</a></div><p>Use space bufn4 at the moment for rx buffers</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">rx_desc</span> <span class="o">=</span> <span class="n">memmap</span><span class="o">-&gt;</span><span class="n">bufn4</span><span class="p">;</span>
  
  <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">rxfreebufstart</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">)</span> <span class="o">|</span> <span class="n">BUFF_STATUS_EMPTY</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="n">buff_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buff_count</span> <span class="o">&lt;</span> <span class="n">BUFN4_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">buff_count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">BUFF_STATUS_EMPTY</span><span class="p">);</span>
    
    <span class="n">rx_desc</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">wr_mem</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">BUF_PTR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">rxfreebufend</span><span class="p">)</span> <span class="o">|</span> <span class="n">BUFF_STATUS_EMPTY</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-139"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-139">&#182;</a></div><p>Initialise the receive free buffer count</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_FREE_BUFFER_COUNT_OFF</span><span class="p">,</span> <span class="n">BUFN4_SIZE</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-140"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-140">&#182;</a></div><p>Initialize Horizons registers</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-141"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-141">&#182;</a></div><p>TX config</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_CONFIG_OFF</span><span class="p">,</span>
	   <span class="n">ABR_ROUND_ROBIN</span> <span class="o">|</span> <span class="n">TX_NORMAL_OPERATION</span> <span class="o">|</span> <span class="n">DRVR_DRVRBAR_ENABLE</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-142"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-142">&#182;</a></div><p>RX config. Use 10-x VC bits, x VP bits, non user cells in channel 0.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CONFIG_OFF</span><span class="p">,</span>
	   <span class="n">DISCARD_UNUSED_VPI_VCI_BITS_SET</span> <span class="o">|</span> <span class="n">NON_USER_CELLS_IN_ONE_CHANNEL</span> <span class="o">|</span> <span class="n">vpi_bits</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-143"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-143">&#182;</a></div><p>RX line config</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_LINE_CONFIG_OFF</span><span class="p">,</span>
	   <span class="n">LOCK_DETECT_ENABLE</span> <span class="o">|</span> <span class="n">FREQUENCY_DETECT_ENABLE</span> <span class="o">|</span> <span class="n">GXTALOUT_SELECT_DIV4</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-144"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-144">&#182;</a></div><p>Set the max AAL5 cell count to be just enough to contain the
largest AAL5 frame that the user wants to receive</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MAX_AAL5_CELL_COUNT_OFF</span><span class="p">,</span>
	   <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">max_rx_size</span> <span class="o">+</span> <span class="n">ATM_AAL5_TRAILER</span><span class="p">,</span> <span class="n">ATM_CELL_PAYLOAD</span><span class="p">));</span>
  </pre></div></td></tr>


<tr id="section-145"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-145">&#182;</a></div><p>Enable receive</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CONFIG_OFF</span><span class="p">,</span> <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_CONFIG_OFF</span><span class="p">)</span> <span class="o">|</span> <span class="n">RX_ENABLE</span><span class="p">);</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; control&quot;</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-146"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-146">&#182;</a></div><p>Drive the OE of the LEDs then turn the green LED on</p></td><td class="code"><div class="highlight"><pre>  <span class="n">ctrl</span> <span class="o">|=</span> <span class="n">GREEN_LED_OE</span> <span class="o">|</span> <span class="n">YELLOW_LED_OE</span> <span class="o">|</span> <span class="n">GREEN_LED</span> <span class="o">|</span> <span class="n">YELLOW_LED</span><span class="p">;</span>
  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-147"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-147">&#182;</a></div><p>Test for a 155-capable card</p></td><td class="code"><div class="highlight"><pre>  
  <span class="k">if</span> <span class="p">(</span><span class="n">onefivefive</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-148"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-148">&#182;</a></div><p>Select 155 mode... make this a choice (or: how do we detect
external line speed and switch?)</p></td><td class="code"><div class="highlight"><pre>    <span class="n">ctrl</span> <span class="o">|=</span> <span class="n">ATM_LAYER_SELECT</span><span class="p">;</span>
    <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CONTROL_0_REG</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
    </pre></div></td></tr>


<tr id="section-149"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-149">&#182;</a></div><p>test SUNI-lite vs SAMBA</p></td><td class="code"><div class="highlight"><pre>    </pre></div></td></tr>


<tr id="section-150"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-150">&#182;</a></div><p>Register 0x00 in the SUNI will have some of bits 3-7 set, and
they will always be zero for the SAMBA.  Ha!  Bloody hardware
engineers.  It'll never work.</p></td><td class="code"><div class="highlight"><pre>    
    <span class="k">if</span> <span class="p">(</span><span class="n">rd_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00f0</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-151"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-151">&#182;</a></div><p>SUNI</p></td><td class="code"><div class="highlight"><pre>      <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; SUNI&quot;</span><span class="p">);</span>
      </pre></div></td></tr>


<tr id="section-152"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-152">&#182;</a></div><p>Reset, just in case</p></td><td class="code"><div class="highlight"><pre>      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x0080</span><span class="p">);</span>
      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
      </pre></div></td></tr>


<tr id="section-153"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-153">&#182;</a></div><p>Configure transmit FIFO</p></td><td class="code"><div class="highlight"><pre>      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x63</span><span class="p">,</span> <span class="n">rd_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x63</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0002</span><span class="p">);</span>
      </pre></div></td></tr>


<tr id="section-154"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-154">&#182;</a></div><p>Set line timed mode</p></td><td class="code"><div class="highlight"><pre>      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="n">rd_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0001</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-155"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-155">&#182;</a></div><p>SAMBA</p></td><td class="code"><div class="highlight"><pre>      <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; SAMBA&quot;</span><span class="p">);</span>
      </pre></div></td></tr>


<tr id="section-156"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-156">&#182;</a></div><p>Reset, just in case</p></td><td class="code"><div class="highlight"><pre>      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rd_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0001</span><span class="p">);</span>
      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rd_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;~</span> <span class="mh">0x0001</span><span class="p">);</span>
      </pre></div></td></tr>


<tr id="section-157"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-157">&#182;</a></div><p>Turn off diagnostic loopback and enable line-timed mode</p></td><td class="code"><div class="highlight"><pre>      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x0002</span><span class="p">);</span>
      </pre></div></td></tr>


<tr id="section-158"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-158">&#182;</a></div><p>Turn on transmit outputs</p></td><td class="code"><div class="highlight"><pre>      <span class="n">wr_framer</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0x0B80</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-159"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-159">&#182;</a></div><p>Select 25 mode</p></td><td class="code"><div class="highlight"><pre>    <span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATM_LAYER_SELECT</span><span class="p">;</span>
    </pre></div></td></tr>


<tr id="section-160"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-160">&#182;</a></div><p>Madge B154 setup
none required?</p></td><td class="code"><div class="highlight"><pre>  <span class="p">}</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; LEDs&quot;</span><span class="p">);</span>
  
  <span class="n">GREEN_LED_ON</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  <span class="n">YELLOW_LED_ON</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; ESI=&quot;</span><span class="p">);</span>
  
  <span class="p">{</span>
    <span class="n">u16</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">u8</span> <span class="o">*</span> <span class="n">esi</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">esi</span><span class="p">;</span>
    </pre></div></td></tr>


<tr id="section-161"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-161">&#182;</a></div><p>in the card I have, EEPROM
addresses 0, 1, 2 contain 0
addresess 5, 6 etc. contain ffff
NB: Madge prefix is 00 00 f6 (which is 00 00 6f in Ethernet bit order)
the read_bia routine gets the BIA in Ethernet bit order</p></td><td class="code"><div class="highlight"><pre>    
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ESI_LEN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">read_bia</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
      <span class="k">else</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
      <span class="n">esi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
      <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;%02x&quot;</span><span class="p">,</span> <span class="n">esi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-162"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-162">&#182;</a></div><p>Enable RX<em>Q and ?X</em>COMPLETE interrupts only</p></td><td class="code"><div class="highlight"><pre>  <span class="n">wr_regl</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">INT_ENABLE_REG_OFF</span><span class="p">,</span> <span class="n">INTERESTING_INTERRUPTS</span><span class="p">);</span>
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot; IRQ on&quot;</span><span class="p">);</span>
  
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">onefivefive</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** check max_sdu **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_max_sdu</span> <span class="p">(</span><span class="n">hrz_aal</span> <span class="n">aal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">atm_trafprm</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_frame_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="o">|</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;check_max_sdu&quot;</span><span class="p">);</span>
  
  <span class="k">switch</span> <span class="p">(</span><span class="n">aal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">aal0</span>:
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;defaulting max_sdu&quot;</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">=</span> <span class="n">ATM_AAL0_SDU</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">!=</span> <span class="n">ATM_AAL0_SDU</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;rejecting max_sdu&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">aal34</span>:
      <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">&gt;</span> <span class="n">ATM_MAX_AAL34_PDU</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;%sing max_sdu&quot;</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">?</span> <span class="s">&quot;capp&quot;</span> <span class="o">:</span> <span class="s">&quot;default&quot;</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">=</span> <span class="n">ATM_MAX_AAL34_PDU</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">aal5</span>:
      <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">&gt;</span> <span class="n">max_frame_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;%sing max_sdu&quot;</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">?</span> <span class="s">&quot;capp&quot;</span> <span class="o">:</span> <span class="s">&quot;default&quot;</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_sdu</span> <span class="o">=</span> <span class="n">max_frame_size</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** check pcr **********/</span></pre></div></td></tr>


<tr id="section-163"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-163">&#182;</a></div><p>something like this should be part of ATM Linux</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">atm_pcr_check</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atm_trafprm</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcr</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-164"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-164">&#182;</a></div><p>we are assuming non-UBR, and non-special values of pcr</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_pcr</span> <span class="o">==</span> <span class="n">ATM_MAX_PCR</span><span class="p">)</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;luser gave min_pcr = ATM_MAX_PCR&quot;</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_pcr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;luser gave negative min_pcr&quot;</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_pcr</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_pcr</span> <span class="o">&gt;</span> <span class="n">pcr</span><span class="p">)</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;pcr less than min_pcr&quot;</span><span class="p">);</span>
  <span class="k">else</span></pre></div></td></tr>


<tr id="section-165"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-165">&#182;</a></div><p>!! max<em>pcr = UNSPEC (0) is equivalent to max</em>pcr = MAX (-1)
easier to #define ATM<em>MAX</em>PCR 0 and have all rates unsigned?
[this would get rid of next two conditionals]</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">((</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_pcr</span> <span class="o">==</span> <span class="n">ATM_MAX_PCR</span><span class="p">)</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;luser gave max_pcr = ATM_MAX_PCR&quot;</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_pcr</span> <span class="o">!=</span> <span class="n">ATM_MAX_PCR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_pcr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;luser gave negative max_pcr&quot;</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_pcr</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_pcr</span> <span class="o">!=</span> <span class="n">ATM_MAX_PCR</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_pcr</span> <span class="o">&lt;</span> <span class="n">pcr</span><span class="p">)</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;pcr greater than max_pcr&quot;</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-166"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-166">&#182;</a></div><p>each limit unspecified or not violated</p></td><td class="code"><div class="highlight"><pre>      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;xBR(pcr) OK&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;pcr=%u, tp: min_pcr=%d, pcr=%d, max_pcr=%d&quot;</span><span class="p">,</span>
	  <span class="n">pcr</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">min_pcr</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pcr</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_pcr</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** open VC **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrz_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atm_vcc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
  <span class="n">u16</span> <span class="n">channel</span><span class="p">;</span>
  
  <span class="k">struct</span> <span class="n">atm_qos</span> <span class="o">*</span> <span class="n">qos</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">atm_trafprm</span> <span class="o">*</span> <span class="n">txtp</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">atm_trafprm</span> <span class="o">*</span> <span class="n">rxtp</span><span class="p">;</span>
  
  <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">HRZ_DEV</span><span class="p">(</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
  <span class="n">hrz_vcc</span> <span class="n">vcc</span><span class="p">;</span>
  <span class="n">hrz_vcc</span> <span class="o">*</span> <span class="n">vccp</span><span class="p">;</span> <span class="c1">// allocated late</span>
  <span class="kt">short</span> <span class="n">vpi</span> <span class="o">=</span> <span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">vci</span> <span class="o">=</span> <span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">vci</span><span class="p">;</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;hrz_open %x %x&quot;</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>
  
<span class="cp">#ifdef ATM_VPI_UNSPEC</span></pre></div></td></tr>


<tr id="section-167"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-167">&#182;</a></div><p>UNSPEC is deprecated, remove this code eventually</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">vpi</span> <span class="o">==</span> <span class="n">ATM_VPI_UNSPEC</span> <span class="o">||</span> <span class="n">vci</span> <span class="o">==</span> <span class="n">ATM_VCI_UNSPEC</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="s">&quot;rejecting open with unspecified VPI/VCI (deprecated)&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cp">#endif</span>
  
  <span class="n">error</span> <span class="o">=</span> <span class="n">vpivci_to_channel</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_WARN</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;VPI/VCI out of range: %hd/%d&quot;</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">vci</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">vcc</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-168"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-168">&#182;</a></div><p>max speed for the moment</p></td><td class="code"><div class="highlight"><pre>  <span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
  
  <span class="n">qos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">;</span>
  </pre></div></td></tr>


<tr id="section-169"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-169">&#182;</a></div><p>check AAL and remember it</p></td><td class="code"><div class="highlight"><pre>  <span class="k">switch</span> <span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">aal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ATM_AAL0</span>:</pre></div></td></tr>


<tr id="section-170"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-170">&#182;</a></div><p>we would if it were 48 bytes and not 52!</p></td><td class="code"><div class="highlight"><pre>      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;AAL0&quot;</span><span class="p">);</span>
      <span class="n">vcc</span><span class="p">.</span><span class="n">aal</span> <span class="o">=</span> <span class="n">aal0</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ATM_AAL34</span>:</pre></div></td></tr>


<tr id="section-171"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-171">&#182;</a></div><p>we would if I knew how do the SAR!</p></td><td class="code"><div class="highlight"><pre>      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;AAL3/4&quot;</span><span class="p">);</span>
      <span class="n">vcc</span><span class="p">.</span><span class="n">aal</span> <span class="o">=</span> <span class="n">aal34</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ATM_AAL5</span>:
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;AAL5&quot;</span><span class="p">);</span>
      <span class="n">vcc</span><span class="p">.</span><span class="n">aal</span> <span class="o">=</span> <span class="n">aal5</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;Bad AAL!&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-172"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-172">&#182;</a></div><p>TX traffic parameters</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-173"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-173">&#182;</a></div><p>there are two, interrelated problems here: 1. the reservation of
PCR is not a binary choice, we are given bounds and/or a
desirable value; 2. the device is only capable of certain values,
most of which are not integers. It is almost certainly acceptable
to be off by a maximum of 1 to 10 cps.</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-174"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-174">&#182;</a></div><p>Pragmatic choice: always store an integral PCR as that which has
been allocated, even if we allocate a little (or a lot) less,
after rounding. The actual allocation depends on what we can
manage with our rate selection algorithm. The rate selection
algorithm is given an integral PCR and a tolerance and told
whether it should round the value up or down if the tolerance is
exceeded; it returns: a) the actual rate selected (rounded up to
the nearest integer), b) a bit pattern to feed to the timer
register, and c) a failure value if no applicable rate exists.</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-175"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-175">&#182;</a></div><p>Part of the job is done by atm<em>pcr</em>goal which gives us a PCR
specification which says: EITHER grab the maximum available PCR
(and perhaps a lower bound which we musn't pass), OR grab this
amount, rounding down if you have to (and perhaps a lower bound
which we musn't pass) OR grab this amount, rounding up if you
have to (and perhaps an upper bound which we musn't pass). If any
bounds ARE passed we fail. Note that rounding is only rounding to
match device limitations, we do not round down to satisfy
bandwidth availability even if this would not violate any given
lower bound.</p></td><td class="code"><div class="highlight"><pre>  </pre></div></td></tr>


<tr id="section-176"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-176">&#182;</a></div><p>Note: telephony = 64kb/s = 48 byte cell payload @ 500/3 cells/s
(say) so this is not even a binary fixpoint cell rate (but this
device can do it). To avoid this sort of hassle we use a
tolerance parameter (currently fixed at 10 cps).</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;TX:&quot;</span><span class="p">);</span>
  
  <span class="n">txtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">txtp</span><span class="p">;</span>
  </pre></div></td></tr>


<tr id="section-177"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-177">&#182;</a></div><p>set up defaults for no traffic</p></td><td class="code"><div class="highlight"><pre>  <span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-178"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-178">&#182;</a></div><p>who knows what would actually happen if you try and send on this?</p></td><td class="code"><div class="highlight"><pre>  <span class="n">vcc</span><span class="p">.</span><span class="n">tx_xbr_bits</span> <span class="o">=</span> <span class="n">IDLE_RATE_TYPE</span><span class="p">;</span>
  <span class="n">vcc</span><span class="p">.</span><span class="n">tx_pcr_bits</span> <span class="o">=</span> <span class="n">CLOCK_DISABLE</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  vcc.tx_scr_bits = CLOCK_DISABLE;</span>
<span class="c">  vcc.tx_bucket_bits = 0;</span>
<span class="cp">#endif</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">txtp</span><span class="o">-&gt;</span><span class="n">traffic_class</span> <span class="o">!=</span> <span class="n">ATM_NONE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">check_max_sdu</span> <span class="p">(</span><span class="n">vcc</span><span class="p">.</span><span class="n">aal</span><span class="p">,</span> <span class="n">txtp</span><span class="p">,</span> <span class="n">max_tx_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;TX max_sdu check failed&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">switch</span> <span class="p">(</span><span class="n">txtp</span><span class="o">-&gt;</span><span class="n">traffic_class</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">ATM_UBR</span>: <span class="p">{</span></pre></div></td></tr>


<tr id="section-179"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-179">&#182;</a></div><p>we take "the PCR" as a rate-cap
not reserved</p></td><td class="code"><div class="highlight"><pre>	<span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">make_rate</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">,</span> <span class="n">round_nearest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="p">.</span><span class="n">tx_pcr_bits</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">vcc</span><span class="p">.</span><span class="n">tx_xbr_bits</span> <span class="o">=</span> <span class="n">ABR_RATE_TYPE</span><span class="p">;</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">      case ATM_ABR: {</span></pre></div></td></tr>


<tr id="section-180"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-180">&#182;</a></div><p>reserve min, allow up to max</p></td><td class="code"><div class="highlight"><pre><span class="c">	vcc.tx_rate = 0; // ?</span>
<span class="c">	make_rate (dev, 1&lt;&lt;30, round_nearest, &amp;vcc.tx_pcr_bits, 0);</span>
<span class="c">	vcc.tx_xbr_bits = ABR_RATE_TYPE;</span>
<span class="c">	break;</span>
<span class="c">      }</span>
<span class="cp">#endif</span>
      <span class="k">case</span> <span class="n">ATM_CBR</span>: <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pcr</span> <span class="o">=</span> <span class="n">atm_pcr_goal</span> <span class="p">(</span><span class="n">txtp</span><span class="p">);</span>
	<span class="n">rounding</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcr</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-181"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-181">&#182;</a></div><p>down vs. up, remaining bandwidth vs. unlimited bandwidth!!
should really have: once someone gets unlimited bandwidth
that no more non-UBR channels can be opened until the
unlimited one closes?? For the moment, round_down means
greedy people actually get something and not nothing</p></td><td class="code"><div class="highlight"><pre>	  <span class="n">r</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-182"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-182">&#182;</a></div><p>slight race (no locking) here so we may get -EAGAIN
later; the greedy bastards would deserve it :)</p></td><td class="code"><div class="highlight"><pre>	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;snatching all remaining TX bandwidth&quot;</span><span class="p">);</span>
	  <span class="n">pcr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_avail</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pcr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">r</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">;</span>
	  <span class="n">pcr</span> <span class="o">=</span> <span class="o">-</span><span class="n">pcr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	  <span class="n">r</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">make_rate_with_tolerance</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcr</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">vcc</span><span class="p">.</span><span class="n">tx_pcr_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;could not make rate from TX PCR&quot;</span><span class="p">);</span>
	  <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-183"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-183">&#182;</a></div><p>not really clear what further checking is needed</p></td><td class="code"><div class="highlight"><pre>	<span class="n">error</span> <span class="o">=</span> <span class="n">atm_pcr_check</span> <span class="p">(</span><span class="n">txtp</span><span class="p">,</span> <span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;TX PCR failed consistency check&quot;</span><span class="p">);</span>
	  <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcc</span><span class="p">.</span><span class="n">tx_xbr_bits</span> <span class="o">=</span> <span class="n">CBR_RATE_TYPE</span><span class="p">;</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">      case ATM_VBR: {</span>
<span class="c">	int pcr = atm_pcr_goal (txtp);</span></pre></div></td></tr>


<tr id="section-184"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-184">&#182;</a></div><p>int scr = atm<em>scr</em>goal (txtp);</p></td><td class="code"><div class="highlight"><pre><span class="c">	int scr = pcr/2; // just for fun</span>
<span class="c">	unsigned int mbs = 60; // just for fun</span>
<span class="c">	rounding pr;</span>
<span class="c">	rounding sr;</span>
<span class="c">	unsigned int bucket;</span>
<span class="c">	if (!pcr) {</span>
<span class="c">	  pr = round_nearest;</span>
<span class="c">	  pcr = 1&lt;&lt;30;</span>
<span class="c">	} else if (pcr &lt; 0) {</span>
<span class="c">	  pr = round_down;</span>
<span class="c">	  pcr = -pcr;</span>
<span class="c">	} else {</span>
<span class="c">	  pr = round_up;</span>
<span class="c">	}</span>
<span class="c">	error = make_rate_with_tolerance (dev, pcr, pr, 10,</span>
<span class="c">					  &amp;vcc.tx_pcr_bits, 0);</span>
<span class="c">	if (!scr) {</span></pre></div></td></tr>


<tr id="section-185"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-185">&#182;</a></div><p>see comments for PCR with CBR above</p></td><td class="code"><div class="highlight"><pre><span class="c">	  sr = round_down;</span></pre></div></td></tr>


<tr id="section-186"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-186">&#182;</a></div><p>slight race (no locking) here so we may get -EAGAIN
later; the greedy bastards would deserve it :)</p></td><td class="code"><div class="highlight"><pre><span class="c">	  PRINTD (DBG_QOS, &quot;snatching all remaining TX bandwidth&quot;);</span>
<span class="c">	  scr = dev-&gt;tx_avail;</span>
<span class="c">	} else if (scr &lt; 0) {</span>
<span class="c">	  sr = round_down;</span>
<span class="c">	  scr = -scr;</span>
<span class="c">	} else {</span>
<span class="c">	  sr = round_up;</span>
<span class="c">	}</span>
<span class="c">	error = make_rate_with_tolerance (dev, scr, sr, 10,</span>
<span class="c">					  &amp;vcc.tx_scr_bits, &amp;vcc.tx_rate);</span>
<span class="c">	if (error) {</span>
<span class="c">	  PRINTD (DBG_QOS, &quot;could not make rate from TX SCR&quot;);</span>
<span class="c">	  return error;</span>
<span class="c">	}</span></pre></div></td></tr>


<tr id="section-187"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-187">&#182;</a></div><p>not really clear what further checking is needed
error = atm<em>scr</em>check (txtp, vcc.tx_rate);</p></td><td class="code"><div class="highlight"><pre><span class="c">	if (error) {</span>
<span class="c">	  PRINTD (DBG_QOS, &quot;TX SCR failed consistency check&quot;);</span>
<span class="c">	  return error;</span>
<span class="c">	}</span></pre></div></td></tr>


<tr id="section-188"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-188">&#182;</a></div><p>bucket calculations (from a piece of paper...) cell bucket
capacity must be largest integer smaller than m(p-s)/p + 1
where m = max burst size, p = pcr, s = scr</p></td><td class="code"><div class="highlight"><pre><span class="c">	bucket = mbs*(pcr-scr)/pcr;</span>
<span class="c">	if (bucket*pcr != mbs*(pcr-scr))</span>
<span class="c">	  bucket += 1;</span>
<span class="c">	if (bucket &gt; BUCKET_MAX_SIZE) {</span>
<span class="c">	  PRINTD (DBG_QOS, &quot;shrinking bucket from %u to %u&quot;,</span>
<span class="c">		  bucket, BUCKET_MAX_SIZE);</span>
<span class="c">	  bucket = BUCKET_MAX_SIZE;</span>
<span class="c">	}</span>
<span class="c">	vcc.tx_xbr_bits = VBR_RATE_TYPE;</span>
<span class="c">	vcc.tx_bucket_bits = bucket;</span>
<span class="c">	break;</span>
<span class="c">      }</span>
<span class="cp">#endif</span>
      <span class="nl">default:</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;unsupported TX traffic class&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-189"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-189">&#182;</a></div><p>RX traffic parameters</p></td><td class="code"><div class="highlight"><pre>  
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;RX:&quot;</span><span class="p">);</span>
  
  <span class="n">rxtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">rxtp</span><span class="p">;</span>
  </pre></div></td></tr>


<tr id="section-190"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-190">&#182;</a></div><p>set up defaults for no traffic</p></td><td class="code"><div class="highlight"><pre>  <span class="n">vcc</span><span class="p">.</span><span class="n">rx_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">rxtp</span><span class="o">-&gt;</span><span class="n">traffic_class</span> <span class="o">!=</span> <span class="n">ATM_NONE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">check_max_sdu</span> <span class="p">(</span><span class="n">vcc</span><span class="p">.</span><span class="n">aal</span><span class="p">,</span> <span class="n">rxtp</span><span class="p">,</span> <span class="n">max_rx_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;RX max_sdu check failed&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">rxtp</span><span class="o">-&gt;</span><span class="n">traffic_class</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">ATM_UBR</span>: <span class="p">{</span></pre></div></td></tr>


<tr id="section-191"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-191">&#182;</a></div><p>not reserved</p></td><td class="code"><div class="highlight"><pre>	<span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">      case ATM_ABR: {</span></pre></div></td></tr>


<tr id="section-192"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-192">&#182;</a></div><p>reserve min</p></td><td class="code"><div class="highlight"><pre><span class="c">	vcc.rx_rate = 0; // ?</span>
<span class="c">	break;</span>
<span class="c">      }</span>
<span class="cp">#endif</span>
      <span class="k">case</span> <span class="n">ATM_CBR</span>: <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pcr</span> <span class="o">=</span> <span class="n">atm_pcr_goal</span> <span class="p">(</span><span class="n">rxtp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcr</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-193"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-193">&#182;</a></div><p>slight race (no locking) here so we may get -EAGAIN
later; the greedy bastards would deserve it :)</p></td><td class="code"><div class="highlight"><pre>	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;snatching all remaining RX bandwidth&quot;</span><span class="p">);</span>
	  <span class="n">pcr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_avail</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pcr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">pcr</span> <span class="o">=</span> <span class="o">-</span><span class="n">pcr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcc</span><span class="p">.</span><span class="n">rx_rate</span> <span class="o">=</span> <span class="n">pcr</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-194"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-194">&#182;</a></div><p>not really clear what further checking is needed</p></td><td class="code"><div class="highlight"><pre>	<span class="n">error</span> <span class="o">=</span> <span class="n">atm_pcr_check</span> <span class="p">(</span><span class="n">rxtp</span><span class="p">,</span> <span class="n">vcc</span><span class="p">.</span><span class="n">rx_rate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;RX PCR failed consistency check&quot;</span><span class="p">);</span>
	  <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">      case ATM_VBR: {</span></pre></div></td></tr>


<tr id="section-195"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-195">&#182;</a></div><p>int scr = atm<em>scr</em>goal (rxtp);</p></td><td class="code"><div class="highlight"><pre><span class="c">	int scr = 1&lt;&lt;16; // just for fun</span>
<span class="c">	if (!scr) {</span></pre></div></td></tr>


<tr id="section-196"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-196">&#182;</a></div><p>slight race (no locking) here so we may get -EAGAIN
later; the greedy bastards would deserve it :)</p></td><td class="code"><div class="highlight"><pre><span class="c">	  PRINTD (DBG_QOS, &quot;snatching all remaining RX bandwidth&quot;);</span>
<span class="c">	  scr = dev-&gt;rx_avail;</span>
<span class="c">	} else if (scr &lt; 0) {</span>
<span class="c">	  scr = -scr;</span>
<span class="c">	}</span>
<span class="c">	vcc.rx_rate = scr;</span></pre></div></td></tr>


<tr id="section-197"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-197">&#182;</a></div><p>not really clear what further checking is needed
error = atm<em>scr</em>check (rxtp, vcc.rx_rate);</p></td><td class="code"><div class="highlight"><pre><span class="c">	if (error) {</span>
<span class="c">	  PRINTD (DBG_QOS, &quot;RX SCR failed consistency check&quot;);</span>
<span class="c">	  return error;</span>
<span class="c">	}</span>
<span class="c">	break;</span>
<span class="c">      }</span>
<span class="cp">#endif</span>
      <span class="nl">default:</span> <span class="p">{</span>
	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;unsupported RX traffic class&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  </pre></div></td></tr>


<tr id="section-198"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-198">&#182;</a></div><p>late abort useful for diagnostics</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">vcc</span><span class="p">.</span><span class="n">aal</span> <span class="o">!=</span> <span class="n">aal5</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;AAL not supported&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-199"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-199">&#182;</a></div><p>get space for our vcc stuff and copy parameters into it</p></td><td class="code"><div class="highlight"><pre>  <span class="n">vccp</span> <span class="o">=</span> <span class="n">kmalloc</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hrz_vcc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vccp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;out of memory!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">*</span><span class="n">vccp</span> <span class="o">=</span> <span class="n">vcc</span><span class="p">;</span>
  </pre></div></td></tr>


<tr id="section-200"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-200">&#182;</a></div><p>clear error and grab cell rate resource lock</p></td><td class="code"><div class="highlight"><pre>  <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rate_lock</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_avail</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;not enough TX PCR left&quot;</span><span class="p">);</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">vcc</span><span class="p">.</span><span class="n">rx_rate</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_avail</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="p">,</span> <span class="s">&quot;not enough RX PCR left&quot;</span><span class="p">);</span>
    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-201"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-201">&#182;</a></div><p>really consume cell rates</p></td><td class="code"><div class="highlight"><pre>    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_avail</span> <span class="o">-=</span> <span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_avail</span> <span class="o">-=</span> <span class="n">vcc</span><span class="p">.</span><span class="n">rx_rate</span><span class="p">;</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;reserving %u TX PCR and %u RX PCR&quot;</span><span class="p">,</span>
	    <span class="n">vcc</span><span class="p">.</span><span class="n">tx_rate</span><span class="p">,</span> <span class="n">vcc</span><span class="p">.</span><span class="n">rx_rate</span><span class="p">);</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-202"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-202">&#182;</a></div><p>release lock and exit on error</p></td><td class="code"><div class="highlight"><pre>  <span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rate_lock</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;insufficient cell rate resources&quot;</span><span class="p">);</span>
    <span class="n">kfree</span> <span class="p">(</span><span class="n">vccp</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-203"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-203">&#182;</a></div><p>this is "immediately before allocating the connection identifier
in hardware" - so long as the next call does not fail :)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_ADDR</span><span class="p">,</span><span class="o">&amp;</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-204"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-204">&#182;</a></div><p>any errors here are very serious and should never occur</p></td><td class="code"><div class="highlight"><pre>  
  <span class="k">if</span> <span class="p">(</span><span class="n">rxtp</span><span class="o">-&gt;</span><span class="n">traffic_class</span> <span class="o">!=</span> <span class="n">ATM_NONE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxer</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_ERR</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;VC already open for RX&quot;</span><span class="p">);</span>
      <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
      <span class="n">error</span> <span class="o">=</span> <span class="n">hrz_open_rx</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">kfree</span> <span class="p">(</span><span class="n">vccp</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span></pre></div></td></tr>


<tr id="section-205"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-205">&#182;</a></div><p>this link allows RX frames through</p></td><td class="code"><div class="highlight"><pre>    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxer</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">atm_vcc</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-206"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-206">&#182;</a></div><p>success, set elements of atm_vcc</p></td><td class="code"><div class="highlight"><pre>  <span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">dev_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">vccp</span><span class="p">;</span>
  </pre></div></td></tr>


<tr id="section-207"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-207">&#182;</a></div><p>indicate readiness</p></td><td class="code"><div class="highlight"><pre>  <span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_READY</span><span class="p">,</span><span class="o">&amp;</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********** close VC **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrz_close</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span> <span class="n">atm_vcc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">HRZ_DEV</span><span class="p">(</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
  <span class="n">hrz_vcc</span> <span class="o">*</span> <span class="n">vcc</span> <span class="o">=</span> <span class="n">HRZ_VCC</span><span class="p">(</span><span class="n">atm_vcc</span><span class="p">);</span>
  <span class="n">u16</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_VCC</span><span class="o">|</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;hrz_close&quot;</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-208"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-208">&#182;</a></div><p>indicate unreadiness</p></td><td class="code"><div class="highlight"><pre>  <span class="n">clear_bit</span><span class="p">(</span><span class="n">ATM_VF_READY</span><span class="p">,</span><span class="o">&amp;</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">txtp</span><span class="p">.</span><span class="n">traffic_class</span> <span class="o">!=</span> <span class="n">ATM_NONE</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    </pre></div></td></tr>


<tr id="section-209"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-209">&#182;</a></div><p>let any TX on this channel that has started complete
no restart, just keep trying</p></td><td class="code"><div class="highlight"><pre>    <span class="k">while</span> <span class="p">(</span><span class="n">tx_hold</span> <span class="p">(</span><span class="n">dev</span><span class="p">))</span>
      <span class="p">;</span></pre></div></td></tr>


<tr id="section-210"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-210">&#182;</a></div><p>remove record of any tx_channel having been setup for this channel</p></td><td class="code"><div class="highlight"><pre>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_CHANS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_channel_record</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_channel_record</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vc</span> <span class="o">==</span> <span class="n">channel</span><span class="p">)</span>
      <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_last</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">tx_release</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">rxtp</span><span class="p">.</span><span class="n">traffic_class</span> <span class="o">!=</span> <span class="n">ATM_NONE</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-211"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-211">&#182;</a></div><p>disable RXing - it tries quite hard</p></td><td class="code"><div class="highlight"><pre>    <span class="n">hrz_close_rx</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-212"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-212">&#182;</a></div><p>forget the vcc - no more skbs will be pushed</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">atm_vcc</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxer</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>
      <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;%s atm_vcc=%p rxer[channel]=%p&quot;</span><span class="p">,</span>
	      <span class="s">&quot;arghhh! we&#39;re going to die!&quot;</span><span class="p">,</span>
	      <span class="n">atm_vcc</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxer</span><span class="p">[</span><span class="n">channel</span><span class="p">]);</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rxer</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  </pre></div></td></tr>


<tr id="section-213"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-213">&#182;</a></div><p>atomically release our rate reservation</p></td><td class="code"><div class="highlight"><pre>  <span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rate_lock</span><span class="p">);</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_QOS</span><span class="o">|</span><span class="n">DBG_VCC</span><span class="p">,</span> <span class="s">&quot;releasing %u TX PCR and %u RX PCR&quot;</span><span class="p">,</span>
	  <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">tx_rate</span><span class="p">,</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">rx_rate</span><span class="p">);</span>
  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_avail</span> <span class="o">+=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">tx_rate</span><span class="p">;</span>
  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_avail</span> <span class="o">+=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">rx_rate</span><span class="p">;</span>
  <span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rate_lock</span><span class="p">);</span>
  </pre></div></td></tr>


<tr id="section-214"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-214">&#182;</a></div><p>free our structure</p></td><td class="code"><div class="highlight"><pre>  <span class="n">kfree</span> <span class="p">(</span><span class="n">vcc</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-215"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-215">&#182;</a></div><p>say the VPI/VCI is free again</p></td><td class="code"><div class="highlight"><pre>  <span class="n">clear_bit</span><span class="p">(</span><span class="n">ATM_VF_ADDR</span><span class="p">,</span><span class="o">&amp;</span><span class="n">atm_vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int hrz_getsockopt (struct atm_vcc * atm_vcc, int level, int optname,</span>
<span class="c">			   void *optval, int optlen) {</span>
<span class="c">  hrz_dev * dev = HRZ_DEV(atm_vcc-&gt;dev);</span>
<span class="c">  PRINTD (DBG_FLOW|DBG_VCC, &quot;hrz_getsockopt&quot;);</span>
<span class="c">  switch (level) {</span>
<span class="c">    case SOL_SOCKET:</span>
<span class="c">      switch (optname) {</span></pre></div></td></tr>


<tr id="section-216"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-216">&#182;</a></div><p>case SO<em>BCTXOPT:
  break;
case SO</em>BCRXOPT:
  break;</p></td><td class="code"><div class="highlight"><pre><span class="c">	default:</span>
<span class="c">	  return -ENOPROTOOPT;</span>
<span class="c">      };</span>
<span class="c">      break;</span>
<span class="c">  }</span>
<span class="c">  return -EINVAL;</span>
<span class="c">}</span>

<span class="c">static int hrz_setsockopt (struct atm_vcc * atm_vcc, int level, int optname,</span>
<span class="c">			   void *optval, unsigned int optlen) {</span>
<span class="c">  hrz_dev * dev = HRZ_DEV(atm_vcc-&gt;dev);</span>
<span class="c">  PRINTD (DBG_FLOW|DBG_VCC, &quot;hrz_setsockopt&quot;);</span>
<span class="c">  switch (level) {</span>
<span class="c">    case SOL_SOCKET:</span>
<span class="c">      switch (optname) {</span></pre></div></td></tr>


<tr id="section-217"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-217">&#182;</a></div><p>case SO<em>BCTXOPT:
  break;
case SO</em>BCRXOPT:
  break;</p></td><td class="code"><div class="highlight"><pre><span class="c">	default:</span>
<span class="c">	  return -ENOPROTOOPT;</span>
<span class="c">      };</span>
<span class="c">      break;</span>
<span class="c">  }</span>
<span class="c">  return -EINVAL;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int hrz_ioctl (struct atm_dev * atm_dev, unsigned int cmd, void *arg) {</span>
<span class="c">  hrz_dev * dev = HRZ_DEV(atm_dev);</span>
<span class="c">  PRINTD (DBG_FLOW, &quot;hrz_ioctl&quot;);</span>
<span class="c">  return -1;</span>
<span class="c">}</span>

<span class="c">unsigned char hrz_phy_get (struct atm_dev * atm_dev, unsigned long addr) {</span>
<span class="c">  hrz_dev * dev = HRZ_DEV(atm_dev);</span>
<span class="c">  PRINTD (DBG_FLOW, &quot;hrz_phy_get&quot;);</span>
<span class="c">  return 0;</span>
<span class="c">}</span>

<span class="c">static void hrz_phy_put (struct atm_dev * atm_dev, unsigned char value,</span>
<span class="c">			 unsigned long addr) {</span>
<span class="c">  hrz_dev * dev = HRZ_DEV(atm_dev);</span>
<span class="c">  PRINTD (DBG_FLOW, &quot;hrz_phy_put&quot;);</span>
<span class="c">}</span>

<span class="c">static int hrz_change_qos (struct atm_vcc * atm_vcc, struct atm_qos *qos, int flgs) {</span>
<span class="c">  hrz_dev * dev = HRZ_DEV(vcc-&gt;dev);</span>
<span class="c">  PRINTD (DBG_FLOW, &quot;hrz_change_qos&quot;);</span>
<span class="c">  return -1;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/********** proc file contents **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrz_proc_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span> <span class="n">atm_dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">page</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">HRZ_DEV</span><span class="p">(</span><span class="n">atm_dev</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;hrz_proc_read&quot;</span><span class="p">);</span>
  
  <span class="cm">/* more diagnostics here? */</span>
  
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  if (!left--) {</span>
<span class="c">    unsigned int count = sprintf (page, &quot;vbr buckets:&quot;);</span>
<span class="c">    unsigned int i;</span>
<span class="c">    for (i = 0; i &lt; TX_CHANS; ++i)</span>
<span class="c">      count += sprintf (page, &quot; %u/%u&quot;,</span>
<span class="c">			query_tx_channel_config (dev, i, BUCKET_FULLNESS_ACCESS),</span>
<span class="c">			query_tx_channel_config (dev, i, BUCKET_CAPACITY_ACCESS));</span>
<span class="c">    count += sprintf (page+count, &quot;.\n&quot;);</span>
<span class="c">    return count;</span>
<span class="c">  }</span>
<span class="cp">#endif</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="o">--</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sprintf</span> <span class="p">(</span><span class="n">page</span><span class="p">,</span>
		    <span class="s">&quot;cells: TX %lu, RX %lu, HEC errors %lu, unassigned %lu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_cell_count</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_cell_count</span><span class="p">,</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hec_error_count</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">unassigned_cell_count</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="o">--</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sprintf</span> <span class="p">(</span><span class="n">page</span><span class="p">,</span>
		    <span class="s">&quot;free cell buffers: TX %hu, RX %hu+%hu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">TX_FREE_BUFFER_COUNT_OFF</span><span class="p">),</span>
		    <span class="n">rd_regw</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">RX_FREE_BUFFER_COUNT_OFF</span><span class="p">),</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">noof_spare_buffers</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="o">--</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sprintf</span> <span class="p">(</span><span class="n">page</span><span class="p">,</span>
		    <span class="s">&quot;cps remaining: TX %u, RX %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_avail</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_avail</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">atmdev_ops</span> <span class="n">hrz_ops</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">hrz_open</span><span class="p">,</span>
  <span class="p">.</span><span class="n">close</span>	<span class="o">=</span> <span class="n">hrz_close</span><span class="p">,</span>
  <span class="p">.</span><span class="n">send</span>	<span class="o">=</span> <span class="n">hrz_send</span><span class="p">,</span>
  <span class="p">.</span><span class="n">proc_read</span>	<span class="o">=</span> <span class="n">hrz_proc_read</span><span class="p">,</span>
  <span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hrz_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pci_ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrz_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-218"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-218">&#182;</a></div><p>adapter slot free, read resources from PCI configuration space</p></td><td class="code"><div class="highlight"><pre>	<span class="n">u32</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">pci_resource_start</span> <span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span> <span class="n">membase</span> <span class="o">=</span> <span class="n">bus_to_virt</span> <span class="p">(</span><span class="n">pci_resource_start</span> <span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lat</span><span class="p">;</span>

	<span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;hrz_probe&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* XXX DEV_LABEL is a guess */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">HRZ_IO_EXTENT</span><span class="p">,</span> <span class="n">DEV_LABEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_disable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hrz_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-219"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-219">&#182;</a></div><p>perhaps we should be nice: deregister all adapters and abort?</p></td><td class="code"><div class="highlight"><pre>		<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;out of memory&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-220"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-220">&#182;</a></div><p>grab IRQ and install handler - move this someplace more sensible</p></td><td class="code"><div class="highlight"><pre>	<span class="n">irq</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span>
			<span class="n">interrupt_handler</span><span class="p">,</span>
			<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="cm">/* irqflags guess */</span>
			<span class="n">DEV_LABEL</span><span class="p">,</span> <span class="cm">/* name guess */</span>
			<span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_WARN</span><span class="p">,</span> <span class="s">&quot;request IRQ failed!&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_INFO</span><span class="p">,</span> <span class="s">&quot;found Madge ATM adapter (hrz) at: IO %x, IRQ %u, MEM %p&quot;</span><span class="p">,</span>
	       <span class="n">iobase</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">membase</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span> <span class="o">=</span> <span class="n">atm_dev_register</span><span class="p">(</span><span class="n">DEV_LABEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrz_ops</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_ERR</span><span class="p">,</span> <span class="s">&quot;failed to register Madge ATM adapter&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_INFO</span><span class="p">,</span> <span class="s">&quot;registered Madge ATM adapter (no. %d) (%p) at %p&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">dev_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="p">;</span> </pre></div></td></tr>


<tr id="section-221"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-221">&#182;</a></div><p>enable bus master accesses</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-222"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-222">&#182;</a></div><p>frobnicate latency (upwards, usually)</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_lat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_INFO</span><span class="p">,</span> <span class="s">&quot;%s PCI latency timer from %hu to %hu&quot;</span><span class="p">,</span>
		       <span class="s">&quot;changing&quot;</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">pci_lat</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="n">pci_lat</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lat</span> <span class="o">&lt;</span> <span class="n">MIN_PCI_LATENCY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PRINTK</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;%s PCI latency timer from %hu to %hu&quot;</span><span class="p">,</span>
		       <span class="s">&quot;increasing&quot;</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">MIN_PCI_LATENCY</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="n">MIN_PCI_LATENCY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span> 
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">=</span> <span class="n">membase</span><span class="p">;</span> 

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_entry</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_reset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">rx_q_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_q_wrap</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">memmap</span><span class="o">-&gt;</span><span class="n">rx_q_entries</span><span class="p">[</span><span class="n">RX_CHANS</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-223"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-223">&#182;</a></div><p>these next three are performance hacks</p></td><td class="code"><div class="highlight"><pre>	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_last</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_regions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_iovec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_cell_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_cell_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hec_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">unassigned_cell_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">noof_spare_buffers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TX_CHANS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_channel_record</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-224"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-224">&#182;</a></div><p>Allocate cell rates and remember ASIC version
Fibre: ATM<em>OC3</em>PCR = 1555200000/8/270<em>260/53 - 29/53
Copper: (WRONG) we want 6 into the above, close to 25Mb/s
Copper: (plagarise!) 25600000/8/270</em>260/53 - n/53</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">hrz_init</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-225"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-225">&#182;</a></div><p>to be really pedantic, this should be ATM<em>OC3c</em>PCR</p></td><td class="code"><div class="highlight"><pre>		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_avail</span> <span class="o">=</span> <span class="n">ATM_OC3_PCR</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_avail</span> <span class="o">=</span> <span class="n">ATM_OC3_PCR</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ultra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span> <span class="c1">// NOT &quot;|= ultra&quot; !</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_avail</span> <span class="o">=</span> <span class="p">((</span><span class="mi">25600000</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">26</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">27</span><span class="o">*</span><span class="mi">53</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_avail</span> <span class="o">=</span> <span class="p">((</span><span class="mi">25600000</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">26</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">27</span><span class="o">*</span><span class="mi">53</span><span class="p">);</span>
		<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_WARN</span><span class="p">,</span> <span class="s">&quot;Buggy ASIC: no TX bus-mastering.&quot;</span><span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-226"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-226">&#182;</a></div><p>rate changes spinlock</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rate_lock</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-227"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-227">&#182;</a></div><p>on-board memory access spinlock; we want atomic reads and
writes to adapter memory (handles IRQ and SMP)</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-228"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-228">&#182;</a></div><p>vpi in 0..4, vci in 6..10</p></td><td class="code"><div class="highlight"><pre>	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">ci_range</span><span class="p">.</span><span class="n">vpi_bits</span> <span class="o">=</span> <span class="n">vpi_bits</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="o">-&gt;</span><span class="n">ci_range</span><span class="p">.</span><span class="n">vci_bits</span> <span class="o">=</span> <span class="mi">10</span><span class="o">-</span><span class="n">vpi_bits</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">housekeeping</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">housekeeping</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">do_housekeeping</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">housekeeping</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">housekeeping</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out_release:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">HRZ_IO_EXTENT</span><span class="p">);</span>
<span class="nl">out_disable:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">hrz_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrz_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">PRINTD</span><span class="p">(</span><span class="n">DBG_INFO</span><span class="p">,</span> <span class="s">&quot;closing %p (atm_dev = %p)&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">housekeeping</span><span class="p">);</span>
	<span class="n">hrz_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">atm_dev_deregister</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">atm_dev</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">,</span> <span class="n">HRZ_IO_EXTENT</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">hrz_check_args</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_HORIZON</span>
  <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="s">&quot;debug bitmap is %hx&quot;</span><span class="p">,</span> <span class="n">debug</span> <span class="o">&amp;=</span> <span class="n">DBG_MASK</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="s">&quot;no debug support in this image&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">vpi_bits</span> <span class="o">&gt;</span> <span class="n">HRZ_MAX_VPI</span><span class="p">)</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;vpi_bits has been limited to %hu&quot;</span><span class="p">,</span>
	    <span class="n">vpi_bits</span> <span class="o">=</span> <span class="n">HRZ_MAX_VPI</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">max_tx_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">max_tx_size</span> <span class="o">&gt;</span> <span class="n">TX_AAL5_LIMIT</span><span class="p">)</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="s">&quot;max_tx_size has been limited to %hu&quot;</span><span class="p">,</span>
	    <span class="n">max_tx_size</span> <span class="o">=</span> <span class="n">TX_AAL5_LIMIT</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">max_rx_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">max_rx_size</span> <span class="o">&gt;</span> <span class="n">RX_AAL5_LIMIT</span><span class="p">)</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="s">&quot;max_rx_size has been limited to %hu&quot;</span><span class="p">,</span>
	    <span class="n">max_rx_size</span> <span class="o">=</span> <span class="n">RX_AAL5_LIMIT</span><span class="p">);</span>
  
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">maintainer_string</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">description_string</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">vpi_bits</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_tx_size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_rx_size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">pci_lat</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;debug bitmap, see .h file&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">vpi_bits</span><span class="p">,</span> <span class="s">&quot;number of bits (0..4) to allocate to VPIs&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_tx_size</span><span class="p">,</span> <span class="s">&quot;maximum size of TX AAL5 frames&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_rx_size</span><span class="p">,</span> <span class="s">&quot;maximum size of RX AAL5 frames&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">pci_lat</span><span class="p">,</span> <span class="s">&quot;PCI latency in bus cycles&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">hrz_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_MADGE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_MADGE_HORIZON</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
	  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">hrz_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">hrz_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;horizon&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">hrz_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span>	<span class="n">__devexit_p</span><span class="p">(</span><span class="n">hrz_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">hrz_pci_tbl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/********** module entry **********/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hrz_module_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-229"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-229">&#182;</a></div><p>sanity check - cast is needed since printk does not support %Zu</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MEMMAP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTK</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Fix struct MEMMAP (is %lu fakewords).&quot;</span><span class="p">,</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MEMMAP</span><span class="p">));</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">show_version</span><span class="p">();</span>
  </pre></div></td></tr>


<tr id="section-230"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-230">&#182;</a></div><p>check arguments</p></td><td class="code"><div class="highlight"><pre>  <span class="n">hrz_check_args</span><span class="p">();</span>
  </pre></div></td></tr>


<tr id="section-231"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-231">&#182;</a></div><p>get the juice</p></td><td class="code"><div class="highlight"><pre>  <span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrz_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********** module exit **********/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hrz_module_exit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">PRINTD</span> <span class="p">(</span><span class="n">DBG_FLOW</span><span class="p">,</span> <span class="s">&quot;cleanup_module&quot;</span><span class="p">);</span>

  <span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrz_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">hrz_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hrz_module_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
