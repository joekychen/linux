<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › firmware › google › gsmi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>gsmi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Google Inc. All Rights Reserved.</span>
<span class="cm"> * Author: dlaurie@google.com (Duncan Laurie)</span>
<span class="cm"> *</span>
<span class="cm"> * Re-worked to expose sysfs APIs by mikew@google.com (Mike Waychison)</span>
<span class="cm"> *</span>
<span class="cm"> * EFI SMI interface for Google platforms</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#define GSMI_SHUTDOWN_CLEAN	0	</span><span class="cm">/* Clean Shutdown */</span><span class="cp"></span>
<span class="cm">/* TODO(mikew@google.com): Tie in HARDLOCKUP_DETECTOR with NMIWDT */</span>
<span class="cp">#define GSMI_SHUTDOWN_NMIWDT	1	</span><span class="cm">/* NMI Watchdog */</span><span class="cp"></span>
<span class="cp">#define GSMI_SHUTDOWN_PANIC	2	</span><span class="cm">/* Panic */</span><span class="cp"></span>
<span class="cp">#define GSMI_SHUTDOWN_OOPS	3	</span><span class="cm">/* Oops */</span><span class="cp"></span>
<span class="cp">#define GSMI_SHUTDOWN_DIE	4	</span><span class="cm">/* Die -- No longer meaningful */</span><span class="cp"></span>
<span class="cp">#define GSMI_SHUTDOWN_MCE	5	</span><span class="cm">/* Machine Check */</span><span class="cp"></span>
<span class="cp">#define GSMI_SHUTDOWN_SOFTWDT	6	</span><span class="cm">/* Software Watchdog */</span><span class="cp"></span>
<span class="cp">#define GSMI_SHUTDOWN_MBE	7	</span><span class="cm">/* Uncorrected ECC */</span><span class="cp"></span>
<span class="cp">#define GSMI_SHUTDOWN_TRIPLE	8	</span><span class="cm">/* Triple Fault */</span><span class="cp"></span>

<span class="cp">#define DRIVER_VERSION		&quot;1.0&quot;</span>
<span class="cp">#define GSMI_GUID_SIZE		16</span>
<span class="cp">#define GSMI_BUF_SIZE		1024</span>
<span class="cp">#define GSMI_BUF_ALIGN		sizeof(u64)</span>
<span class="cp">#define GSMI_CALLBACK		0xef</span>

<span class="cm">/* SMI return codes */</span>
<span class="cp">#define GSMI_SUCCESS		0x00</span>
<span class="cp">#define GSMI_UNSUPPORTED2	0x03</span>
<span class="cp">#define GSMI_LOG_FULL		0x0b</span>
<span class="cp">#define GSMI_VAR_NOT_FOUND	0x0e</span>
<span class="cp">#define GSMI_HANDSHAKE_SPIN	0x7d</span>
<span class="cp">#define GSMI_HANDSHAKE_CF	0x7e</span>
<span class="cp">#define GSMI_HANDSHAKE_NONE	0x7f</span>
<span class="cp">#define GSMI_INVALID_PARAMETER	0x82</span>
<span class="cp">#define GSMI_UNSUPPORTED	0x83</span>
<span class="cp">#define GSMI_BUFFER_TOO_SMALL	0x85</span>
<span class="cp">#define GSMI_NOT_READY		0x86</span>
<span class="cp">#define GSMI_DEVICE_ERROR	0x87</span>
<span class="cp">#define GSMI_NOT_FOUND		0x8e</span>

<span class="cp">#define QUIRKY_BOARD_HASH 0x78a30a50</span>

<span class="cm">/* Internally used commands passed to the firmware */</span>
<span class="cp">#define GSMI_CMD_GET_NVRAM_VAR		0x01</span>
<span class="cp">#define GSMI_CMD_GET_NEXT_VAR		0x02</span>
<span class="cp">#define GSMI_CMD_SET_NVRAM_VAR		0x03</span>
<span class="cp">#define GSMI_CMD_SET_EVENT_LOG		0x08</span>
<span class="cp">#define GSMI_CMD_CLEAR_EVENT_LOG	0x09</span>
<span class="cp">#define GSMI_CMD_CLEAR_CONFIG		0x20</span>
<span class="cp">#define GSMI_CMD_HANDSHAKE_TYPE		0xC1</span>

<span class="cm">/* Magic entry type for kernel events */</span>
<span class="cp">#define GSMI_LOG_ENTRY_TYPE_KERNEL     0xDEAD</span>

<span class="cm">/* SMI buffers must be in 32bit physical address space */</span>
<span class="k">struct</span> <span class="n">gsmi_buf</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>			<span class="cm">/* start of buffer */</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>			<span class="cm">/* length of buffer */</span>
	<span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">;</span>		<span class="cm">/* dma allocation handle */</span>
	<span class="n">u32</span> <span class="n">address</span><span class="p">;</span>			<span class="cm">/* physical address of buffer */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">gsmi_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>	<span class="cm">/* platform device */</span>
	<span class="k">struct</span> <span class="n">gsmi_buf</span> <span class="o">*</span><span class="n">name_buf</span><span class="p">;</span>	<span class="cm">/* variable name buffer */</span>
	<span class="k">struct</span> <span class="n">gsmi_buf</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">;</span>	<span class="cm">/* generic data buffer */</span>
	<span class="k">struct</span> <span class="n">gsmi_buf</span> <span class="o">*</span><span class="n">param_buf</span><span class="p">;</span>	<span class="cm">/* parameter buffer */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>		<span class="cm">/* serialize access to SMIs */</span>
	<span class="n">u16</span> <span class="n">smi_cmd</span><span class="p">;</span>			<span class="cm">/* SMI command port */</span>
	<span class="kt">int</span> <span class="n">handshake_type</span><span class="p">;</span>		<span class="cm">/* firmware handler interlock type */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span> <span class="o">*</span><span class="n">dma_pool</span><span class="p">;</span>	<span class="cm">/* DMA buffer pool */</span>
<span class="p">}</span> <span class="n">gsmi_dev</span><span class="p">;</span>

<span class="cm">/* Packed structures for communicating with the firmware */</span>
<span class="k">struct</span> <span class="n">gsmi_nvram_var_param</span> <span class="p">{</span>
	<span class="n">efi_guid_t</span>	<span class="n">guid</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">name_ptr</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">attributes</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">data_len</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">data_ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">gsmi_get_next_var_param</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">guid</span><span class="p">[</span><span class="n">GSMI_GUID_SIZE</span><span class="p">];</span>
	<span class="n">u32</span>	<span class="n">name_ptr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">name_len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">gsmi_set_eventlog_param</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">data_ptr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">data_len</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Event log formats */</span>
<span class="k">struct</span> <span class="n">gsmi_log_entry_type_1</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="n">type</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">instance</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Some platforms don&#39;t have explicit SMI handshake</span>
<span class="cm"> * and need to wait for SMI to complete.</span>
<span class="cm"> */</span>
<span class="cp">#define GSMI_DEFAULT_SPINCOUNT	0x10000</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spincount</span> <span class="o">=</span> <span class="n">GSMI_DEFAULT_SPINCOUNT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">spincount</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">spincount</span><span class="p">,</span>
	<span class="s">&quot;The number of loop iterations to use when using the spin handshake.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">gsmi_buf</span> <span class="o">*</span><span class="nf">gsmi_buf_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsmi_buf</span> <span class="o">*</span><span class="n">smibuf</span><span class="p">;</span>

	<span class="n">smibuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">smibuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smibuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate buffer in 32bit address space */</span>
	<span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">dma_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: failed to allocate name buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">smibuf</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fill in the buffer handle */</span>
	<span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">GSMI_BUF_SIZE</span><span class="p">;</span>
	<span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">smibuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmi_buf_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsmi_buf</span> <span class="o">*</span><span class="n">smibuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smibuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
			<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">dma_pool</span><span class="p">,</span> <span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				      <span class="n">smibuf</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">smibuf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make a call to gsmi func(sub).  GSMI error codes are translated to</span>
<span class="cm"> * in-kernel errnos (0 on success, -ERRNO on error).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmi_exec</span><span class="p">(</span><span class="n">u8</span> <span class="n">func</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * AH  : Subfunction number</span>
<span class="cm">	 * AL  : Function number</span>
<span class="cm">	 * EBX : Parameter block address</span>
<span class="cm">	 * DX  : SMI command port</span>
<span class="cm">	 *</span>
<span class="cm">	 * Three protocols here. See also the comment in gsmi_init().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">handshake_type</span> <span class="o">==</span> <span class="n">GSMI_HANDSHAKE_CF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If handshake_type == HANDSHAKE_CF then set CF on the</span>
<span class="cm">		 * way in and wait for the handler to clear it; this avoids</span>
<span class="cm">		 * corrupting register state on those chipsets which have</span>
<span class="cm">		 * a delay between writing the SMI trigger register and</span>
<span class="cm">		 * entering SMM.</span>
<span class="cm">		 */</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
			<span class="s">&quot;stc</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;outb %%al, %%dx</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;1:      jc 1b</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
			  <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">smi_cmd</span><span class="p">),</span>
			  <span class="s">&quot;b&quot;</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span>
		<span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">handshake_type</span> <span class="o">==</span> <span class="n">GSMI_HANDSHAKE_SPIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If handshake_type == HANDSHAKE_SPIN we spin a</span>
<span class="cm">		 * hundred-ish usecs to ensure the SMI has triggered.</span>
<span class="cm">		 */</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
			<span class="s">&quot;outb %%al, %%dx</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;1:      loop 1b</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
			  <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">smi_cmd</span><span class="p">),</span>
			  <span class="s">&quot;b&quot;</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">),</span>
			  <span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">spincount</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span>
		<span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If handshake_type == HANDSHAKE_NONE we do nothing;</span>
<span class="cm">		 * either we don&#39;t need to or it&#39;s legacy firmware that</span>
<span class="cm">		 * doesn&#39;t understand the CF protocol.</span>
<span class="cm">		 */</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
			<span class="s">&quot;outb %%al, %%dx</span><span class="se">\n\t</span><span class="s">&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
			  <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">smi_cmd</span><span class="p">),</span>
			  <span class="s">&quot;b&quot;</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span>
		<span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* check return code from SMI handler */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GSMI_SUCCESS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_VAR_NOT_FOUND</span>:
		<span class="cm">/* not really an error, but let the caller know */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_INVALID_PARAMETER</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Invalid parameter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_BUFFER_TOO_SMALL</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Buffer too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_UNSUPPORTED</span>:
	<span class="k">case</span> <span class="n">GSMI_UNSUPPORTED2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">!=</span> <span class="n">GSMI_CMD_HANDSHAKE_TYPE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_NOT_READY</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_DEVICE_ERROR</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Device error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_NOT_FOUND</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Data not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_LOG_FULL</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Log full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMI_HANDSHAKE_CF</span>:
	<span class="k">case</span> <span class="n">GSMI_HANDSHAKE_SPIN</span>:
	<span class="k">case</span> <span class="n">GSMI_HANDSHAKE_NONE</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: exec 0x%04x: Unknown error 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cmd</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the number of unicode characters in data */</span>
<span class="k">static</span> <span class="kt">size_t</span>
<span class="nf">utf16_strlen</span><span class="p">(</span><span class="n">efi_char16_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxlength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">++</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">maxlength</span><span class="p">)</span>
		<span class="n">length</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">efi_status_t</span> <span class="nf">gsmi_get_variable</span><span class="p">(</span><span class="n">efi_char16_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				      <span class="n">efi_guid_t</span> <span class="o">*</span><span class="n">vendor</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">data_size</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsmi_nvram_var_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name_ptr</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">*</span><span class="n">data_size</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">efi_status_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_SUCCESS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">name_len</span> <span class="o">=</span> <span class="n">utf16_strlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GSMI_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">&gt;=</span> <span class="n">GSMI_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFI_BAD_BUFFER_SIZE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Vendor guid */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">,</span> <span class="n">vendor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">));</span>

	<span class="cm">/* variable name, already in UTF-16 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* data pointer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="cm">/* parameter buffer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_GET_NVRAM_VAR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: Get Variable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_LOAD_ERROR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* variable was not found */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_NOT_FOUND</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Get the arguments back */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

		<span class="cm">/* The size reported is the min of all of our buffers */</span>
		<span class="o">*</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="o">*</span><span class="n">data_size</span><span class="p">,</span>
						<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="o">*</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="o">*</span><span class="n">data_size</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">data_len</span><span class="p">);</span>

		<span class="cm">/* Copy data back to return buffer. */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">data_size</span><span class="p">);</span>

		<span class="cm">/* All variables are have the following attributes */</span>
		<span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="n">EFI_VARIABLE_NON_VOLATILE</span> <span class="o">|</span>
			<span class="n">EFI_VARIABLE_BOOTSERVICE_ACCESS</span> <span class="o">|</span>
			<span class="n">EFI_VARIABLE_RUNTIME_ACCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">efi_status_t</span> <span class="nf">gsmi_get_next_variable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">name_size</span><span class="p">,</span>
					   <span class="n">efi_char16_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					   <span class="n">efi_guid_t</span> <span class="o">*</span><span class="n">vendor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsmi_get_next_var_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name_ptr</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">efi_status_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_SUCCESS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* For the moment, only support buffers that exactly match in size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">name_size</span> <span class="o">!=</span> <span class="n">GSMI_BUF_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFI_BAD_BUFFER_SIZE</span><span class="p">;</span>

	<span class="cm">/* Let&#39;s make sure the thing is at least null-terminated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">utf16_strlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GSMI_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">GSMI_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFI_INVALID_PARAMETER</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* guid */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">,</span> <span class="n">vendor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">));</span>

	<span class="cm">/* variable name, already in UTF-16 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">name_size</span><span class="p">);</span>

	<span class="cm">/* parameter buffer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_GET_NEXT_VAR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: Get Next Variable Name failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_LOAD_ERROR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* variable not found -- end of list */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_NOT_FOUND</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* copy variable data back to return buffer */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

		<span class="cm">/* Copy the name back */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">GSMI_BUF_SIZE</span><span class="p">);</span>
		<span class="o">*</span><span class="n">name_size</span> <span class="o">=</span> <span class="n">utf16_strlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GSMI_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* copy guid to return buffer */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">efi_status_t</span> <span class="nf">gsmi_set_variable</span><span class="p">(</span><span class="n">efi_char16_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				      <span class="n">efi_guid_t</span> <span class="o">*</span><span class="n">vendor</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">attr</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_size</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsmi_nvram_var_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name_ptr</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">data_size</span><span class="p">,</span>
		<span class="p">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">EFI_VARIABLE_NON_VOLATILE</span> <span class="o">|</span>
			      <span class="n">EFI_VARIABLE_BOOTSERVICE_ACCESS</span> <span class="o">|</span>
			      <span class="n">EFI_VARIABLE_RUNTIME_ACCESS</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">size_t</span> <span class="n">name_len</span> <span class="o">=</span> <span class="n">utf16_strlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GSMI_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">efi_status_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_SUCCESS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">&gt;=</span> <span class="n">GSMI_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFI_BAD_BUFFER_SIZE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* guid */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">,</span> <span class="n">vendor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">guid</span><span class="p">));</span>

	<span class="cm">/* variable name, already in UTF-16 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* data pointer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>

	<span class="cm">/* parameter buffer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_SET_NVRAM_VAR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: Set Variable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">EFI_INVALID_PARAMETER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">efivar_operations</span> <span class="n">efivar_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_variable</span> <span class="o">=</span> <span class="n">gsmi_get_variable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_variable</span> <span class="o">=</span> <span class="n">gsmi_set_variable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_next_variable</span> <span class="o">=</span> <span class="n">gsmi_get_next_variable</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">eventlog_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsmi_set_eventlog_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Pull the type out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">param</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/* The remaining buffer is the data payload */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">param</span><span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* data pointer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">data_len</span><span class="p">);</span>

	<span class="cm">/* parameter buffer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_SET_EVENT_LOG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: Set Event Log failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">eventlog_bin_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;append_to_eventlog&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0200</span><span class="p">},</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">eventlog_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gsmi_clear_eventlog_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">percentage</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">data_type</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">param</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Value entered is a percentage, 0 through 100, anything else</span>
<span class="cm">	 * is invalid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* data_type here selects the smbios event log. */</span>
	<span class="n">param</span><span class="p">.</span><span class="n">percentage</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">param</span><span class="p">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* parameter buffer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_CLEAR_EVENT_LOG</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">gsmi_clear_eventlog_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;clear_eventlog&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0200</span><span class="p">},</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">gsmi_clear_eventlog_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gsmi_clear_config_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* clear parameter buffer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_CLEAR_CONFIG</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">gsmi_clear_config_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;clear_config&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0200</span><span class="p">},</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">gsmi_clear_config_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">gsmi_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">gsmi_clear_config_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">gsmi_clear_eventlog_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmi_shutdown_reason</span><span class="p">(</span><span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsmi_log_entry_type_1</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">type</span>     <span class="o">=</span> <span class="n">GSMI_LOG_ENTRY_TYPE_KERNEL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">reason</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">gsmi_set_eventlog_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span>
		<span class="p">.</span><span class="n">type</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">saved_reason</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* avoid duplicate entries in the log */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">saved_reason</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">reason</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">saved_reason</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">reason</span><span class="p">);</span>

	<span class="cm">/* data pointer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>

	<span class="cm">/* parameter buffer */</span>
	<span class="n">param</span><span class="p">.</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_SET_EVENT_LOG</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: Log Shutdown Reason failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;gsmi: Log Shutdown Reason 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">reason</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmi_reboot_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gsmi_shutdown_reason</span><span class="p">(</span><span class="n">GSMI_SHUTDOWN_CLEAN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">gsmi_reboot_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">gsmi_reboot_callback</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmi_die_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">DIE_OOPS</span><span class="p">)</span>
		<span class="n">gsmi_shutdown_reason</span><span class="p">(</span><span class="n">GSMI_SHUTDOWN_OOPS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">gsmi_die_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">gsmi_die_callback</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmi_panic_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gsmi_shutdown_reason</span><span class="p">(</span><span class="n">GSMI_SHUTDOWN_PANIC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">gsmi_panic_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">gsmi_panic_callback</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This hash function was blatantly copied from include/linux/hash.h.</span>
<span class="cm"> * It is used by this driver to obfuscate a board name that requires a</span>
<span class="cm"> * quirk within this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Please do not remove this copy of the function as any changes to the</span>
<span class="cm"> * global utility hash_64() function would break this driver&#39;s ability</span>
<span class="cm"> * to identify a board and provide the appropriate quirk -- mikew@google.com</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__init</span> <span class="nf">local_hash_64</span><span class="p">(</span><span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/*  Sigh, gcc can&#39;t optimise this alone like it does for 32 bits. */</span>
	<span class="n">u64</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">18</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">33</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* High bits are more random, so use them. */</span>
	<span class="k">return</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">__init</span> <span class="nf">hash_oem_table_id</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">input</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">local_hash_64</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">gsmi_dmi_table</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;Google Board&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BOARD_VENDOR</span><span class="p">,</span> <span class="s">&quot;Google, Inc.&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">dmi</span><span class="p">,</span> <span class="n">gsmi_dmi_table</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">gsmi_system_valid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmi_check_system</span><span class="p">(</span><span class="n">gsmi_dmi_table</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only newer firmware supports the gsmi interface.  All older</span>
<span class="cm">	 * firmware that didn&#39;t support this interface used to plug the</span>
<span class="cm">	 * table name in the first four bytes of the oem_table_id field.</span>
<span class="cm">	 * Newer firmware doesn&#39;t do that though, so use that as the</span>
<span class="cm">	 * discriminant factor.  We have to do this in order to</span>
<span class="cm">	 * whitewash our board names out of the public driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">oem_table_id</span><span class="p">,</span> <span class="s">&quot;FACP&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;gsmi: Board is too old</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable on board with 1.0 BIOS due to Google bug 2602657 */</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_oem_table_id</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">oem_table_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">==</span> <span class="n">QUIRKY_BOARD_HASH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bios_ver</span> <span class="o">=</span> <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">bios_ver</span><span class="p">,</span> <span class="s">&quot;1.0&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;gsmi: disabled on this board&#39;s BIOS %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bios_ver</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* check for valid SMI command port in ACPI FADT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">smi_command</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;gsmi: missing smi_command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Found */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">gsmi_kobj</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">efivars</span> <span class="n">efivars</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">gsmi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gsmi_system_valid</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">smi_cmd</span> <span class="o">=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">smi_command</span><span class="p">;</span>

	<span class="cm">/* register device */</span>
	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">platform_device_register_simple</span><span class="p">(</span><span class="s">&quot;gsmi&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: unable to register platform device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* SMI access needs to be serialized */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* SMI callbacks require 32bit addresses */</span>
	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">dma_pool</span> <span class="o">=</span> <span class="n">dma_pool_create</span><span class="p">(</span><span class="s">&quot;gsmi&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">GSMI_BUF_SIZE</span><span class="p">,</span> <span class="n">GSMI_BUF_ALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">dma_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pre-allocate buffers because sometimes we are called when</span>
<span class="cm">	 * this is not feasible: oops, panic, die, mce, etc</span>
<span class="cm">	 */</span>
	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span> <span class="o">=</span> <span class="n">gsmi_buf_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: failed to allocate name buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span> <span class="o">=</span> <span class="n">gsmi_buf_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: failed to allocate data buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span> <span class="o">=</span> <span class="n">gsmi_buf_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gsmi: failed to allocate param buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine type of handshake used to serialize the SMI</span>
<span class="cm">	 * entry. See also gsmi_exec().</span>
<span class="cm">	 *</span>
<span class="cm">	 * There&#39;s a &quot;behavior&quot; present on some chipsets where writing the</span>
<span class="cm">	 * SMI trigger register in the southbridge doesn&#39;t result in an</span>
<span class="cm">	 * immediate SMI. Rather, the processor can execute &quot;a few&quot; more</span>
<span class="cm">	 * instructions before the SMI takes effect. To ensure synchronous</span>
<span class="cm">	 * behavior, implement a handshake between the kernel driver and the</span>
<span class="cm">	 * firmware handler to spin until released. This ioctl determines</span>
<span class="cm">	 * the type of handshake.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NONE: The firmware handler does not implement any</span>
<span class="cm">	 * handshake. Either it doesn&#39;t need to, or it&#39;s legacy firmware</span>
<span class="cm">	 * that doesn&#39;t know it needs to and never will.</span>
<span class="cm">	 *</span>
<span class="cm">	 * CF: The firmware handler will clear the CF in the saved</span>
<span class="cm">	 * state before returning. The driver may set the CF and test for</span>
<span class="cm">	 * it to clear before proceeding.</span>
<span class="cm">	 *</span>
<span class="cm">	 * SPIN: The firmware handler does not implement any handshake</span>
<span class="cm">	 * but the driver should spin for a hundred or so microseconds</span>
<span class="cm">	 * to ensure the SMI has triggered.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Finally, the handler will return -ENOSYS if</span>
<span class="cm">	 * GSMI_CMD_HANDSHAKE_TYPE is unimplemented, which implies</span>
<span class="cm">	 * HANDSHAKE_NONE.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">handshake_type</span> <span class="o">=</span> <span class="n">GSMI_HANDSHAKE_SPIN</span><span class="p">;</span>
	<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">handshake_type</span> <span class="o">=</span>
	    <span class="n">gsmi_exec</span><span class="p">(</span><span class="n">GSMI_CALLBACK</span><span class="p">,</span> <span class="n">GSMI_CMD_HANDSHAKE_TYPE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">handshake_type</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span>
		<span class="n">gsmi_dev</span><span class="p">.</span><span class="n">handshake_type</span> <span class="o">=</span> <span class="n">GSMI_HANDSHAKE_NONE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Remove and clean up gsmi if the handshake could not complete. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">handshake_type</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;gsmi version &quot;</span> <span class="n">DRIVER_VERSION</span>
		       <span class="s">&quot; failed to load</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register in the firmware directory */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">gsmi_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;gsmi&quot;</span><span class="p">,</span> <span class="n">firmware_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsmi_kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;gsmi: Failed to create firmware kobj</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup eventlog access */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventlog_bin_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;gsmi: Failed to setup eventlog&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Other attributes */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sysfs_create_files</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">,</span> <span class="n">gsmi_attrs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;gsmi: Failed to add attrs&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_remove_bin_file</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_efivars</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efivars</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efivar_ops</span><span class="p">,</span> <span class="n">gsmi_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;gsmi: Failed to register efivars</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_remove_sysfs_files</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_reboot_notifier</span><span class="p">);</span>
	<span class="n">register_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_die_notifier</span><span class="p">);</span>
	<span class="n">atomic_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">panic_notifier_list</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">gsmi_panic_notifier</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;gsmi version &quot;</span> <span class="n">DRIVER_VERSION</span> <span class="s">&quot; loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_remove_sysfs_files:</span>
	<span class="n">sysfs_remove_files</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">,</span> <span class="n">gsmi_attrs</span><span class="p">);</span>
<span class="nl">out_remove_bin_file:</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventlog_bin_attr</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">);</span>
	<span class="n">gsmi_buf_free</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="p">);</span>
	<span class="n">gsmi_buf_free</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="p">);</span>
	<span class="n">gsmi_buf_free</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">dma_pool</span><span class="p">)</span>
		<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">dma_pool</span><span class="p">);</span>
	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;gsmi: failed to load: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">gsmi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_reboot_notifier</span><span class="p">);</span>
	<span class="n">unregister_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsmi_die_notifier</span><span class="p">);</span>
	<span class="n">atomic_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">panic_notifier_list</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">gsmi_panic_notifier</span><span class="p">);</span>
	<span class="n">unregister_efivars</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efivars</span><span class="p">);</span>

	<span class="n">sysfs_remove_files</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">,</span> <span class="n">gsmi_attrs</span><span class="p">);</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventlog_bin_attr</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">gsmi_kobj</span><span class="p">);</span>
	<span class="n">gsmi_buf_free</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">param_buf</span><span class="p">);</span>
	<span class="n">gsmi_buf_free</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">data_buf</span><span class="p">);</span>
	<span class="n">gsmi_buf_free</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">name_buf</span><span class="p">);</span>
	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">dma_pool</span><span class="p">);</span>
	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">gsmi_dev</span><span class="p">.</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">gsmi_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">gsmi_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Google, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
