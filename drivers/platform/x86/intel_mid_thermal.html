<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › platform › x86 › intel_mid_thermal.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>intel_mid_thermal.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * intel_mid_thermal.c - Intel MID platform thermal driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Intel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.        See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> * Author: Durgadoss R &lt;durgadoss.r@intel.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) &quot;intel_mid_thermal: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/thermal.h&gt;</span>
<span class="cp">#include &lt;linux/mfd/intel_msic.h&gt;</span>

<span class="cm">/* Number of thermal sensors */</span>
<span class="cp">#define MSIC_THERMAL_SENSORS	4</span>

<span class="cm">/* ADC1 - thermal registers */</span>
<span class="cp">#define MSIC_ADC_ENBL		0x10</span>
<span class="cp">#define MSIC_ADC_START		0x08</span>

<span class="cp">#define MSIC_ADCTHERM_ENBL	0x04</span>
<span class="cp">#define MSIC_ADCRRDATA_ENBL	0x05</span>
<span class="cp">#define MSIC_CHANL_MASK_VAL	0x0F</span>

<span class="cp">#define MSIC_STOPBIT_MASK	16</span>
<span class="cp">#define MSIC_ADCTHERM_MASK	4</span>
<span class="cm">/* Number of ADC channels */</span>
<span class="cp">#define ADC_CHANLS_MAX		15</span>
<span class="cp">#define ADC_LOOP_MAX		(ADC_CHANLS_MAX - MSIC_THERMAL_SENSORS)</span>

<span class="cm">/* ADC channel code values */</span>
<span class="cp">#define SKIN_SENSOR0_CODE	0x08</span>
<span class="cp">#define SKIN_SENSOR1_CODE	0x09</span>
<span class="cp">#define SYS_SENSOR_CODE		0x0A</span>
<span class="cp">#define MSIC_DIE_SENSOR_CODE	0x03</span>

<span class="cp">#define SKIN_THERM_SENSOR0	0</span>
<span class="cp">#define SKIN_THERM_SENSOR1	1</span>
<span class="cp">#define SYS_THERM_SENSOR2	2</span>
<span class="cp">#define MSIC_DIE_THERM_SENSOR3	3</span>

<span class="cm">/* ADC code range */</span>
<span class="cp">#define ADC_MAX			977</span>
<span class="cp">#define ADC_MIN			162</span>
<span class="cp">#define ADC_VAL0C		887</span>
<span class="cp">#define ADC_VAL20C		720</span>
<span class="cp">#define ADC_VAL40C		508</span>
<span class="cp">#define ADC_VAL60C		315</span>

<span class="cm">/* ADC base addresses */</span>
<span class="cp">#define ADC_CHNL_START_ADDR	INTEL_MSIC_ADC1ADDR0	</span><span class="cm">/* increments by 1 */</span><span class="cp"></span>
<span class="cp">#define ADC_DATA_START_ADDR	INTEL_MSIC_ADC1SNS0H	</span><span class="cm">/* increments by 2 */</span><span class="cp"></span>

<span class="cm">/* MSIC die attributes */</span>
<span class="cp">#define MSIC_DIE_ADC_MIN	488</span>
<span class="cp">#define MSIC_DIE_ADC_MAX	1004</span>

<span class="cm">/* This holds the address of the first free ADC channel,</span>
<span class="cm"> * among the 15 channels</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">channel_index</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">platform_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thermal_zone_device</span> <span class="o">*</span><span class="n">tzd</span><span class="p">[</span><span class="n">MSIC_THERMAL_SENSORS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">thermal_device_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chnl_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">direct</span><span class="p">;</span>
	<span class="cm">/* This holds the current temperature in millidegree celsius */</span>
	<span class="kt">long</span> <span class="n">curr_temp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * to_msic_die_temp - converts adc_val to msic_die temperature</span>
<span class="cm"> * @adc_val: ADC value to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">to_msic_die_temp</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">adc_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">368</span> <span class="o">*</span> <span class="p">(</span><span class="n">adc_val</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">-</span> <span class="mi">220</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_valid_adc - checks whether the adc code is within the defined range</span>
<span class="cm"> * @min: minimum value for the sensor</span>
<span class="cm"> * @max: maximum value for the sensor</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_valid_adc</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">adc_val</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">min</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">adc_val</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adc_val</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * adc_to_temp - converts the ADC code to temperature in C</span>
<span class="cm"> * @direct: true if ths channel is direct index</span>
<span class="cm"> * @adc_val: the adc_val that needs to be converted</span>
<span class="cm"> * @tp: temperature return value</span>
<span class="cm"> *</span>
<span class="cm"> * Linear approximation is used to covert the skin adc value into temperature.</span>
<span class="cm"> * This technique is used to avoid very long look-up table to get</span>
<span class="cm"> * the appropriate temp value from ADC value.</span>
<span class="cm"> * The adc code vs sensor temp curve is split into five parts</span>
<span class="cm"> * to achieve very close approximate temp value with less than</span>
<span class="cm"> * 0.5C error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">adc_to_temp</span><span class="p">(</span><span class="kt">int</span> <span class="n">direct</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">adc_val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* Direct conversion for die temperature */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direct</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_adc</span><span class="p">(</span><span class="n">adc_val</span><span class="p">,</span> <span class="n">MSIC_DIE_ADC_MIN</span><span class="p">,</span> <span class="n">MSIC_DIE_ADC_MAX</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">to_msic_die_temp</span><span class="p">(</span><span class="n">adc_val</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_adc</span><span class="p">(</span><span class="n">adc_val</span><span class="p">,</span> <span class="n">ADC_MIN</span><span class="p">,</span> <span class="n">ADC_MAX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

	<span class="cm">/* Linear approximation for skin temperature */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adc_val</span> <span class="o">&gt;</span> <span class="n">ADC_VAL0C</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="mi">177</span> <span class="o">-</span> <span class="p">(</span><span class="n">adc_val</span><span class="o">/</span><span class="mi">5</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">adc_val</span> <span class="o">&lt;=</span> <span class="n">ADC_VAL0C</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adc_val</span> <span class="o">&gt;</span> <span class="n">ADC_VAL20C</span><span class="p">))</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="mi">111</span> <span class="o">-</span> <span class="p">(</span><span class="n">adc_val</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">adc_val</span> <span class="o">&lt;=</span> <span class="n">ADC_VAL20C</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adc_val</span> <span class="o">&gt;</span> <span class="n">ADC_VAL40C</span><span class="p">))</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="mi">92</span> <span class="o">-</span> <span class="p">(</span><span class="n">adc_val</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">adc_val</span> <span class="o">&lt;=</span> <span class="n">ADC_VAL40C</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adc_val</span> <span class="o">&gt;</span> <span class="n">ADC_VAL60C</span><span class="p">))</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="mi">91</span> <span class="o">-</span> <span class="p">(</span><span class="n">adc_val</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="mi">112</span> <span class="o">-</span> <span class="p">(</span><span class="n">adc_val</span><span class="o">/</span><span class="mi">6</span><span class="p">);</span>

	<span class="cm">/* Convert temperature in celsius to milli degree celsius */</span>
	<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mid_read_temp - read sensors for temperature</span>
<span class="cm"> * @temp: holds the current temperature for the sensor after reading</span>
<span class="cm"> *</span>
<span class="cm"> * reads the adc_code from the channel and converts it to real</span>
<span class="cm"> * temperature. The converted value is stored in temp.</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mid_read_temp</span><span class="p">(</span><span class="k">struct</span> <span class="n">thermal_zone_device</span> <span class="o">*</span><span class="n">tzd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">temp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thermal_device_info</span> <span class="o">*</span><span class="n">td_info</span> <span class="o">=</span> <span class="n">tzd</span><span class="o">-&gt;</span><span class="n">devdata</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">adc_val</span><span class="p">,</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_temp</span><span class="p">;</span>


	<span class="n">addr</span> <span class="o">=</span> <span class="n">td_info</span><span class="o">-&gt;</span><span class="n">chnl_addr</span><span class="p">;</span>

	<span class="cm">/* Enable the msic for conversion before reading */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">INTEL_MSIC_ADC1CNTL3</span><span class="p">,</span> <span class="n">MSIC_ADCRRDATA_ENBL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Re-toggle the RRDATARD bit (temporary workaround) */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">INTEL_MSIC_ADC1CNTL3</span><span class="p">,</span> <span class="n">MSIC_ADCTHERM_ENBL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Read the higher bits of data */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_read</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Shift bits to accommodate the lower two data bits */</span>
	<span class="n">adc_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">addr</span><span class="o">++</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_read</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span><span class="cm">/* Read lower bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Adding lower two bits to the higher bits */</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="mo">03</span><span class="p">;</span>
	<span class="n">adc_val</span> <span class="o">+=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Convert ADC value to temperature */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">adc_to_temp</span><span class="p">(</span><span class="n">td_info</span><span class="o">-&gt;</span><span class="n">direct</span><span class="p">,</span> <span class="n">adc_val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr_temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">td_info</span><span class="o">-&gt;</span><span class="n">curr_temp</span> <span class="o">=</span> <span class="n">curr_temp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * configure_adc - enables/disables the ADC for conversion</span>
<span class="cm"> * @val: zero: disables the ADC non-zero:enables the ADC</span>
<span class="cm"> *</span>
<span class="cm"> * Enable/Disable the ADC depending on the argument</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">configure_adc</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_read</span><span class="p">(</span><span class="n">INTEL_MSIC_ADC1CNTL1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable and start the ADC */</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MSIC_ADC_ENBL</span> <span class="o">|</span> <span class="n">MSIC_ADC_START</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Just stop the ADC */</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">MSIC_ADC_START</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">INTEL_MSIC_ADC1CNTL1</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_up_therm_channel - enable thermal channel for conversion</span>
<span class="cm"> * @base_addr: index of free msic ADC channel</span>
<span class="cm"> *</span>
<span class="cm"> * Enable all the three channels for conversion</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_up_therm_channel</span><span class="p">(</span><span class="n">u16</span> <span class="n">base_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Enable all the sensor channels */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">SKIN_SENSOR0_CODE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SKIN_SENSOR1_CODE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SYS_SENSOR_CODE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Since this is the last channel, set the stop bit</span>
<span class="cm">	 * to 1 by ORing the DIE_SENSOR_CODE with 0x10 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
			<span class="p">(</span><span class="n">MSIC_DIE_SENSOR_CODE</span> <span class="o">|</span> <span class="mh">0x10</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Enable ADC and start it */</span>
	<span class="k">return</span> <span class="n">configure_adc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reset_stopbit - sets the stop bit to 0 on the given channel</span>
<span class="cm"> * @addr: address of the channel</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_stopbit</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_read</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Set the stop bit to zero */</span>
	<span class="k">return</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xEF</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_free_channel - finds an empty channel for conversion</span>
<span class="cm"> *</span>
<span class="cm"> * If the ADC is not enabled then start using 0th channel</span>
<span class="cm"> * itself. Otherwise find an empty channel by looking for a</span>
<span class="cm"> * channel in which the stopbit is set to 1. returns the index</span>
<span class="cm"> * of the first free channel if succeeds or an error code.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Ultimately the channel allocator will move into the intel_scu_ipc</span>
<span class="cm"> * code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_free_channel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* check whether ADC is enabled */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_read</span><span class="p">(</span><span class="n">INTEL_MSIC_ADC1CNTL1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">MSIC_ADC_ENBL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ADC is already enabled; Looking for an empty channel */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ADC_CHANLS_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_read</span><span class="p">(</span><span class="n">ADC_CHNL_START_ADDR</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">MSIC_STOPBIT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="n">ADC_LOOP_MAX</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mid_initialize_adc - initializing the ADC</span>
<span class="cm"> * @dev: our device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the ADC for reading thermistor values. Can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mid_initialize_adc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>  <span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">base_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that adctherm is disabled before we</span>
<span class="cm">	 * initialize the ADC</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_read</span><span class="p">(</span><span class="n">INTEL_MSIC_ADC1CNTL3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSIC_ADCTHERM_MASK</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_msic_reg_write</span><span class="p">(</span><span class="n">INTEL_MSIC_ADC1CNTL3</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Index of the first channel in which the stop bit is set */</span>
	<span class="n">channel_index</span> <span class="o">=</span> <span class="n">find_free_channel</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No free ADC channels&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">channel_index</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">base_addr</span> <span class="o">=</span> <span class="n">ADC_CHNL_START_ADDR</span> <span class="o">+</span> <span class="n">channel_index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">channel_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">channel_index</span> <span class="o">==</span> <span class="n">ADC_LOOP_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Reset stop bit for channels other than 0 and 12 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reset_stopbit</span><span class="p">(</span><span class="n">base_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Index of the first free channel */</span>
		<span class="n">base_addr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">channel_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_up_therm_channel</span><span class="p">(</span><span class="n">base_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to enable ADC&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ADC initialization successful&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * initialize_sensor - sets default temp and timer ranges</span>
<span class="cm"> * @index: index of the sensor</span>
<span class="cm"> *</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">thermal_device_info</span> <span class="o">*</span><span class="nf">initialize_sensor</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thermal_device_info</span> <span class="o">*</span><span class="n">td_info</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thermal_device_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td_info</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Set the base addr of the channel for this sensor */</span>
	<span class="n">td_info</span><span class="o">-&gt;</span><span class="n">chnl_addr</span> <span class="o">=</span> <span class="n">ADC_DATA_START_ADDR</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">channel_index</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
	<span class="cm">/* Sensor 3 is direct conversion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">td_info</span><span class="o">-&gt;</span><span class="n">direct</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">td_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mid_thermal_resume - resume routine</span>
<span class="cm"> * @pdev: platform device structure</span>
<span class="cm"> *</span>
<span class="cm"> * mid thermal resume: re-initializes the adc. Can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mid_thermal_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mid_initialize_adc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mid_thermal_suspend - suspend routine</span>
<span class="cm"> * @pdev: platform device structure</span>
<span class="cm"> *</span>
<span class="cm"> * mid thermal suspend implements the suspend functionality</span>
<span class="cm"> * by stopping the ADC. Can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mid_thermal_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This just stops the ADC and does not disable it.</span>
<span class="cm">	 * temporary workaround until we have a generic ADC driver.</span>
<span class="cm">	 * If 0 is passed, it disables the ADC.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">configure_adc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_curr_temp - reads the current temperature and stores in temp</span>
<span class="cm"> * @temp: holds the current temperature value after reading</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_curr_temp</span><span class="p">(</span><span class="k">struct</span> <span class="n">thermal_zone_device</span> <span class="o">*</span><span class="n">tzd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">temp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tzd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mid_read_temp</span><span class="p">(</span><span class="n">tzd</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Can&#39;t be const */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">thermal_zone_device_ops</span> <span class="n">tzd_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_temp</span> <span class="o">=</span> <span class="n">read_curr_temp</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * mid_thermal_probe - mfld thermal initialize</span>
<span class="cm"> * @pdev: platform device structure</span>
<span class="cm"> *</span>
<span class="cm"> * mid thermal probe initializes the hardware and registers</span>
<span class="cm"> * all the sensors with the generic thermal framework. Can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mid_thermal_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="n">MSIC_THERMAL_SENSORS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;skin0&quot;</span><span class="p">,</span> <span class="s">&quot;skin1&quot;</span><span class="p">,</span> <span class="s">&quot;sys&quot;</span><span class="p">,</span> <span class="s">&quot;msicdie&quot;</span>
	<span class="p">};</span>

	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_info</span> <span class="o">*</span><span class="n">pinfo</span><span class="p">;</span>

	<span class="n">pinfo</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinfo</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Initializing the hardware */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mid_initialize_adc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ADC init failed&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pinfo</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register each sensor with the generic thermal framework*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MSIC_THERMAL_SENSORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">thermal_device_info</span> <span class="o">*</span><span class="n">td_info</span> <span class="o">=</span> <span class="n">initialize_sensor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">td_info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">tzd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermal_zone_device_register</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="mi">0</span><span class="p">,</span> <span class="n">td_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tzd_ops</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">tzd</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">td_info</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">tzd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pinfo</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">tzd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">devdata</span><span class="p">);</span>
		<span class="n">thermal_zone_device_unregister</span><span class="p">(</span><span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">tzd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">configure_adc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pinfo</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mid_thermal_remove - mfld thermal finalize</span>
<span class="cm"> * @dev: platform device structure</span>
<span class="cm"> *</span>
<span class="cm"> * MLFD thermal remove unregisters all the sensors from the generic</span>
<span class="cm"> * thermal framework. Can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mid_thermal_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_info</span> <span class="o">*</span><span class="n">pinfo</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MSIC_THERMAL_SENSORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">tzd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">devdata</span><span class="p">);</span>
		<span class="n">thermal_zone_device_unregister</span><span class="p">(</span><span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">tzd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pinfo</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Stop the ADC */</span>
	<span class="k">return</span> <span class="n">configure_adc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define DRIVER_NAME &quot;msic_thermal&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">platform_device_id</span> <span class="n">therm_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">DRIVER_NAME</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;msic_thermal&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">mid_thermal_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">mid_thermal_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">mid_thermal_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">mid_thermal_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">mid_thermal_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">therm_id_table</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">mid_thermal_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Durgadoss R &lt;durgadoss.r@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel Medfield Platform Thermal Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
