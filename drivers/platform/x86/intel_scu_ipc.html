<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › platform › x86 › intel_scu_ipc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>intel_scu_ipc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * intel_scu_ipc.c: Driver for the Intel SCU IPC mechanism</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2008-2010 Intel Corporation</span>
<span class="cm"> * Author: Sreedhara DS (sreedhara.ds@intel.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; version 2</span>
<span class="cm"> * of the License.</span>
<span class="cm"> *</span>
<span class="cm"> * SCU running in ARC processor communicates with other entity running in IA</span>
<span class="cm"> * core through IPC mechanism which in turn messaging between IA core ad SCU.</span>
<span class="cm"> * SCU has two IPC mechanism IPC-1 and IPC-2. IPC-1 is used between IA32 and</span>
<span class="cm"> * SCU where IPC-2 is used between P-Unit and SCU. This driver delas with</span>
<span class="cm"> * IPC-1 Driver provides an API for power control unit registers (e.g. MSIC)</span>
<span class="cm"> * along with other APIs.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/sfi.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/mrst.h&gt;</span>
<span class="cp">#include &lt;asm/intel_scu_ipc.h&gt;</span>

<span class="cm">/* IPC defines the following message types */</span>
<span class="cp">#define IPCMSG_WATCHDOG_TIMER 0xF8 </span><span class="cm">/* Set Kernel Watchdog Threshold */</span><span class="cp"></span>
<span class="cp">#define IPCMSG_BATTERY        0xEF </span><span class="cm">/* Coulomb Counter Accumulator */</span><span class="cp"></span>
<span class="cp">#define IPCMSG_FW_UPDATE      0xFE </span><span class="cm">/* Firmware update */</span><span class="cp"></span>
<span class="cp">#define IPCMSG_PCNTRL         0xFF </span><span class="cm">/* Power controller unit read/write */</span><span class="cp"></span>
<span class="cp">#define IPCMSG_FW_REVISION    0xF4 </span><span class="cm">/* Get firmware revision */</span><span class="cp"></span>

<span class="cm">/* Command id associated with message IPCMSG_PCNTRL */</span>
<span class="cp">#define IPC_CMD_PCNTRL_W      0 </span><span class="cm">/* Register write */</span><span class="cp"></span>
<span class="cp">#define IPC_CMD_PCNTRL_R      1 </span><span class="cm">/* Register read */</span><span class="cp"></span>
<span class="cp">#define IPC_CMD_PCNTRL_M      2 </span><span class="cm">/* Register read-modify-write */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * IPC register summary</span>
<span class="cm"> *</span>
<span class="cm"> * IPC register blocks are memory mapped at fixed address of 0xFF11C000</span>
<span class="cm"> * To read or write information to the SCU, driver writes to IPC-1 memory</span>
<span class="cm"> * mapped registers (base address 0xFF11C000). The following is the IPC</span>
<span class="cm"> * mechanism</span>
<span class="cm"> *</span>
<span class="cm"> * 1. IA core cDMI interface claims this transaction and converts it to a</span>
<span class="cm"> *    Transaction Layer Packet (TLP) message which is sent across the cDMI.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. South Complex cDMI block receives this message and writes it to</span>
<span class="cm"> *    the IPC-1 register block, causing an interrupt to the SCU</span>
<span class="cm"> *</span>
<span class="cm"> * 3. SCU firmware decodes this interrupt and IPC message and the appropriate</span>
<span class="cm"> *    message handler is called within firmware.</span>
<span class="cm"> */</span>

<span class="cp">#define IPC_BASE_ADDR     0xFF11C000	</span><span class="cm">/* IPC1 base register address */</span><span class="cp"></span>
<span class="cp">#define IPC_MAX_ADDR      0x100		</span><span class="cm">/* Maximum IPC regisers */</span><span class="cp"></span>
<span class="cp">#define IPC_WWBUF_SIZE    20		</span><span class="cm">/* IPC Write buffer Size */</span><span class="cp"></span>
<span class="cp">#define IPC_RWBUF_SIZE    20		</span><span class="cm">/* IPC Read buffer Size */</span><span class="cp"></span>
<span class="cp">#define IPC_I2C_BASE      0xFF12B000	</span><span class="cm">/* I2C control register base address */</span><span class="cp"></span>
<span class="cp">#define IPC_I2C_MAX_ADDR  0x10		</span><span class="cm">/* Maximum I2C regisers */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ipc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ipc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">intel_scu_ipc_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ipc_base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">i2c_base</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">intel_scu_ipc_dev</span>  <span class="n">ipcdev</span><span class="p">;</span> <span class="cm">/* Only one for now */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">platform</span><span class="p">;</span>		<span class="cm">/* Platform type */</span>

<span class="cm">/*</span>
<span class="cm"> * IPC Read Buffer (Read Only):</span>
<span class="cm"> * 16 byte buffer for receiving data from SCU, if IPC command</span>
<span class="cm"> * processing results in response data</span>
<span class="cm"> */</span>
<span class="cp">#define IPC_READ_BUFFER		0x90</span>

<span class="cp">#define IPC_I2C_CNTRL_ADDR	0</span>
<span class="cp">#define I2C_DATA_ADDR		0x04</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ipclock</span><span class="p">);</span> <span class="cm">/* lock used to prevent multiple call to SCU */</span>

<span class="cm">/*</span>
<span class="cm"> * Command Register (Write Only):</span>
<span class="cm"> * A write to this register results in an interrupt to the SCU core processor</span>
<span class="cm"> * Format:</span>
<span class="cm"> * |rfu2(8) | size(8) | command id(4) | rfu1(3) | ioc(1) | command(8)|</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipc_command</span><span class="p">(</span><span class="n">u32</span> <span class="n">cmd</span><span class="p">)</span> <span class="cm">/* Send ipc command */</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IPC Write Buffer (Write Only):</span>
<span class="cm"> * 16-byte buffer for sending data associated with IPC command to</span>
<span class="cm"> * SCU. Size of the data is specified in the IPC_COMMAND_REG register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipc_data_writel</span><span class="p">(</span><span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span> <span class="cm">/* Write ipc data */</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span> <span class="o">+</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Status Register (Read Only):</span>
<span class="cm"> * Driver will read this register to get the ready/busy status of the IPC</span>
<span class="cm"> * block and error status of the IPC command that was just processed by SCU</span>
<span class="cm"> * Format:</span>
<span class="cm"> * |rfu3(8)|error code(8)|initiator id(8)|cmd id(4)|rfu1(2)|error(1)|busy(1)|</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ipc_read_status</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span> <span class="o">+</span> <span class="mh">0x04</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ipc_data_readb</span><span class="p">(</span><span class="n">u32</span> <span class="n">offset</span><span class="p">)</span> <span class="cm">/* Read ipc byte data */</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span> <span class="o">+</span> <span class="n">IPC_READ_BUFFER</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipc_data_readl</span><span class="p">(</span><span class="n">u32</span> <span class="n">offset</span><span class="p">)</span> <span class="cm">/* Read ipc u32 data */</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span> <span class="o">+</span> <span class="n">IPC_READ_BUFFER</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">busy_loop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="cm">/* Wait till scu status is busy */</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">loop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ipc_read_status</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* scu processing time is in few u secods */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ipc_read_status</span><span class="p">();</span>
		<span class="n">loop_count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* break if scu doesn&#39;t reset busy bit after huge retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loop_count</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IPC timed out&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Read/Write power control(PMIC in Langwell, MSIC in PenWell) registers */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pwr_reg_rdwr</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cbuf</span><span class="p">[</span><span class="n">IPC_WWBUF_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cbuf</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cbuf</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">nc</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">[</span><span class="n">nc</span><span class="p">];</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">IPC_CMD_PCNTRL_R</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">nc</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">ipc_data_writel</span><span class="p">(</span><span class="n">wbuf</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">ipc_command</span><span class="p">((</span><span class="n">count</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>  <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">IPC_CMD_PCNTRL_W</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">nc</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">cbuf</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">nc</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">nc</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">ipc_data_writel</span><span class="p">(</span><span class="n">wbuf</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">ipc_command</span><span class="p">((</span><span class="n">count</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>  <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">IPC_CMD_PCNTRL_M</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">ipc_data_writel</span><span class="p">(</span><span class="n">wbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* Write wbuff */</span>
		<span class="n">ipc_command</span><span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>  <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">busy_loop</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">IPC_CMD_PCNTRL_R</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Read rbuf */</span>
		<span class="cm">/* Workaround: values are read as 0 without memcpy_fromio */</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span> <span class="o">+</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">nc</span><span class="o">++</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipc_data_readb</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_ioread8		-	read a word via the SCU</span>
<span class="cm"> *	@addr: register on SCU</span>
<span class="cm"> *	@data: return pointer for read byte</span>
<span class="cm"> *</span>
<span class="cm"> *	Read a single register. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_ioread8</span><span class="p">(</span><span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_R</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_ioread8</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_ioread16		-	read a word via the SCU</span>
<span class="cm"> *	@addr: register on SCU</span>
<span class="cm"> *	@data: return pointer for read word</span>
<span class="cm"> *</span>
<span class="cm"> *	Read a register pair. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_ioread16</span><span class="p">(</span><span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_R</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_ioread16</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_ioread32		-	read a dword via the SCU</span>
<span class="cm"> *	@addr: register on SCU</span>
<span class="cm"> *	@data: return pointer for read dword</span>
<span class="cm"> *</span>
<span class="cm"> *	Read four registers. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_ioread32</span><span class="p">(</span><span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">};</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_R</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_ioread32</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_iowrite8		-	write a byte via the SCU</span>
<span class="cm"> *	@addr: register on SCU</span>
<span class="cm"> *	@data: byte to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a single register. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_iowrite8</span><span class="p">(</span><span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_W</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_iowrite8</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_iowrite16		-	write a word via the SCU</span>
<span class="cm"> *	@addr: register on SCU</span>
<span class="cm"> *	@data: word to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write two registers. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_iowrite16</span><span class="p">(</span><span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_W</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_iowrite16</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_iowrite32		-	write a dword via the SCU</span>
<span class="cm"> *	@addr: register on SCU</span>
<span class="cm"> *	@data: dword to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write four registers. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_iowrite32</span><span class="p">(</span><span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">};</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_W</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_iowrite32</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_readvv		-	read a set of registers</span>
<span class="cm"> *	@addr: register list</span>
<span class="cm"> *	@data: bytes to return</span>
<span class="cm"> *	@len: length of array</span>
<span class="cm"> *</span>
<span class="cm"> *	Read registers. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	The largest array length permitted by the hardware is 5 items.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_readv</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_R</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_readv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_writev		-	write a set of registers</span>
<span class="cm"> *	@addr: register list</span>
<span class="cm"> *	@data: bytes to write</span>
<span class="cm"> *	@len: length of array</span>
<span class="cm"> *</span>
<span class="cm"> *	Write registers. Returns 0 on success or an error code. All</span>
<span class="cm"> *	locking between SCU accesses is handled for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	The largest array length permitted by the hardware is 5 items.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_writev</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_W</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_writev</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_update_register	-	r/m/w a register</span>
<span class="cm"> *	@addr: register address</span>
<span class="cm"> *	@bits: bits to update</span>
<span class="cm"> *	@mask: mask of bits to update</span>
<span class="cm"> *</span>
<span class="cm"> *	Read-modify-write power control unit register. The first data argument</span>
<span class="cm"> *	must be register value and second is mask value</span>
<span class="cm"> *	mask is a bitmap that indicates which bits to update.</span>
<span class="cm"> *	0 = masked. Don&#39;t modify this bit, 1 = modify this bit.</span>
<span class="cm"> *	returns 0 on success or an error code.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep. Locking between SCU accesses is handled</span>
<span class="cm"> *	for the caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_update_register</span><span class="p">(</span><span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bits</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">bits</span><span class="p">,</span> <span class="n">mask</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">pwr_reg_rdwr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPCMSG_PCNTRL</span><span class="p">,</span> <span class="n">IPC_CMD_PCNTRL_M</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_update_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_simple_command	-	send a simple command</span>
<span class="cm"> *	@cmd: command</span>
<span class="cm"> *	@sub: sub type</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue a simple command to the SCU. Do not use this interface if</span>
<span class="cm"> *	you must then access data as any data values may be overwritten</span>
<span class="cm"> *	by another SCU access by the time this function returns.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may sleep. Locking for SCU accesses is handled for</span>
<span class="cm"> *	the caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_simple_command</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ipc_command</span><span class="p">(</span><span class="n">sub</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">busy_loop</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_simple_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_command	-	command with data</span>
<span class="cm"> *	@cmd: command</span>
<span class="cm"> *	@sub: sub type</span>
<span class="cm"> *	@in: input data</span>
<span class="cm"> *	@inlen: input length in dwords</span>
<span class="cm"> *	@out: output data</span>
<span class="cm"> *	@outlein: output length in dwords</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue a command to the SCU which involves data transfers. Do the</span>
<span class="cm"> *	data copies under the lock but leave it for the caller to interpret</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">intel_scu_ipc_command</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sub</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inlen</span><span class="p">,</span>
							<span class="n">u32</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">outlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ipc_data_writel</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="o">++</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">ipc_command</span><span class="p">((</span><span class="n">inlen</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">busy_loop</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">outlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="n">ipc_data_readl</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_command</span><span class="p">);</span>

<span class="cm">/*I2C commands */</span>
<span class="cp">#define IPC_I2C_WRITE 1 </span><span class="cm">/* I2C Write command */</span><span class="cp"></span>
<span class="cp">#define IPC_I2C_READ  2 </span><span class="cm">/* I2C Read command */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> *	intel_scu_ipc_i2c_cntrl		-	I2C read/write operations</span>
<span class="cm"> *	@addr: I2C address + command bits</span>
<span class="cm"> *	@data: data to read/write</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform an an I2C read/write operation via the SCU. All locking is</span>
<span class="cm"> *	handled for the caller. This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns an error code or 0 on success.</span>
<span class="cm"> *</span>
<span class="cm"> *	This has to be in the IPC driver for the locking.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_scu_ipc_i2c_cntrl</span><span class="p">(</span><span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">IPC_I2C_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ipcdev</span><span class="p">.</span><span class="n">i2c_base</span> <span class="o">+</span> <span class="n">IPC_I2C_CNTRL_ADDR</span><span class="p">);</span>
		<span class="cm">/* Write not getting updated without delay */</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">i2c_base</span> <span class="o">+</span> <span class="n">I2C_DATA_ADDR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">IPC_I2C_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">ipcdev</span><span class="p">.</span><span class="n">i2c_base</span> <span class="o">+</span> <span class="n">I2C_DATA_ADDR</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ipcdev</span><span class="p">.</span><span class="n">i2c_base</span> <span class="o">+</span> <span class="n">IPC_I2C_CNTRL_ADDR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;intel_scu_ipc: I2C INVALID_CMD = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipclock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">intel_scu_ipc_i2c_cntrl</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler gets called when ioc bit of IPC_COMMAND_REG set to 1</span>
<span class="cm"> * When ioc bit is set to 1, caller api must wait for interrupt handler called</span>
<span class="cm"> * which in turn unlocks the caller api. Currently this is not used</span>
<span class="cm"> *</span>
<span class="cm"> * This is edge triggered so we need take no action to clear anything</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ioc</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ipc_probe	-	probe an Intel SCU IPC</span>
<span class="cm"> *	@dev: the PCI device matching</span>
<span class="cm"> *	@id: entry in the match table</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable and install an intel SCU IPC. This appears in the PCI space</span>
<span class="cm"> *	but uses some hard coded addresses as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">pci_resource</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span><span class="p">)</span>		<span class="cm">/* We support only one SCU */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_dev_get</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;intel_scu_ipc&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_resource</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_resource</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ioc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;intel_scu_ipc&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipcdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">IPC_BASE_ADDR</span><span class="p">,</span> <span class="n">IPC_MAX_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ipcdev</span><span class="p">.</span><span class="n">i2c_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">IPC_I2C_BASE</span><span class="p">,</span> <span class="n">IPC_I2C_MAX_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">i2c_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">intel_scu_devices_create</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ipc_remove	-	remove a bound IPC device</span>
<span class="cm"> *	@pdev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> *	In practice the SCU is not removable but this function is also</span>
<span class="cm"> *	called for each device on a module unload or cleanup which is the</span>
<span class="cm"> *	path that will get used.</span>
<span class="cm"> *</span>
<span class="cm"> *	Free up the mappings and release the PCI resources</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipcdev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">ipc_base</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">ipcdev</span><span class="p">.</span><span class="n">i2c_base</span><span class="p">);</span>
	<span class="n">ipcdev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">intel_scu_devices_destroy</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci_ids</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x082a</span><span class="p">)},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pci_ids</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">ipc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;intel_scu_ipc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">pci_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ipc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">ipc_remove</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">intel_scu_ipc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform</span> <span class="o">=</span> <span class="n">mrst_identify_cpu</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span>  <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipc_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">intel_scu_ipc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipc_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Sreedhara DS &lt;sreedhara.ds@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel SCU IPC driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">intel_scu_ipc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">intel_scu_ipc_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
