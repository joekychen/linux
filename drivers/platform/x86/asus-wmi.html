<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › platform › x86 › asus-wmi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>asus-wmi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Asus PC WMI hotkey driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(C) 2010 Intel Corporation.</span>
<span class="cm"> * Copyright(C) 2010-2011 Corentin Chary &lt;corentin.chary@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Portions based on wistron_btns.c:</span>
<span class="cm"> * Copyright (C) 2005 Miloslav Trmac &lt;mitr@volny.cz&gt;</span>
<span class="cm"> * Copyright (C) 2005 Bernhard Rosenkraenzer &lt;bero@arklinux.org&gt;</span>
<span class="cm"> * Copyright (C) 2005 Dmitry Torokhov &lt;dtor@mail.ru&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/input.h&gt;</span>
<span class="cp">#include &lt;linux/input/sparse-keymap.h&gt;</span>
<span class="cp">#include &lt;linux/fb.h&gt;</span>
<span class="cp">#include &lt;linux/backlight.h&gt;</span>
<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;linux/rfkill.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pci_hotplug.h&gt;</span>
<span class="cp">#include &lt;linux/hwmon.h&gt;</span>
<span class="cp">#include &lt;linux/hwmon-sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/thermal.h&gt;</span>
<span class="cp">#include &lt;acpi/acpi_bus.h&gt;</span>
<span class="cp">#include &lt;acpi/acpi_drivers.h&gt;</span>

<span class="cp">#include &quot;asus-wmi.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Corentin Chary &lt;corentincj@iksaif.net&gt;, &quot;</span>
	      <span class="s">&quot;Yong Wang &lt;yong.y.wang@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Asus Generic WMI Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cp">#define to_platform_driver(drv)					\</span>
<span class="cp">	(container_of((drv), struct platform_driver, driver))</span>

<span class="cp">#define to_asus_wmi_driver(pdrv)					\</span>
<span class="cp">	(container_of((pdrv), struct asus_wmi_driver, platform_driver))</span>

<span class="cp">#define ASUS_WMI_MGMT_GUID	&quot;97845ED0-4E6D-11DE-8A39-0800200C9A66&quot;</span>

<span class="cp">#define NOTIFY_BRNUP_MIN		0x11</span>
<span class="cp">#define NOTIFY_BRNUP_MAX		0x1f</span>
<span class="cp">#define NOTIFY_BRNDOWN_MIN		0x20</span>
<span class="cp">#define NOTIFY_BRNDOWN_MAX		0x2e</span>
<span class="cp">#define NOTIFY_KBD_BRTUP		0xc4</span>
<span class="cp">#define NOTIFY_KBD_BRTDWN		0xc5</span>

<span class="cm">/* WMI Methods */</span>
<span class="cp">#define ASUS_WMI_METHODID_SPEC	        0x43455053 </span><span class="cm">/* BIOS SPECification */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_SFBD		0x44424653 </span><span class="cm">/* Set First Boot Device */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_GLCD		0x44434C47 </span><span class="cm">/* Get LCD status */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_GPID		0x44495047 </span><span class="cm">/* Get Panel ID?? (Resol) */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_QMOD		0x444F4D51 </span><span class="cm">/* Quiet MODe */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_SPLV		0x4C425053 </span><span class="cm">/* Set Panel Light Value */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_SFUN		0x4E554653 </span><span class="cm">/* FUNCtionalities */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_SDSP		0x50534453 </span><span class="cm">/* Set DiSPlay output */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_GDSP		0x50534447 </span><span class="cm">/* Get DiSPlay output */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_DEVP		0x50564544 </span><span class="cm">/* DEVice Policy */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_OSVR		0x5256534F </span><span class="cm">/* OS VeRsion */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_DSTS		0x53544344 </span><span class="cm">/* Device STatuS */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_DSTS2		0x53545344 </span><span class="cm">/* Device STatuS #2*/</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_BSTS		0x53545342 </span><span class="cm">/* Bios STatuS ? */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_DEVS		0x53564544 </span><span class="cm">/* DEVice Set */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_CFVS		0x53564643 </span><span class="cm">/* CPU Frequency Volt Set */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_KBFT		0x5446424B </span><span class="cm">/* KeyBoard FilTer */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_INIT		0x54494E49 </span><span class="cm">/* INITialize */</span><span class="cp"></span>
<span class="cp">#define ASUS_WMI_METHODID_HKEY		0x59454B48 </span><span class="cm">/* Hot KEY ?? */</span><span class="cp"></span>

<span class="cp">#define ASUS_WMI_UNSUPPORTED_METHOD	0xFFFFFFFE</span>

<span class="cm">/* Wireless */</span>
<span class="cp">#define ASUS_WMI_DEVID_HW_SWITCH	0x00010001</span>
<span class="cp">#define ASUS_WMI_DEVID_WIRELESS_LED	0x00010002</span>
<span class="cp">#define ASUS_WMI_DEVID_CWAP		0x00010003</span>
<span class="cp">#define ASUS_WMI_DEVID_WLAN		0x00010011</span>
<span class="cp">#define ASUS_WMI_DEVID_BLUETOOTH	0x00010013</span>
<span class="cp">#define ASUS_WMI_DEVID_GPS		0x00010015</span>
<span class="cp">#define ASUS_WMI_DEVID_WIMAX		0x00010017</span>
<span class="cp">#define ASUS_WMI_DEVID_WWAN3G		0x00010019</span>
<span class="cp">#define ASUS_WMI_DEVID_UWB		0x00010021</span>

<span class="cm">/* Leds */</span>
<span class="cm">/* 0x000200XX and 0x000400XX */</span>
<span class="cp">#define ASUS_WMI_DEVID_LED1		0x00020011</span>
<span class="cp">#define ASUS_WMI_DEVID_LED2		0x00020012</span>
<span class="cp">#define ASUS_WMI_DEVID_LED3		0x00020013</span>
<span class="cp">#define ASUS_WMI_DEVID_LED4		0x00020014</span>
<span class="cp">#define ASUS_WMI_DEVID_LED5		0x00020015</span>
<span class="cp">#define ASUS_WMI_DEVID_LED6		0x00020016</span>

<span class="cm">/* Backlight and Brightness */</span>
<span class="cp">#define ASUS_WMI_DEVID_BACKLIGHT	0x00050011</span>
<span class="cp">#define ASUS_WMI_DEVID_BRIGHTNESS	0x00050012</span>
<span class="cp">#define ASUS_WMI_DEVID_KBD_BACKLIGHT	0x00050021</span>
<span class="cp">#define ASUS_WMI_DEVID_LIGHT_SENSOR	0x00050022 </span><span class="cm">/* ?? */</span><span class="cp"></span>

<span class="cm">/* Misc */</span>
<span class="cp">#define ASUS_WMI_DEVID_CAMERA		0x00060013</span>

<span class="cm">/* Storage */</span>
<span class="cp">#define ASUS_WMI_DEVID_CARDREADER	0x00080013</span>

<span class="cm">/* Input */</span>
<span class="cp">#define ASUS_WMI_DEVID_TOUCHPAD		0x00100011</span>
<span class="cp">#define ASUS_WMI_DEVID_TOUCHPAD_LED	0x00100012</span>

<span class="cm">/* Fan, Thermal */</span>
<span class="cp">#define ASUS_WMI_DEVID_THERMAL_CTRL	0x00110011</span>
<span class="cp">#define ASUS_WMI_DEVID_FAN_CTRL		0x00110012</span>

<span class="cm">/* Power */</span>
<span class="cp">#define ASUS_WMI_DEVID_PROCESSOR_STATE	0x00120012</span>

<span class="cm">/* DSTS masks */</span>
<span class="cp">#define ASUS_WMI_DSTS_STATUS_BIT	0x00000001</span>
<span class="cp">#define ASUS_WMI_DSTS_UNKNOWN_BIT	0x00000002</span>
<span class="cp">#define ASUS_WMI_DSTS_PRESENCE_BIT	0x00010000</span>
<span class="cp">#define ASUS_WMI_DSTS_USER_BIT		0x00020000</span>
<span class="cp">#define ASUS_WMI_DSTS_BIOS_BIT		0x00040000</span>
<span class="cp">#define ASUS_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF</span>
<span class="cp">#define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00</span>

<span class="k">struct</span> <span class="n">bios_args</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">arg0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">arg1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * &lt;platform&gt;/    - debugfs root directory</span>
<span class="cm"> *   dev_id      - current dev_id</span>
<span class="cm"> *   ctrl_param  - current ctrl_param</span>
<span class="cm"> *   method_id   - current method_id</span>
<span class="cm"> *   devs        - call DEVS(dev_id, ctrl_param) and print result</span>
<span class="cm"> *   dsts        - call DSTS(dev_id)  and print result</span>
<span class="cm"> *   call        - call method_id(dev_id, ctrl_param) and print result</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">asus_wmi_debug</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">method_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_param</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dev_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">dsts_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sfun</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">inputdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backlight_device</span> <span class="o">*</span><span class="n">backlight_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwmon_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">platform_device</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">led_classdev</span> <span class="n">tpd_led</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tpd_led_wk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">led_classdev</span> <span class="n">kbd_led</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">kbd_led_wk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">led_workqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tpd_led_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">kbd_led_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="n">wlan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="n">bluetooth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="n">wimax</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="n">wwan3g</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="n">gps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="n">uwb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hotplug_slot</span> <span class="o">*</span><span class="n">hotplug_slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">hotplug_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">wmi_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">hotplug_workqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">hotplug_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">asus_wmi_debug</span> <span class="n">debug</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">asus_wmi_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_input_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span> <span class="o">=</span> <span class="n">input_allocate_device</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">;</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="o">-&gt;</span><span class="n">phys</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">input_phys</span><span class="p">;</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">bustype</span> <span class="o">=</span> <span class="n">BUS_HOST</span><span class="p">;</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EV_REP</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="o">-&gt;</span><span class="n">evbit</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sparse_keymap_setup</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">keymap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_dev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">input_register_device</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_keymap</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free_keymap:</span>
	<span class="n">sparse_keymap_free</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">);</span>
<span class="nl">err_free_dev:</span>
	<span class="n">input_free_device</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_input_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sparse_keymap_free</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">);</span>
		<span class="n">input_unregister_device</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">u32</span> <span class="n">method_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">u32</span> <span class="n">arg1</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="o">*</span><span class="n">retval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bios_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">arg0</span> <span class="o">=</span> <span class="n">arg0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">input</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">acpi_size</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">args</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ACPI_ALLOCATE_BUFFER</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_MGMT_GUID</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">method_id</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="p">)</span><span class="n">output</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ACPI_TYPE_INTEGER</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">ASUS_WMI_UNSUPPORTED_METHOD</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_get_devstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dev_id</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">retval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">dsts_id</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">u32</span> <span class="n">dev_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctrl_param</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="o">*</span><span class="n">retval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_METHODID_DEVS</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span>
					<span class="n">ctrl_param</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Helper for special devices with magic return codes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_get_devstate_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">dev_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">retval</span> <span class="o">&amp;</span> <span class="n">ASUS_WMI_DSTS_PRESENCE_BIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">ASUS_WMI_DSTS_STATUS_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;</span> <span class="n">ASUS_WMI_DSTS_UNKNOWN_BIT</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">asus_wmi_get_devstate_bits</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span>
					  <span class="n">ASUS_WMI_DSTS_STATUS_BIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * LEDs</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * These functions actually update the LED&#39;s, and are called from a</span>
<span class="cm"> * workqueue. By doing this as separate work rather than when the LED</span>
<span class="cm"> * subsystem asks, we avoid messing with the Asus ACPI stuff during a</span>
<span class="cm"> * potentially bad time, such as a timer interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tpd_led_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctrl_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">,</span> <span class="n">tpd_led_work</span><span class="p">);</span>

	<span class="n">ctrl_param</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led_wk</span><span class="p">;</span>
	<span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">ASUS_WMI_DEVID_TOUCHPAD_LED</span><span class="p">,</span> <span class="n">ctrl_param</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tpd_led_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">led_classdev</span> <span class="o">*</span><span class="n">led_cdev</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">led_brightness</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">led_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">,</span> <span class="n">tpd_led</span><span class="p">);</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led_wk</span> <span class="o">=</span> <span class="o">!!</span><span class="n">value</span><span class="p">;</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">led_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_tpd_led_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_TOUCHPAD_LED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">led_brightness</span> <span class="nf">tpd_led_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">led_classdev</span> <span class="o">*</span><span class="n">led_cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">led_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">,</span> <span class="n">tpd_led</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">read_tpd_led_state</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kbd_led_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctrl_param</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">,</span> <span class="n">kbd_led_work</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * bits 0-2: level</span>
<span class="cm">	 * bit 7: light on/off</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led_wk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctrl_param</span> <span class="o">=</span> <span class="mh">0x80</span> <span class="o">|</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led_wk</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">);</span>

	<span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">ASUS_WMI_DEVID_KBD_BACKLIGHT</span><span class="p">,</span> <span class="n">ctrl_param</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kbd_led_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bits 0-2: level</span>
<span class="cm">	 * bit 7: light on/off</span>
<span class="cm">	 * bit 8-10: environment (0: dark, 1: normal, 2: light)</span>
<span class="cm">	 * bit 17: status unknown</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_bits</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_KBD_BACKLIGHT</span><span class="p">,</span>
					    <span class="mh">0xFFFF</span><span class="p">);</span>

	<span class="cm">/* Unknown status is considered as off */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mh">0x8000</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">)</span>
			<span class="o">*</span><span class="n">level</span> <span class="o">=</span> <span class="n">retval</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">)</span>
			<span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kbd_led_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">led_classdev</span> <span class="o">*</span><span class="n">led_cdev</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">led_brightness</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">led_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">,</span> <span class="n">kbd_led</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">.</span><span class="n">max_brightness</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">.</span><span class="n">max_brightness</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led_wk</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">led_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">led_brightness</span> <span class="nf">kbd_led_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">led_classdev</span> <span class="o">*</span><span class="n">led_cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">led_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">,</span> <span class="n">kbd_led</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kbd_led_read</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_led_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">.</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">led_classdev_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led</span><span class="p">.</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">led_classdev_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">led_workqueue</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">led_workqueue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_led_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">led_workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;led_workqueue&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">led_workqueue</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_tpd_led_state</span><span class="p">(</span><span class="n">asus</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led_work</span><span class="p">,</span> <span class="n">tpd_led_update</span><span class="p">);</span>

		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;asus::touchpad&quot;</span><span class="p">;</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led</span><span class="p">.</span><span class="n">brightness_set</span> <span class="o">=</span> <span class="n">tpd_led_set</span><span class="p">;</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led</span><span class="p">.</span><span class="n">brightness_get</span> <span class="o">=</span> <span class="n">tpd_led_get</span><span class="p">;</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led</span><span class="p">.</span><span class="n">max_brightness</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">led_classdev_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">tpd_led</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kbd_led_read</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led_work</span><span class="p">,</span> <span class="n">kbd_led_update</span><span class="p">);</span>

		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;asus::kbd_backlight&quot;</span><span class="p">;</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">.</span><span class="n">brightness_set</span> <span class="o">=</span> <span class="n">kbd_led_set</span><span class="p">;</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">.</span><span class="n">brightness_get</span> <span class="o">=</span> <span class="n">kbd_led_get</span><span class="p">;</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">.</span><span class="n">max_brightness</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">led_classdev_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">kbd_led</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">asus_wmi_led_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * PCI hotplug (for wlan rfkill)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">asus_wlan_rfkill_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WLAN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_rfkill_hotplug</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">blocked</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">absent</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">l</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wmi_lock</span><span class="p">);</span>
	<span class="n">blocked</span> <span class="o">=</span> <span class="n">asus_wlan_rfkill_blocked</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wmi_lock</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span>
		<span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bus</span> <span class="o">=</span> <span class="n">pci_find_bus</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Unable to find PCI bus 1?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_bus_read_config_dword</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PCI_VENDOR_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to read PCI config space?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">absent</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span> <span class="o">!=</span> <span class="n">absent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;BIOS says wireless lan is %s, &quot;</span>
				<span class="s">&quot;but the pci device is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">blocked</span> <span class="o">?</span> <span class="s">&quot;blocked&quot;</span> <span class="o">:</span> <span class="s">&quot;unblocked&quot;</span><span class="p">,</span>
				<span class="n">absent</span> <span class="o">?</span> <span class="s">&quot;absent&quot;</span> <span class="o">:</span> <span class="s">&quot;present&quot;</span><span class="p">);</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;skipped wireless hotplug as probably &quot;</span>
				<span class="s">&quot;inappropriate for this model</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blocked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Device already present */</span>
				<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_scan_single_device</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_bus_assign_resources</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pci_bus_add_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to hotplug wifi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_stop_and_remove_bus_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_rfkill_notify</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">!=</span> <span class="n">ACPI_NOTIFY_BUS_CHECK</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t call directly asus_rfkill_hotplug because most</span>
<span class="cm">	 * of the time WMBC is still being executed and not reetrant.</span>
<span class="cm">	 * There is currently no way to tell ACPICA that  we want this</span>
<span class="cm">	 * method to be serialized, we schedule a asus_rfkill_hotplug</span>
<span class="cm">	 * call later, in a safer context.</span>
<span class="cm">	 */</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_register_rfkill_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_get_handle</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_install_notify_handler</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
						     <span class="n">ACPI_SYSTEM_NOTIFY</span><span class="p">,</span>
						     <span class="n">asus_rfkill_notify</span><span class="p">,</span> <span class="n">asus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Failed to register notify on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_unregister_rfkill_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>
	<span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_get_handle</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_remove_notify_handler</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
						    <span class="n">ACPI_SYSTEM_NOTIFY</span><span class="p">,</span>
						    <span class="n">asus_rfkill_notify</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error removing rfkill notify handler %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_get_adapter_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">hotplug_slot</span> <span class="o">*</span><span class="n">hotplug_slot</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WLAN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="o">!!</span><span class="n">result</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_cleanup_pci_hotplug</span><span class="p">(</span><span class="k">struct</span> <span class="n">hotplug_slot</span> <span class="o">*</span><span class="n">hotplug_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hotplug_slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hotplug_slot_ops</span> <span class="n">asus_hotplug_slot_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_adapter_status</span> <span class="o">=</span> <span class="n">asus_get_adapter_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_power_status</span> <span class="o">=</span> <span class="n">asus_get_adapter_status</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_hotplug_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">,</span> <span class="n">hotplug_work</span><span class="p">);</span>
	<span class="n">asus_rfkill_hotplug</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_setup_pci_hotplug</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pci_find_bus</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to find wifi PCI bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_workqueue</span> <span class="o">=</span>
	    <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;hotplug_workqueue&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_workqueue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_workqueue</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_work</span><span class="p">,</span> <span class="n">asus_hotplug_work</span><span class="p">);</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hotplug_slot</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_slot</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hotplug_slot_info</span><span class="p">),</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_info</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">asus</span><span class="p">;</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asus_cleanup_pci_hotplug</span><span class="p">;</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asus_hotplug_slot_ops</span><span class="p">;</span>
	<span class="n">asus_get_adapter_status</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">adapter_status</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_hp_register</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;asus-wifi&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to register hotplug slot - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_register</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_register:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
<span class="nl">error_info:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="p">);</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">error_slot:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_workqueue</span><span class="p">);</span>
<span class="nl">error_workqueue:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rfkill devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_rfkill_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_param</span> <span class="o">=</span> <span class="o">!</span><span class="n">blocked</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">ctrl_param</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_rfkill_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">asus</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rfkill</span><span class="p">,</span> <span class="o">!</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_rfkill_wlan_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">asus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This handler is enabled only if hotplug is enabled.</span>
<span class="cm">	 * In this case, the asus_wmi_set_devstate() will</span>
<span class="cm">	 * trigger a wmi notification and we need to wait</span>
<span class="cm">	 * this call to finish before being able to call</span>
<span class="cm">	 * any wmi method</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wmi_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">asus_rfkill_set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wmi_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rfkill_ops</span> <span class="n">asus_rfkill_wlan_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set_block</span> <span class="o">=</span> <span class="n">asus_rfkill_wlan_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">asus_rfkill_query</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rfkill_ops</span> <span class="n">asus_rfkill_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set_block</span> <span class="o">=</span> <span class="n">asus_rfkill_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">asus_rfkill_query</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_new_rfkill</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">asus_rfkill</span> <span class="o">*</span><span class="n">arfkill</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">**</span><span class="n">rfkill</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arfkill</span><span class="o">-&gt;</span><span class="n">rfkill</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">arfkill</span><span class="o">-&gt;</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">arfkill</span><span class="o">-&gt;</span><span class="n">asus</span> <span class="o">=</span> <span class="n">asus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_id</span> <span class="o">==</span> <span class="n">ASUS_WMI_DEVID_WLAN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">hotplug_wireless</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">rfkill_alloc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">asus_rfkill_wlan_ops</span><span class="p">,</span> <span class="n">arfkill</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">rfkill_alloc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">asus_rfkill_ops</span><span class="p">,</span> <span class="n">arfkill</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">rfkill</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rfkill_init_sw_state</span><span class="p">(</span><span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="o">!</span><span class="n">result</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">rfkill_register</span><span class="p">(</span><span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_rfkill_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asus_unregister_rfkill_notifier</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">_SB.PCI0.P0P5&quot;</span><span class="p">);</span>
	<span class="n">asus_unregister_rfkill_notifier</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">_SB.PCI0.P0P6&quot;</span><span class="p">);</span>
	<span class="n">asus_unregister_rfkill_notifier</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">_SB.PCI0.P0P7&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_unregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Refresh pci hotplug in case the rfkill state was changed after</span>
<span class="cm">	 * asus_unregister_rfkill_notifier()</span>
<span class="cm">	 */</span>
	<span class="n">asus_rfkill_hotplug</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="p">)</span>
		<span class="n">pci_hp_deregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_slot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_workqueue</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_workqueue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">bluetooth</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_unregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">bluetooth</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">bluetooth</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">bluetooth</span><span class="p">.</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wimax</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_unregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wimax</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wimax</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">wimax</span><span class="p">.</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wwan3g</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_unregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wwan3g</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wwan3g</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">wwan3g</span><span class="p">.</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">gps</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_unregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">gps</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">gps</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">gps</span><span class="p">.</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">uwb</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_unregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">uwb</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">rfkill_destroy</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">uwb</span><span class="p">.</span><span class="n">rfkill</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">uwb</span><span class="p">.</span><span class="n">rfkill</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_rfkill_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">hotplug_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wmi_lock</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_new_rfkill</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">,</span> <span class="s">&quot;asus-wlan&quot;</span><span class="p">,</span>
				 <span class="n">RFKILL_TYPE_WLAN</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WLAN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_new_rfkill</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">bluetooth</span><span class="p">,</span>
				 <span class="s">&quot;asus-bluetooth&quot;</span><span class="p">,</span> <span class="n">RFKILL_TYPE_BLUETOOTH</span><span class="p">,</span>
				 <span class="n">ASUS_WMI_DEVID_BLUETOOTH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_new_rfkill</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wimax</span><span class="p">,</span> <span class="s">&quot;asus-wimax&quot;</span><span class="p">,</span>
				 <span class="n">RFKILL_TYPE_WIMAX</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WIMAX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_new_rfkill</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wwan3g</span><span class="p">,</span> <span class="s">&quot;asus-wwan3g&quot;</span><span class="p">,</span>
				 <span class="n">RFKILL_TYPE_WWAN</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WWAN3G</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_new_rfkill</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">gps</span><span class="p">,</span> <span class="s">&quot;asus-gps&quot;</span><span class="p">,</span>
				 <span class="n">RFKILL_TYPE_GPS</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_GPS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_new_rfkill</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">uwb</span><span class="p">,</span> <span class="s">&quot;asus-uwb&quot;</span><span class="p">,</span>
				 <span class="n">RFKILL_TYPE_UWB</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_UWB</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">hotplug_wireless</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">asus_setup_pci_hotplug</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we get -EBUSY then something else is handling the PCI hotplug -</span>
<span class="cm">	 * don&#39;t fail in this case</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asus_register_rfkill_notifier</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">_SB.PCI0.P0P5&quot;</span><span class="p">);</span>
	<span class="n">asus_register_rfkill_notifier</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">_SB.PCI0.P0P6&quot;</span><span class="p">);</span>
	<span class="n">asus_register_rfkill_notifier</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">_SB.PCI0.P0P7&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Refresh pci hotplug in case the rfkill state was changed during</span>
<span class="cm">	 * setup.</span>
<span class="cm">	 */</span>
	<span class="n">asus_rfkill_hotplug</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="n">asus_wmi_rfkill_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hwmon device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">asus_hwmon_pwm1</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_FAN_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">&amp;=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* Low Speed */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">85</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">170</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unknown fan speed %#x&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">asus_hwmon_temp1</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_THERMAL_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">KELVIN_TO_CELSIUS</span><span class="p">((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SENSOR_DEVICE_ATTR</span><span class="p">(</span><span class="n">pwm1</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">asus_hwmon_pwm1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">SENSOR_DEVICE_ATTR</span><span class="p">(</span><span class="n">temp1_input</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">asus_hwmon_temp1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;asus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">SENSOR_DEVICE_ATTR</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">hwmon_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">sensor_dev_attr_pwm1</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">sensor_dev_attr_temp1_input</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">sensor_dev_attr_name</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">umode_t</span> <span class="nf">asus_hwmon_sysfs_is_visible</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ASUS_WMI_UNSUPPORTED_METHOD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">sensor_dev_attr_pwm1</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">)</span>
		<span class="n">dev_id</span> <span class="o">=</span> <span class="n">ASUS_WMI_DEVID_FAN_CTRL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">sensor_dev_attr_temp1_input</span><span class="p">.</span><span class="n">dev_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">)</span>
		<span class="n">dev_id</span> <span class="o">=</span> <span class="n">ASUS_WMI_DEVID_THERMAL_CTRL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* can&#39;t return negative here */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_id</span> <span class="o">==</span> <span class="n">ASUS_WMI_DEVID_FAN_CTRL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to find a better way, probably using sfun,</span>
<span class="cm">		 * bits or spec ...</span>
<span class="cm">		 * Currently we disable it if:</span>
<span class="cm">		 * - ASUS_WMI_UNSUPPORTED_METHOD is returned</span>
<span class="cm">		 * - reverved bits are non-zero</span>
<span class="cm">		 * - sfun and presence bit are not set</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">ASUS_WMI_UNSUPPORTED_METHOD</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFFF80000</span>
		    <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">sfun</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">ASUS_WMI_DSTS_PRESENCE_BIT</span><span class="p">)))</span>
			<span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev_id</span> <span class="o">==</span> <span class="n">ASUS_WMI_DEVID_THERMAL_CTRL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If value is zero, something is clearly wrong */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ok</span> <span class="o">?</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">hwmon_attribute_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">is_visible</span> <span class="o">=</span> <span class="n">asus_hwmon_sysfs_is_visible</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">hwmon_attributes</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_hwmon_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwmon</span><span class="p">;</span>

	<span class="n">hwmon</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">hwmon_device</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwmon</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwmon</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwmon_attribute_group</span><span class="p">);</span>
	<span class="n">hwmon_device_unregister</span><span class="p">(</span><span class="n">hwmon</span><span class="p">);</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hwmon_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_hwmon_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hwmon</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">hwmon</span> <span class="o">=</span> <span class="n">hwmon_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hwmon</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Could not register asus hwmon device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hwmon</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">hwmon</span><span class="p">,</span> <span class="n">asus</span><span class="p">);</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">hwmon_device</span> <span class="o">=</span> <span class="n">hwmon</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwmon</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwmon_attribute_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">asus_wmi_hwmon_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Backlight</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_backlight_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">store_backlight_power</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">panel_power</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span>
						   <span class="n">ASUS_WMI_DEVID_BACKLIGHT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">FB_BLANK_UNBLANK</span> <span class="o">:</span> <span class="n">FB_BLANK_POWERDOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_brightness_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_BRIGHTNESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span> <span class="o">&amp;</span> <span class="n">ASUS_WMI_DSTS_MAX_BRIGTH_MASK</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_brightness</span><span class="p">(</span><span class="k">struct</span> <span class="n">backlight_device</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">bl_get_data</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_BRIGHTNESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span> <span class="o">&amp;</span> <span class="n">ASUS_WMI_DSTS_BRIGHTNESS_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_scalar_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">backlight_device</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">bl_get_data</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">ctrl_param</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">&lt;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span> <span class="o">==</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">max_brightness</span><span class="p">)</span>
		<span class="n">ctrl_param</span> <span class="o">=</span> <span class="mh">0x00008001</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">&gt;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span><span class="p">)</span> <span class="o">||</span>
		 <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctrl_param</span> <span class="o">=</span> <span class="mh">0x00008000</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ctrl_param</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_bl_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">backlight_device</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">bl_get_data</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">ctrl_param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">power</span> <span class="o">=</span> <span class="n">read_backlight_power</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">&amp;&amp;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">power</span> <span class="o">!=</span> <span class="n">power</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl_param</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">power</span> <span class="o">==</span> <span class="n">FB_BLANK_UNBLANK</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">ASUS_WMI_DEVID_BACKLIGHT</span><span class="p">,</span>
					    <span class="n">ctrl_param</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">store_backlight_power</span><span class="p">)</span>
			<span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">panel_power</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">power</span><span class="p">;</span>

		<span class="cm">/* When using scalar brightness, updating the brightness</span>
<span class="cm">		 * will mess with the backlight power */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">scalar_panel_brightness</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">scalar_panel_brightness</span><span class="p">)</span>
		<span class="n">ctrl_param</span> <span class="o">=</span> <span class="n">get_scalar_command</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ctrl_param</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">ASUS_WMI_DEVID_BRIGHTNESS</span><span class="p">,</span>
				    <span class="n">ctrl_param</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">backlight_ops</span> <span class="n">asus_wmi_bl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_brightness</span> <span class="o">=</span> <span class="n">read_brightness</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_status</span> <span class="o">=</span> <span class="n">update_bl_status</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_backlight_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backlight_device</span> <span class="o">*</span><span class="n">bd</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">backlight_device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="n">NOTIFY_BRNUP_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="n">NOTIFY_BRNUP_MAX</span><span class="p">)</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">code</span> <span class="o">-</span> <span class="n">NOTIFY_BRNUP_MIN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="n">NOTIFY_BRNDOWN_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="n">NOTIFY_BRNDOWN_MAX</span><span class="p">)</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">code</span> <span class="o">-</span> <span class="n">NOTIFY_BRNDOWN_MIN</span><span class="p">;</span>

	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">backlight_update_status</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="n">backlight_force_update</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">BACKLIGHT_UPDATE_HOTKEY</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_backlight_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backlight_device</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backlight_properties</span> <span class="n">props</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="n">read_brightness_max</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">power</span> <span class="o">=</span> <span class="n">read_backlight_power</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">power</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="n">power</span> <span class="o">=</span> <span class="n">FB_BLANK_UNBLANK</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">power</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">props</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">backlight_properties</span><span class="p">));</span>
	<span class="n">props</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BACKLIGHT_PLATFORM</span><span class="p">;</span>
	<span class="n">props</span><span class="p">.</span><span class="n">max_brightness</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">bd</span> <span class="o">=</span> <span class="n">backlight_device_register</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">asus</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">asus_wmi_bl_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">props</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Could not register backlight device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">backlight_device</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">store_backlight_power</span><span class="p">)</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">panel_power</span> <span class="o">=</span> <span class="n">power</span><span class="p">;</span>

	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">read_brightness</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="p">;</span>
	<span class="n">backlight_update_status</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_backlight_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">backlight_device</span><span class="p">)</span>
		<span class="n">backlight_device_unregister</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">backlight_device</span><span class="p">);</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">backlight_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_notify</span><span class="p">(</span><span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">response</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ACPI_ALLOCATE_BUFFER</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_code</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key_value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">autorelease</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">wmi_get_event_data</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">AE_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;bad event status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="p">)</span><span class="n">response</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span> <span class="o">||</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_INTEGER</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">code</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="n">orig_code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">key_filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">key_filter</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_value</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">autorelease</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">ASUS_WMI_KEY_IGNORE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="n">NOTIFY_BRNUP_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="n">NOTIFY_BRNUP_MAX</span><span class="p">)</span>
		<span class="n">code</span> <span class="o">=</span> <span class="n">NOTIFY_BRNUP_MIN</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="n">NOTIFY_BRNDOWN_MIN</span> <span class="o">&amp;&amp;</span>
		 <span class="n">code</span> <span class="o">&lt;=</span> <span class="n">NOTIFY_BRNDOWN_MAX</span><span class="p">)</span>
		<span class="n">code</span> <span class="o">=</span> <span class="n">NOTIFY_BRNDOWN_MIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">NOTIFY_BRNUP_MIN</span> <span class="o">||</span> <span class="n">code</span> <span class="o">==</span> <span class="n">NOTIFY_BRNDOWN_MIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_video_backlight_support</span><span class="p">())</span>
			<span class="n">asus_wmi_backlight_notify</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">orig_code</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sparse_keymap_report_event</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">inputdev</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span>
					       <span class="n">key_value</span><span class="p">,</span> <span class="n">autorelease</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Unknown key %x pressed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sys helpers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_arg</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_sys_wmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devid</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">devid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>	<span class="cm">/* Check device presence */</span>
		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">parse_arg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">devid</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_sys_wmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">devid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ASUS_WMI_CREATE_DEVICE_ATTR(_name, _mode, _cm)			\</span>
<span class="cp">	static ssize_t show_##_name(struct device *dev,			\</span>
<span class="cp">				    struct device_attribute *attr,	\</span>
<span class="cp">				    char *buf)				\</span>
<span class="cp">	{								\</span>
<span class="cp">		struct asus_wmi *asus = dev_get_drvdata(dev);		\</span>
<span class="cp">									\</span>
<span class="cp">		return show_sys_wmi(asus, _cm, buf);			\</span>
<span class="cp">	}								\</span>
<span class="cp">	static ssize_t store_##_name(struct device *dev,		\</span>
<span class="cp">				     struct device_attribute *attr,	\</span>
<span class="cp">				     const char *buf, size_t count)	\</span>
<span class="cp">	{								\</span>
<span class="cp">		struct asus_wmi *asus = dev_get_drvdata(dev);		\</span>
<span class="cp">									\</span>
<span class="cp">		return store_sys_wmi(asus, _cm, buf, count);		\</span>
<span class="cp">	}								\</span>
<span class="cp">	static struct device_attribute dev_attr_##_name = {		\</span>
<span class="cp">		.attr = {						\</span>
<span class="cp">			.name = __stringify(_name),			\</span>
<span class="cp">			.mode = _mode },				\</span>
<span class="cp">		.show   = show_##_name,					\</span>
<span class="cp">		.store  = store_##_name,				\</span>
<span class="cp">	}</span>

<span class="n">ASUS_WMI_CREATE_DEVICE_ATTR</span><span class="p">(</span><span class="n">touchpad</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_TOUCHPAD</span><span class="p">);</span>
<span class="n">ASUS_WMI_CREATE_DEVICE_ATTR</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_CAMERA</span><span class="p">);</span>
<span class="n">ASUS_WMI_CREATE_DEVICE_ATTR</span><span class="p">(</span><span class="n">cardr</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_CARDREADER</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_cpufv</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span> <span class="o">||</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_METHODID_CFVS</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">cpufv</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_cpufv</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">platform_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_cpufv</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_camera</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_cardr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_touchpad</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">umode_t</span> <span class="nf">asus_sysfs_is_visible</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">devid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_camera</span><span class="p">.</span><span class="n">attr</span><span class="p">)</span>
		<span class="n">devid</span> <span class="o">=</span> <span class="n">ASUS_WMI_DEVID_CAMERA</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_cardr</span><span class="p">.</span><span class="n">attr</span><span class="p">)</span>
		<span class="n">devid</span> <span class="o">=</span> <span class="n">ASUS_WMI_DEVID_CARDREADER</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_attr_touchpad</span><span class="p">.</span><span class="n">attr</span><span class="p">)</span>
		<span class="n">devid</span> <span class="o">=</span> <span class="n">ASUS_WMI_DEVID_TOUCHPAD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ok</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">devid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ok</span> <span class="o">?</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">platform_attribute_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">is_visible</span> <span class="o">=</span> <span class="n">asus_sysfs_is_visible</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">platform_attributes</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_sysfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">platform_attribute_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_sysfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">platform_attribute_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Platform device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_platform_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="cm">/* INIT enable hotkeys on some models */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_METHODID_INIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rv</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Initialization: %#x&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t know yet what to do with this version... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_METHODID_SPEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;BIOS WMI version: %d.%d&quot;</span><span class="p">,</span> <span class="n">rv</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">rv</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">spec</span> <span class="o">=</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The SFUN method probably allows the original driver to get the list</span>
<span class="cm">	 * of features supported by a given model. For now, 0x0100 or 0x0800</span>
<span class="cm">	 * bit signifies that the laptop is equipped with a Wi-Fi MiniPCI card.</span>
<span class="cm">	 * The significance of others is yet to be found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_METHODID_SFUN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;SFUN value: %#x&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">sfun</span> <span class="o">=</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Eee PC and Notebooks seems to have different method_id for DSTS,</span>
<span class="cm">	 * but it may also be related to the BIOS&#39;s SPEC.</span>
<span class="cm">	 * Note, on most Eeepc, there is no way to check if a method exist</span>
<span class="cm">	 * or note, while on notebooks, they returns 0xFFFFFFFE on failure,</span>
<span class="cm">	 * but once again, SPEC may probably be used for that kind of things.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_METHODID_DSTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">dsts_id</span> <span class="o">=</span> <span class="n">ASUS_WMI_METHODID_DSTS</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus_wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_METHODID_DSTS2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">asus</span><span class="o">-&gt;</span><span class="n">dsts_id</span> <span class="o">=</span> <span class="n">ASUS_WMI_METHODID_DSTS2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">dsts_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t find DSTS&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* CWAP allow to define the behavior of the Fn+F2 key,</span>
<span class="cm">	 * this method doesn&#39;t seems to be present on Eee PCs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">wapf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">ASUS_WMI_DEVID_CWAP</span><span class="p">,</span>
				      <span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="o">-&gt;</span><span class="n">wapf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">asus_wmi_sysfs_init</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_platform_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asus_wmi_sysfs_exit</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * debugfs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">asus_wmi_debugfs_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_dsts</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DSTS(%#x) = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">ctrl_param</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DEVS(%#x, %#x) = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span>
		   <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">ctrl_param</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bios_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">arg0</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span>
		<span class="p">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">ctrl_param</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">input</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">acpi_size</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">args</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ACPI_ALLOCATE_BUFFER</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">wmi_evaluate_method</span><span class="p">(</span><span class="n">ASUS_WMI_MGMT_GUID</span><span class="p">,</span>
				     <span class="mi">1</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">method_id</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="p">)</span><span class="n">output</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ACPI_TYPE_INTEGER</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%#x(%#x, %#x) = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">method_id</span><span class="p">,</span>
			   <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">ctrl_param</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%#x(%#x, %#x) = t:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">method_id</span><span class="p">,</span>
			   <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">ctrl_param</span><span class="p">,</span>
			   <span class="n">obj</span> <span class="o">?</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">asus_wmi_debugfs_node</span> <span class="n">asus_wmi_debug_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;devs&quot;</span><span class="p">,</span> <span class="n">show_devs</span><span class="p">},</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;dsts&quot;</span><span class="p">,</span> <span class="n">show_dsts</span><span class="p">},</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;call&quot;</span><span class="p">,</span> <span class="n">show_call</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_debugfs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi_debugfs_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">asus</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">asus_wmi_debugfs_io_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">asus_wmi_debugfs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_wmi_debugfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to create debugfs directory&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_debugfs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_x32</span><span class="p">(</span><span class="s">&quot;method_id&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
				  <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">method_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_debugfs</span><span class="p">;</span>

	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_x32</span><span class="p">(</span><span class="s">&quot;dev_id&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
				  <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">dev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_debugfs</span><span class="p">;</span>

	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_x32</span><span class="p">(</span><span class="s">&quot;ctrl_param&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
				  <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">ctrl_param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_debugfs</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">asus_wmi_debug_files</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">asus_wmi_debugfs_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asus_wmi_debug_files</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">node</span><span class="o">-&gt;</span><span class="n">asus</span> <span class="o">=</span> <span class="n">asus</span><span class="p">;</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span>
					   <span class="n">asus</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">asus_wmi_debugfs_io_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to create debug file: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_debugfs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_debugfs:</span>
	<span class="n">asus_wmi_debugfs_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * WMI Driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_driver</span> <span class="o">*</span><span class="n">pdrv</span> <span class="o">=</span> <span class="n">to_platform_driver</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">asus_wmi_driver</span> <span class="o">*</span><span class="n">wdrv</span> <span class="o">=</span> <span class="n">to_asus_wmi_driver</span><span class="p">(</span><span class="n">pdrv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">wdrv</span><span class="p">;</span>
	<span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">wdrv</span><span class="o">-&gt;</span><span class="n">platform_device</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="p">,</span> <span class="n">asus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wdrv</span><span class="o">-&gt;</span><span class="n">detect_quirks</span><span class="p">)</span>
		<span class="n">wdrv</span><span class="o">-&gt;</span><span class="n">detect_quirks</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_platform_init</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_platform</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_input_init</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_input</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_hwmon_init</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_hwmon</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_led_init</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_leds</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_rfkill_init</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_rfkill</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_video_backlight_support</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_backlight_init</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_backlight</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Backlight controlled by ACPI video driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">wmi_install_notify_handler</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">event_guid</span><span class="p">,</span>
					    <span class="n">asus_wmi_notify</span><span class="p">,</span> <span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to register notify handler - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_wmi_handler</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">asus_wmi_debugfs_init</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_debugfs</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_debugfs:</span>
	<span class="n">wmi_remove_notify_handler</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">event_guid</span><span class="p">);</span>
<span class="nl">fail_wmi_handler:</span>
	<span class="n">asus_wmi_backlight_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="nl">fail_backlight:</span>
	<span class="n">asus_wmi_rfkill_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="nl">fail_rfkill:</span>
	<span class="n">asus_wmi_led_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="nl">fail_leds:</span>
	<span class="n">asus_wmi_hwmon_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="nl">fail_hwmon:</span>
	<span class="n">asus_wmi_input_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="nl">fail_input:</span>
	<span class="n">asus_wmi_platform_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
<span class="nl">fail_platform:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span><span class="p">;</span>

	<span class="n">asus</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">wmi_remove_notify_handler</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">event_guid</span><span class="p">);</span>
	<span class="n">asus_wmi_backlight_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="n">asus_wmi_input_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="n">asus_wmi_hwmon_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="n">asus_wmi_led_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="n">asus_wmi_rfkill_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="n">asus_wmi_debugfs_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="n">asus_wmi_platform_exit</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Platform driver - hibernate/resume callbacks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_hotk_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">wlan</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Work around bios bug - acpi _PTS turns off the wireless led</span>
<span class="cm">		 * during suspend.  Normally it restores it on resume, but</span>
<span class="cm">		 * we should kick it ourselves in case hibernation is aborted.</span>
<span class="cm">		 */</span>
		<span class="n">wlan</span> <span class="o">=</span> <span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WLAN</span><span class="p">);</span>
		<span class="n">asus_wmi_set_devstate</span><span class="p">(</span><span class="n">ASUS_WMI_DEVID_WLAN</span><span class="p">,</span> <span class="n">wlan</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_hotk_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asus_wmi</span> <span class="o">*</span><span class="n">asus</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">bl</span><span class="p">;</span>

	<span class="cm">/* Refresh both wlan rfkill state and pci hotplug */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wlan</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span>
		<span class="n">asus_rfkill_hotplug</span><span class="p">(</span><span class="n">asus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">bluetooth</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="o">!</span><span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span>
						   <span class="n">ASUS_WMI_DEVID_BLUETOOTH</span><span class="p">);</span>
		<span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">bluetooth</span><span class="p">.</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wimax</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="o">!</span><span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WIMAX</span><span class="p">);</span>
		<span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wimax</span><span class="p">.</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wwan3g</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="o">!</span><span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_WWAN3G</span><span class="p">);</span>
		<span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">wwan3g</span><span class="p">.</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">gps</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="o">!</span><span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_GPS</span><span class="p">);</span>
		<span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">gps</span><span class="p">.</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">uwb</span><span class="p">.</span><span class="n">rfkill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="o">!</span><span class="n">asus_wmi_get_devstate_simple</span><span class="p">(</span><span class="n">asus</span><span class="p">,</span> <span class="n">ASUS_WMI_DEVID_UWB</span><span class="p">);</span>
		<span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="n">asus</span><span class="o">-&gt;</span><span class="n">uwb</span><span class="p">.</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">asus_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">asus_hotk_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">asus_hotk_restore</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">asus_wmi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_driver</span> <span class="o">*</span><span class="n">pdrv</span> <span class="o">=</span> <span class="n">to_platform_driver</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">asus_wmi_driver</span> <span class="o">*</span><span class="n">wdrv</span> <span class="o">=</span> <span class="n">to_asus_wmi_driver</span><span class="p">(</span><span class="n">pdrv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wmi_has_guid</span><span class="p">(</span><span class="n">ASUS_WMI_MGMT_GUID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Management GUID not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wdrv</span><span class="o">-&gt;</span><span class="n">event_guid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wmi_has_guid</span><span class="p">(</span><span class="n">wdrv</span><span class="o">-&gt;</span><span class="n">event_guid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Event GUID not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wdrv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wdrv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">asus_wmi_add</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">used</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">asus_wmi_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_driver</span> <span class="o">*</span><span class="n">platform_driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">platform_device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">used</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">platform_driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">platform_driver</span><span class="p">;</span>
	<span class="n">platform_driver</span><span class="o">-&gt;</span><span class="n">remove</span> <span class="o">=</span> <span class="n">asus_wmi_remove</span><span class="p">;</span>
	<span class="n">platform_driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">platform_driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">platform_driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asus_pm_ops</span><span class="p">;</span>

	<span class="n">platform_device</span> <span class="o">=</span> <span class="n">platform_create_bundle</span><span class="p">(</span><span class="n">platform_driver</span><span class="p">,</span>
						 <span class="n">asus_wmi_probe</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">platform_device</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">platform_device</span><span class="p">);</span>

	<span class="n">used</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">asus_wmi_register_driver</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">asus_wmi_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">asus_wmi_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">platform_device</span><span class="p">);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">platform_driver</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">asus_wmi_unregister_driver</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">asus_wmi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wmi_has_guid</span><span class="p">(</span><span class="n">ASUS_WMI_MGMT_GUID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Asus Management GUID not found&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ASUS WMI generic driver loaded&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">asus_wmi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ASUS WMI generic driver unloaded&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">asus_wmi_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">asus_wmi_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
