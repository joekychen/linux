<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › lguest › lg.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lg.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LGUEST_H</span>
<span class="cp">#define _LGUEST_H</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/lguest.h&gt;</span>
<span class="cp">#include &lt;linux/lguest_launcher.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/lguest.h&gt;</span>

<span class="kt">void</span> <span class="n">free_pagetables</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">init_pagetables</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">switcher_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pgdir</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpgdir</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* We have two pages shared with guests, per cpu.  */</span>
<span class="k">struct</span> <span class="n">lguest_pages</span> <span class="p">{</span>
	<span class="cm">/* This is the stack page mapped rw in guest */</span>
	<span class="kt">char</span> <span class="n">spare</span><span class="p">[</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest_regs</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">lguest_regs</span> <span class="n">regs</span><span class="p">;</span>

	<span class="cm">/* This is the host state &amp; guest descriptor page, ro in guest */</span>
	<span class="k">struct</span> <span class="n">lguest_ro_state</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">)));</span>

<span class="cp">#define CHANGED_IDT		1</span>
<span class="cp">#define CHANGED_GDT		2</span>
<span class="cp">#define CHANGED_GDT_TLS		4 </span><span class="cm">/* Actually a subset of CHANGED_GDT */</span><span class="cp"></span>
<span class="cp">#define CHANGED_ALL	        3</span>

<span class="k">struct</span> <span class="n">lg_cpu</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span> 	<span class="cm">/* == tsk-&gt;mm, but that becomes NULL on exit */</span>

	<span class="n">u32</span> <span class="n">cr2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ts</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">esp1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ss1</span><span class="p">;</span>

	<span class="cm">/* Bitmap of what has changed: see CHANGED_* above. */</span>
	<span class="kt">int</span> <span class="n">changed</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_notify</span><span class="p">;</span> <span class="cm">/* pfn from LHCALL_NOTIFY */</span>

	<span class="cm">/* At end of a page shared mapped over lguest_pages in guest. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regs_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lguest_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lguest_pages</span> <span class="o">*</span><span class="n">last_pages</span><span class="p">;</span>

	<span class="cm">/* Initialization mode: linear map everything. */</span>
	<span class="n">bool</span> <span class="n">linear_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu_pgd</span><span class="p">;</span> <span class="cm">/* Which pgd this cpu is currently using */</span>

	<span class="cm">/* If a hypercall was asked for, this points to the arguments. */</span>
	<span class="k">struct</span> <span class="n">hcall_args</span> <span class="o">*</span><span class="n">hcall</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_hcall</span><span class="p">;</span>

	<span class="cm">/* Virtual clock device */</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">hrt</span><span class="p">;</span>

	<span class="cm">/* Did the Guest tell us to halt? */</span>
	<span class="kt">int</span> <span class="n">halted</span><span class="p">;</span>

	<span class="cm">/* Pending virtual interrupts */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">irqs_pending</span><span class="p">,</span> <span class="n">LGUEST_IRQS</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">lg_cpu_arch</span> <span class="n">arch</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lg_eventfd</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lg_eventfd_map</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lg_eventfd</span> <span class="n">map</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/* The private info the thread maintains about the guest. */</span>
<span class="k">struct</span> <span class="n">lguest</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lguest_data</span> <span class="n">__user</span> <span class="o">*</span><span class="n">lguest_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lg_cpu</span> <span class="n">cpus</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_cpus</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">pfn_limit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This provides the offset to the base of guest-physical memory in the</span>
<span class="cm">	 * Launcher.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mem_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_address</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pgdir</span> <span class="n">pgdirs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">noirq_start</span><span class="p">,</span> <span class="n">noirq_end</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stack_pages</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsc_khz</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lg_eventfd_map</span> <span class="o">*</span><span class="n">eventfds</span><span class="p">;</span>

	<span class="cm">/* Dead? */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dead</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">lguest_lock</span><span class="p">;</span>

<span class="cm">/* core.c: */</span>
<span class="n">bool</span> <span class="n">lguest_address_ok</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__lgread</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__lgwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>

<span class="cm">/*H:035</span>
<span class="cm"> * Using memory-copy operations like that is usually inconvient, so we</span>
<span class="cm"> * have the following helper macros which read and write a specific type (often</span>
<span class="cm"> * an unsigned long).</span>
<span class="cm"> *</span>
<span class="cm"> * This reads into a variable of the given type then returns that.</span>
<span class="cm"> */</span>
<span class="cp">#define lgread(cpu, addr, type)						\</span>
<span class="cp">	({ type _v; __lgread((cpu), &amp;_v, (addr), sizeof(_v)); _v; })</span>

<span class="cm">/* This checks that the variable is of the given type, then writes it out. */</span>
<span class="cp">#define lgwrite(cpu, addr, type, val)				\</span>
<span class="cp">	do {							\</span>
<span class="cp">		typecheck(type, val);				\</span>
<span class="cp">		__lgwrite((cpu), (addr), &amp;(val), sizeof(val));	\</span>
<span class="cp">	} while(0)</span>
<span class="cm">/* (end of memory access helper routines) :*/</span>

<span class="kt">int</span> <span class="n">run_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Helper macros to obtain the first 12 or the last 20 bits, this is only the</span>
<span class="cm"> * first step in the migration to the kernel types.  pte_pfn is already defined</span>
<span class="cm"> * in the kernel.</span>
<span class="cm"> */</span>
<span class="cp">#define pgd_flags(x)	(pgd_val(x) &amp; ~PAGE_MASK)</span>
<span class="cp">#define pgd_pfn(x)	(pgd_val(x) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define pmd_flags(x)    (pmd_val(x) &amp; ~PAGE_MASK)</span>
<span class="cp">#define pmd_pfn(x)	(pmd_val(x) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/* interrupts_and_traps.c: */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">more</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">try_deliver_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">more</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">deliver_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">load_guest_idt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">guest_set_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">esp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pin_stack_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">setup_default_idt_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest_ro_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">def</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">copy_traps</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">idt</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">def</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">guest_set_clockevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">send_notify_to_eventfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_clockdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">check_syscall_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">init_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* segments.c: */</span>
<span class="kt">void</span> <span class="n">setup_default_gdt_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest_ro_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">setup_guest_gdt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">load_guest_gdt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">guest_load_tls</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tls_array</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">copy_gdt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">gdt</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">copy_gdt_tls</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">gdt</span><span class="p">);</span>

<span class="cm">/* page_tables.c: */</span>
<span class="kt">int</span> <span class="n">init_guest_pagetable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_guest_pagetable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">guest_new_pagetable</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgtable</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">guest_set_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpgdir</span><span class="p">,</span> <span class="n">u32</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_PAE</span>
<span class="kt">void</span> <span class="n">guest_set_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpgdir</span><span class="p">,</span> <span class="n">u32</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="kt">void</span> <span class="n">guest_pagetable_clear_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">guest_pagetable_flush_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">guest_set_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpgdir</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">map_switcher_in_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lguest_pages</span> <span class="o">*</span><span class="n">pages</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">demand_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errcode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pin_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">guest_pa</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_table_guest_data_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>

<span class="cm">/* &lt;arch&gt;/core.c: */</span>
<span class="kt">void</span> <span class="n">lguest_arch_host_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lguest_arch_host_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lguest_arch_run_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lguest_arch_handle_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">lguest_arch_init_hypercalls</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">lguest_arch_do_hcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hcall_args</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lguest_arch_setup_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">);</span>

<span class="cm">/* &lt;arch&gt;/switcher.S: */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">start_switcher_text</span><span class="p">[],</span> <span class="n">end_switcher_text</span><span class="p">[],</span> <span class="n">switch_to_guest</span><span class="p">[];</span>

<span class="cm">/* lguest_user.c: */</span>
<span class="kt">int</span> <span class="n">lguest_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lguest_device_remove</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* hypercalls.c: */</span>
<span class="kt">void</span> <span class="n">do_hypercalls</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">write_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">);</span>

<span class="cm">/*L:035</span>
<span class="cm"> * Let&#39;s step aside for the moment, to study one important routine that&#39;s used</span>
<span class="cm"> * widely in the Host code.</span>
<span class="cm"> *</span>
<span class="cm"> * There are many cases where the Guest can do something invalid, like pass crap</span>
<span class="cm"> * to a hypercall.  Since only the Guest kernel can make hypercalls, it&#39;s quite</span>
<span class="cm"> * acceptable to simply terminate the Guest and give the Launcher a nicely</span>
<span class="cm"> * formatted reason.  It&#39;s also simpler for the Guest itself, which doesn&#39;t</span>
<span class="cm"> * need to check most hypercalls for &quot;success&quot;; if you&#39;re still running, it</span>
<span class="cm"> * succeeded.</span>
<span class="cm"> *</span>
<span class="cm"> * Once this is called, the Guest will never run again, so most Host code can</span>
<span class="cm"> * call this then continue as if nothing had happened.  This means many</span>
<span class="cm"> * functions don&#39;t have to explicitly return an error code, which keeps the</span>
<span class="cm"> * code simple.</span>
<span class="cm"> *</span>
<span class="cm"> * It also means that this can be called more than once: only the first one is</span>
<span class="cm"> * remembered.  The only trick is that we still need to kill the Guest even if</span>
<span class="cm"> * we can&#39;t allocate memory to store the reason.  Linux has a neat way of</span>
<span class="cm"> * packing error codes into invalid pointers, so we use that here.</span>
<span class="cm"> *</span>
<span class="cm"> * Like any macro which uses an &quot;if&quot;, it is safely wrapped in a run-once &quot;do {</span>
<span class="cm"> * } while(0)&quot;.</span>
<span class="cm"> */</span>
<span class="cp">#define kill_guest(cpu, fmt...)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (!(cpu)-&gt;lg-&gt;dead) {					\</span>
<span class="cp">		(cpu)-&gt;lg-&gt;dead = kasprintf(GFP_ATOMIC, fmt);	\</span>
<span class="cp">		if (!(cpu)-&gt;lg-&gt;dead)				\</span>
<span class="cp">			(cpu)-&gt;lg-&gt;dead = ERR_PTR(-ENOMEM);	\</span>
<span class="cp">	}							\</span>
<span class="cp">} while(0)</span>
<span class="cm">/* (End of aside) :*/</span>

<span class="cp">#endif	</span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* _LGUEST_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
