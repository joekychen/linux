<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › lguest › lguest_user.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lguest_user.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*P:200 This contains all the /dev/lguest code, whereby the userspace</span>
<span class="cm"> * launcher controls and communicates with the Guest.  For example,</span>
<span class="cm"> * the first write will tell us the Guest&#39;s memory layout and entry</span>
<span class="cm"> * point.  A read will run the Guest until something happens, such as</span>
<span class="cm"> * a signal or the Guest doing a NOTIFY out to the Launcher.  There is</span>
<span class="cm"> * also a way for the Launcher to attach eventfds to particular NOTIFY</span>
<span class="cm"> * values instead of returning from the read() call.</span>
<span class="cm">:*/</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/eventfd.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;lg.h&quot;</span>

<span class="cm">/*L:056</span>
<span class="cm"> * Before we move on, let&#39;s jump ahead and look at what the kernel does when</span>
<span class="cm"> * it needs to look up the eventfds.  That will complete our picture of how we</span>
<span class="cm"> * use RCU.</span>
<span class="cm"> *</span>
<span class="cm"> * The notification value is in cpu-&gt;pending_notify: we return true if it went</span>
<span class="cm"> * to an eventfd.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">send_notify_to_eventfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lg_eventfd_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This &quot;rcu_read_lock()&quot; helps track when someone is still looking at</span>
<span class="cm">	 * the (RCU-using) eventfds array.  It&#39;s not actually a lock at all;</span>
<span class="cm">	 * indeed it&#39;s a noop in many configurations.  (You didn&#39;t expect me to</span>
<span class="cm">	 * explain all the RCU secrets here, did you?)</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * rcu_dereference is the counter-side of rcu_assign_pointer(); it</span>
<span class="cm">	 * makes sure we don&#39;t access the memory pointed to by</span>
<span class="cm">	 * cpu-&gt;lg-&gt;eventfds before cpu-&gt;lg-&gt;eventfds is set.  Sounds crazy,</span>
<span class="cm">	 * but Alpha allows this!  Paul McKenney points out that a really</span>
<span class="cm">	 * aggressive compiler could have the same effect:</span>
<span class="cm">	 *   http://lists.ozlabs.org/pipermail/lguest/2009-July/001560.html</span>
<span class="cm">	 *</span>
<span class="cm">	 * So play safe, use rcu_dereference to get the rcu-protected pointer:</span>
<span class="cm">	 */</span>
	<span class="n">map</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Simple array search: even if they add an eventfd while we do this,</span>
<span class="cm">	 * we&#39;ll continue to use the old array and just won&#39;t see the new one.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">==</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eventfd_signal</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* We&#39;re done with the rcu-protected variable cpu-&gt;lg-&gt;eventfds. */</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/* If we cleared the notification, it&#39;s because we found a match. */</span>
	<span class="k">return</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:055</span>
<span class="cm"> * One of the more tricksy tricks in the Linux Kernel is a technique called</span>
<span class="cm"> * Read Copy Update.  Since one point of lguest is to teach lguest journeyers</span>
<span class="cm"> * about kernel coding, I use it here.  (In case you&#39;re curious, other purposes</span>
<span class="cm"> * include learning about virtualization and instilling a deep appreciation for</span>
<span class="cm"> * simplicity and puppies).</span>
<span class="cm"> *</span>
<span class="cm"> * We keep a simple array which maps LHCALL_NOTIFY values to eventfds, but we</span>
<span class="cm"> * add new eventfds without ever blocking readers from accessing the array.</span>
<span class="cm"> * The current Launcher only does this during boot, so that never happens.  But</span>
<span class="cm"> * Read Copy Update is cool, and adding a lock risks damaging even more puppies</span>
<span class="cm"> * than this code does.</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate a brand new one-larger array, copy the old one and add our new</span>
<span class="cm"> * element.  Then we make the lg eventfd pointer point to the new array.</span>
<span class="cm"> * That&#39;s the easy part: now we need to free the old one, but we need to make</span>
<span class="cm"> * sure no slow CPU somewhere is still looking at it.  That&#39;s what</span>
<span class="cm"> * synchronize_rcu does for us: waits until every CPU has indicated that it has</span>
<span class="cm"> * moved on to know it&#39;s no longer using the old one.</span>
<span class="cm"> *</span>
<span class="cm"> * If that&#39;s unclear, see http://en.wikipedia.org/wiki/Read-copy-update.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_eventfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lg_eventfd_map</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t allow notifications on value 0 anyway (pending_notify of</span>
<span class="cm">	 * 0 means &quot;nothing pending&quot;).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Replace the old array with the new one, carefully: others can</span>
<span class="cm">	 * be accessing it at the same time.</span>
<span class="cm">	 */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
		      <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* First make identical copy. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>

	<span class="cm">/* Now append new entry. */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">].</span><span class="n">event</span> <span class="o">=</span> <span class="n">eventfd_ctx_fdget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">].</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span>  <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">].</span><span class="n">event</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">num</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now put new one in place: rcu_assign_pointer() is a fancy way of</span>
<span class="cm">	 * doing &quot;lg-&gt;eventfds = new&quot;, but it uses memory barriers to make</span>
<span class="cm">	 * absolutely sure that the contents of &quot;new&quot; written above is nailed</span>
<span class="cm">	 * down before we actually do the assignment.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We have to think about these kinds of things when we&#39;re operating on</span>
<span class="cm">	 * live data without locks.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re not in a big hurry.  Wait until no one&#39;s looking at old</span>
<span class="cm">	 * version, then free it.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:052</span>
<span class="cm"> * Receiving notifications from the Guest is usually done by attaching a</span>
<span class="cm"> * particular LHCALL_NOTIFY value to an event filedescriptor.  The eventfd will</span>
<span class="cm"> * become readable when the Guest does an LHCALL_NOTIFY with that value.</span>
<span class="cm"> *</span>
<span class="cm"> * This is really convenient for processing each virtqueue in a separate</span>
<span class="cm"> * thread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">attach_eventfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">input</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just make sure two callers don&#39;t add eventfds at once.  We really</span>
<span class="cm">	 * only need to lock against callers adding to the same Guest, so using</span>
<span class="cm">	 * the Big Lguest Lock is overkill.  But this is setup, not a fast path.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">add_eventfd</span><span class="p">(</span><span class="n">lg</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:050</span>
<span class="cm"> * Sending an interrupt is done by writing LHREQ_IRQ and an interrupt</span>
<span class="cm"> * number to /dev/lguest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">user_send_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">LGUEST_IRQS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Next time the Guest runs, the core code will see if it can deliver</span>
<span class="cm">	 * this interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">set_interrupt</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:040</span>
<span class="cm"> * Once our Guest is initialized, the Launcher makes it run by reading</span>
<span class="cm"> * from /dev/lguest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="n">loff_t</span><span class="o">*</span><span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span> <span class="o">=</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>

	<span class="cm">/* You must write LHREQ_INITIALIZE first! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Watch out for arbitrary vcpu indexes! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_id</span> <span class="o">&gt;=</span> <span class="n">lg</span><span class="o">-&gt;</span><span class="n">nr_cpus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">];</span>

	<span class="cm">/* If you&#39;re not the task which owns the Guest, go away. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* If the Guest is already dead, we indicate why */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* lg-&gt;dead either contains an error code, or a string. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">);</span>

		<span class="cm">/* We can only return as much as the buffer they read with. */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we returned from read() last time because the Guest sent I/O,</span>
<span class="cm">	 * clear the flag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span><span class="p">)</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Run the Guest until something interesting happens. */</span>
	<span class="k">return</span> <span class="n">run_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">user</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*L:025</span>
<span class="cm"> * This actually initializes a CPU.  For the moment, a Guest is only</span>
<span class="cm"> * uniprocessor, so &quot;id&quot; is always 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lg_cpu_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We have a limited number the number of CPUs in the lguest struct. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Set up this CPU&#39;s id, and pointer back to the lguest struct. */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">((</span><span class="n">cpu</span> <span class="o">-</span> <span class="n">id</span><span class="p">),</span> <span class="k">struct</span> <span class="n">lguest</span><span class="p">,</span> <span class="n">cpus</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">nr_cpus</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Each CPU has a timer it can set. */</span>
	<span class="n">init_clockdev</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need a complete page for the Guest registers: they are accessible</span>
<span class="cm">	 * to the Guest and we can only grant it access to whole pages.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs_page</span> <span class="o">=</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs_page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* We actually put the registers at the bottom of the page. */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs_page</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we initialize the Guest&#39;s registers, handing it the start</span>
<span class="cm">	 * address.</span>
<span class="cm">	 */</span>
	<span class="n">lguest_arch_setup_regs</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">start_ip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We keep a pointer to the Launcher task (ie. current task) for when</span>
<span class="cm">	 * other Guests want to wake this one (eg. console input).</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to keep a pointer to the Launcher&#39;s memory map, because if</span>
<span class="cm">	 * the Launcher dies we need to clean it up.  If we don&#39;t keep a</span>
<span class="cm">	 * reference, it is destroyed before close() is called.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We remember which CPU&#39;s pages this Guest used last, for optimization</span>
<span class="cm">	 * when the same Guest runs on the same CPU twice.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">last_pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* No error == success. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:020</span>
<span class="cm"> * The initialization write supplies 3 pointer sized (32 or 64 bit) values (in</span>
<span class="cm"> * addition to the LHREQ_INITIALIZE value).  These are:</span>
<span class="cm"> *</span>
<span class="cm"> * base: The start of the Guest-physical memory inside the Launcher memory.</span>
<span class="cm"> *</span>
<span class="cm"> * pfnlimit: The highest (Guest-physical) page number the Guest should be</span>
<span class="cm"> * allowed to access.  The Guest memory lives inside the Launcher, so it sets</span>
<span class="cm"> * this to ensure the Guest can only reach its own memory.</span>
<span class="cm"> *</span>
<span class="cm"> * start: The first instruction to execute (&quot;eip&quot; in x86-speak).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* &quot;struct lguest&quot; contains all we (the Host) know about a Guest. */</span>
	<span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * We grab the Big Lguest lock, which protects against multiple</span>
<span class="cm">	 * simultaneous initializations.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_lock</span><span class="p">);</span>
	<span class="cm">/* You can&#39;t initialize twice!  Close the device and start again... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_lg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Populate the easy fields of our &quot;struct lguest&quot; */</span>
	<span class="n">lg</span><span class="o">-&gt;</span><span class="n">mem_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">lg</span><span class="o">-&gt;</span><span class="n">pfn_limit</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* This is the first cpu (cpu 0) and it will start booting at args[2] */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lg_cpu_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_eventfds</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the Guest&#39;s shadow page tables.  This allocates</span>
<span class="cm">	 * memory, so can fail.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">init_guest_pagetable</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_regs</span><span class="p">;</span>

	<span class="cm">/* We keep our &quot;struct lguest&quot; in the file&#39;s private_data. */</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">lg</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_lock</span><span class="p">);</span>

	<span class="cm">/* And because this is a write() call, we return the length used. */</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

<span class="nl">free_regs:</span>
	<span class="cm">/* FIXME: This should be in free_vcpu */</span>
	<span class="n">free_page</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">regs_page</span><span class="p">);</span>
<span class="nl">free_eventfds:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="p">);</span>
<span class="nl">free_lg:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:010</span>
<span class="cm"> * The first operation the Launcher does must be a write.  All writes</span>
<span class="cm"> * start with an unsigned long number: for the first write this must be</span>
<span class="cm"> * LHREQ_INITIALIZE to set up the Guest.  After that the Launcher can use</span>
<span class="cm"> * writes of other values to send interrupts or set up receipt of notifications.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we overload the &quot;offset&quot; in the /dev/lguest file to indicate what</span>
<span class="cm"> * CPU number we&#39;re dealing with.  Currently this is always 0 since we only</span>
<span class="cm"> * support uniprocessor Guests, but you can see the beginnings of SMP support</span>
<span class="cm"> * here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Once the Guest is initialized, we hold the &quot;struct lguest&quot; in the</span>
<span class="cm">	 * file private data.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span> <span class="o">=</span> <span class="o">*</span><span class="n">off</span><span class="p">;</span>

	<span class="cm">/* The first value tells us what this request is. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">input</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If you haven&#39;t initialized, you must do that first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">!=</span> <span class="n">LHREQ_INITIALIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lg</span> <span class="o">||</span> <span class="p">(</span><span class="n">cpu_id</span> <span class="o">&gt;=</span> <span class="n">lg</span><span class="o">-&gt;</span><span class="n">nr_cpus</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">];</span>

		<span class="cm">/* Once the Guest is dead, you can only read() why it died. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LHREQ_INITIALIZE</span>:
		<span class="k">return</span> <span class="n">initialize</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">LHREQ_IRQ</span>:
		<span class="k">return</span> <span class="n">user_send_irq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">LHREQ_EVENTFD</span>:
		<span class="k">return</span> <span class="n">attach_eventfd</span><span class="p">(</span><span class="n">lg</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*L:060</span>
<span class="cm"> * The final piece of interface code is the close() routine.  It reverses</span>
<span class="cm"> * everything done in initialize().  This is usually called because the</span>
<span class="cm"> * Launcher exited.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the close routine returns 0 or a negative error number: it can&#39;t</span>
<span class="cm"> * really fail, but it can whine.  I blame Sun for this wart, and K&amp;R C for</span>
<span class="cm"> * letting them do it.</span>
<span class="cm">:*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* If we never successfully initialized, there&#39;s nothing to clean up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need the big lock, to protect from inter-guest I/O and other</span>
<span class="cm">	 * Launchers initializing guests.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_lock</span><span class="p">);</span>

	<span class="cm">/* Free up the shadow page tables for the Guest. */</span>
	<span class="n">free_guest_pagetable</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lg</span><span class="o">-&gt;</span><span class="n">nr_cpus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cancels the hrtimer set via LHCALL_SET_CLOCKEVENT. */</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hrt</span><span class="p">);</span>
		<span class="cm">/* We can free up the register page we allocated. */</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regs_page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now all the memory cleanups are done, it&#39;s safe to release</span>
<span class="cm">		 * the Launcher&#39;s memory management structure.</span>
<span class="cm">		 */</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Release any eventfds they registered. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">eventfd_ctx_put</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">eventfds</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If lg-&gt;dead doesn&#39;t contain an error code it will be NULL or a</span>
<span class="cm">	 * kmalloc()ed string, either of which is ok to hand to kfree().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">);</span>
	<span class="cm">/* Free the memory allocated to the lguest_struct */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span>
	<span class="cm">/* Release lock and exit. */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:000</span>
<span class="cm"> * Welcome to our journey through the Launcher!</span>
<span class="cm"> *</span>
<span class="cm"> * The Launcher is the Host userspace program which sets up, runs and services</span>
<span class="cm"> * the Guest.  In fact, many comments in the Drivers which refer to &quot;the Host&quot;</span>
<span class="cm"> * doing things are inaccurate: the Launcher does all the device handling for</span>
<span class="cm"> * the Guest, but the Guest can&#39;t know that.</span>
<span class="cm"> *</span>
<span class="cm"> * Just to confuse you: to the Host kernel, the Launcher *is* the Guest and we</span>
<span class="cm"> * shall see more of that later.</span>
<span class="cm"> *</span>
<span class="cm"> * We begin our understanding with the Host kernel interface which the Launcher</span>
<span class="cm"> * uses: reading and writing a character device called /dev/lguest.  All the</span>
<span class="cm"> * work happens in the read(), write() and close() routines:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">lguest_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>	 <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>	 <span class="o">=</span> <span class="n">write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	 <span class="o">=</span> <span class="n">read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>
<span class="cm">/*:*/</span>

<span class="cm">/*</span>
<span class="cm"> * This is a textbook example of a &quot;misc&quot; character device.  Populate a &quot;struct</span>
<span class="cm"> * miscdevice&quot; and register it with misc_register().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">lguest_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span>	<span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;lguest&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">lguest_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">lguest_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">lguest_device_remove</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_dev</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
