<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › lguest › interrupts_and_traps.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>interrupts_and_traps.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*P:800</span>
<span class="cm"> * Interrupts (traps) are complicated enough to earn their own file.</span>
<span class="cm"> * There are three classes of interrupts:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Real hardware interrupts which occur while we&#39;re running the Guest,</span>
<span class="cm"> * 2) Interrupts for virtual devices attached to the Guest, and</span>
<span class="cm"> * 3) Traps and faults from the Guest.</span>
<span class="cm"> *</span>
<span class="cm"> * Real hardware interrupts must be delivered to the Host, not the Guest.</span>
<span class="cm"> * Virtual interrupts must be delivered to the Guest, but we make them look</span>
<span class="cm"> * just like real hardware would deliver them.  Traps from the Guest can be set</span>
<span class="cm"> * up to go directly back into the Guest, but sometimes the Host wants to see</span>
<span class="cm"> * them first, so we also have a way of &quot;reflecting&quot; them into the Guest as if</span>
<span class="cm"> * they had been delivered to it directly.</span>
<span class="cm">:*/</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &quot;lg.h&quot;</span>

<span class="cm">/* Allow Guests to use a non-128 (ie. non-Linux) syscall trap. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">syscall_vector</span> <span class="o">=</span> <span class="n">SYSCALL_VECTOR</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">syscall_vector</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>

<span class="cm">/* The address of the interrupt handler is split into two bits: */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">idt_address</span><span class="p">(</span><span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;type&quot; of the interrupt handler is a 4 bit field: we only support a</span>
<span class="cm"> * couple of types.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">idt_type</span><span class="p">(</span><span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* An IDT entry can&#39;t be used unless the &quot;present&quot; bit is set. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">idt_present</span><span class="p">(</span><span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need a helper to &quot;push&quot; a value onto the Guest&#39;s stack, since that&#39;s a</span>
<span class="cm"> * big part of what delivering an interrupt does.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">push_guest_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">gstack</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stack grows upwards: move stack then write value. */</span>
	<span class="o">*</span><span class="n">gstack</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">lgwrite</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">*</span><span class="n">gstack</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*H:210</span>
<span class="cm"> * The set_guest_interrupt() routine actually delivers the interrupt or</span>
<span class="cm"> * trap.  The mechanics of delivering traps and interrupts to the Guest are the</span>
<span class="cm"> * same, except some traps have an &quot;error code&quot; which gets pushed onto the</span>
<span class="cm"> * stack as well: the caller tells us if this is one.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;lo&quot; and &quot;hi&quot; are the two parts of the Interrupt Descriptor Table for this</span>
<span class="cm"> * interrupt or trap.  It&#39;s split into two parts for traditional reasons: gcc</span>
<span class="cm"> * on i386 used to be frightened by 64 bit numbers.</span>
<span class="cm"> *</span>
<span class="cm"> * We set up the stack just like the CPU does for a real interrupt, so it&#39;s</span>
<span class="cm"> * identical for the Guest (and the standard &quot;iret&quot; instruction will undo</span>
<span class="cm"> * it).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_guest_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">has_err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gstack</span><span class="p">,</span> <span class="n">origstack</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eflags</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">irq_enable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">virtstack</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are two cases for interrupts: one where the Guest is already</span>
<span class="cm">	 * in the kernel, and a more complex one where the Guest is in</span>
<span class="cm">	 * userspace.  We check the privilege level to find out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ss</span><span class="o">&amp;</span><span class="mh">0x3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GUEST_PL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The Guest told us their kernel stack with the SET_STACK</span>
<span class="cm">		 * hypercall: both the virtual address and the segment.</span>
<span class="cm">		 */</span>
		<span class="n">virtstack</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">esp1</span><span class="p">;</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">ss1</span><span class="p">;</span>

		<span class="n">origstack</span> <span class="o">=</span> <span class="n">gstack</span> <span class="o">=</span> <span class="n">guest_pa</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">virtstack</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We push the old stack segment and pointer onto the new</span>
<span class="cm">		 * stack: when the Guest does an &quot;iret&quot; back from the interrupt</span>
<span class="cm">		 * handler the CPU will notice they&#39;re dropping privilege</span>
<span class="cm">		 * levels and expect these here.</span>
<span class="cm">		 */</span>
		<span class="n">push_guest_stack</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gstack</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">);</span>
		<span class="n">push_guest_stack</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gstack</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">esp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We&#39;re staying on the same Guest (kernel) stack. */</span>
		<span class="n">virtstack</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">esp</span><span class="p">;</span>
		<span class="n">ss</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">;</span>

		<span class="n">origstack</span> <span class="o">=</span> <span class="n">gstack</span> <span class="o">=</span> <span class="n">guest_pa</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">virtstack</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remember that we never let the Guest actually disable interrupts, so</span>
<span class="cm">	 * the &quot;Interrupt Flag&quot; bit is always set.  We copy that bit from the</span>
<span class="cm">	 * Guest&#39;s &quot;irq_enabled&quot; field into the eflags word: we saw the Guest</span>
<span class="cm">	 * copy it back in &quot;lguest_iret&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">eflags</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eflags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">irq_enable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">irq_enable</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">))</span>
		<span class="n">eflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_IF</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An interrupt is expected to push three things on the stack: the old</span>
<span class="cm">	 * &quot;eflags&quot; word, the old code segment, and the old instruction</span>
<span class="cm">	 * pointer.</span>
<span class="cm">	 */</span>
	<span class="n">push_guest_stack</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gstack</span><span class="p">,</span> <span class="n">eflags</span><span class="p">);</span>
	<span class="n">push_guest_stack</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gstack</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">push_guest_stack</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gstack</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">);</span>

	<span class="cm">/* For the six traps which supply an error code, we push that, too. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_err</span><span class="p">)</span>
		<span class="n">push_guest_stack</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gstack</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">errcode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we&#39;ve pushed all the old state, we change the stack, the code</span>
<span class="cm">	 * segment and the address to execute.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ss</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">esp</span> <span class="o">=</span> <span class="n">virtstack</span> <span class="o">+</span> <span class="p">(</span><span class="n">gstack</span> <span class="o">-</span> <span class="n">origstack</span><span class="p">);</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">=</span> <span class="p">(</span><span class="n">__KERNEL_CS</span><span class="o">|</span><span class="n">GUEST_PL</span><span class="p">);</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">=</span> <span class="n">idt_address</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are two kinds of interrupt handlers: 0xE is an &quot;interrupt</span>
<span class="cm">	 * gate&quot; which expects interrupts to be disabled on entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idt_type</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xE</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">))</span>
			<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Disabling interrupts&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*H:205</span>
<span class="cm"> * Virtual Interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * interrupt_pending() returns the first pending interrupt which isn&#39;t blocked</span>
<span class="cm"> * by the Guest.  It is called before every entry to the Guest, and just before</span>
<span class="cm"> * we go to sleep when the Guest has halted itself.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">interrupt_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">LGUEST_IRQS</span><span class="p">);</span>

	<span class="cm">/* If the Guest hasn&#39;t even initialized yet, we can do nothing. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LGUEST_IRQS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take our &quot;irqs_pending&quot; array and remove any interrupts the Guest</span>
<span class="cm">	 * wants blocked: the result ends up in &quot;blk&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">blocked_interrupts</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">blk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">LGUEST_IRQS</span><span class="p">;</span>
	<span class="n">bitmap_andnot</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">irqs_pending</span><span class="p">,</span> <span class="n">blk</span><span class="p">,</span> <span class="n">LGUEST_IRQS</span><span class="p">);</span>

	<span class="cm">/* Find the first interrupt. */</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">LGUEST_IRQS</span><span class="p">);</span>
	<span class="o">*</span><span class="n">more</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">LGUEST_IRQS</span><span class="p">,</span> <span class="n">irq</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This actually diverts the Guest to running an interrupt handler, once an</span>
<span class="cm"> * interrupt has been identified by interrupt_pending().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">try_deliver_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">idt</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">LGUEST_IRQS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * They may be in the middle of an iret, where they asked us never to</span>
<span class="cm">	 * deliver interrupts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">&gt;=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">noirq_start</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">&lt;</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">noirq_end</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If they&#39;re halted, interrupts restart them. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">halted</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Re-enable interrupts. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">X86_EFLAGS_IF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">))</span>
			<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Re-enabling interrupts&quot;</span><span class="p">);</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise we check if they have interrupts disabled. */</span>
		<span class="n">u32</span> <span class="n">irq_enabled</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">irq_enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">))</span>
			<span class="n">irq_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Make sure they know an IRQ is pending. */</span>
			<span class="n">put_user</span><span class="p">(</span><span class="n">X86_EFLAGS_IF</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look at the IDT entry the Guest gave us for this interrupt.  The</span>
<span class="cm">	 * first 32 (FIRST_EXTERNAL_VECTOR) entries are for traps, so we skip</span>
<span class="cm">	 * over them.</span>
<span class="cm">	 */</span>
	<span class="n">idt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">[</span><span class="n">FIRST_EXTERNAL_VECTOR</span><span class="o">+</span><span class="n">irq</span><span class="p">];</span>
	<span class="cm">/* If they don&#39;t have a handler (yet?), we just ignore it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idt_present</span><span class="p">(</span><span class="n">idt</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">idt</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* OK, mark it no longer pending and deliver it. */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">irqs_pending</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * set_guest_interrupt() takes the interrupt descriptor and a</span>
<span class="cm">		 * flag to say whether this interrupt pushes an error code onto</span>
<span class="cm">		 * the stack as well: virtual interrupts never do.</span>
<span class="cm">		 */</span>
		<span class="n">set_guest_interrupt</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idt</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">idt</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Every time we deliver an interrupt, we update the timestamp in the</span>
<span class="cm">	 * Guest&#39;s lguest_data struct.  It would be better for the Guest if we</span>
<span class="cm">	 * did this more often, but it can actually be quite slow: doing it</span>
<span class="cm">	 * here is a compromise which means at least it gets updated every</span>
<span class="cm">	 * timer interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">write_timestamp</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are no other interrupts we want to deliver, clear</span>
<span class="cm">	 * the pending flag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">more</span><span class="p">)</span>
		<span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* And this is the routine when we want to set an interrupt for the Guest. */</span>
<span class="kt">void</span> <span class="nf">set_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Next time the Guest runs, the core code will see if it can deliver</span>
<span class="cm">	 * this interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">irqs_pending</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure it sees it; it might be asleep (eg. halted), or running</span>
<span class="cm">	 * the Guest right now, in which case kick_process() will knock it out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wake_up_process</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">))</span>
		<span class="n">kick_process</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*</span>
<span class="cm"> * Linux uses trap 128 for system calls.  Plan9 uses 64, and Ron Minnich sent</span>
<span class="cm"> * me a patch, so we support that too.  It&#39;d be a big step for lguest if half</span>
<span class="cm"> * the Plan 9 user base were to start using it.</span>
<span class="cm"> *</span>
<span class="cm"> * Actually now I think of it, it&#39;s possible that Ron *is* half the Plan 9</span>
<span class="cm"> * userbase.  Oh well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">could_be_syscall</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Normal Linux SYSCALL_VECTOR or reserved vector? */</span>
	<span class="k">return</span> <span class="n">num</span> <span class="o">==</span> <span class="n">SYSCALL_VECTOR</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="n">syscall_vector</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The syscall vector it wants must be unused by Host. */</span>
<span class="n">bool</span> <span class="nf">check_syscall_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest</span> <span class="o">*</span><span class="n">lg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">syscall_vec</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">could_be_syscall</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">init_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If they want some strange system call vector, reserve it now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">syscall_vector</span> <span class="o">!=</span> <span class="n">SYSCALL_VECTOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">syscall_vector</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">vector_used_by_percpu_irq</span><span class="p">(</span><span class="n">syscall_vector</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;lg: couldn&#39;t reserve syscall %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">syscall_vector</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">syscall_vector</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">syscall_vector</span> <span class="o">!=</span> <span class="n">SYSCALL_VECTOR</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">syscall_vector</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*H:220</span>
<span class="cm"> * Now we&#39;ve got the routines to deliver interrupts, delivering traps like</span>
<span class="cm"> * page fault is easy.  The only trick is that Intel decided that some traps</span>
<span class="cm"> * should have error codes:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">has_err</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">trap</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">||</span> <span class="p">(</span><span class="n">trap</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">trap</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">)</span> <span class="o">||</span> <span class="n">trap</span> <span class="o">==</span> <span class="mi">17</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* deliver_trap() returns true if it could deliver the trap. */</span>
<span class="n">bool</span> <span class="nf">deliver_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Trap numbers are always 8 bit, but we set an impossible trap number</span>
<span class="cm">	 * for traps inside the Switcher, so check that here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Early on the Guest hasn&#39;t set the IDT entries (or maybe it put a</span>
<span class="cm">	 * bogus one in): if we fail here, the Guest will be killed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idt_present</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">b</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">set_guest_interrupt</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">a</span><span class="p">,</span>
			    <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">b</span><span class="p">,</span> <span class="n">has_err</span><span class="p">(</span><span class="n">num</span><span class="p">));</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*H:250</span>
<span class="cm"> * Here&#39;s the hard part: returning to the Host every time a trap happens</span>
<span class="cm"> * and then calling deliver_trap() and re-entering the Guest is slow.</span>
<span class="cm"> * Particularly because Guest userspace system calls are traps (usually trap</span>
<span class="cm"> * 128).</span>
<span class="cm"> *</span>
<span class="cm"> * So we&#39;d like to set up the IDT to tell the CPU to deliver traps directly</span>
<span class="cm"> * into the Guest.  This is possible, but the complexities cause the size of</span>
<span class="cm"> * this file to double!  However, 150 lines of code is worth writing for taking</span>
<span class="cm"> * system calls down from 1750ns to 270ns.  Plus, if lguest didn&#39;t do it, all</span>
<span class="cm"> * the other hypervisors would beat it up at lunchtime.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine indicates if a particular trap number could be delivered</span>
<span class="cm"> * directly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">direct_trap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hardware interrupts don&#39;t go to the Guest at all (except system</span>
<span class="cm">	 * call).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">FIRST_EXTERNAL_VECTOR</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">could_be_syscall</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Host needs to see page faults (for shadow paging and to save the</span>
<span class="cm">	 * fault address), general protection faults (in/out emulation) and</span>
<span class="cm">	 * device not available (TS handling) and of course, the hypercall trap.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">num</span> <span class="o">!=</span> <span class="mi">14</span> <span class="o">&amp;&amp;</span> <span class="n">num</span> <span class="o">!=</span> <span class="mi">13</span> <span class="o">&amp;&amp;</span> <span class="n">num</span> <span class="o">!=</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">num</span> <span class="o">!=</span> <span class="n">LGUEST_TRAP_ENTRY</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*M:005</span>
<span class="cm"> * The Guest has the ability to turn its interrupt gates into trap gates,</span>
<span class="cm"> * if it is careful.  The Host will let trap gates can go directly to the</span>
<span class="cm"> * Guest, but the Guest needs the interrupts atomically disabled for an</span>
<span class="cm"> * interrupt gate.  It can do this by pointing the trap gate at instructions</span>
<span class="cm"> * within noirq_start and noirq_end, where it can safely disable interrupts.</span>
<span class="cm"> */</span>

<span class="cm">/*M:006</span>
<span class="cm"> * The Guests do not use the sysenter (fast system call) instruction,</span>
<span class="cm"> * because it&#39;s hardcoded to enter privilege level 0 and so can&#39;t go direct.</span>
<span class="cm"> * It&#39;s about twice as fast as the older &quot;int 0x80&quot; system call, so it might</span>
<span class="cm"> * still be worthwhile to handle it in the Switcher and lcall down to the</span>
<span class="cm"> * Guest.  The sysenter semantics are hairy tho: search for that keyword in</span>
<span class="cm"> * entry.S</span>
<span class="cm">:*/</span>

<span class="cm">/*H:260</span>
<span class="cm"> * When we make traps go directly into the Guest, we need to make sure</span>
<span class="cm"> * the kernel stack is valid (ie. mapped in the page tables).  Otherwise, the</span>
<span class="cm"> * CPU trying to deliver the trap will fault while trying to push the interrupt</span>
<span class="cm"> * words on the stack: this is called a double fault, and it forces us to kill</span>
<span class="cm"> * the Guest.</span>
<span class="cm"> *</span>
<span class="cm"> * Which is deeply unfair, because (literally!) it wasn&#39;t the Guests&#39; fault.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pin_stack_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Depending on the CONFIG_4KSTACKS option, the Guest can have one or</span>
<span class="cm">	 * two pages of stack space.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">stack_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * The stack grows *upwards*, so the address we&#39;re given is the</span>
<span class="cm">		 * start of the page after the kernel stack.  Subtract one to</span>
<span class="cm">		 * get back onto the first stack page, and keep subtracting to</span>
<span class="cm">		 * get to the rest of the stack pages.</span>
<span class="cm">		 */</span>
		<span class="n">pin_page</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">esp1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Direct traps also mean that we need to know whenever the Guest wants to use</span>
<span class="cm"> * a different kernel stack, so we can change the guest TSS to use that</span>
<span class="cm"> * stack.  The TSS entries expect a virtual address, so unlike most addresses</span>
<span class="cm"> * the Guest gives us, the &quot;esp&quot; (stack pointer) value here is virtual, not</span>
<span class="cm"> * physical.</span>
<span class="cm"> *</span>
<span class="cm"> * In Linux each process has its own kernel stack, so this happens a lot: we</span>
<span class="cm"> * change stacks on each context switch.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">guest_set_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">esp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * You&#39;re not allowed a stack segment with privilege level 0: bad Guest!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GUEST_PL</span><span class="p">)</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;bad stack segment %i&quot;</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="cm">/* We only expect one or two stack pages. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;bad stack pages %u&quot;</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="cm">/* Save where the stack is, and how many pages */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">ss1</span> <span class="o">=</span> <span class="n">seg</span><span class="p">;</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">esp1</span> <span class="o">=</span> <span class="n">esp</span><span class="p">;</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">stack_pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="cm">/* Make sure the new stack pages are mapped */</span>
	<span class="n">pin_stack_pages</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All this reference to mapping stacks leads us neatly into the other complex</span>
<span class="cm"> * part of the Host: page table handling.</span>
<span class="cm"> */</span>

<span class="cm">/*H:235</span>
<span class="cm"> * This is the routine which actually checks the Guest&#39;s IDT entry and</span>
<span class="cm"> * transfers it into the entry in &quot;struct lguest&quot;:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">trap</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span> <span class="o">=</span> <span class="n">idt_type</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

	<span class="cm">/* We zero-out a not-present entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idt_present</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trap</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="n">trap</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We only support interrupt and trap gates. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="mh">0xE</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="mh">0xF</span><span class="p">)</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;bad IDT type %i&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only copy the handler address, present bit, privilege level and</span>
<span class="cm">	 * type.  The privilege level controls where the trap can be triggered</span>
<span class="cm">	 * manually with an &quot;int&quot; instruction.  This is usually GUEST_PL,</span>
<span class="cm">	 * except for system calls which userspace can use.</span>
<span class="cm">	 */</span>
	<span class="n">trap</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">__KERNEL_CS</span><span class="o">|</span><span class="n">GUEST_PL</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">lo</span><span class="o">&amp;</span><span class="mh">0x0000FFFF</span><span class="p">);</span>
	<span class="n">trap</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span><span class="o">&amp;</span><span class="mh">0xFFFFEF00</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*H:230</span>
<span class="cm"> * While we&#39;re here, dealing with delivering traps and interrupts to the</span>
<span class="cm"> * Guest, we might as well complete the picture: how the Guest tells us where</span>
<span class="cm"> * it wants them to go.  This would be simple, except making traps fast</span>
<span class="cm"> * requires some tricks.</span>
<span class="cm"> *</span>
<span class="cm"> * We saw the Guest setting Interrupt Descriptor Table (IDT) entries with the</span>
<span class="cm"> * LHCALL_LOAD_IDT_ENTRY hypercall before: that comes here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">load_guest_idt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Guest never handles: NMI, doublefault, spurious interrupt or</span>
<span class="cm">	 * hypercall.  We ignore when it tries to set them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="n">LGUEST_TRAP_ENTRY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark the IDT as changed: next time the Guest runs we&#39;ll know we have</span>
<span class="cm">	 * to copy this again.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">|=</span> <span class="n">CHANGED_IDT</span><span class="p">;</span>

	<span class="cm">/* Check that the Guest doesn&#39;t try to step outside the bounds. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">))</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Setting idt entry %u&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_trap</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="n">num</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The default entry for each interrupt points into the Switcher routines which</span>
<span class="cm"> * simply return to the Host.  The run_guest() loop will then call</span>
<span class="cm"> * deliver_trap() to bounce it back into the Guest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">default_idt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">idt</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">trap</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handler</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* A present interrupt gate. */</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="mh">0x8e00</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the privilege level on the entry for the hypercall: this allows</span>
<span class="cm">	 * the Guest to use the &quot;int&quot; instruction to trigger it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trap</span> <span class="o">==</span> <span class="n">LGUEST_TRAP_ENTRY</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">GUEST_PL</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Copy privilege level from what Guest asked for.  This allows</span>
<span class="cm">		 * debug (int 3) traps from Guest userspace, for example.</span>
<span class="cm">		 */</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mh">0x6000</span><span class="p">);</span>

	<span class="cm">/* Now pack it into the IDT entry in its weird format. */</span>
	<span class="n">idt</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">LGUEST_CS</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">handler</span><span class="o">&amp;</span><span class="mh">0x0000FFFF</span><span class="p">);</span>
	<span class="n">idt</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">handler</span><span class="o">&amp;</span><span class="mh">0xFFFF0000</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* When the Guest first starts, we put default entries into the IDT. */</span>
<span class="kt">void</span> <span class="nf">setup_default_idt_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest_ro_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">def</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_idt</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">default_idt_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_idt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">def</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*H:240</span>
<span class="cm"> * We don&#39;t use the IDT entries in the &quot;struct lguest&quot; directly, instead</span>
<span class="cm"> * we copy them into the IDT which we&#39;ve set up for Guests on this CPU, just</span>
<span class="cm"> * before we run the Guest.  This routine does that copy.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">copy_traps</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">idt</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">def</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can simply copy the direct traps, otherwise we use the default</span>
<span class="cm">	 * ones in the Switcher: they will return to the Host.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">gidt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">idt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* If no Guest can ever override this trap, leave it alone. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">direct_trap</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only trap gates (type 15) can go direct to the Guest.</span>
<span class="cm">		 * Interrupt gates (type 14) disable interrupts as they are</span>
<span class="cm">		 * entered, which we never let the Guest do.  Not present</span>
<span class="cm">		 * entries (type 0x0) also can&#39;t go direct, of course.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If it can&#39;t go direct, we still need to copy the priv. level:</span>
<span class="cm">		 * they might want to give userspace access to a software</span>
<span class="cm">		 * interrupt.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idt_type</span><span class="p">(</span><span class="n">gidt</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">gidt</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xF</span><span class="p">)</span>
			<span class="n">idt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">gidt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">default_idt_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">def</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gidt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*H:200</span>
<span class="cm"> * The Guest Clock.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two sources of virtual interrupts.  We saw one in lguest_user.c:</span>
<span class="cm"> * the Launcher sending interrupts for virtual devices.  The other is the Guest</span>
<span class="cm"> * timer interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * The Guest uses the LHCALL_SET_CLOCKEVENT hypercall to tell us how long to</span>
<span class="cm"> * the next timer interrupt (in nanoseconds).  We use the high-resolution timer</span>
<span class="cm"> * infrastructure to set a callback at that time.</span>
<span class="cm"> *</span>
<span class="cm"> * 0 means &quot;turn off the clock&quot;.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">guest_set_clockevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Clock event device is shutting down. */</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use wallclock time here, so the Guest might not be running for</span>
<span class="cm">	 * all the time between now and the timer interrupt it asked for.  This</span>
<span class="cm">	 * is almost always the right thing to do.</span>
<span class="cm">	 */</span>
	<span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">(),</span> <span class="n">delta</span><span class="p">);</span>
	<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is the function called when the Guest&#39;s timer expires. */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">clockdev_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lg_cpu</span><span class="p">,</span> <span class="n">hrt</span><span class="p">);</span>

	<span class="cm">/* Remember the first interrupt is the timer interrupt. */</span>
	<span class="n">set_interrupt</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This sets up the timer for this Guest. */</span>
<span class="kt">void</span> <span class="nf">init_clockdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">,</span> <span class="n">CLOCK_REALTIME</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">clockdev_fn</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
