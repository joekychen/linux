<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › lguest › x86 › core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2006, Rusty Russell &lt;rusty@rustcorp.com.au&gt; IBM Corporation.</span>
<span class="cm"> * Copyright (C) 2007, Jes Sorensen &lt;jes@sgi.com&gt; SGI.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>
<span class="cm">/*P:450</span>
<span class="cm"> * This file contains the x86-specific lguest code.  It used to be all</span>
<span class="cm"> * mixed in with drivers/lguest/core.c but several foolhardy code slashers</span>
<span class="cm"> * wrestled most of the dependencies out to here in preparation for porting</span>
<span class="cm"> * lguest to other architectures (see what I mean by foolhardy?).</span>
<span class="cm"> *</span>
<span class="cm"> * This also contains a couple of non-obvious setup and teardown pieces which</span>
<span class="cm"> * were implemented after days of debugging pain.</span>
<span class="cm">:*/</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/start_kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/screen_info.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/lguest.h&gt;</span>
<span class="cp">#include &lt;linux/lguest_launcher.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#include &lt;asm/param.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/lguest.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/i387.h&gt;</span>
<span class="cp">#include &quot;../lg.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cpu_had_pge</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">segment</span><span class="p">;</span>
<span class="p">}</span> <span class="n">lguest_entry</span><span class="p">;</span>

<span class="cm">/* Offset from where switcher.S was compiled to where we&#39;ve copied it */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">switcher_offset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SWITCHER_ADDR</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_switcher_text</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This cpu&#39;s struct lguest_pages. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lguest_pages</span> <span class="o">*</span><span class="nf">lguest_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">lguest_pages</span> <span class="o">*</span><span class="p">)</span>
		  <span class="p">(</span><span class="n">SWITCHER_ADDR</span> <span class="o">+</span> <span class="n">SHARED_SWITCHER_PAGES</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">))[</span><span class="n">cpu</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="p">,</span> <span class="n">lg_last_cpu</span><span class="p">);</span>

<span class="cm">/*S:010</span>
<span class="cm"> * We approach the Switcher.</span>
<span class="cm"> *</span>
<span class="cm"> * Remember that each CPU has two pages which are visible to the Guest when it</span>
<span class="cm"> * runs on that CPU.  This has to contain the state for that Guest: we copy the</span>
<span class="cm"> * state in just before we run the Guest.</span>
<span class="cm"> *</span>
<span class="cm"> * Each Guest has &quot;changed&quot; flags which indicate what has changed in the Guest</span>
<span class="cm"> * since it last ran.  We saw this set in interrupts_and_traps.c and</span>
<span class="cm"> * segments.c.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_in_guest_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lguest_pages</span> <span class="o">*</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copying all this data can be quite expensive.  We usually run the</span>
<span class="cm">	 * same Guest we ran last time (and that Guest hasn&#39;t run anywhere else</span>
<span class="cm">	 * meanwhile).  If that&#39;s not the case, we pretend everything in the</span>
<span class="cm">	 * Guest has changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">lg_last_cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cpu</span> <span class="o">||</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">last_pages</span> <span class="o">!=</span> <span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">lg_last_cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">last_pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="n">CHANGED_ALL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * These copies are pretty cheap, so we do them unconditionally: */</span>
	<span class="cm">/* Save the current Host top-level page directory.</span>
<span class="cm">	 */</span>
	<span class="n">pages</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">host_cr3</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up the Guest&#39;s page tables to see this CPU&#39;s pages (and no</span>
<span class="cm">	 * other CPU&#39;s pages).</span>
<span class="cm">	 */</span>
	<span class="n">map_switcher_in_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up the two &quot;TSS&quot; members which tell the CPU what stack to use</span>
<span class="cm">	 * for traps which do directly into the Guest (ie. traps at privilege</span>
<span class="cm">	 * level 1).</span>
<span class="cm">	 */</span>
	<span class="n">pages</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">guest_tss</span><span class="p">.</span><span class="n">sp1</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">esp1</span><span class="p">;</span>
	<span class="n">pages</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">guest_tss</span><span class="p">.</span><span class="n">ss1</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">ss1</span><span class="p">;</span>

	<span class="cm">/* Copy direct-to-Guest trap entries. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">CHANGED_IDT</span><span class="p">)</span>
		<span class="n">copy_traps</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pages</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">guest_idt</span><span class="p">,</span> <span class="n">default_idt_entries</span><span class="p">);</span>

	<span class="cm">/* Copy all GDT entries which the Guest can change. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">CHANGED_GDT</span><span class="p">)</span>
		<span class="n">copy_gdt</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pages</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">guest_gdt</span><span class="p">);</span>
	<span class="cm">/* If only the TLS entries have changed, copy them. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">CHANGED_GDT_TLS</span><span class="p">)</span>
		<span class="n">copy_gdt_tls</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pages</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">guest_gdt</span><span class="p">);</span>

	<span class="cm">/* Mark the Guest as unchanged for next time. */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Finally: the code to actually call into the Switcher to run the Guest. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_guest_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lguest_pages</span> <span class="o">*</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is a dummy value we need for GCC&#39;s sake. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clobber</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the guest-specific information into this CPU&#39;s &quot;struct</span>
<span class="cm">	 * lguest_pages&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">copy_in_guest_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the trap number to 256 (impossible value).  If we fault while</span>
<span class="cm">	 * switching to the Guest (bad segment registers or bug), this will</span>
<span class="cm">	 * cause us to abort the Guest.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trapnum</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now: we push the &quot;eflags&quot; register on the stack, then do an &quot;lcall&quot;.</span>
<span class="cm">	 * This is how we change from using the kernel code segment to using</span>
<span class="cm">	 * the dedicated lguest code segment, as well as jumping into the</span>
<span class="cm">	 * Switcher.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The lcall also pushes the old code segment (KERNEL_CS) onto the</span>
<span class="cm">	 * stack, then the address of this call.  This stack layout happens to</span>
<span class="cm">	 * exactly match the stack layout created by an interrupt...</span>
<span class="cm">	 */</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;pushf; lcall *lguest_entry&quot;</span>
		     <span class="cm">/*</span>
<span class="cm">		      * This is how we tell GCC that %eax (&quot;a&quot;) and %ebx (&quot;b&quot;)</span>
<span class="cm">		      * are changed by this routine.  The &quot;=&quot; means output.</span>
<span class="cm">		      */</span>
		     <span class="o">:</span> <span class="s">&quot;=a&quot;</span><span class="p">(</span><span class="n">clobber</span><span class="p">),</span> <span class="s">&quot;=b&quot;</span><span class="p">(</span><span class="n">clobber</span><span class="p">)</span>
		     <span class="cm">/*</span>
<span class="cm">		      * %eax contains the pages pointer.  (&quot;0&quot; refers to the</span>
<span class="cm">		      * 0-th argument above, ie &quot;a&quot;).  %ebx contains the</span>
<span class="cm">		      * physical address of the Guest&#39;s top-level page</span>
<span class="cm">		      * directory.</span>
<span class="cm">		      */</span>
		     <span class="o">:</span> <span class="s">&quot;0&quot;</span><span class="p">(</span><span class="n">pages</span><span class="p">),</span> <span class="s">&quot;1&quot;</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">pgdirs</span><span class="p">[</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cpu_pgd</span><span class="p">].</span><span class="n">pgdir</span><span class="p">))</span>
		     <span class="cm">/*</span>
<span class="cm">		      * We tell gcc that all these registers could change,</span>
<span class="cm">		      * which means we don&#39;t have to save and restore them in</span>
<span class="cm">		      * the Switcher.</span>
<span class="cm">		      */</span>
		     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;%edx&quot;</span><span class="p">,</span> <span class="s">&quot;%ecx&quot;</span><span class="p">,</span> <span class="s">&quot;%edi&quot;</span><span class="p">,</span> <span class="s">&quot;%esi&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*M:002</span>
<span class="cm"> * There are hooks in the scheduler which we can register to tell when we</span>
<span class="cm"> * get kicked off the CPU (preempt_notifier_register()).  This would allow us</span>
<span class="cm"> * to lazily disable SYSENTER which would regain some performance, and should</span>
<span class="cm"> * also simplify copy_in_guest_info().  Note that we&#39;d still need to restore</span>
<span class="cm"> * things when we exit to Launcher userspace, but that&#39;s fairly easy.</span>
<span class="cm"> *</span>
<span class="cm"> * We could also try using these hooks for PGE, but that might be too expensive.</span>
<span class="cm"> *</span>
<span class="cm"> * The hooks were designed for KVM, but we can also put them to good use.</span>
<span class="cm">:*/</span>

<span class="cm">/*H:040</span>
<span class="cm"> * This is the i386-specific code to setup and run the Guest.  Interrupts</span>
<span class="cm"> * are disabled: we own the CPU.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lguest_arch_run_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remember the awfully-named TS bit?  If the Guest has asked to set it</span>
<span class="cm">	 * we set it now, so we can trap and pass that trap to the Guest if it</span>
<span class="cm">	 * uses the FPU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">)</span>
		<span class="n">unlazy_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SYSENTER is an optimized way of doing system calls.  We can&#39;t allow</span>
<span class="cm">	 * it because it always jumps to privilege level 0.  A normal Guest</span>
<span class="cm">	 * won&#39;t try it because we don&#39;t advertise it in CPUID, but a malicious</span>
<span class="cm">	 * Guest (or malicious Guest userspace program) could, so we tell the</span>
<span class="cm">	 * CPU to disable it before running the Guest.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_SEP</span><span class="p">))</span>
		<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we actually run the Guest.  It will return when something</span>
<span class="cm">	 * interesting happens, and we can examine its registers to see what it</span>
<span class="cm">	 * was doing.</span>
<span class="cm">	 */</span>
	<span class="n">run_guest_once</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">lguest_pages</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">()));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that the &quot;regs&quot; structure contains two extra entries which are</span>
<span class="cm">	 * not really registers: a trap number which says what interrupt or</span>
<span class="cm">	 * trap made the switcher code come back, and an error code which some</span>
<span class="cm">	 * traps set.</span>
<span class="cm">	 */</span>

	 <span class="cm">/* Restore SYSENTER if it&#39;s supposed to be on. */</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_SEP</span><span class="p">))</span>
		<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="n">__KERNEL_CS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the Guest page faulted, then the cr2 register will tell us the</span>
<span class="cm">	 * bad virtual address.  We have to grab this now, because once we</span>
<span class="cm">	 * re-enable interrupts an interrupt could fault and thus overwrite</span>
<span class="cm">	 * cr2, or we could even move off to a different CPU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trapnum</span> <span class="o">==</span> <span class="mi">14</span><span class="p">)</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_pagefault</span> <span class="o">=</span> <span class="n">read_cr2</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Similarly, if we took a trap because the Guest used the FPU,</span>
<span class="cm">	 * we have to restore the FPU it expects to see.</span>
<span class="cm">	 * math_state_restore() may sleep and we may even move off to</span>
<span class="cm">	 * a different CPU. So all the critical stuff should be done</span>
<span class="cm">	 * before this.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trapnum</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">math_state_restore</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*H:130</span>
<span class="cm"> * Now we&#39;ve examined the hypercall code; our Guest can make requests.</span>
<span class="cm"> * Our Guest is usually so well behaved; it never tries to do things it isn&#39;t</span>
<span class="cm"> * allowed to, and uses hypercalls instead.  Unfortunately, Linux&#39;s paravirtual</span>
<span class="cm"> * infrastructure isn&#39;t quite complete, because it doesn&#39;t contain replacements</span>
<span class="cm"> * for the Intel I/O instructions.  As a result, the Guest sometimes fumbles</span>
<span class="cm"> * across one during the boot process as it probes for various things which are</span>
<span class="cm"> * usually attached to a PC.</span>
<span class="cm"> *</span>
<span class="cm"> * When the Guest uses one of these instructions, we get a trap (General</span>
<span class="cm"> * Protection Fault) and come here.  We see if it&#39;s one of those troublesome</span>
<span class="cm"> * instructions and skip over it.  We return true if we did.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulate_insn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">insn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insnlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">small_operand</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The eip contains the *virtual* address of the Guest&#39;s instruction:</span>
<span class="cm">	 * walk the Guest&#39;s page tables to find the &quot;physical&quot; address.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physaddr</span> <span class="o">=</span> <span class="n">guest_pa</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This must be the Guest kernel trying to do something, not userspace!</span>
<span class="cm">	 * The bottom two bits of the CS segment register are the privilege</span>
<span class="cm">	 * level.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GUEST_PL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Decoding x86 instructions is icky. */</span>
	<span class="n">insn</span> <span class="o">=</span> <span class="n">lgread</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">physaddr</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Around 2.6.33, the kernel started using an emulation for the</span>
<span class="cm">	 * cmpxchg8b instruction in early boot on many configurations.  This</span>
<span class="cm">	 * code isn&#39;t paravirtualized, and it tries to disable interrupts.</span>
<span class="cm">	 * Ignore it, which will Mostly Work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">==</span> <span class="mh">0xfa</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &quot;cli&quot;, or Clear Interrupt Enable instruction.  Skip it. */</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * 0x66 is an &quot;operand prefix&quot;.  It means a 16, not 32 bit in/out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">==</span> <span class="mh">0x66</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">small_operand</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* The instruction is 1 byte so far, read the next byte. */</span>
		<span class="n">insnlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">insn</span> <span class="o">=</span> <span class="n">lgread</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">physaddr</span> <span class="o">+</span> <span class="n">insnlen</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can ignore the lower bit for the moment and decode the 4 opcodes</span>
<span class="cm">	 * we need to emulate.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0xFE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0xE4</span>: <span class="cm">/* in     &lt;next byte&gt;,%al */</span>
		<span class="n">insnlen</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">in</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xEC</span>: <span class="cm">/* in     (%dx),%al */</span>
		<span class="n">insnlen</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">in</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xE6</span>: <span class="cm">/* out    %al,&lt;next byte&gt; */</span>
		<span class="n">insnlen</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xEE</span>: <span class="cm">/* out    %al,(%dx) */</span>
		<span class="n">insnlen</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* OK, we don&#39;t know what this is, can&#39;t emulate. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it was an &quot;IN&quot; instruction, they expect the result to be read</span>
<span class="cm">	 * into %eax, so we change %eax.  We always return all-ones, which</span>
<span class="cm">	 * traditionally means &quot;there&#39;s nothing there&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Lower bit tells means it&#39;s a 32/16 bit access */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">small_operand</span><span class="p">)</span>
				<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eax</span> <span class="o">|=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eax</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eax</span> <span class="o">|=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Finally, we&#39;ve &quot;done&quot; the instruction, so move past it. */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">+=</span> <span class="n">insnlen</span><span class="p">;</span>
	<span class="cm">/* Success! */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*H:050 Once we&#39;ve re-enabled interrupts, we look at why the Guest exited. */</span>
<span class="kt">void</span> <span class="nf">lguest_arch_handle_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trapnum</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">13</span>: <span class="cm">/* We&#39;ve intercepted a General Protection Fault. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if this was one of those annoying IN or OUT</span>
<span class="cm">		 * instructions which we need to emulate.  If so, we just go</span>
<span class="cm">		 * back into the Guest after we&#39;ve done it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">errcode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">emulate_insn</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">14</span>: <span class="cm">/* We&#39;ve intercepted a Page Fault. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * The Guest accessed a virtual address that wasn&#39;t mapped.</span>
<span class="cm">		 * This happens a lot: we don&#39;t actually set up most of the page</span>
<span class="cm">		 * tables for the Guest at all when we start: as it runs it asks</span>
<span class="cm">		 * for more and more, and we set them up as required. In this</span>
<span class="cm">		 * case, we don&#39;t even tell the Guest that the fault happened.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The errcode tells whether this was a read or a write, and</span>
<span class="cm">		 * whether kernel or userspace code.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">demand_page</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_pagefault</span><span class="p">,</span>
				<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">errcode</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * OK, it&#39;s really not there (or not OK): the Guest needs to</span>
<span class="cm">		 * know.  We write out the cr2 value so it knows where the</span>
<span class="cm">		 * fault occurred.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that if the Guest were really messed up, this could</span>
<span class="cm">		 * happen before it&#39;s done the LHCALL_LGUEST_INIT hypercall, so</span>
<span class="cm">		 * lg-&gt;lguest_data could be NULL</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span> <span class="o">&amp;&amp;</span>
		    <span class="n">put_user</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_pagefault</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">cr2</span><span class="p">))</span>
			<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Writing cr2&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">7</span>: <span class="cm">/* We&#39;ve intercepted a Device Not Available fault. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the Guest doesn&#39;t want to know, we already restored the</span>
<span class="cm">		 * Floating Point Unit, so we just continue without telling it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">32</span> <span class="p">...</span> <span class="mi">255</span>:
		<span class="cm">/*</span>
<span class="cm">		 * These values mean a real interrupt occurred, in which case</span>
<span class="cm">		 * the Host handler has already been run. We just do a</span>
<span class="cm">		 * friendly check if another process should now be run, then</span>
<span class="cm">		 * return to run the Guest again.</span>
<span class="cm">		 */</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LGUEST_TRAP_ENTRY</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Our &#39;struct hcall_args&#39; maps directly over our regs: we set</span>
<span class="cm">		 * up the pointer now to indicate a hypercall is pending.</span>
<span class="cm">		 */</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hcall_args</span> <span class="o">*</span><span class="p">)</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We didn&#39;t handle the trap, so it needs to go to the Guest. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deliver_trap</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trapnum</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the Guest doesn&#39;t have a handler (either it hasn&#39;t</span>
<span class="cm">		 * registered any yet, or it&#39;s one of the faults we don&#39;t let</span>
<span class="cm">		 * it handle), it dies with this cryptic error message.</span>
<span class="cm">		 */</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;unhandled trap %li at %#lx (%#lx)&quot;</span><span class="p">,</span>
			   <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trapnum</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">,</span>
			   <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trapnum</span> <span class="o">==</span> <span class="mi">14</span> <span class="o">?</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_pagefault</span>
			   <span class="o">:</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">errcode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Now we can look at each of the routines this calls, in increasing order of</span>
<span class="cm"> * complexity: do_hypercalls(), emulate_insn(), maybe_do_interrupt(),</span>
<span class="cm"> * deliver_trap() and demand_page().  After all those, we&#39;ll be ready to</span>
<span class="cm"> * examine the Switcher, and our philosophical understanding of the Host/Guest</span>
<span class="cm"> * duality will be complete.</span>
<span class="cm">:*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">adjust_pge</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span>
		<span class="n">write_cr4</span><span class="p">(</span><span class="n">read_cr4</span><span class="p">()</span> <span class="o">|</span> <span class="n">X86_CR4_PGE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">write_cr4</span><span class="p">(</span><span class="n">read_cr4</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">X86_CR4_PGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*H:020</span>
<span class="cm"> * Now the Switcher is mapped and every thing else is ready, we need to do</span>
<span class="cm"> * some more i386-specific initialization.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">lguest_arch_host_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Most of the x86/switcher_32.S doesn&#39;t care that it&#39;s been moved; on</span>
<span class="cm">	 * Intel, jumps are relative, and it doesn&#39;t access any references to</span>
<span class="cm">	 * external code or data.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The only exception is the interrupt handlers in switcher.S: their</span>
<span class="cm">	 * addresses are placed in a table (default_idt_entries), so we need to</span>
<span class="cm">	 * update the table with the new addresses.  switcher_offset() is a</span>
<span class="cm">	 * convenience function which returns the distance between the</span>
<span class="cm">	 * compiled-in switcher code and the high-mapped copy we just made.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IDT_ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">default_idt_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">switcher_offset</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the Switcher&#39;s per-cpu areas.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Each CPU gets two pages of its own within the high-mapped region</span>
<span class="cm">	 * (aka. &quot;struct lguest_pages&quot;).  Much of this can be initialized now,</span>
<span class="cm">	 * but some depends on what Guest we are running (which is set up in</span>
<span class="cm">	 * copy_in_guest_info()).</span>
<span class="cm">	 */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* lguest_pages() returns this CPU&#39;s two pages. */</span>
		<span class="k">struct</span> <span class="n">lguest_pages</span> <span class="o">*</span><span class="n">pages</span> <span class="o">=</span> <span class="n">lguest_pages</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="cm">/* This is a convenience pointer to make the code neater. */</span>
		<span class="k">struct</span> <span class="n">lguest_ro_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The Global Descriptor Table: the Host has a different one</span>
<span class="cm">		 * for each CPU.  We keep a descriptor for the GDT which says</span>
<span class="cm">		 * where it is and how big it is (the size is actually the last</span>
<span class="cm">		 * byte, not the size, hence the &quot;-1&quot;).</span>
<span class="cm">		 */</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">host_gdt_desc</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">GDT_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">host_gdt_desc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * All CPUs on the Host use the same Interrupt Descriptor</span>
<span class="cm">		 * Table, so we just use store_idt(), which gets this CPU&#39;s IDT</span>
<span class="cm">		 * descriptor.</span>
<span class="cm">		 */</span>
		<span class="n">store_idt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">host_idt_desc</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The descriptors for the Guest&#39;s GDT and IDT can be filled</span>
<span class="cm">		 * out now, too.  We copy the GDT &amp; IDT into -&gt;guest_gdt and</span>
<span class="cm">		 * -&gt;guest_idt before actually running the Guest.</span>
<span class="cm">		 */</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_idt_desc</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_idt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_idt_desc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_idt</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_gdt_desc</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_gdt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_gdt_desc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_gdt</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We know where we want the stack to be when the Guest enters</span>
<span class="cm">		 * the Switcher: in pages-&gt;regs.  The stack grows upwards, so</span>
<span class="cm">		 * we start it at the end of that structure.</span>
<span class="cm">		 */</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_tss</span><span class="p">.</span><span class="n">sp0</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * And this is the GDT entry to use for the stack: we keep a</span>
<span class="cm">		 * couple of special LGUEST entries.</span>
<span class="cm">		 */</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_tss</span><span class="p">.</span><span class="n">ss0</span> <span class="o">=</span> <span class="n">LGUEST_DS</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * x86 can have a finegrained bitmap which indicates what I/O</span>
<span class="cm">		 * ports the process can use.  We set it to the end of our</span>
<span class="cm">		 * structure, meaning &quot;none&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_tss</span><span class="p">.</span><span class="n">io_bitmap_base</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">guest_tss</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some GDT entries are the same across all Guests, so we can</span>
<span class="cm">		 * set them up now.</span>
<span class="cm">		 */</span>
		<span class="n">setup_default_gdt_entries</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="cm">/* Most IDT entries are the same for all Guests, too.*/</span>
		<span class="n">setup_default_idt_entries</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">default_idt_entries</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The Host needs to be able to use the LGUEST segments on this</span>
<span class="cm">		 * CPU, too, so put them in the Host GDT.</span>
<span class="cm">		 */</span>
		<span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">GDT_ENTRY_LGUEST_CS</span><span class="p">]</span> <span class="o">=</span> <span class="n">FULL_EXEC_SEGMENT</span><span class="p">;</span>
		<span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">GDT_ENTRY_LGUEST_DS</span><span class="p">]</span> <span class="o">=</span> <span class="n">FULL_SEGMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the Switcher, we want the %cs segment register to use the</span>
<span class="cm">	 * LGUEST_CS GDT entry: we&#39;ve put that in the Host and Guest GDTs, so</span>
<span class="cm">	 * it will be undisturbed when we switch.  To change %cs and jump we</span>
<span class="cm">	 * need this structure to feed to Intel&#39;s &quot;lcall&quot; instruction.</span>
<span class="cm">	 */</span>
	<span class="n">lguest_entry</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">switch_to_guest</span> <span class="o">+</span> <span class="n">switcher_offset</span><span class="p">();</span>
	<span class="n">lguest_entry</span><span class="p">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">LGUEST_CS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, we need to turn off &quot;Page Global Enable&quot;.  PGE is an</span>
<span class="cm">	 * optimization where page table entries are specially marked to show</span>
<span class="cm">	 * they never change.  The Host kernel marks all the kernel pages this</span>
<span class="cm">	 * way because it&#39;s always present, even when userspace is running.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Lguest breaks this: unbeknownst to the rest of the Host kernel, we</span>
<span class="cm">	 * switch to the Guest kernel.  If you don&#39;t disable this on all CPUs,</span>
<span class="cm">	 * you&#39;ll get really weird bugs that you&#39;ll chase for two days.</span>
<span class="cm">	 *</span>
<span class="cm">	 * I used to turn PGE off every time we switched to the Guest and back</span>
<span class="cm">	 * on when we return, but that slowed the Switcher down noticibly.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need the complexity of CPUs coming and going while we&#39;re</span>
<span class="cm">	 * doing this.</span>
<span class="cm">	 */</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_pge</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* We have a broader idea of &quot;global&quot;. */</span>
		<span class="cm">/* Remember that this was originally set (for cleanup). */</span>
		<span class="n">cpu_had_pge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * adjust_pge is a helper function which sets or unsets the PGE</span>
<span class="cm">		 * bit on its CPU, depending on the argument (0 == unset).</span>
<span class="cm">		 */</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">adjust_pge</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* Turn off the feature in the global feature set. */</span>
		<span class="n">clear_cpu_cap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">,</span> <span class="n">X86_FEATURE_PGE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">lguest_arch_host_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we had PGE before we started, turn it back on now. */</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_had_pge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cpu_cap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">,</span> <span class="n">X86_FEATURE_PGE</span><span class="p">);</span>
		<span class="cm">/* adjust_pge&#39;s argument &quot;1&quot; means set PGE. */</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">adjust_pge</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*H:122 The i386-specific hypercalls simply farm out to the right functions. */</span>
<span class="kt">int</span> <span class="nf">lguest_arch_do_hcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hcall_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">arg0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LHCALL_LOAD_GDT_ENTRY</span>:
		<span class="n">load_guest_gdt_entry</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_LOAD_IDT_ENTRY</span>:
		<span class="n">load_guest_idt_entry</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_LOAD_TLS</span>:
		<span class="n">guest_load_tls</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Bad Guest.  Bad! */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*H:126 i386-specific hypercall initialization: */</span>
<span class="kt">int</span> <span class="nf">lguest_arch_init_hypercalls</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tsc_speed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The pointer to the Guest&#39;s &quot;struct lguest_data&quot; is the only argument.</span>
<span class="cm">	 * We check that address now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lguest_address_ok</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Having checked it, we simply set lg-&gt;lguest_data to point straight</span>
<span class="cm">	 * into the Launcher&#39;s memory at the right place and then use</span>
<span class="cm">	 * copy_to_user/from_user from now on, instead of lgread/write.  I put</span>
<span class="cm">	 * this in to show that I&#39;m not immune to writing stupid</span>
<span class="cm">	 * optimizations.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">mem_base</span> <span class="o">+</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We insist that the Time Stamp Counter exist and doesn&#39;t change with</span>
<span class="cm">	 * cpu frequency.  Some devious chip manufacturers decided that TSC</span>
<span class="cm">	 * changes could be handled in software.  I decided that time going</span>
<span class="cm">	 * backwards might be good for benchmarks, but it&#39;s bad for users.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We also insist that the TSC be stable: the kernel detects unreliable</span>
<span class="cm">	 * TSCs for its own purposes, and we use that here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">check_tsc_unstable</span><span class="p">())</span>
		<span class="n">tsc_speed</span> <span class="o">=</span> <span class="n">tsc_khz</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tsc_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">tsc_speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">tsc_khz</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* The interrupt code might not like the system call vector. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_syscall_vector</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="p">))</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;bad syscall vector&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*L:030</span>
<span class="cm"> * Most of the Guest&#39;s registers are left alone: we used get_zeroed_page() to</span>
<span class="cm"> * allocate the structure, so they will be 0.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lguest_arch_setup_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lguest_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are four &quot;segment&quot; registers which the Guest needs to boot:</span>
<span class="cm">	 * The &quot;code segment&quot; register (cs) refers to the kernel code segment</span>
<span class="cm">	 * __KERNEL_CS, and the &quot;data&quot;, &quot;extra&quot; and &quot;stack&quot; segment registers</span>
<span class="cm">	 * refer to the kernel data segment __KERNEL_DS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The privilege level is packed into the lower bits.  The Guest runs</span>
<span class="cm">	 * at privilege level 1 (GUEST_PL).</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ds</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">es</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ss</span> <span class="o">=</span> <span class="n">__KERNEL_DS</span><span class="o">|</span><span class="n">GUEST_PL</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">=</span> <span class="n">__KERNEL_CS</span><span class="o">|</span><span class="n">GUEST_PL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &quot;eflags&quot; register contains miscellaneous flags.  Bit 1 (0x002)</span>
<span class="cm">	 * is supposed to always be &quot;1&quot;.  Bit 9 (0x200) controls whether</span>
<span class="cm">	 * interrupts are enabled.  We always leave interrupts enabled while</span>
<span class="cm">	 * running the Guest.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">eflags</span> <span class="o">=</span> <span class="n">X86_EFLAGS_IF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_BIT1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &quot;Extended Instruction Pointer&quot; register says where the Guest is</span>
<span class="cm">	 * running.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * %esi points to our boot information, at physical address 0, so don&#39;t</span>
<span class="cm">	 * touch it.</span>
<span class="cm">	 */</span>

	<span class="cm">/* There are a couple of GDT entries the Guest expects at boot. */</span>
	<span class="n">setup_guest_gdt</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
