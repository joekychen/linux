<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › lguest › hypercalls.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hypercalls.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*P:500</span>
<span class="cm"> * Just as userspace programs request kernel operations through a system</span>
<span class="cm"> * call, the Guest requests Host operations through a &quot;hypercall&quot;.  You might</span>
<span class="cm"> * notice this nomenclature doesn&#39;t really follow any logic, but the name has</span>
<span class="cm"> * been around for long enough that we&#39;re stuck with it.  As you&#39;d expect, this</span>
<span class="cm"> * code is basically a one big switch statement.</span>
<span class="cm">:*/</span>

<span class="cm">/*  Copyright (C) 2006 Rusty Russell IBM Corporation</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA</span>
<span class="cm">*/</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &quot;lg.h&quot;</span>

<span class="cm">/*H:120</span>
<span class="cm"> * This is the core hypercall routine: where the Guest gets what it wants.</span>
<span class="cm"> * Or gets killed.  Or, in the case of LHCALL_SHUTDOWN, both.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_hcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hcall_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">arg0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LHCALL_FLUSH_ASYNC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This call does nothing, except by breaking out of the Guest</span>
<span class="cm">		 * it makes us process all the asynchronous hypercalls.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_SEND_INTERRUPTS</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This call does nothing too, but by breaking out of the Guest</span>
<span class="cm">		 * it makes us process any pending interrupts.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_LGUEST_INIT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * You can&#39;t get here unless you&#39;re already initialized.  Don&#39;t</span>
<span class="cm">		 * do that.</span>
<span class="cm">		 */</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;already have lguest_data&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_SHUTDOWN</span>: <span class="p">{</span>
		<span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Shutdown is such a trivial hypercall that we do it in five</span>
<span class="cm">		 * lines right here.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If the lgread fails, it will call kill_guest() itself; the</span>
<span class="cm">		 * kill_guest() with the message will be ignored.</span>
<span class="cm">		 */</span>
		<span class="n">__lgread</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
		<span class="n">msg</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;CRASH: %s&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span> <span class="o">==</span> <span class="n">LGUEST_SHUTDOWN_RESTART</span><span class="p">)</span>
			<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ERESTART</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">LHCALL_FLUSH_TLB</span>:
		<span class="cm">/* FLUSH_TLB comes in two flavors, depending on the argument: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">)</span>
			<span class="n">guest_pagetable_clear_all</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">guest_pagetable_flush_user</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * All these calls simply pass the arguments through to the right</span>
<span class="cm">	 * routines.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">LHCALL_NEW_PGTABLE</span>:
		<span class="n">guest_new_pagetable</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_SET_STACK</span>:
		<span class="n">guest_set_stack</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_SET_PTE</span>:
<span class="cp">#ifdef CONFIG_X86_PAE</span>
		<span class="n">guest_set_pte</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">,</span>
				<span class="n">__pte</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">arg3</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">arg4</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">));</span>
<span class="cp">#else</span>
		<span class="n">guest_set_pte</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">arg3</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_SET_PGD</span>:
		<span class="n">guest_set_pgd</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_PAE</span>
	<span class="k">case</span> <span class="n">LHCALL_SET_PMD</span>:
		<span class="n">guest_set_pmd</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">LHCALL_SET_CLOCKEVENT</span>:
		<span class="n">guest_set_clockevent</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_TS</span>:
		<span class="cm">/* This sets the TS flag, as we saw used in run_guest(). */</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">ts</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_HALT</span>:
		<span class="cm">/* Similarly, this sets the halted flag for run_guest(). */</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">halted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LHCALL_NOTIFY</span>:
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* It should be an architecture-specific hypercall. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lguest_arch_do_hcall</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
			<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Bad hypercall %li</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">arg0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*H:124</span>
<span class="cm"> * Asynchronous hypercalls are easy: we just look in the array in the</span>
<span class="cm"> * Guest&#39;s &quot;struct lguest_data&quot; to see if any new ones are marked &quot;ready&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * We are careful to do these in order: obviously we respect the order the</span>
<span class="cm"> * Guest put them in the ring, but we also promise the Guest that they will</span>
<span class="cm"> * happen before any normal hypercall (which is why we check this before</span>
<span class="cm"> * checking for a normal hcall).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_async_hcalls</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">st</span><span class="p">[</span><span class="n">LHCALL_RING_SIZE</span><span class="p">];</span>

	<span class="cm">/* For simplicity, we copy the entire call status array in at once. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">hcall_status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">st</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We process &quot;struct lguest_data&quot;s hcalls[] ring once. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">st</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hcall_args</span> <span class="n">args</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We remember where we were up to from last time.  This makes</span>
<span class="cm">		 * sure that the hypercalls are done in the order the Guest</span>
<span class="cm">		 * places them in the ring.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">next_hcall</span><span class="p">;</span>

		<span class="cm">/* 0xFF means there&#39;s no call here (yet). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * OK, we have hypercall.  Increment the &quot;next_hcall&quot; cursor,</span>
<span class="cm">		 * and wrap back to 0 if we reach the end.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">next_hcall</span> <span class="o">==</span> <span class="n">LHCALL_RING_SIZE</span><span class="p">)</span>
			<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">next_hcall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Copy the hypercall arguments into a local copy of the</span>
<span class="cm">		 * hcall_args struct.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">hcalls</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hcall_args</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Fetching async hypercalls&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Do the hypercall, same as a normal one. */</span>
		<span class="n">do_hcall</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

		<span class="cm">/* Mark the hypercall done. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">hcall_status</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Writing result for async hypercall&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Stop doing hypercalls if they want to notify the Launcher:</span>
<span class="cm">		 * it needs to service this first.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Last of all, we look at what happens first of all.  The very first time the</span>
<span class="cm"> * Guest makes a hypercall, we end up here to set things up:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * You can&#39;t do anything until you&#39;re initialized.  The Guest knows the</span>
<span class="cm">	 * rules, so we&#39;re unforgiving here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span><span class="o">-&gt;</span><span class="n">arg0</span> <span class="o">!=</span> <span class="n">LHCALL_LGUEST_INIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;hypercall %li before INIT&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span><span class="o">-&gt;</span><span class="n">arg0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lguest_arch_init_hypercalls</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;bad guest page %p&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Guest tells us where we&#39;re not to deliver interrupts by putting</span>
<span class="cm">	 * the range of addresses into &quot;struct lguest_data&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">noirq_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">noirq_start</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">get_user</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">noirq_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">noirq_end</span><span class="p">))</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;bad guest page %p&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We write the current time into the Guest&#39;s data page once so it can</span>
<span class="cm">	 * set its clock.</span>
<span class="cm">	 */</span>
	<span class="n">write_timestamp</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* page_tables.c will also do some setup. */</span>
	<span class="n">page_table_guest_data_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the one case where the above accesses might have been the</span>
<span class="cm">	 * first write to a Guest page.  This may have caused a copy-on-write</span>
<span class="cm">	 * fault, but the old page might be (read-only) in the Guest</span>
<span class="cm">	 * pagetable.</span>
<span class="cm">	 */</span>
	<span class="n">guest_pagetable_clear_all</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*M:013</span>
<span class="cm"> * If a Guest reads from a page (so creates a mapping) that it has never</span>
<span class="cm"> * written to, and then the Launcher writes to it (ie. the output of a virtual</span>
<span class="cm"> * device), the Guest will still see the old page.  In practice, this never</span>
<span class="cm"> * happens: why would the Guest read a page which it has never written to?  But</span>
<span class="cm"> * a similar scenario might one day bite us, so it&#39;s worth mentioning.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if we used a shared anonymous mapping in the Launcher instead of</span>
<span class="cm"> * mapping /dev/zero private, we wouldn&#39;t worry about cop-on-write.  And we</span>
<span class="cm"> * need that to switch the Launcher to processes (away from threads) anyway.</span>
<span class="cm">:*/</span>

<span class="cm">/*H:100</span>
<span class="cm"> * Hypercalls</span>
<span class="cm"> *</span>
<span class="cm"> * Remember from the Guest, hypercalls come in two flavors: normal and</span>
<span class="cm"> * asynchronous.  This file handles both of types.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_hypercalls</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Not initialized yet?  This hypercall must do it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Set up the &quot;struct lguest_data&quot; */</span>
		<span class="n">initialize</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="cm">/* Hcall is done. */</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Guest has initialized.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Look in the hypercall ring for the async hypercalls:</span>
<span class="cm">	 */</span>
	<span class="n">do_async_hcalls</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we stopped reading the hypercall ring because the Guest did a</span>
<span class="cm">	 * NOTIFY to the Launcher, we want to return now.  Otherwise we do</span>
<span class="cm">	 * the hypercall.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pending_notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_hcall</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tricky point: we reset the hcall pointer to mark the</span>
<span class="cm">		 * hypercall as &quot;done&quot;.  We use the hcall pointer rather than</span>
<span class="cm">		 * the trap number to indicate a hypercall is pending.</span>
<span class="cm">		 * Normally it doesn&#39;t matter: the Guest will run again and</span>
<span class="cm">		 * update the trap number before we come back here.</span>
<span class="cm">		 *</span>
<span class="cm">		 * However, if we are signalled or the Guest sends I/O to the</span>
<span class="cm">		 * Launcher, the run_guest() loop will exit without running the</span>
<span class="cm">		 * Guest.  When it comes back it would try to re-run the</span>
<span class="cm">		 * hypercall.  Finding that bug sucked.</span>
<span class="cm">		 */</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">hcall</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine supplies the Guest with time: it&#39;s used for wallclock time at</span>
<span class="cm"> * initial boot and as a rough time source if the TSC isn&#39;t available.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">write_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lg_cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">ktime_get_real_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">lg</span><span class="o">-&gt;</span><span class="n">lguest_data</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span><span class="p">)))</span>
		<span class="n">kill_guest</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;Writing timestamp&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
