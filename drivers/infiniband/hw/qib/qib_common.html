<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › qib › qib_common.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qib_common.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, 2007, 2008, 2009, 2010 QLogic Corporation.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _QIB_COMMON_H</span>
<span class="cp">#define _QIB_COMMON_H</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains defines, structures, etc. that are used</span>
<span class="cm"> * to communicate between kernel and user code.</span>
<span class="cm"> */</span>

<span class="cm">/* This is the IEEE-assigned OUI for QLogic Inc. QLogic_IB */</span>
<span class="cp">#define QIB_SRC_OUI_1 0x00</span>
<span class="cp">#define QIB_SRC_OUI_2 0x11</span>
<span class="cp">#define QIB_SRC_OUI_3 0x75</span>

<span class="cm">/* version of protocol header (known to chip also). In the long run,</span>
<span class="cm"> * we should be able to generate and accept a range of version numbers;</span>
<span class="cm"> * for now we only accept one, and it&#39;s compiled in.</span>
<span class="cm"> */</span>
<span class="cp">#define IPS_PROTO_VERSION 2</span>

<span class="cm">/*</span>
<span class="cm"> * These are compile time constants that you may want to enable or disable</span>
<span class="cm"> * if you are trying to debug problems with code or performance.</span>
<span class="cm"> * QIB_VERBOSE_TRACING define as 1 if you want additional tracing in</span>
<span class="cm"> * fastpath code</span>
<span class="cm"> * QIB_TRACE_REGWRITES define as 1 if you want register writes to be</span>
<span class="cm"> * traced in faspath code</span>
<span class="cm"> * _QIB_TRACING define as 0 if you want to remove all tracing in a</span>
<span class="cm"> * compilation unit</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The value in the BTH QP field that QLogic_IB uses to differentiate</span>
<span class="cm"> * an qlogic_ib protocol IB packet vs standard IB transport</span>
<span class="cm"> * This it needs to be even (0x656b78), because the LSB is sometimes</span>
<span class="cm"> * used for the MSB of context. The change may cause a problem</span>
<span class="cm"> * interoperating with older software.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_KD_QP 0x656b78</span>

<span class="cm">/*</span>
<span class="cm"> * These are the status bits readable (in ascii form, 64bit value)</span>
<span class="cm"> * from the &quot;status&quot; sysfs file.  For binary compatibility, values</span>
<span class="cm"> * must remain as is; removed states can be reused for different</span>
<span class="cm"> * purposes.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_STATUS_INITTED       0x1    </span><span class="cm">/* basic initialization done */</span><span class="cp"></span>
<span class="cm">/* Chip has been found and initted */</span>
<span class="cp">#define QIB_STATUS_CHIP_PRESENT 0x20</span>
<span class="cm">/* IB link is at ACTIVE, usable for data traffic */</span>
<span class="cp">#define QIB_STATUS_IB_READY     0x40</span>
<span class="cm">/* link is configured, LID, MTU, etc. have been set */</span>
<span class="cp">#define QIB_STATUS_IB_CONF      0x80</span>
<span class="cm">/* A Fatal hardware error has occurred. */</span>
<span class="cp">#define QIB_STATUS_HWERROR     0x200</span>

<span class="cm">/*</span>
<span class="cm"> * The list of usermode accessible registers.  Also see Reg_* later in file.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">qib_ureg</span> <span class="p">{</span>
	<span class="cm">/* (RO)  DMA RcvHdr to be used next. */</span>
	<span class="n">ur_rcvhdrtail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* (RW)  RcvHdr entry to be processed next by host. */</span>
	<span class="n">ur_rcvhdrhead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/* (RO)  Index of next Eager index to use. */</span>
	<span class="n">ur_rcvegrindextail</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="cm">/* (RW)  Eager TID to be processed next */</span>
	<span class="n">ur_rcvegrindexhead</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="cm">/* For internal use only; max register number. */</span>
	<span class="n">_QIB_UregMax</span>
<span class="p">};</span>

<span class="cm">/* bit values for spi_runtime_flags */</span>
<span class="cp">#define QIB_RUNTIME_PCIE                0x0002</span>
<span class="cp">#define QIB_RUNTIME_FORCE_WC_ORDER      0x0004</span>
<span class="cp">#define QIB_RUNTIME_RCVHDR_COPY         0x0008</span>
<span class="cp">#define QIB_RUNTIME_MASTER              0x0010</span>
<span class="cp">#define QIB_RUNTIME_RCHK                0x0020</span>
<span class="cp">#define QIB_RUNTIME_NODMA_RTAIL         0x0080</span>
<span class="cp">#define QIB_RUNTIME_SPECIAL_TRIGGER     0x0100</span>
<span class="cp">#define QIB_RUNTIME_SDMA                0x0200</span>
<span class="cp">#define QIB_RUNTIME_FORCE_PIOAVAIL      0x0400</span>
<span class="cp">#define QIB_RUNTIME_PIO_REGSWAPPED      0x0800</span>
<span class="cp">#define QIB_RUNTIME_CTXT_MSB_IN_QP      0x1000</span>
<span class="cp">#define QIB_RUNTIME_CTXT_REDIRECT       0x2000</span>
<span class="cp">#define QIB_RUNTIME_HDRSUPP             0x4000</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is returned by qib_userinit() immediately after</span>
<span class="cm"> * open to get implementation-specific info, and info specific to this</span>
<span class="cm"> * instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This struct must have explict pad fields where type sizes</span>
<span class="cm"> * may result in different alignments between 32 and 64 bit</span>
<span class="cm"> * programs, since the 64 bit * bit kernel requires the user code</span>
<span class="cm"> * to have matching offsets</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_base_info</span> <span class="p">{</span>
	<span class="cm">/* version of hardware, for feature checking. */</span>
	<span class="n">__u32</span> <span class="n">spi_hw_version</span><span class="p">;</span>
	<span class="cm">/* version of software, for feature checking. */</span>
	<span class="n">__u32</span> <span class="n">spi_sw_version</span><span class="p">;</span>
	<span class="cm">/* QLogic_IB context assigned, goes into sent packets */</span>
	<span class="n">__u16</span> <span class="n">spi_ctxt</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">spi_subctxt</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * IB MTU, packets IB data must be less than this.</span>
<span class="cm">	 * The MTU is in bytes, and will be a multiple of 4 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_mtu</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Size of a PIO buffer.  Any given packet&#39;s total size must be less</span>
<span class="cm">	 * than this (in words).  Included is the starting control word, so</span>
<span class="cm">	 * if 513 is returned, then total pkt size is 512 words or less.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_piosize</span><span class="p">;</span>
	<span class="cm">/* size of the TID cache in qlogic_ib, in entries */</span>
	<span class="n">__u32</span> <span class="n">spi_tidcnt</span><span class="p">;</span>
	<span class="cm">/* size of the TID Eager list in qlogic_ib, in entries */</span>
	<span class="n">__u32</span> <span class="n">spi_tidegrcnt</span><span class="p">;</span>
	<span class="cm">/* size of a single receive header queue entry in words. */</span>
	<span class="n">__u32</span> <span class="n">spi_rcvhdrent_size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Count of receive header queue entries allocated.</span>
<span class="cm">	 * This may be less than the spu_rcvhdrcnt passed in!.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_rcvhdr_cnt</span><span class="p">;</span>

	<span class="cm">/* per-chip and other runtime features bitmap (QIB_RUNTIME_*) */</span>
	<span class="n">__u32</span> <span class="n">spi_runtime_flags</span><span class="p">;</span>

	<span class="cm">/* address where hardware receive header queue is mapped */</span>
	<span class="n">__u64</span> <span class="n">spi_rcvhdr_base</span><span class="p">;</span>

	<span class="cm">/* user program. */</span>

	<span class="cm">/* base address of eager TID receive buffers used by hardware. */</span>
	<span class="n">__u64</span> <span class="n">spi_rcv_egrbufs</span><span class="p">;</span>

	<span class="cm">/* Allocated by initialization code, not by protocol. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Size of each TID buffer in host memory, starting at</span>
<span class="cm">	 * spi_rcv_egrbufs.  The buffers are virtually contiguous.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrbufsize</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The special QP (queue pair) value that identifies an qlogic_ib</span>
<span class="cm">	 * protocol packet from standard IB packets.  More, probably much</span>
<span class="cm">	 * more, to be added.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_qpair</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * User register base for init code, not to be used directly by</span>
<span class="cm">	 * protocol or applications.  Always points to chip registers,</span>
<span class="cm">	 * for normal or shared context.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_uregbase</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Maximum buffer size in bytes that can be used in a single TID</span>
<span class="cm">	 * entry (assuming the buffer is aligned to this boundary).  This is</span>
<span class="cm">	 * the minimum of what the hardware and software support Guaranteed</span>
<span class="cm">	 * to be a power of 2.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_tid_maxsize</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * alignment of each pio send buffer (byte count</span>
<span class="cm">	 * to add to spi_piobufbase to get to second buffer)</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_pioalign</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The index of the first pio buffer available to this process;</span>
<span class="cm">	 * needed to do lookup in spi_pioavailaddr; not added to</span>
<span class="cm">	 * spi_piobufbase.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_pioindex</span><span class="p">;</span>
	 <span class="cm">/* number of buffers mapped for this process */</span>
	<span class="n">__u32</span> <span class="n">spi_piocnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Base address of writeonly pio buffers for this process.</span>
<span class="cm">	 * Each buffer has spi_piosize words, and is aligned on spi_pioalign</span>
<span class="cm">	 * boundaries.  spi_piocnt buffers are mapped from this address</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_piobufbase</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Base address of readonly memory copy of the pioavail registers.</span>
<span class="cm">	 * There are 2 bits for each buffer.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_pioavailaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Address where driver updates a copy of the interface and driver</span>
<span class="cm">	 * status (QIB_STATUS_*) as a 64 bit value.  It&#39;s followed by a</span>
<span class="cm">	 * link status qword (formerly combined with driver status), then a</span>
<span class="cm">	 * string indicating hardware error, if there was one.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_status</span><span class="p">;</span>

	<span class="cm">/* number of chip ctxts available to user processes */</span>
	<span class="n">__u32</span> <span class="n">spi_nctxts</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">spi_unit</span><span class="p">;</span> <span class="cm">/* unit number of chip we are using */</span>
	<span class="n">__u16</span> <span class="n">spi_port</span><span class="p">;</span> <span class="cm">/* IB port number we are using */</span>
	<span class="cm">/* num bufs in each contiguous set */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrperchunk</span><span class="p">;</span>
	<span class="cm">/* size in bytes of each contiguous set */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrchunksize</span><span class="p">;</span>
	<span class="cm">/* total size of mmap to cover full rcvegrbuffers */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrbuftotlen</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">spi_rhf_offset</span><span class="p">;</span> <span class="cm">/* dword offset in hdrqent for rcvhdr flags */</span>
	<span class="cm">/* address of readonly memory copy of the rcvhdrq tail register. */</span>
	<span class="n">__u64</span> <span class="n">spi_rcvhdr_tailaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * shared memory pages for subctxts if ctxt is shared; these cover</span>
<span class="cm">	 * all the processes in the group sharing a single context.</span>
<span class="cm">	 * all have enough space for the num_subcontexts value on this job.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_subctxt_uregbase</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">spi_subctxt_rcvegrbuf</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">spi_subctxt_rcvhdr_base</span><span class="p">;</span>

	<span class="cm">/* shared memory page for send buffer disarm status */</span>
	<span class="n">__u64</span> <span class="n">spi_sendbuf_status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * This version number is given to the driver by the user code during</span>
<span class="cm"> * initialization in the spu_userversion field of qib_user_info, so</span>
<span class="cm"> * the driver can check for compatibility with user code.</span>
<span class="cm"> *</span>
<span class="cm"> * The major version changes when data structures</span>
<span class="cm"> * change in an incompatible way.  The driver must be the same or higher</span>
<span class="cm"> * for initialization to succeed.  In some cases, a higher version</span>
<span class="cm"> * driver will not interoperate with older software, and initialization</span>
<span class="cm"> * will return an error.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_USER_SWMAJOR 1</span>

<span class="cm">/*</span>
<span class="cm"> * Minor version differences are always compatible</span>
<span class="cm"> * a within a major version, however if user software is larger</span>
<span class="cm"> * than driver software, some new features and/or structure fields</span>
<span class="cm"> * may not be implemented; the user code must deal with this if it</span>
<span class="cm"> * cares, or it must abort after initialization reports the difference.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_USER_SWMINOR 11</span>

<span class="cp">#define QIB_USER_SWVERSION ((QIB_USER_SWMAJOR &lt;&lt; 16) | QIB_USER_SWMINOR)</span>

<span class="cp">#ifndef QIB_KERN_TYPE</span>
<span class="cp">#define QIB_KERN_TYPE 0</span>
<span class="cp">#define QIB_IDSTR &quot;QLogic kernel.org driver&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Similarly, this is the kernel version going back to the user.  It&#39;s</span>
<span class="cm"> * slightly different, in that we want to tell if the driver was built as</span>
<span class="cm"> * part of a QLogic release, or from the driver from openfabrics.org,</span>
<span class="cm"> * kernel.org, or a standard distribution, for support reasons.</span>
<span class="cm"> * The high bit is 0 for non-QLogic and 1 for QLogic-built/supplied.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s returned by the driver to the user code during initialization in the</span>
<span class="cm"> * spi_sw_version field of qib_base_info, so the user code can in turn</span>
<span class="cm"> * check for compatibility with the kernel.</span>
<span class="cm">*/</span>
<span class="cp">#define QIB_KERN_SWVERSION ((QIB_KERN_TYPE &lt;&lt; 31) | QIB_USER_SWVERSION)</span>

<span class="cm">/*</span>
<span class="cm"> * If the unit is specified via open, HCA choice is fixed.  If port is</span>
<span class="cm"> * specified, it&#39;s also fixed.  Otherwise we try to spread contexts</span>
<span class="cm"> * across ports and HCAs, using different algorithims.  WITHIN is</span>
<span class="cm"> * the old default, prior to this mechanism.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_PORT_ALG_ACROSS 0 </span><span class="cm">/* round robin contexts across HCAs, then</span>
<span class="cm">			       * ports; this is the default */</span><span class="cp"></span>
<span class="cp">#define QIB_PORT_ALG_WITHIN 1 </span><span class="cm">/* use all contexts on an HCA (round robin</span>
<span class="cm">			       * active ports within), then next HCA */</span><span class="cp"></span>
<span class="cp">#define QIB_PORT_ALG_COUNT 2 </span><span class="cm">/* number of algorithm choices */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This structure is passed to qib_userinit() to tell the driver where</span>
<span class="cm"> * user code buffers are, sizes, etc.   The offsets and sizes of the</span>
<span class="cm"> * fields must remain unchanged, for binary compatibility.  It can</span>
<span class="cm"> * be extended, if userversion is changed so user code can tell, if needed</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_user_info</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * version of user software, to detect compatibility issues.</span>
<span class="cm">	 * Should be set to QIB_USER_SWVERSION.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spu_userversion</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">_spu_unused2</span><span class="p">;</span>

	<span class="cm">/* size of struct base_info to write to */</span>
	<span class="n">__u32</span> <span class="n">spu_base_info_size</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">spu_port_alg</span><span class="p">;</span> <span class="cm">/* which QIB_PORT_ALG_*; unused user minor &lt; 11 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If two or more processes wish to share a context, each process</span>
<span class="cm">	 * must set the spu_subctxt_cnt and spu_subctxt_id to the same</span>
<span class="cm">	 * values.  The only restriction on the spu_subctxt_id is that</span>
<span class="cm">	 * it be unique for a given node.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">spu_subctxt_cnt</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">spu_subctxt_id</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">spu_port</span><span class="p">;</span> <span class="cm">/* IB port requested by user if &gt; 0 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * address of struct base_info to write to</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spu_base_info</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/* User commands. */</span>

<span class="cm">/* 16 available, was: old set up userspace (for old user code) */</span>
<span class="cp">#define QIB_CMD_CTXT_INFO       17      </span><span class="cm">/* find out what resources we got */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_RECV_CTRL       18      </span><span class="cm">/* control receipt of packets */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_TID_UPDATE      19      </span><span class="cm">/* update expected TID entries */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_TID_FREE        20      </span><span class="cm">/* free expected TID entries */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_SET_PART_KEY    21      </span><span class="cm">/* add partition key */</span><span class="cp"></span>
<span class="cm">/* 22 available, was: return info on slave processes (for old user code) */</span>
<span class="cp">#define QIB_CMD_ASSIGN_CTXT     23      </span><span class="cm">/* allocate HCA and ctxt */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_USER_INIT       24      </span><span class="cm">/* set up userspace */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_UNUSED_1        25</span>
<span class="cp">#define QIB_CMD_UNUSED_2        26</span>
<span class="cp">#define QIB_CMD_PIOAVAILUPD     27      </span><span class="cm">/* force an update of PIOAvail reg */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_POLL_TYPE       28      </span><span class="cm">/* set the kind of polling we want */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_ARMLAUNCH_CTRL  29      </span><span class="cm">/* armlaunch detection control */</span><span class="cp"></span>
<span class="cm">/* 30 is unused */</span>
<span class="cp">#define QIB_CMD_SDMA_INFLIGHT   31      </span><span class="cm">/* sdma inflight counter request */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_SDMA_COMPLETE   32      </span><span class="cm">/* sdma completion counter request */</span><span class="cp"></span>
<span class="cm">/* 33 available, was a testing feature  */</span>
<span class="cp">#define QIB_CMD_DISARM_BUFS     34      </span><span class="cm">/* disarm send buffers w/ errors */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_ACK_EVENT       35      </span><span class="cm">/* ack &amp; clear bits */</span><span class="cp"></span>
<span class="cp">#define QIB_CMD_CPUS_LIST       36      </span><span class="cm">/* list of cpus allocated, for pinned</span>
<span class="cm">					 * processes: qib_cpus_list */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * QIB_CMD_ACK_EVENT obsoletes QIB_CMD_DISARM_BUFS, but we keep it for</span>
<span class="cm"> * compatibility with libraries from previous release.   The ACK_EVENT</span>
<span class="cm"> * will take appropriate driver action (if any, just DISARM for now),</span>
<span class="cm"> * then clear the bits passed in as part of the mask.  These bits are</span>
<span class="cm"> * in the first 64bit word at spi_sendbuf_status, and are passed to</span>
<span class="cm"> * the driver in the event_mask union as well.</span>
<span class="cm"> */</span>
<span class="cp">#define _QIB_EVENT_DISARM_BUFS_BIT	0</span>
<span class="cp">#define _QIB_EVENT_LINKDOWN_BIT		1</span>
<span class="cp">#define _QIB_EVENT_LID_CHANGE_BIT	2</span>
<span class="cp">#define _QIB_EVENT_LMC_CHANGE_BIT	3</span>
<span class="cp">#define _QIB_EVENT_SL2VL_CHANGE_BIT	4</span>
<span class="cp">#define _QIB_MAX_EVENT_BIT _QIB_EVENT_SL2VL_CHANGE_BIT</span>

<span class="cp">#define QIB_EVENT_DISARM_BUFS_BIT	(1UL &lt;&lt; _QIB_EVENT_DISARM_BUFS_BIT)</span>
<span class="cp">#define QIB_EVENT_LINKDOWN_BIT		(1UL &lt;&lt; _QIB_EVENT_LINKDOWN_BIT)</span>
<span class="cp">#define QIB_EVENT_LID_CHANGE_BIT	(1UL &lt;&lt; _QIB_EVENT_LID_CHANGE_BIT)</span>
<span class="cp">#define QIB_EVENT_LMC_CHANGE_BIT	(1UL &lt;&lt; _QIB_EVENT_LMC_CHANGE_BIT)</span>
<span class="cp">#define QIB_EVENT_SL2VL_CHANGE_BIT	(1UL &lt;&lt; _QIB_EVENT_SL2VL_CHANGE_BIT)</span>


<span class="cm">/*</span>
<span class="cm"> * Poll types</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_POLL_TYPE_ANYRCV     0x0</span>
<span class="cp">#define QIB_POLL_TYPE_URGENT     0x1</span>

<span class="k">struct</span> <span class="n">qib_ctxt_info</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">num_active</span><span class="p">;</span>       <span class="cm">/* number of active units */</span>
	<span class="n">__u16</span> <span class="n">unit</span><span class="p">;</span>             <span class="cm">/* unit (chip) assigned to caller */</span>
	<span class="n">__u16</span> <span class="n">port</span><span class="p">;</span>             <span class="cm">/* IB port assigned to caller (1-based) */</span>
	<span class="n">__u16</span> <span class="n">ctxt</span><span class="p">;</span>             <span class="cm">/* ctxt on unit assigned to caller */</span>
	<span class="n">__u16</span> <span class="n">subctxt</span><span class="p">;</span>          <span class="cm">/* subctxt on unit assigned to caller */</span>
	<span class="n">__u16</span> <span class="n">num_ctxts</span><span class="p">;</span>        <span class="cm">/* number of ctxts available on unit */</span>
	<span class="n">__u16</span> <span class="n">num_subctxts</span><span class="p">;</span>     <span class="cm">/* number of subctxts opened on ctxt */</span>
	<span class="n">__u16</span> <span class="n">rec_cpu</span><span class="p">;</span>          <span class="cm">/* cpu # for affinity (ffff if none) */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qib_tid_info</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">tidcnt</span><span class="p">;</span>
	<span class="cm">/* make structure same size in 32 and 64 bit */</span>
	<span class="n">__u32</span> <span class="n">tid__unused</span><span class="p">;</span>
	<span class="cm">/* virtual address of first page in transfer */</span>
	<span class="n">__u64</span> <span class="n">tidvaddr</span><span class="p">;</span>
	<span class="cm">/* pointer (same size 32/64 bit) to __u16 tid array */</span>
	<span class="n">__u64</span> <span class="n">tidlist</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pointer (same size 32/64 bit) to bitmap of TIDs used</span>
<span class="cm">	 * for this call; checked for being large enough at open</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">tidmap</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qib_cmd</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>                     <span class="cm">/* command type */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qib_tid_info</span> <span class="n">tid_info</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">qib_user_info</span> <span class="n">user_info</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * address in userspace where we should put the sdma</span>
<span class="cm">		 * inflight counter</span>
<span class="cm">		 */</span>
		<span class="n">__u64</span> <span class="n">sdma_inflight</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * address in userspace where we should put the sdma</span>
<span class="cm">		 * completion counter</span>
<span class="cm">		 */</span>
		<span class="n">__u64</span> <span class="n">sdma_complete</span><span class="p">;</span>
		<span class="cm">/* address in userspace of struct qib_ctxt_info to</span>
<span class="cm">		   write result to */</span>
		<span class="n">__u64</span> <span class="n">ctxt_info</span><span class="p">;</span>
		<span class="cm">/* enable/disable receipt of packets */</span>
		<span class="n">__u32</span> <span class="n">recv_ctrl</span><span class="p">;</span>
		<span class="cm">/* enable/disable armlaunch errors (non-zero to enable) */</span>
		<span class="n">__u32</span> <span class="n">armlaunch_ctrl</span><span class="p">;</span>
		<span class="cm">/* partition key to set */</span>
		<span class="n">__u16</span> <span class="n">part_key</span><span class="p">;</span>
		<span class="cm">/* user address of __u32 bitmask of active slaves */</span>
		<span class="n">__u64</span> <span class="n">slave_mask_addr</span><span class="p">;</span>
		<span class="cm">/* type of polling we want */</span>
		<span class="n">__u16</span> <span class="n">poll_type</span><span class="p">;</span>
		<span class="cm">/* back pressure enable bit for one particular context */</span>
		<span class="n">__u8</span> <span class="n">ctxt_bp</span><span class="p">;</span>
		<span class="cm">/* qib_user_event_ack(), IPATH_EVENT_* bits */</span>
		<span class="n">__u64</span> <span class="n">event_mask</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qib_iovec</span> <span class="p">{</span>
	<span class="cm">/* Pointer to data, but same size 32 and 64 bit */</span>
	<span class="n">__u64</span> <span class="n">iov_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Length of data; don&#39;t need 64 bits, but want</span>
<span class="cm">	 * qib_sendpkt to remain same size as before 32 bit changes, so...</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">iov_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Describes a single packet for send.  Each packet can have one or more</span>
<span class="cm"> * buffers, but the total length (exclusive of IB headers) must be less</span>
<span class="cm"> * than the MTU, and if using the PIO method, entire packet length,</span>
<span class="cm"> * including IB headers, must be less than the qib_piosize value (words).</span>
<span class="cm"> * Use of this necessitates including sys/uio.h</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__qib_sendpkt</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">sps_flags</span><span class="p">;</span>        <span class="cm">/* flags for packet (TBD) */</span>
	<span class="n">__u32</span> <span class="n">sps_cnt</span><span class="p">;</span>          <span class="cm">/* number of entries to use in sps_iov */</span>
	<span class="cm">/* array of iov&#39;s describing packet. TEMPORARY */</span>
	<span class="k">struct</span> <span class="n">qib_iovec</span> <span class="n">sps_iov</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Diagnostics can send a packet by &quot;writing&quot; the following</span>
<span class="cm"> * structs to the diag data special file.</span>
<span class="cm"> * This allows a custom</span>
<span class="cm"> * pbc (+ static rate) qword, so that special modes and deliberate</span>
<span class="cm"> * changes to CRCs can be used. The elements were also re-ordered</span>
<span class="cm"> * for better alignment and to avoid padding issues.</span>
<span class="cm"> */</span>
<span class="cp">#define _DIAG_XPKT_VERS 3</span>
<span class="k">struct</span> <span class="n">qib_diag_xpkt</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">unit</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">pbc_wd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Data layout in I2C flash (for GUID, etc.)</span>
<span class="cm"> * All fields are little-endian binary unless otherwise stated</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_FLASH_VERSION 2</span>
<span class="k">struct</span> <span class="n">qib_flash</span> <span class="p">{</span>
	<span class="cm">/* flash layout version (QIB_FLASH_VERSION) */</span>
	<span class="n">__u8</span> <span class="n">if_fversion</span><span class="p">;</span>
	<span class="cm">/* checksum protecting if_length bytes */</span>
	<span class="n">__u8</span> <span class="n">if_csum</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * valid length (in use, protected by if_csum), including</span>
<span class="cm">	 * if_fversion and if_csum themselves)</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span> <span class="n">if_length</span><span class="p">;</span>
	<span class="cm">/* the GUID, in network order */</span>
	<span class="n">__u8</span> <span class="n">if_guid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* number of GUIDs to use, starting from if_guid */</span>
	<span class="n">__u8</span> <span class="n">if_numguid</span><span class="p">;</span>
	<span class="cm">/* the (last 10 characters of) board serial number, in ASCII */</span>
	<span class="kt">char</span> <span class="n">if_serial</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="cm">/* board mfg date (YYYYMMDD ASCII) */</span>
	<span class="kt">char</span> <span class="n">if_mfgdate</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* last board rework/test date (YYYYMMDD ASCII) */</span>
	<span class="kt">char</span> <span class="n">if_testdate</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* logging of error counts, TBD */</span>
	<span class="n">__u8</span> <span class="n">if_errcntp</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* powered on hours, updated at driver unload */</span>
	<span class="n">__u8</span> <span class="n">if_powerhour</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* ASCII free-form comment field */</span>
	<span class="kt">char</span> <span class="n">if_comment</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="cm">/* Backwards compatible prefix for longer QLogic Serial Numbers */</span>
	<span class="kt">char</span> <span class="n">if_sprefix</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* 82 bytes used, min flash size is 128 bytes */</span>
	<span class="n">__u8</span> <span class="n">if_future</span><span class="p">[</span><span class="mi">46</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * These are the counters implemented in the chip, and are listed in order.</span>
<span class="cm"> * The InterCaps naming is taken straight from the chip spec.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qlogic_ib_counters</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">LBIntCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">LBFlowStallCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxSDmaDescCnt</span><span class="p">;</span>    <span class="cm">/* was Reserved1 */</span>
	<span class="n">__u64</span> <span class="n">TxUnsupVLErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxDataPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxFlowPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxDwordCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxMaxMinLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxUnderrunCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxFlowStallCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxDroppedPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDroppedPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDataPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxFlowPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDwordCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxMaxMinLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxICRCErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxVCRCErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxFlowCtrlErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxBadFormatCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxLinkProblemCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxEBPCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxLPCRCErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxBufOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxTIDFullErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxTIDValidErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxPKeyMismatchCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP0HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP1HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP2HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP3HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP4HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP5HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP6HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP7HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP8HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP9HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP10HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP11HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP12HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP13HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP14HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP15HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP16HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IBStatusChangeCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IBLinkErrRecoveryCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IBLinkDownedCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IBSymbolErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxVL15DroppedPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxOtherLocalPhyErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">PcieRetryBufDiagQwordCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ExcessBufferOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">LocalLinkIntegrityErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxVlErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDlidFltrCnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The next set of defines are for packet headers, and chip register</span>
<span class="cm"> * and memory bits that are visible to and/or used by user-mode software.</span>
<span class="cm"> */</span>

<span class="cm">/* RcvHdrFlags bits */</span>
<span class="cp">#define QLOGIC_IB_RHF_LENGTH_MASK 0x7FF</span>
<span class="cp">#define QLOGIC_IB_RHF_LENGTH_SHIFT 0</span>
<span class="cp">#define QLOGIC_IB_RHF_RCVTYPE_MASK 0x7</span>
<span class="cp">#define QLOGIC_IB_RHF_RCVTYPE_SHIFT 11</span>
<span class="cp">#define QLOGIC_IB_RHF_EGRINDEX_MASK 0xFFF</span>
<span class="cp">#define QLOGIC_IB_RHF_EGRINDEX_SHIFT 16</span>
<span class="cp">#define QLOGIC_IB_RHF_SEQ_MASK 0xF</span>
<span class="cp">#define QLOGIC_IB_RHF_SEQ_SHIFT 0</span>
<span class="cp">#define QLOGIC_IB_RHF_HDRQ_OFFSET_MASK 0x7FF</span>
<span class="cp">#define QLOGIC_IB_RHF_HDRQ_OFFSET_SHIFT 4</span>
<span class="cp">#define QLOGIC_IB_RHF_H_ICRCERR   0x80000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_VCRCERR   0x40000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_PARITYERR 0x20000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_LENERR    0x10000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_MTUERR    0x08000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_IHDRERR   0x04000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_TIDERR    0x02000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_MKERR     0x01000000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_IBERR     0x00800000</span>
<span class="cp">#define QLOGIC_IB_RHF_H_ERR_MASK  0xFF800000</span>
<span class="cp">#define QLOGIC_IB_RHF_L_USE_EGR   0x80000000</span>
<span class="cp">#define QLOGIC_IB_RHF_L_SWA       0x00008000</span>
<span class="cp">#define QLOGIC_IB_RHF_L_SWB       0x00004000</span>

<span class="cm">/* qlogic_ib header fields */</span>
<span class="cp">#define QLOGIC_IB_I_VERS_MASK 0xF</span>
<span class="cp">#define QLOGIC_IB_I_VERS_SHIFT 28</span>
<span class="cp">#define QLOGIC_IB_I_CTXT_MASK 0xF</span>
<span class="cp">#define QLOGIC_IB_I_CTXT_SHIFT 24</span>
<span class="cp">#define QLOGIC_IB_I_TID_MASK 0x7FF</span>
<span class="cp">#define QLOGIC_IB_I_TID_SHIFT 13</span>
<span class="cp">#define QLOGIC_IB_I_OFFSET_MASK 0x1FFF</span>
<span class="cp">#define QLOGIC_IB_I_OFFSET_SHIFT 0</span>

<span class="cm">/* K_PktFlags bits */</span>
<span class="cp">#define QLOGIC_IB_KPF_INTR 0x1</span>
<span class="cp">#define QLOGIC_IB_KPF_SUBCTXT_MASK 0x3</span>
<span class="cp">#define QLOGIC_IB_KPF_SUBCTXT_SHIFT 1</span>

<span class="cp">#define QLOGIC_IB_MAX_SUBCTXT   4</span>

<span class="cm">/* SendPIO per-buffer control */</span>
<span class="cp">#define QLOGIC_IB_SP_TEST    0x40</span>
<span class="cp">#define QLOGIC_IB_SP_TESTEBP 0x20</span>
<span class="cp">#define QLOGIC_IB_SP_TRIGGER_SHIFT  15</span>

<span class="cm">/* SendPIOAvail bits */</span>
<span class="cp">#define QLOGIC_IB_SENDPIOAVAIL_BUSY_SHIFT 1</span>
<span class="cp">#define QLOGIC_IB_SENDPIOAVAIL_CHECK_SHIFT 0</span>

<span class="cm">/* qlogic_ib header format */</span>
<span class="k">struct</span> <span class="n">qib_header</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Version - 4 bits, Context - 4 bits, TID - 10 bits and Offset -</span>
<span class="cm">	 * 14 bits before ECO change ~28 Dec 03.  After that, Vers 4,</span>
<span class="cm">	 * Context 4, TID 11, offset 13.</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">ver_ctxt_tid_offset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">pkt_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * qlogic_ib user message header format.</span>
<span class="cm"> * This structure contains the first 4 fields common to all protocols</span>
<span class="cm"> * that employ qlogic_ib.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_message_header</span> <span class="p">{</span>
	<span class="n">__be16</span> <span class="n">lrh</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__be32</span> <span class="n">bth</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="cm">/* fields below this point are in host byte order */</span>
	<span class="k">struct</span> <span class="n">qib_header</span> <span class="n">iph</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sub_opcode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* IB - LRH header consts */</span>
<span class="cp">#define QIB_LRH_GRH 0x0003      </span><span class="cm">/* 1. word of IB LRH - next header: GRH */</span><span class="cp"></span>
<span class="cp">#define QIB_LRH_BTH 0x0002      </span><span class="cm">/* 1. word of IB LRH - next header: BTH */</span><span class="cp"></span>

<span class="cm">/* misc. */</span>
<span class="cp">#define SIZE_OF_CRC 1</span>

<span class="cp">#define QIB_DEFAULT_P_KEY 0xFFFF</span>
<span class="cp">#define QIB_PERMISSIVE_LID 0xFFFF</span>
<span class="cp">#define QIB_AETH_CREDIT_SHIFT 24</span>
<span class="cp">#define QIB_AETH_CREDIT_MASK 0x1F</span>
<span class="cp">#define QIB_AETH_CREDIT_INVAL 0x1F</span>
<span class="cp">#define QIB_PSN_MASK 0xFFFFFF</span>
<span class="cp">#define QIB_MSN_MASK 0xFFFFFF</span>
<span class="cp">#define QIB_QPN_MASK 0xFFFFFF</span>
<span class="cp">#define QIB_MULTICAST_LID_BASE 0xC000</span>
<span class="cp">#define QIB_EAGER_TID_ID QLOGIC_IB_I_TID_MASK</span>
<span class="cp">#define QIB_MULTICAST_QPN 0xFFFFFF</span>

<span class="cm">/* Receive Header Queue: receive type (from qlogic_ib) */</span>
<span class="cp">#define RCVHQ_RCV_TYPE_EXPECTED  0</span>
<span class="cp">#define RCVHQ_RCV_TYPE_EAGER     1</span>
<span class="cp">#define RCVHQ_RCV_TYPE_NON_KD    2</span>
<span class="cp">#define RCVHQ_RCV_TYPE_ERROR     3</span>

<span class="cp">#define QIB_HEADER_QUEUE_WORDS 9</span>

<span class="cm">/* functions for extracting fields from rcvhdrq entries for the driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_err_flags</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">QLOGIC_IB_RHF_H_ERR_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_rcv_type</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">QLOGIC_IB_RHF_RCVTYPE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">QLOGIC_IB_RHF_RCVTYPE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_length_in_bytes</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">QLOGIC_IB_RHF_LENGTH_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">QLOGIC_IB_RHF_LENGTH_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_index</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">QLOGIC_IB_RHF_EGRINDEX_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">QLOGIC_IB_RHF_EGRINDEX_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_seq</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">QLOGIC_IB_RHF_SEQ_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">QLOGIC_IB_RHF_SEQ_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_offset</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">QLOGIC_IB_RHF_HDRQ_OFFSET_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">QLOGIC_IB_RHF_HDRQ_OFFSET_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_use_egr_buf</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">QLOGIC_IB_RHF_L_USE_EGR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">qib_hdrget_qib_ver</span><span class="p">(</span><span class="n">__le32</span> <span class="n">hdrword</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">hdrword</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">QLOGIC_IB_I_VERS_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">QLOGIC_IB_I_VERS_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif                          </span><span class="cm">/* _QIB_COMMON_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
